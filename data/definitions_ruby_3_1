[Ño:(Rucoa::Definitions::ClassDefinition:@descriptionI"“CAn Array is an ordered, integer-indexed collection of objects, called
*elements*.  Any object may be an Array element.

## Array Indexes

Array indexing starts at 0, as in C or Java.

A positive index is an offset from the first element:
*   Index 0 indicates the first element.
*   Index 1 indicates the second element.
*   ...


A negative index is an offset, backwards, from the end of the array:
*   Index -1 indicates the last element.
*   Index -2 indicates the next-to-last element.
*   ...


A non-negative index is *in range* if it is smaller than the size of the
array.  For a 3-element array:
*   Indexes 0 through 2 are in range.
*   Index 3 is out of range.


A negative index is *in range* if its absolute value is not larger than the
size of the array.  For a 3-element array:
*   Indexes -1 through -3 are in range.
*   Index -4 is out of range.


## Creating Arrays

You can create an Array object explicitly with:

*   An [array literal](doc/syntax/literals_rdoc.html#label-Array+Literals).


You can convert certain objects to Arrays with:

*   Method [Array](Kernel.html#method-i-Array).


An Array can contain different types of objects.  For example, the array below
contains an Integer, a String and a Float:

    ary = [1, "two", 3.0] #=> [1, "two", 3.0]

An array can also be created by calling Array.new with zero, one (the initial
size of the Array) or two arguments (the initial size and a default object).

    ary = Array.new    #=> []
    Array.new(3)       #=> [nil, nil, nil]
    Array.new(3, true) #=> [true, true, true]

Note that the second argument populates the array with references to the same
object.  Therefore, it is only recommended in cases when you need to
instantiate arrays with natively immutable objects such as Symbols, numbers,
true or false.

To create an array with separate objects a block can be passed instead. This
method is safe to use with mutable objects such as hashes, strings or other
arrays:

    Array.new(4) {Hash.new}    #=> [{}, {}, {}, {}]
    Array.new(4) {|i| i.to_s } #=> ["0", "1", "2", "3"]

This is also a quick way to build up multi-dimensional arrays:

    empty_table = Array.new(3) {Array.new(3)}
    #=> [[nil, nil, nil], [nil, nil, nil], [nil, nil, nil]]

An array can also be created by using the Array() method, provided by Kernel,
which tries to call #to_ary, then #to_a on its argument.

    Array({:a => "a", :b => "b"}) #=> [[:a, "a"], [:b, "b"]]

## Example Usage

In addition to the methods it mixes in through the Enumerable module, the
Array class has proprietary methods for accessing, searching and otherwise
manipulating arrays.

Some of the more common ones are illustrated below.

## Accessing Elements

Elements in an array can be retrieved using the Array#[] method.  It can take
a single integer argument (a numeric index), a pair of arguments (start and
length) or a range. Negative indices start counting from the end, with -1
being the last element.

    arr = [1, 2, 3, 4, 5, 6]
    arr[2]    #=> 3
    arr[100]  #=> nil
    arr[-3]   #=> 4
    arr[2, 3] #=> [3, 4, 5]
    arr[1..4] #=> [2, 3, 4, 5]
    arr[1..-3] #=> [2, 3, 4]

Another way to access a particular array element is by using the #at method

    arr.at(0) #=> 1

The #slice method works in an identical manner to Array#[].

To raise an error for indices outside of the array bounds or else to provide a
default value when that happens, you can use #fetch.

    arr = ['a', 'b', 'c', 'd', 'e', 'f']
    arr.fetch(100) #=> IndexError: index 100 outside of array bounds: -6...6
    arr.fetch(100, "oops") #=> "oops"

The special methods #first and #last will return the first and last elements
of an array, respectively.

    arr.first #=> 1
    arr.last  #=> 6

To return the first `n` elements of an array, use #take

    arr.take(3) #=> [1, 2, 3]

#drop does the opposite of #take, by returning the elements after `n` elements
have been dropped:

    arr.drop(3) #=> [4, 5, 6]

## Obtaining Information about an Array

Arrays keep track of their own length at all times.  To query an array about
the number of elements it contains, use #length, #count or #size.

    browsers = ['Chrome', 'Firefox', 'Safari', 'Opera', 'IE']
    browsers.length #=> 5
    browsers.count #=> 5

To check whether an array contains any elements at all

    browsers.empty? #=> false

To check whether a particular item is included in the array

    browsers.include?('Konqueror') #=> false

## Adding Items to Arrays

Items can be added to the end of an array by using either #push or #<<

    arr = [1, 2, 3, 4]
    arr.push(5) #=> [1, 2, 3, 4, 5]
    arr << 6    #=> [1, 2, 3, 4, 5, 6]

#unshift will add a new item to the beginning of an array.

    arr.unshift(0) #=> [0, 1, 2, 3, 4, 5, 6]

With #insert you can add a new element to an array at any position.

    arr.insert(3, 'apple')  #=> [0, 1, 2, 'apple', 3, 4, 5, 6]

Using the #insert method, you can also insert multiple values at once:

    arr.insert(3, 'orange', 'pear', 'grapefruit')
    #=> [0, 1, 2, "orange", "pear", "grapefruit", "apple", 3, 4, 5, 6]

## Removing Items from an Array

The method #pop removes the last element in an array and returns it:

    arr =  [1, 2, 3, 4, 5, 6]
    arr.pop #=> 6
    arr #=> [1, 2, 3, 4, 5]

To retrieve and at the same time remove the first item, use #shift:

    arr.shift #=> 1
    arr #=> [2, 3, 4, 5]

To delete an element at a particular index:

    arr.delete_at(2) #=> 4
    arr #=> [2, 3, 5]

To delete a particular element anywhere in an array, use #delete:

    arr = [1, 2, 2, 3]
    arr.delete(2) #=> 2
    arr #=> [1,3]

A useful method if you need to remove `nil` values from an array is #compact:

    arr = ['foo', 0, nil, 'bar', 7, 'baz', nil]
    arr.compact  #=> ['foo', 0, 'bar', 7, 'baz']
    arr          #=> ['foo', 0, nil, 'bar', 7, 'baz', nil]
    arr.compact! #=> ['foo', 0, 'bar', 7, 'baz']
    arr          #=> ['foo', 0, 'bar', 7, 'baz']

Another common need is to remove duplicate elements from an array.

It has the non-destructive #uniq, and destructive method #uniq!

    arr = [2, 5, 6, 556, 6, 6, 8, 9, 0, 123, 556]
    arr.uniq #=> [2, 5, 6, 556, 8, 9, 0, 123]

## Iterating over Arrays

Like all classes that include the Enumerable module, Array has an each method,
which defines what elements should be iterated over and how.  In case of
Array's #each, all elements in the Array instance are yielded to the supplied
block in sequence.

Note that this operation leaves the array unchanged.

    arr = [1, 2, 3, 4, 5]
    arr.each {|a| print a -= 10, " "}
    # prints: -9 -8 -7 -6 -5
    #=> [1, 2, 3, 4, 5]

Another sometimes useful iterator is #reverse_each which will iterate over the
elements in the array in reverse order.

    words = %w[first second third fourth fifth sixth]
    str = ""
    words.reverse_each {|word| str += "#{word} "}
    p str #=> "sixth fifth fourth third second first "

The #map method can be used to create a new array based on the original array,
but with the values modified by the supplied block:

    arr.map {|a| 2*a}     #=> [2, 4, 6, 8, 10]
    arr                   #=> [1, 2, 3, 4, 5]
    arr.map! {|a| a**2}   #=> [1, 4, 9, 16, 25]
    arr                   #=> [1, 4, 9, 16, 25]

## Selecting Items from an Array

Elements can be selected from an array according to criteria defined in a
block.  The selection can happen in a destructive or a non-destructive manner.
 While the destructive operations will modify the array they were called on,
the non-destructive methods usually return a new array with the selected
elements, but leave the original array unchanged.

### Non-destructive Selection

    arr = [1, 2, 3, 4, 5, 6]
    arr.select {|a| a > 3}       #=> [4, 5, 6]
    arr.reject {|a| a < 3}       #=> [3, 4, 5, 6]
    arr.drop_while {|a| a < 4}   #=> [4, 5, 6]
    arr                          #=> [1, 2, 3, 4, 5, 6]

### Destructive Selection

#select! and #reject! are the corresponding destructive methods to #select and
#reject

Similar to #select vs. #reject, #delete_if and #keep_if have the exact
opposite result when supplied with the same block:

    arr.delete_if {|a| a < 4}   #=> [4, 5, 6]
    arr                         #=> [4, 5, 6]

    arr = [1, 2, 3, 4, 5, 6]
    arr.keep_if {|a| a < 4}   #=> [1, 2, 3]
    arr                       #=> [1, 2, 3]

## What's Here

First, what's elsewhere. Class Array:

*   Inherits from [class
    Object](Object.html#class-Object-label-What-27s+Here).
*   Includes [module
    Enumerable](Enumerable.html#module-Enumerable-label-What-27s+Here), which
    provides dozens of additional methods.


Here, class Array provides methods that are useful for:

*   [Creating an Array](#class-Array-label-Methods+for+Creating+an+Array)
*   [Querying](#class-Array-label-Methods+for+Querying)
*   [Comparing](#class-Array-label-Methods+for+Comparing)
*   [Fetching](#class-Array-label-Methods+for+Fetching)
*   [Assigning](#class-Array-label-Methods+for+Assigning)
*   [Deleting](#class-Array-label-Methods+for+Deleting)
*   [Combining](#class-Array-label-Methods+for+Combining)
*   [Iterating](#class-Array-label-Methods+for+Iterating)
*   [Converting](#class-Array-label-Methods+for+Converting)
*   [And more....](#class-Array-label-Other+Methods)


### Methods for Creating an Array

::[]
:   Returns a new array populated with given objects.
::new
:   Returns a new array.
::try_convert
:   Returns a new array created from a given object.


### Methods for Querying

#length, #size
:   Returns the count of elements.
#include?
:   Returns whether any element `==` a given object.
#empty?
:   Returns whether there are no elements.
#all?
:   Returns whether all elements meet a given criterion.
#any?
:   Returns whether any element meets a given criterion.
#none?
:   Returns whether no element `==` a given object.
#one?
:   Returns whether exactly one element `==` a given object.
#count
:   Returns the count of elements that meet a given criterion.
#find_index, #index
:   Returns the index of the first element that meets a given criterion.
#rindex
:   Returns the index of the last element that meets a given criterion.
#hash
:   Returns the integer hash code.


### Methods for Comparing
[#<=>](#method-i-3C-3D-3E)
:   Returns -1, 0, or 1 as `self` is less than, equal to, or greater than a
    given object.
[#==](#method-i-3D-3D)
:   Returns whether each element in `self` is `==` to the corresponding
    element in a given object.
#eql?
:   Returns whether each element in `self` is `eql?` to the corresponding
    element in a given object.


### Methods for Fetching

These methods do not modify `self`.

#[]
:   Returns one or more elements.
#fetch
:   Returns the element at a given offset.
#first
:   Returns one or more leading elements.
#last
:   Returns one or more trailing elements.
#max
:   Returns one or more maximum-valued elements, as determined by `<=>` or a
    given block.
#max
:   Returns one or more minimum-valued elements, as determined by `<=>` or a
    given block.
#minmax
:   Returns the minimum-valued and maximum-valued elements, as determined by
    `<=>` or a given block.
#assoc
:   Returns the first element that is an array whose first element `==` a
    given object.
#rassoc
:   Returns the first element that is an array whose second element `==` a
    given object.
#at
:   Returns the element at a given offset.
#values_at
:   Returns the elements at given offsets.
#dig
:   Returns the object in nested objects that is specified by a given index
    and additional arguments.
#drop
:   Returns trailing elements as determined by a given index.
#take
:   Returns leading elements as determined by a given index.
#drop_while
:   Returns trailing elements as determined by a given block.
#take_while
:   Returns leading elements as determined by a given block.
#slice
:   Returns consecutive elements as determined by a given argument.
#sort
:   Returns all elements in an order determined by `<=>` or a given block.
#reverse
:   Returns all elements in reverse order.
#compact
:   Returns an array containing all non-`nil` elements.
#select, #filter
:   Returns an array containing elements selected by a given block.
#uniq
:   Returns an array containing non-duplicate elements.
#rotate
:   Returns all elements with some rotated from one end to the other.
#bsearch
:   Returns an element selected via a binary search as determined by a given
    block.
#bsearch_index
:   Returns the index of an element selected via a binary search as determined
    by a given block.
#sample
:   Returns one or more random elements.
#shuffle
:   Returns elements in a random order.


### Methods for Assigning

These methods add, replace, or reorder elements in `self`.

#[]=
:   Assigns specified elements with a given object.
#push, #append, #<<
:   Appends trailing elements.
#unshift, #prepend
:   Prepends leading elements.
#insert
:   Inserts given objects at a given offset; does not replace elements.
#concat
:   Appends all elements from given arrays.
#fill
:   Replaces specified elements with specified objects.
#replace
:   Replaces the content of `self` with the content of a given array.
#reverse!
:   Replaces `self` with its elements reversed.
#rotate!
:   Replaces `self` with its elements rotated.
#shuffle!
:   Replaces `self` with its elements in random order.
#sort!
:   Replaces `self` with its elements sorted, as determined by `<=>` or a
    given block.
#sort_by!
:   Replaces `self` with its elements sorted, as determined by a given block.


### Methods for Deleting

Each of these methods removes elements from `self`:

#pop
:   Removes and returns the last element.
#shift
:   Removes and returns the first element.
#compact!
:   Removes all non-`nil` elements.
#delete
:   Removes elements equal to a given object.
#delete_at
:   Removes the element at a given offset.
#delete_if
:   Removes elements specified by a given block.
#keep_if
:   Removes elements not specified by a given block.
#reject!
:   Removes elements specified by a given block.
#select!, #filter!
:   Removes elements not specified by a given block.
#slice!
:   Removes and returns a sequence of elements.
#uniq!
:   Removes duplicates.


### Methods for Combining

[#&](#method-i-26)
:   Returns an array containing elements found both in `self` and a given
    array.
#intersection
:   Returns an array containing elements found both in `self` and in each
    given array.
#+
:   Returns an array containing all elements of `self` followed by all
    elements of a given array.
#-
:   Returns an array containiing all elements of `self` that are not found in
    a given array.
[#|](#method-i-7C)
:   Returns an array containing all elements of `self` and all elements of a
    given array, duplicates removed.
#union
:   Returns an array containing all elements of `self` and all elements of
    given arrays, duplicates removed.
#difference
:   Returns an array containing all elements of `self` that are not found in
    any of the given arrays..
#product
:   Returns or yields all combinations of elements from `self` and given
    arrays.


### Methods for Iterating

#each
:   Passes each element to a given block.
#reverse_each
:   Passes each element, in reverse order, to a given block.
#each_index
:   Passes each element index to a given block.
#cycle
:   Calls a given block with each element, then does so again, for a specified
    number of times, or forever.
#combination
:   Calls a given block with combinations of elements of `self`; a combination
    does not use the same element more than once.
#permutation
:   Calls a given block with permutations of elements of `self`; a permutation
    does not use the same element more than once.
#repeated_combination
:   Calls a given block with combinations of elements of `self`; a combination
    may use the same element more than once.
#repeated_permutation
:   Calls a given block with permutations of elements of `self`; a permutation
    may use the same element more than once.


### Methods for Converting

#map, #collect
:   Returns an array containing the block return-value for each element.
#map!, #collect!
:   Replaces each element with a block return-value.
#flatten
:   Returns an array that is a recursive flattening of `self`.
#flatten!
:   Replaces each nested array in `self` with the elements from that array.
#inspect, #to_s
:   Returns a new String containing the elements.
#join
:   Returns a newsString containing the elements joined by the field
    separator.
#to_a
:   Returns `self` or a new array containing all elements.
#to_ary
:   Returns `self`.
#to_h
:   Returns a new hash formed from the elements.
#transpose
:   Transposes `self`, which must be an array of arrays.
#zip
:   Returns a new array of arrays containing `self` and given arrays; follow
    the link for details.


### Other Methods

#*
:   Returns one of the following:
    *   With integer argument `n`, a new array that is the concatenation of
        `n` copies of `self`.
    *   With string argument `field_separator`, a new string that is
        equivalent to `join(field_separator)`.

#abbrev
:   Returns a hash of unambiguous abbreviations for elements.
#pack
:   Packs the elements into a binary sequence.
#sum
:   Returns a sum of elements according to either `+` or a given block.

:ET:@location0:@fully_qualified_nameI"
Array;T:#@included_module_chained_names[ :+@included_module_fully_qualified_names[I"Enumerable;T:@module_nesting0:$@prepended_module_chained_names[ :,@prepended_module_fully_qualified_names[ :@super_class_chained_name0:&@super_class_fully_qualified_nameI"Object;To:)Rucoa::Definitions::MethodDefinition;I"2Returns a new Array.

With no block and no arguments, returns a new empty Array object.

With no block and a single Array argument `array`, returns a new Array formed
from `array`:
    a = Array.new([:foo, 'bar', 2])
    a.class # => Array
    a # => [:foo, "bar", 2]

With no block and a single Integer argument `size`, returns a new Array of the
given size whose elements are all `nil`:
    a = Array.new(3)
    a # => [nil, nil, nil]

With no block and arguments `size` and `default_value`, returns an Array of
the given size; each element is that same `default_value`:
    a = Array.new(3, 'x')
    a # => ['x', 'x', 'x']

With a block and argument `size`, returns an Array of the given size; the
block is called with each successive integer `index`; the element for that
`index` is the return value from the block:
    a = Array.new(3) {|index| "Element #{index}" }
    a # => ["Element 0", "Element 1", "Element 2"]

Raises ArgumentError if `size` is negative.

With a block and no argument, or a single argument `0`, ignores the block and
returns a new empty Array.

;T;0:
@kind:instance:@method_nameI"initialize;F:@namespaceI"
Array;T:@types[	o:Rucoa::Types::MethodType:@parameters_stringI" ;F:@return_typeI"	void;To;;I"::Array[Elem] ary;T;I"	void;To;;I"::int size, ?Elem val;T;I"	void;To;;I"::int size;T;I"	void;To;;I"ËReturns a new array populated with the given objects.

    Array.[]( 1, 'a', /^A/)  # => [1, "a", /^A/]
    Array[ 1, 'a', /^A/ ]    # => [1, "a", /^A/]
    [ 1, 'a', /^A/ ]         # => [1, "a", /^A/]

;T;0;:singleton;I"[];F;I"
Array;T;[o;;I"*U;T;I"Array[U];To;;I"If `object` is an Array object, returns `object`.

Otherwise if `object` responds to `:to_ary`, calls `object.to_ary` and returns
the result.

Returns `nil` if `object` does not respond to `:to_ary`

Raises an exception unless `object.to_ary` returns an Array object.

;T;0;;;I"try_convert;F;I"
Array;T;[o;;I"untyped;T;I"Array[U]?;To;;I"JReturns a new Array containing each element found in both `array` and Array
`other_array`; duplicates are omitted; items are compared using `eql?`:
    [0, 1, 2, 3] & [1, 2] # => [1, 2]
    [0, 1, 0, 1] & [0, 1] # => [0, 1]

Preserves order from `array`:
    [0, 1, 2] & [3, 2, 1, 0] # => [0, 1, 2]

Related: Array#intersection.

;T;0;;;I"&;F;I"
Array;T;[o;;I")::Array[untyped] | ::_ToAry[untyped];T;I"Array[Elem];To;;I"TWhen non-negative argument Integer `n` is given, returns a new Array built by
concatenating the `n` copies of `self`:
    a = ['x', 'y']
    a * 3 # => ["x", "y", "x", "y", "x", "y"]

When String argument `string_separator` is given, equivalent to
`array.join(string_separator)`:
    [0, [0, 1], {foo: 0}] * ', ' # => "0, 0, 1, {:foo=>0}"

;T;0;;;I"*;F;I"
Array;T;[o;;I"::string str;T;I"String;To;;I"::int int;T;I"Array[Elem];To;;I"¦Returns a new Array containing all elements of `array` followed by all
elements of `other_array`:
    a = [0, 1] + [2, 3]
    a # => [0, 1, 2, 3]

Related: #concat.

;T;0;;;I"+;F;I"
Array;T;[o;;I"::_ToAry[U];T;I"Array[Elem | U];To;;I"LReturns a new Array containing only those elements from `array` that are not
found in Array `other_array`; items are compared using `eql?`; the order from
`array` is preserved:
    [0, 1, 1, 2, 1, 1, 3, 1, 1] - [1] # => [0, 2, 3]
    [0, 1, 2, 3] - [3, 0] # => [1, 2]
    [0, 1, 2] - [4] # => [0, 1, 2]

Related: Array#difference.

;T;0;;;I"-;F;I"
Array;T;[o;;I"::_ToAry[untyped];T;I"Array[Elem];To;;I"Appends `object` to `self`; returns `self`:
    a = [:foo, 'bar', 2]
    a << :baz # => [:foo, "bar", 2, :baz]

Appends `object` as one element, even if it is another Array:
    a = [:foo, 'bar', 2]
    a1 = a << [3, 4]
    a1 # => [:foo, "bar", 2, [3, 4]]

;T;0;;;I"<<;F;I"
Array;T;[o;;I"	Elem;T;I"	self;To;;I"nReturns -1, 0, or 1 as `self` is less than, equal to, or greater than
`other_array`. For each index `i` in `self`, evaluates `result = self[i] <=>
other_array[i]`.

Returns -1 if any result is -1:
    [0, 1, 2] <=> [0, 1, 3] # => -1

Returns 1 if any result is 1:
    [0, 1, 2] <=> [0, 1, 1] # => 1

When all results are zero:
*   Returns -1 if `array` is smaller than `other_array`:
        [0, 1, 2] <=> [0, 1, 2, 3] # => -1

*   Returns 1 if `array` is larger than `other_array`:
        [0, 1, 2] <=> [0, 1] # => 1

*   Returns 0 if `array` and `other_array` are the same size:
        [0, 1, 2] <=> [0, 1, 2] # => 0

;T;0;;;I"<=>;F;I"
Array;T;[o;;I"untyped;T;I"Integer?;To;;I"ZReturns `true` if both `array.size == other_array.size` and for each index `i`
in `array`, `array[i] == other_array[i]`:
    a0 = [:foo, 'bar', 2]
    a1 = [:foo, 'bar', 2.0]
    a1 == a0 # => true
    [] == [] # => true

Otherwise, returns `false`.

This method is different from method Array#eql?, which compares elements using
`Object#eql?`.

;T;0;;;I"==;F;I"
Array;T;[o;;I"untyped other;T;I"	bool;To;;I"D
Returns elements from `self`; does not modify `self`.

When a single Integer argument `index` is given, returns the element at offset
`index`:
    a = [:foo, 'bar', 2]
    a[0] # => :foo
    a[2] # => 2
    a # => [:foo, "bar", 2]

If `index` is negative, counts relative to the end of `self`:
    a = [:foo, 'bar', 2]
    a[-1] # => 2
    a[-2] # => "bar"

If `index` is out of range, returns `nil`.

When two Integer arguments `start` and `length` are given, returns a new Array
of size `length` containing successive elements beginning at offset `start`:
    a = [:foo, 'bar', 2]
    a[0, 2] # => [:foo, "bar"]
    a[1, 2] # => ["bar", 2]

If `start + length` is greater than `self.length`, returns all elements from
offset `start` to the end:
    a = [:foo, 'bar', 2]
    a[0, 4] # => [:foo, "bar", 2]
    a[1, 3] # => ["bar", 2]
    a[2, 2] # => [2]

If `start == self.size` and `length >= 0`, returns a new empty Array.

If `length` is negative, returns `nil`.

When a single Range argument `range` is given, treats `range.min` as `start`
above and `range.size` as `length` above:
    a = [:foo, 'bar', 2]
    a[0..1] # => [:foo, "bar"]
    a[1..2] # => ["bar", 2]

Special case: If `range.start == a.size`, returns a new empty Array.

If `range.end` is negative, calculates the end index from the end:
    a = [:foo, 'bar', 2]
    a[0..-1] # => [:foo, "bar", 2]
    a[0..-2] # => [:foo, "bar"]
    a[0..-3] # => [:foo]

If `range.start` is negative, calculates the start index from the end:
    a = [:foo, 'bar', 2]
    a[-1..2] # => [2]
    a[-2..2] # => ["bar", 2]
    a[-3..2] # => [:foo, "bar", 2]

If `range.start` is larger than the array size, returns `nil`.
    a = [:foo, 'bar', 2]
    a[4..1] # => nil
    a[4..0] # => nil
    a[4..-1] # => nil

When a single Enumerator::ArithmeticSequence argument `aseq` is given, returns
an Array of elements corresponding to the indexes produced by the sequence.
    a = ['--', 'data1', '--', 'data2', '--', 'data3']
    a[(1..).step(2)] # => ["data1", "data2", "data3"]

Unlike slicing with range, if the start or the end of the arithmetic sequence
is larger than array size, throws RangeError.
    a = ['--', 'data1', '--', 'data2', '--', 'data3']
    a[(1..11).step(2)]
    # RangeError (((1..11).step(2)) out of range)
    a[(7..).step(2)]
    # RangeError (((7..).step(2)) out of range)

If given a single argument, and its type is not one of the listed, tries to
convert it to Integer, and raises if it is impossible:
    a = [:foo, 'bar', 2]
    # Raises TypeError (no implicit conversion of Symbol into Integer):
    a[:foo]

Array#slice is an alias for Array#[].

;T;0;;;I"[];F;I"
Array;T;[o;;I"::int index;T;I"	Elem;Fo;;I"::int start, ::int length;T;I"Array[Elem]?;To;;I"::Range[::Integer?] range;T;I"Array[Elem]?;To;;I"(Assigns elements in `self`; returns the given `object`.

When Integer argument `index` is given, assigns `object` to an element in
`self`.

If `index` is non-negative, assigns `object` the element at offset `index`:
    a = [:foo, 'bar', 2]
    a[0] = 'foo' # => "foo"
    a # => ["foo", "bar", 2]

If `index` is greater than `self.length`, extends the array:
    a = [:foo, 'bar', 2]
    a[7] = 'foo' # => "foo"
    a # => [:foo, "bar", 2, nil, nil, nil, nil, "foo"]

If `index` is negative, counts backwards from the end of the array:
    a = [:foo, 'bar', 2]
    a[-1] = 'two' # => "two"
    a # => [:foo, "bar", "two"]

When Integer arguments `start` and `length` are given and `object` is not an
Array, removes `length - 1` elements beginning at offset `start`, and assigns
`object` at offset `start`:
    a = [:foo, 'bar', 2]
    a[0, 2] = 'foo' # => "foo"
    a # => ["foo", 2]

If `start` is negative, counts backwards from the end of the array:
    a = [:foo, 'bar', 2]
    a[-2, 2] = 'foo' # => "foo"
    a # => [:foo, "foo"]

If `start` is non-negative and outside the array (` >= self.size`), extends
the array with `nil`, assigns `object` at offset `start`, and ignores
`length`:
    a = [:foo, 'bar', 2]
    a[6, 50] = 'foo' # => "foo"
    a # => [:foo, "bar", 2, nil, nil, nil, "foo"]

If `length` is zero, shifts elements at and following offset `start` and
assigns `object` at offset `start`:
    a = [:foo, 'bar', 2]
    a[1, 0] = 'foo' # => "foo"
    a # => [:foo, "foo", "bar", 2]

If `length` is too large for the existing array, does not extend the array:
    a = [:foo, 'bar', 2]
    a[1, 5] = 'foo' # => "foo"
    a # => [:foo, "foo"]

When Range argument `range` is given and `object` is an Array, removes `length
- 1` elements beginning at offset `start`, and assigns `object` at offset
`start`:
    a = [:foo, 'bar', 2]
    a[0..1] = 'foo' # => "foo"
    a # => ["foo", 2]

if `range.begin` is negative, counts backwards from the end of the array:
    a = [:foo, 'bar', 2]
    a[-2..2] = 'foo' # => "foo"
    a # => [:foo, "foo"]

If the array length is less than `range.begin`, assigns `object` at offset
`range.begin`, and ignores `length`:
    a = [:foo, 'bar', 2]
    a[6..50] = 'foo' # => "foo"
    a # => [:foo, "bar", 2, nil, nil, nil, "foo"]

If `range.end` is zero, shifts elements at and following offset `start` and
assigns `object` at offset `start`:
    a = [:foo, 'bar', 2]
    a[1..0] = 'foo' # => "foo"
    a # => [:foo, "foo", "bar", 2]

If `range.end` is negative, assigns `object` at offset `start`, retains
`range.end.abs -1` elements past that, and removes those beyond:
    a = [:foo, 'bar', 2]
    a[1..-1] = 'foo' # => "foo"
    a # => [:foo, "foo"]
    a = [:foo, 'bar', 2]
    a[1..-2] = 'foo' # => "foo"
    a # => [:foo, "foo", 2]
    a = [:foo, 'bar', 2]
    a[1..-3] = 'foo' # => "foo"
    a # => [:foo, "foo", "bar", 2]
    a = [:foo, 'bar', 2]

If `range.end` is too large for the existing array, replaces array elements,
but does not extend the array with `nil` values:
    a = [:foo, 'bar', 2]
    a[1..5] = 'foo' # => "foo"
    a # => [:foo, "foo"]

;T;0;;;I"[]=;F;I"
Array;T;[o;;I"::int index, Elem obj;T;I"	Elem;Fo;;I"(::int start, ::int length, Elem obj;T;I"	Elem;Fo;;I"-::int start, ::int length, ::Array[Elem];T;I"Array[Elem];To;;I"#::int start, ::int length, nil;T;I"nil;To;;I""::Range[::Integer?], Elem obj;T;I"	Elem;Fo;;I"'::Range[::Integer?], ::Array[Elem];T;I"Array[Elem];To;;I"::Range[::Integer?], nil;T;I"nil;To;;I"HReturns `true` if all elements of `self` meet a given criterion.

With no block given and no argument, returns `true` if `self` contains only
truthy elements, `false` otherwise:
    [0, 1, :foo].all? # => true
    [0, nil, 2].all? # => false
    [].all? # => true

With a block given and no argument, calls the block with each element in
`self`; returns `true` if the block returns only truthy values, `false`
otherwise:
    [0, 1, 2].all? { |element| element < 3 } # => true
    [0, 1, 2].all? { |element| element < 2 } # => false

If argument `obj` is given, returns `true` if `obj.===` every element, `false`
otherwise:
    ['food', 'fool', 'foot'].all?(/foo/) # => true
    ['food', 'drink'].all?(/bar/) # => false
    [].all?(/foo/) # => true
    [0, 0, 0].all?(0) # => true
    [0, 1, 2].all?(1) # => false

Related: Enumerable#all?

;T;0;;;I"	all?;F;I"
Array;T;[o;;I" ;F;I"	bool;To;;I"$::Array::_Pattern[Elem] pattern;T;I"	bool;To;;I" ;F;I"	bool;To;;I"áReturns the first element in `self` that is an Array whose first element `==`
`obj`:
    a = [{foo: 0}, [2, 4], [4, 5, 6], [4, 5]]
    a.assoc(4) # => [4, 5, 6]

Returns `nil` if no such element is found.

Related: #rassoc.

;T;0;;;I"
assoc;F;I"
Array;T;[o;;I"untyped;T;I"Array[untyped]?;To;;I"ŠReturns the element at Integer offset `index`; does not modify `self`.
    a = [:foo, 'bar', 2]
    a.at(0) # => :foo
    a.at(2) # => 2

;T;0;;;I"at;F;I"
Array;T;[o;;I"::int index;T;I"
Elem?;To;;I"rReturns an element from `self` selected by a binary search.

See [Binary Searching](rdoc-ref:bsearch.rdoc).

;T;0;;;I"bsearch;F;I"
Array;T;[o;;I" ;F;I"Enumerator[Elem, Elem?];To;;I" ;F;I"
Elem?;To;;I" ;F;I"
Elem?;To;;I"~Searches `self` as described at method #bsearch, but returns the *index* of
the found element instead of the element itself.

;T;0;;;I"bsearch_index;F;I"
Array;T;[o;;I" ;F;I"Integer?;To;;I" ;F;I"Integer?;To;;I"URemoves all elements from `self`:
    a = [:foo, 'bar', 2]
    a.clear # => []

;T;0;;;I"
clear;F;I"
Array;T;[o;;I" ;F;I"	self;To;;I"šCalls the block, if given, with each element of `self`; returns a new Array
whose elements are the return values from the block:
    a = [:foo, 'bar', 2]
    a1 = a.map {|element| element.class }
    a1 # => [Symbol, String, Integer]

Returns a new Enumerator if no block given:
    a = [:foo, 'bar', 2]
    a1 = a.map
    a1 # => #<Enumerator: [:foo, "bar", 2]:map>

Array#collect is an alias for Array#map.

;T;0;;;I"collect;F;I"
Array;T;[o;;I" ;F;I"Array[U];To;;I" ;F;I"'Enumerator[Elem, ::Array[untyped]];To;;I"uCalls the block, if given, with each element; replaces the element with the
block's return value:
    a = [:foo, 'bar', 2]
    a.map! { |element| element.class } # => [Symbol, String, Integer]

Returns a new Enumerator if no block given:
    a = [:foo, 'bar', 2]
    a1 = a.map!
    a1 # => #<Enumerator: [:foo, "bar", 2]:map!>

Array#collect! is an alias for Array#map!.

;T;0;;;I"collect!;F;I"
Array;T;[o;;I" ;F;I"	self;To;;I" ;F;I"Enumerator[Elem, self];To;;I"Calls the block, if given, with combinations of elements of `self`; returns
`self`. The order of combinations is indeterminate.

When a block and an in-range positive Integer argument `n` (`0 < n <=
self.size`) are given, calls the block with all `n`-tuple combinations of
`self`.

Example:
    a = [0, 1, 2]
    a.combination(2) {|combination| p combination }

Output:
    [0, 1]
    [0, 2]
    [1, 2]

Another example:
    a = [0, 1, 2]
    a.combination(3) {|combination| p combination }

Output:
    [0, 1, 2]

When `n` is zero, calls the block once with a new empty Array:
    a = [0, 1, 2]
    a1 = a.combination(0) {|combination| p combination }

Output:
    []

When `n` is out of range (negative or larger than `self.size`), does not call
the block:
    a = [0, 1, 2]
    a.combination(-1) {|combination| fail 'Cannot happen' }
    a.combination(4) {|combination| fail 'Cannot happen' }

Returns a new Enumerator if no block given:
    a = [0, 1, 2]
    a.combination(2) # => #<Enumerator: [0, 1, 2]:combination(2)>

;T;0;;;I"combination;F;I"
Array;T;[o;;I"::int n;T;I"	self;To;;I"::int n;T;I"$Enumerator[::Array[Elem], self];To;;I"‡Returns a new Array containing all non-`nil` elements from `self`:
    a = [nil, 0, nil, 1, nil, 2, nil]
    a.compact # => [0, 1, 2]

;T;0;;;I"compact;F;I"
Array;T;[o;;I" ;F;I"Array[Elem];To;;I"hRemoves all `nil` elements from `self`.

Returns `self` if any elements removed, otherwise `nil`.

;T;0;;;I"compact!;F;I"
Array;T;[o;;I" ;F;I"
self?;To;;I"•Adds to `array` all elements from each Array in `other_arrays`; returns
`self`:
    a = [0, 1]
    a.concat([2, 3], [4, 5]) # => [0, 1, 2, 3, 4, 5]

;T;0;;;I"concat;F;I"
Array;T;[o;;I"*::Array[Elem] arrays;T;I"	self;To;;I"dReturns a count of specified elements.

With no argument and no block, returns the count of all elements:
    [0, 1, 2].count # => 3
    [].count # => 0

With argument `obj`, returns the count of elements `==` to `obj`:
    [0, 1, 2, 0.0].count(0) # => 2
    [0, 1, 2].count(3) # => 0

With no argument and a block given, calls the block with each element; returns
the count of elements for which the block returns a truthy value:
    [0, 1, 2, 3].count {|element| element > 1} # => 2

With argument `obj` and a block given, issues a warning, ignores the block,
and returns the count of elements `==` to `obj`:

;T;0;;;I"
count;F;I"
Array;T;[o;;I" ;F;I"Integer;To;;I"Elem obj;T;I"Integer;To;;I" ;F;I"Integer;To;;I"eWhen called with positive Integer argument `count` and a block, calls the
block with each element, then does so again, until it has done so `count`
times; returns `nil`:
    output = []
    [0, 1].cycle(2) {|element| output.push(element) } # => nil
    output # => [0, 1, 0, 1]

If `count` is zero or negative, does not call the block:
    [0, 1].cycle(0) {|element| fail 'Cannot happen' } # => nil
    [0, 1].cycle(-1) {|element| fail 'Cannot happen' } # => nil

When a block is given, and argument is omitted or `nil`, cycles forever:
    # Prints 0 and 1 forever.
    [0, 1].cycle {|element| puts element }
    [0, 1].cycle(nil) {|element| puts element }

When no block is given, returns a new Enumerator:

    [0, 1].cycle(2) # => #<Enumerator: [0, 1]:cycle(2)>
    [0, 1].cycle # => # => #<Enumerator: [0, 1]:cycle>
    [0, 1].cycle.first(5) # => [0, 1, 0, 1, 0]

;T;0;;;I"
cycle;F;I"
Array;T;[o;;I"?::int? n;T;I"nil;To;;I"?::int? n;T;I"Enumerator[Elem, nil];To;;I" ;T;0;;;I"deconstruct;F;I"
Array;T;[o;;I" ;F;I"	self;To;;I"%Removes zero or more elements from `self`; returns `self`.

When no block is given, removes from `self` each element `ele` such that `ele
== obj`; returns the last deleted element:
    s1 = 'bar'; s2 = 'bar'
    a = [:foo, s1, 2, s2]
    a.delete('bar') # => "bar"
    a # => [:foo, 2]

Returns `nil` if no elements removed.

When a block is given, removes from `self` each element `ele` such that `ele
== obj`.

If any such elements are found, ignores the block and returns the last deleted
element:
    s1 = 'bar'; s2 = 'bar'
    a = [:foo, s1, 2, s2]
    deleted_obj = a.delete('bar') {|obj| fail 'Cannot happen' }
    a # => [:foo, 2]

If no such elements are found, returns the block's return value:
    a = [:foo, 'bar', 2]
    a.delete(:nosuch) {|obj| "#{obj} not found" } # => "nosuch not found"

;T;0;;;I"delete;F;I"
Array;T;[o;;I"Elem obj;T;I"
Elem?;To;;I"
S obj;T;I"Elem | T;Fo;;I"ÃDeletes an element from `self`, per the given Integer `index`.

When `index` is non-negative, deletes the element at offset `index`:
    a = [:foo, 'bar', 2]
    a.delete_at(1) # => "bar"
    a # => [:foo, 2]

If index is too large, returns `nil`.

When `index` is negative, counts backward from the end of the array:
    a = [:foo, 'bar', 2]
    a.delete_at(-2) # => "bar"
    a # => [:foo, 2]

If `index` is too small (far from zero), returns nil.

;T;0;;;I"delete_at;F;I"
Array;T;[o;;I"::int index;T;I"
Elem?;To;;I"KRemoves each element in `self` for which the block returns a truthy value;
returns `self`:
    a = [:foo, 'bar', 2, 'bat']
    a.delete_if {|element| element.to_s.start_with?('b') } # => [:foo, 2]

Returns a new Enumerator if no block given:
    a = [:foo, 'bar', 2]
    a.delete_if # => #<Enumerator: [:foo, "bar", 2]:delete_if>

;T;0;;;I"delete_if;F;I"
Array;T;[o;;I" ;F;I"	self;To;;I" ;F;I"Enumerator[Elem, self];To;;I"žReturns a new Array containing only those elements from `self` that are not
found in any of the Arrays `other_arrays`; items are compared using `eql?`;
order from `self` is preserved:
    [0, 1, 1, 2, 1, 1, 3, 1, 1].difference([1]) # => [0, 2, 3]
    [0, 1, 2, 3].difference([3, 0], [1, 3]) # => [2]
    [0, 1, 2].difference([4]) # => [0, 1, 2]

Returns a copy of `self` if no arguments given.

Related: Array#-.

;T;0;;;I"difference;F;I"
Array;T;[o;;I"*::Array[untyped] arrays;T;I"Array[Elem];To;;I"„Finds and returns the object in nested objects that is specified by `index`
and `identifiers`. The nested objects may be instances of various classes. See
[Dig Methods](rdoc-ref:dig_methods.rdoc).

Examples:
    a = [:foo, [:bar, :baz, [:bat, :bam]]]
    a.dig(1) # => [:bar, :baz, [:bat, :bam]]
    a.dig(1, 2) # => [:bat, :bam]
    a.dig(1, 2, 0) # => :bat
    a.dig(1, 2, 3) # => nil

;T;0;;;I"dig;F;I"
Array;T;[o;;I"::int idx;T;I"
Elem?;To;;I"!::int idx, untyped, *untyped;T;I"untyped;To;;I"Returns a new Array containing all but the first `n` element of `self`, where
`n` is a non-negative Integer; does not modify `self`.

Examples:
    a = [0, 1, 2, 3, 4, 5]
    a.drop(0) # => [0, 1, 2, 3, 4, 5]
    a.drop(1) # => [1, 2, 3, 4, 5]
    a.drop(2) # => [2, 3, 4, 5]

;T;0;;;I"	drop;F;I"
Array;T;[o;;I"::int n;T;I"Array[Elem];To;;I"üReturns a new Array containing zero or more trailing elements of `self`; does
not modify `self`.

With a block given, calls the block with each successive element of `self`;
stops if the block returns `false` or `nil`; returns a new Array *omitting*
those elements for which the block returned a truthy value:
    a = [0, 1, 2, 3, 4, 5]
    a.drop_while {|element| element < 3 } # => [3, 4, 5]

With no block given, returns a new Enumerator:
    [0, 1].drop_while # => # => #<Enumerator: [0, 1]:drop_while>

;T;0;;;I"drop_while;F;I"
Array;T;[o;;I" ;F;I"Array[Elem];To;;I" ;F;I"$Enumerator[Elem, ::Array[Elem]];To;;I"ÙIterates over array elements.

When a block given, passes each successive array element to the block; returns
`self`:
    a = [:foo, 'bar', 2]
    a.each {|element|  puts "#{element.class} #{element}" }

Output:
    Symbol foo
    String bar
    Integer 2

Allows the array to be modified during iteration:
    a = [:foo, 'bar', 2]
    a.each {|element| puts element; a.clear if element.to_s.start_with?('b') }

Output:
    foo
    bar

When no block given, returns a new Enumerator:
    a = [:foo, 'bar', 2]
    e = a.each
    e # => #<Enumerator: [:foo, "bar", 2]:each>
    a1 = e.each {|element|  puts "#{element.class} #{element}" }

Output:
    Symbol foo
    String bar
    Integer 2

Related: #each_index, #reverse_each.

;T;0;;;I"	each;F;I"
Array;T;[o;;I" ;F;I"Enumerator[Elem, self];To;;I" ;F;I"	self;To;;I"™Iterates over array indexes.

When a block given, passes each successive array index to the block; returns
`self`:
    a = [:foo, 'bar', 2]
    a.each_index {|index|  puts "#{index} #{a[index]}" }

Output:
    0 foo
    1 bar
    2 2

Allows the array to be modified during iteration:
    a = [:foo, 'bar', 2]
    a.each_index {|index| puts index; a.clear if index > 0 }

Output:
    0
    1

When no block given, returns a new Enumerator:
    a = [:foo, 'bar', 2]
    e = a.each_index
    e # => #<Enumerator: [:foo, "bar", 2]:each_index>
    a1 = e.each {|index|  puts "#{index} #{a[index]}"}

Output:
    0 foo
    1 bar
    2 2

Related: #each, #reverse_each.

;T;0;;;I"each_index;F;I"
Array;T;[o;;I" ;F;I"	self;To;;I" ;F;I" Enumerator[::Integer, self];To;;I"TReturns `true` if the count of elements in `self` is zero, `false` otherwise.

;T;0;;;I"empty?;F;I"
Array;T;[o;;I" ;F;I"	bool;To;;I"[Returns `true` if `self` and `other_array` are the same size, and if, for each
index `i` in `self`, `self[i].eql? other_array[i]`:
    a0 = [:foo, 'bar', 2]
    a1 = [:foo, 'bar', 2]
    a1.eql?(a0) # => true

Otherwise, returns `false`.

This method is different from method [Array#==](#method-i-3D-3D), which
compares using method `Object#==`.

;T;0;;;I"	eql?;F;I"
Array;T;[o;;I"untyped other;T;I"	bool;To;;I"RReturns the element at offset  `index`.

With the single Integer argument `index`, returns the element at offset
`index`:
    a = [:foo, 'bar', 2]
    a.fetch(1) # => "bar"

If `index` is negative, counts from the end of the array:
    a = [:foo, 'bar', 2]
    a.fetch(-1) # => 2
    a.fetch(-2) # => "bar"

With arguments `index` and `default_value`, returns the element at offset
`index` if index is in range, otherwise returns `default_value`:
    a = [:foo, 'bar', 2]
    a.fetch(1, nil) # => "bar"

With argument `index` and a block, returns the element at offset `index` if
index is in range (and the block is not called); otherwise calls the block
with index and returns its return value:

    a = [:foo, 'bar', 2]
    a.fetch(1) {|index| raise 'Cannot happen' } # => "bar"
    a.fetch(50) {|index| "Value for #{index}" } # => "Value for 50"

;T;0;;;I"
fetch;F;I"
Array;T;[o;;I"::int index;T;I"	Elem;Fo;;I"::int index, T default;T;I"Elem | T;Fo;;I"::int index;T;I"Elem | T;Fo;;I"ÛReplaces specified elements in `self` with specified objects; returns `self`.

With argument `obj` and no block given, replaces all elements with that one
object:
    a = ['a', 'b', 'c', 'd']
    a # => ["a", "b", "c", "d"]
    a.fill(:X) # => [:X, :X, :X, :X]

With arguments `obj` and Integer `start`, and no block given, replaces
elements based on the given start.

If `start` is in range (`0 <= start < array.size`), replaces all elements from
offset `start` through the end:
    a = ['a', 'b', 'c', 'd']
    a.fill(:X, 2) # => ["a", "b", :X, :X]

If `start` is too large (`start >= array.size`), does nothing:
    a = ['a', 'b', 'c', 'd']
    a.fill(:X, 4) # => ["a", "b", "c", "d"]
    a = ['a', 'b', 'c', 'd']
    a.fill(:X, 5) # => ["a", "b", "c", "d"]

If `start` is negative, counts from the end (starting index is `start +
array.size`):
    a = ['a', 'b', 'c', 'd']
    a.fill(:X, -2) # => ["a", "b", :X, :X]

If `start` is too small (less than and far from zero), replaces all elements:
    a = ['a', 'b', 'c', 'd']
    a.fill(:X, -6) # => [:X, :X, :X, :X]
    a = ['a', 'b', 'c', 'd']
    a.fill(:X, -50) # => [:X, :X, :X, :X]

With arguments `obj`, Integer `start`, and Integer `length`, and no block
given, replaces elements based on the given `start` and `length`.

If `start` is in range, replaces `length` elements beginning at offset
`start`:
    a = ['a', 'b', 'c', 'd']
    a.fill(:X, 1, 1) # => ["a", :X, "c", "d"]

If `start` is negative, counts from the end:
    a = ['a', 'b', 'c', 'd']
    a.fill(:X, -2, 1) # => ["a", "b", :X, "d"]

If `start` is large (`start >= array.size`), extends `self` with `nil`:
    a = ['a', 'b', 'c', 'd']
    a.fill(:X, 5, 0) # => ["a", "b", "c", "d", nil]
    a = ['a', 'b', 'c', 'd']
    a.fill(:X, 5, 2) # => ["a", "b", "c", "d", nil, :X, :X]

If `length` is zero or negative, replaces no elements:
    a = ['a', 'b', 'c', 'd']
    a.fill(:X, 1, 0) # => ["a", "b", "c", "d"]
    a.fill(:X, 1, -1) # => ["a", "b", "c", "d"]

With arguments `obj` and Range `range`, and no block given, replaces elements
based on the given range.

If the range is positive and ascending (`0 < range.begin <= range.end`),
replaces elements from `range.begin` to `range.end`:
    a = ['a', 'b', 'c', 'd']
    a.fill(:X, (1..1)) # => ["a", :X, "c", "d"]

If `range.first` is negative, replaces no elements:
    a = ['a', 'b', 'c', 'd']
    a.fill(:X, (-1..1)) # => ["a", "b", "c", "d"]

If `range.last` is negative, counts from the end:
    a = ['a', 'b', 'c', 'd']
    a.fill(:X, (0..-2)) # => [:X, :X, :X, "d"]
    a = ['a', 'b', 'c', 'd']
    a.fill(:X, (1..-2)) # => ["a", :X, :X, "d"]

If `range.last` and `range.last` are both negative, both count from the end of
the array:
    a = ['a', 'b', 'c', 'd']
    a.fill(:X, (-1..-1)) # => ["a", "b", "c", :X]
    a = ['a', 'b', 'c', 'd']
    a.fill(:X, (-2..-2)) # => ["a", "b", :X, "d"]

With no arguments and a block given, calls the block with each index; replaces
the corresponding element with the block's return value:
    a = ['a', 'b', 'c', 'd']
    a.fill { |index| "new_#{index}" } # => ["new_0", "new_1", "new_2", "new_3"]

With argument `start` and a block given, calls the block with each index from
offset `start` to the end; replaces the corresponding element with the block's
return value:

If start is in range (`0 <= start < array.size`), replaces from offset `start`
to the end:
    a = ['a', 'b', 'c', 'd']
    a.fill(1) { |index| "new_#{index}" } # => ["a", "new_1", "new_2", "new_3"]

If `start` is too large(`start >= array.size`), does nothing:
    a = ['a', 'b', 'c', 'd']
    a.fill(4) { |index| fail 'Cannot happen' } # => ["a", "b", "c", "d"]
    a = ['a', 'b', 'c', 'd']
    a.fill(4) { |index| fail 'Cannot happen' } # => ["a", "b", "c", "d"]

If `start` is negative, counts from the end:
    a = ['a', 'b', 'c', 'd']
    a.fill(-2) { |index| "new_#{index}" } # => ["a", "b", "new_2", "new_3"]

If start is too small (`start <= -array.size`, replaces all elements:
    a = ['a', 'b', 'c', 'd']
    a.fill(-6) { |index| "new_#{index}" } # => ["new_0", "new_1", "new_2", "new_3"]
    a = ['a', 'b', 'c', 'd']
    a.fill(-50) { |index| "new_#{index}" } # => ["new_0", "new_1", "new_2", "new_3"]

With arguments `start` and `length`, and a block given, calls the block for
each index specified by start length; replaces the corresponding element with
the block's return value.

If `start` is in range, replaces `length` elements beginning at offset
`start`:
    a = ['a', 'b', 'c', 'd']
    a.fill(1, 1) { |index| "new_#{index}" } # => ["a", "new_1", "c", "d"]

If start is negative, counts from the end:
    a = ['a', 'b', 'c', 'd']
    a.fill(-2, 1) { |index| "new_#{index}" } # => ["a", "b", "new_2", "d"]

If `start` is large (`start >= array.size`), extends `self` with `nil`:
    a = ['a', 'b', 'c', 'd']
    a.fill(5, 0) { |index| "new_#{index}" } # => ["a", "b", "c", "d", nil]
    a = ['a', 'b', 'c', 'd']
    a.fill(5, 2) { |index| "new_#{index}" } # => ["a", "b", "c", "d", nil, "new_5", "new_6"]

If `length` is zero or less, replaces no elements:
    a = ['a', 'b', 'c', 'd']
    a.fill(1, 0) { |index| "new_#{index}" } # => ["a", "b", "c", "d"]
    a.fill(1, -1) { |index| "new_#{index}" } # => ["a", "b", "c", "d"]

With arguments `obj` and `range`, and a block given, calls the block with each
index in the given range; replaces the corresponding element with the block's
return value.

If the range is positive and ascending (`range 0 < range.begin <= range.end`,
replaces elements from `range.begin` to `range.end`:
    a = ['a', 'b', 'c', 'd']
    a.fill(1..1) { |index| "new_#{index}" } # => ["a", "new_1", "c", "d"]

If `range.first` is negative, does nothing:
    a = ['a', 'b', 'c', 'd']
    a.fill(-1..1) { |index| fail 'Cannot happen' } # => ["a", "b", "c", "d"]

If `range.last` is negative, counts from the end:
    a = ['a', 'b', 'c', 'd']
    a.fill(0..-2) { |index| "new_#{index}" } # => ["new_0", "new_1", "new_2", "d"]
    a = ['a', 'b', 'c', 'd']
    a.fill(1..-2) { |index| "new_#{index}" } # => ["a", "new_1", "new_2", "d"]

If `range.first` and `range.last` are both negative, both count from the end:
    a = ['a', 'b', 'c', 'd']
    a.fill(-1..-1) { |index| "new_#{index}" } # => ["a", "b", "c", "new_3"]
    a = ['a', 'b', 'c', 'd']
    a.fill(-2..-2) { |index| "new_#{index}" } # => ["a", "b", "new_2", "d"]

;T;0;;;I"	fill;F;I"
Array;T;[
o;;I"Elem obj;T;I"	self;To;;I"+Elem obj, ::int? start, ?::int? length;T;I"	self;To;;I"'Elem obj, ::Range[::Integer] range;T;I"	self;To;;I""?::int? start, ?::int? length;T;I"	self;To;;I"::Range[::Integer] range;T;I"	self;To;;I"ÊCalls the block, if given, with each element of `self`; returns a new Array
containing those elements of `self` for which the block returns a truthy
value:
    a = [:foo, 'bar', 2, :bam]
    a1 = a.select {|element| element.to_s.start_with?('b') }
    a1 # => ["bar", :bam]

Returns a new Enumerator if no block given:
    a = [:foo, 'bar', 2, :bam]
    a.select # => #<Enumerator: [:foo, "bar", 2, :bam]:select>

Array#filter is an alias for Array#select.

;T;0;;;I"filter;F;I"
Array;T;[o;;I" ;F;I"Array[Elem];To;;I" ;F;I"$Enumerator[Elem, ::Array[Elem]];To;;I"
Calls the block, if given  with each element of `self`; removes from `self`
those elements for which the block returns `false` or `nil`.

Returns `self` if any elements were removed:
    a = [:foo, 'bar', 2, :bam]
    a.select! {|element| element.to_s.start_with?('b') } # => ["bar", :bam]

Returns `nil` if no elements were removed.

Returns a new Enumerator if no block given:
    a = [:foo, 'bar', 2, :bam]
    a.select! # => #<Enumerator: [:foo, "bar", 2, :bam]:select!>

Array#filter! is an alias for Array#select!.

;T;0;;;I"filter!;F;I"
Array;T;[o;;I" ;F;I"
self?;To;;I" ;F;I"Enumerator[Elem, self?];To;;I"cReturns the index of a specified element.

When argument `object` is given but no block, returns the index of the first
element `element` for which `object == element`:
    a = [:foo, 'bar', 2, 'bar']
    a.index('bar') # => 1

Returns `nil` if no such element found.

When both argument `object` and a block are given, calls the block with each
successive element; returns the index of the first element for which the block
returns a truthy value:
    a = [:foo, 'bar', 2, 'bar']
    a.index {|element| element == 'bar' } # => 1

Returns `nil` if the block never returns a truthy value.

When neither an argument nor a block is given, returns a new Enumerator:
    a = [:foo, 'bar', 2]
    e = a.index
    e # => #<Enumerator: [:foo, "bar", 2]:index>
    e.each {|element| element == 'bar' } # => 1

Array#find_index is an alias for Array#index.

Related: #rindex.

;T;0;;;I"find_index;F;I"
Array;T;[o;;I"untyped obj;T;I"Integer?;To;;I" ;F;I"Integer?;To;;I" ;F;I"!Enumerator[Elem, ::Integer?];To;;I"LReturns elements from `self`; does not modify `self`.

When no argument is given, returns the first element:
    a = [:foo, 'bar', 2]
    a.first # => :foo
    a # => [:foo, "bar", 2]

If `self` is empty, returns `nil`.

When non-negative Integer argument `n` is given, returns the first `n`
elements in a new Array:
    a = [:foo, 'bar', 2]
    a.first(2) # => [:foo, "bar"]

If `n >= array.size`, returns all elements:
    a = [:foo, 'bar', 2]
    a.first(50) # => [:foo, "bar", 2]

If `n == 0` returns an new empty Array:
    a = [:foo, 'bar', 2]
    a.first(0) # []

Related: #last.

;T;0;;;I"
first;F;I"
Array;T;[o;;I" ;F;I"
Elem?;To;;I"::int n;T;I"Array[Elem];To;;I"¾Returns a new Array that is a recursive flattening of `self`:
*   Each non-Array element is unchanged.
*   Each Array is replaced by its individual elements.


With non-negative Integer argument `level`, flattens recursively through
`level` levels:
    a = [ 0, [ 1, [2, 3], 4 ], 5 ]
    a.flatten(0) # => [0, [1, [2, 3], 4], 5]
    a = [ 0, [ 1, [2, 3], 4 ], 5 ]
    a.flatten(1) # => [0, 1, [2, 3], 4, 5]
    a = [ 0, [ 1, [2, 3], 4 ], 5 ]
    a.flatten(2) # => [0, 1, 2, 3, 4, 5]
    a = [ 0, [ 1, [2, 3], 4 ], 5 ]
    a.flatten(3) # => [0, 1, 2, 3, 4, 5]

With no argument, a `nil` argument, or with negative argument `level`,
flattens all levels:
    a = [ 0, [ 1, [2, 3], 4 ], 5 ]
    a.flatten # => [0, 1, 2, 3, 4, 5]
    [0, 1, 2].flatten # => [0, 1, 2]
    a = [ 0, [ 1, [2, 3], 4 ], 5 ]
    a.flatten(-1) # => [0, 1, 2, 3, 4, 5]
    a = [ 0, [ 1, [2, 3], 4 ], 5 ]
    a.flatten(-2) # => [0, 1, 2, 3, 4, 5]
    [0, 1, 2].flatten(-1) # => [0, 1, 2]

;T;0;;;I"flatten;F;I"
Array;T;[o;;I"?::int level;T;I"Array[untyped];To;;I"fReplaces each nested Array in `self` with the elements from that Array;
returns `self` if any changes, `nil` otherwise.

With non-negative Integer argument `level`, flattens recursively through
`level` levels:
    a = [ 0, [ 1, [2, 3], 4 ], 5 ]
    a.flatten!(1) # => [0, 1, [2, 3], 4, 5]
    a = [ 0, [ 1, [2, 3], 4 ], 5 ]
    a.flatten!(2) # => [0, 1, 2, 3, 4, 5]
    a = [ 0, [ 1, [2, 3], 4 ], 5 ]
    a.flatten!(3) # => [0, 1, 2, 3, 4, 5]
    [0, 1, 2].flatten!(1) # => nil

With no argument, a `nil` argument, or with negative argument `level`,
flattens all levels:
    a = [ 0, [ 1, [2, 3], 4 ], 5 ]
    a.flatten! # => [0, 1, 2, 3, 4, 5]
    [0, 1, 2].flatten! # => nil
    a = [ 0, [ 1, [2, 3], 4 ], 5 ]
    a.flatten!(-1) # => [0, 1, 2, 3, 4, 5]
    a = [ 0, [ 1, [2, 3], 4 ], 5 ]
    a.flatten!(-2) # => [0, 1, 2, 3, 4, 5]
    [0, 1, 2].flatten!(-1) # => nil

;T;0;;;I"flatten!;F;I"
Array;T;[o;;I"?::int level;T;I"
self?;To;;I"éReturns the integer hash value for `self`.

Two arrays with the same content will have the same hash code (and will
compare using eql?):
    [0, 1, 2].hash == [0, 1, 2].hash # => true
    [0, 1, 2].hash == [0, 1, 3].hash # => false

;T;0;;;I"	hash;F;I"
Array;T;[o;;I" ;F;I"Integer;To;;I"ŸReturns `true` if for some index `i` in `self`, `obj == self[i]`; otherwise
`false`:
    [0, 1, 2].include?(2) # => true
    [0, 1, 2].include?(3) # => false

;T;0;;;I"include?;F;I"
Array;T;[o;;I"Elem object;T;I"	bool;To;;I"Inserts given `objects` before or after the element at Integer index `offset`;
returns `self`.

When `index` is non-negative, inserts all given `objects` before the element
at offset `index`:
    a = [:foo, 'bar', 2]
    a.insert(1, :bat, :bam) # => [:foo, :bat, :bam, "bar", 2]

Extends the array if `index` is beyond the array (`index >= self.size`):
    a = [:foo, 'bar', 2]
    a.insert(5, :bat, :bam)
    a # => [:foo, "bar", 2, nil, nil, :bat, :bam]

Does nothing if no objects given:
    a = [:foo, 'bar', 2]
    a.insert(1)
    a.insert(50)
    a.insert(-50)
    a # => [:foo, "bar", 2]

When `index` is negative, inserts all given `objects` *after* the element at
offset `index+self.size`:
    a = [:foo, 'bar', 2]
    a.insert(-2, :bat, :bam)
    a # => [:foo, "bar", :bat, :bam, 2]

;T;0;;;I"insert;F;I"
Array;T;[o;;I"::int index, *Elem obj;T;I"	self;To;;I"¿Returns the new String formed by calling method `#inspect` on each array
element:
    a = [:foo, 'bar', 2]
    a.inspect # => "[:foo, \"bar\", 2]"

Array#to_s is an alias for Array#inspect.

;T;0;;;I"inspect;F;I"
Array;T;[o;;I" ;F;I"String;To;;I"éReturns `true` if the array and `other_ary` have at least one element in
common, otherwise returns `false`.

    a = [ 1, 2, 3 ]
    b = [ 3, 4, 5 ]
    c = [ 5, 6, 7 ]
    a.intersect?(b)   #=> true
    a.intersect?(c)   #=> false

;T;0;;;I"intersect?;F;I"
Array;T;[o;;I"::_ToAry[untyped];T;I"	bool;To;;I"ÇReturns a new Array containing each element found both in `self` and in all of
the given Arrays `other_arrays`; duplicates are omitted; items are compared
using `eql?`:
    [0, 1, 2, 3].intersection([0, 1, 2], [0, 1, 3]) # => [0, 1]
    [0, 0, 1, 1, 2, 3].intersection([0, 1, 2], [0, 1, 3]) # => [0, 1]

Preserves order from `self`:
    [0, 1, 2].intersection([2, 1, 0]) # => [0, 1, 2]

Returns a copy of `self` if no arguments given.

Related: Array#&.

;T;0;;;I"intersection;F;I"
Array;T;[o;;I"4*::Array[untyped] | ::_ToAry[untyped] other_ary;T;I"Array[Elem];To;;I"lReturns the new String formed by joining the array elements after conversion.
For each element `element`
*   Uses `element.to_s` if `element` is not a `kind_of?(Array)`.
*   Uses recursive `element.join(separator)` if `element` is a
    `kind_of?(Array)`.


With no argument, joins using the output field separator, `$,`:
    a = [:foo, 'bar', 2]
    $, # => nil
    a.join # => "foobar2"

With string argument `separator`, joins using that separator:
    a = [:foo, 'bar', 2]
    a.join("\n") # => "foo\nbar\n2"

Joins recursively for nested Arrays:
    a = [:foo, [:bar, [:baz, :bat]]]
    a.join # => "foobarbazbat"

;T;0;;;I"	join;F;I"
Array;T;[o;;I"?::string separator;T;I"String;To;;I"hRetains those elements for which the block returns a truthy value; deletes all
other elements; returns `self`:
    a = [:foo, 'bar', 2, :bam]
    a.keep_if {|element| element.to_s.start_with?('b') } # => ["bar", :bam]

Returns a new Enumerator if no block given:
    a = [:foo, 'bar', 2, :bam]
    a.keep_if # => #<Enumerator: [:foo, "bar", 2, :bam]:keep_if>

;T;0;;;I"keep_if;F;I"
Array;T;[o;;I" ;F;I"	self;To;;I" ;F;I"Enumerator[Elem, self];To;;I"CReturns elements from `self`; `self` is not modified.

When no argument is given, returns the last element:
    a = [:foo, 'bar', 2]
    a.last # => 2
    a # => [:foo, "bar", 2]

If `self` is empty, returns `nil`.

When non-negative Innteger argument `n` is given, returns the last `n`
elements in a new Array:
    a = [:foo, 'bar', 2]
    a.last(2) # => ["bar", 2]

If `n >= array.size`, returns all elements:
    a = [:foo, 'bar', 2]
    a.last(50) # => [:foo, "bar", 2]

If `n == 0`, returns an new empty Array:
    a = [:foo, 'bar', 2]
    a.last(0) # []

Related: #first.

;T;0;;;I"	last;F;I"
Array;T;[o;;I" ;F;I"
Elem?;To;;I"::int n;T;I"Array[Elem];To;;I"/Returns the count of elements in `self`.

;T;0;;;I"length;F;I"
Array;T;[o;;I" ;F;I"Integer;To;;I"Returns one of the following:
*   The maximum-valued element from `self`.
*   A new Array of maximum-valued elements selected from `self`.


When no block is given, each element in `self` must respond to method `<=>`
with an Integer.

With no argument and no block, returns the element in `self` having the
maximum value per method `<=>`:
    [0, 1, 2].max # => 2

With an argument Integer `n` and no block, returns a new Array with at most
`n` elements, in descending order per method `<=>`:
    [0, 1, 2, 3].max(3) # => [3, 2, 1]
    [0, 1, 2, 3].max(6) # => [3, 2, 1, 0]

When a block is given, the block must return an Integer.

With a block and no argument, calls the block `self.size-1` times to compare
elements; returns the element having the maximum value per the block:
    ['0', '00', '000'].max {|a, b| a.size <=> b.size } # => "000"

With an argument `n` and a block, returns a new Array with at most `n`
elements, in descending order per the block:
    ['0', '00', '000'].max(2) {|a, b| a.size <=> b.size } # => ["000", "00"]

;T;0;;;I"max;F;I"
Array;T;[	o;;I" ;F;I"
Elem?;To;;I" ;F;I"
Elem?;To;;I"::int n;T;I"Array[Elem];To;;I"::int n;T;I"Array[Elem];To;;I"’Returns a new 2-element Array containing the minimum and maximum values from
`self`, either per method `<=>` or per a given block:.

When no block is given, each element in `self` must respond to method `<=>`
with an Integer; returns a new 2-element Array containing the minimum and
maximum values from `self`, per method `<=>`:
    [0, 1, 2].minmax # => [0, 2]

When a block is given, the block must return an Integer; the block is called
`self.size-1` times to compare elements; returns a new 2-element Array
containing the minimum and maximum values from `self`, per the block:
    ['0', '00', '000'].minmax {|a, b| a.size <=> b.size } # => ["0", "000"]

;T;0;;;I"minmax;F;I"
Array;T;[o;;I" ;F;I"[ Elem?, Elem? ];To;;I" ;F;I"[ Elem?, Elem? ];To;;I"3Packs the contents of *arr* into a binary sequence according to the directives
in *aTemplateString* (see the table below) Directives ``A,'' ``a,'' and ``Z''
may be followed by a count, which gives the width of the resulting field. The
remaining directives also may take a count, indicating the number of array
elements to convert. If the count is an asterisk (```*`''), all remaining
array elements will be converted. Any of the directives ```sSiIlL`'' may be
followed by an underscore (```_`'') or exclamation mark (```!`'') to use the
underlying platform's native size for the specified type; otherwise, they use
a platform-independent size. Spaces are ignored in the template string. See
also String#unpack.

    a = [ "a", "b", "c" ]
    n = [ 65, 66, 67 ]
    a.pack("A3A3A3")   #=> "a  b  c  "
    a.pack("a3a3a3")   #=> "a\000\000b\000\000c\000\000"
    n.pack("ccc")      #=> "ABC"

If *aBufferString* is specified and its capacity is enough, `pack` uses it as
the buffer and returns it. When the offset is specified by the beginning of
*aTemplateString*, the result is filled after the offset. If original contents
of *aBufferString* exists and it's longer than the offset, the rest of
*offsetOfBuffer* are overwritten by the result. If it's shorter, the gap is
filled with ```\0`''.

    # packed data is appended by default
    [255].pack("C", buffer:"foo".b) #=> "foo\xFF"

    # "@0" (offset 0) specifies that packed data is filled from beginning.
    # Also, original data after packed data is removed. ("oo" is removed.)
    [255].pack("@0C", buffer:"foo".b) #=> "\xFF"

    # If the offset is bigger than the original length, \x00 is filled.
    [255].pack("@5C", buffer:"foo".b) #=> "foo\x00\x00\xFF"

Note that ``buffer:'' option does not guarantee not to allocate memory in
`pack`.  If the capacity of *aBufferString* is not enough, `pack` allocates
memory.

Directives for `pack`.

    Integer       | Array   |
    Directive     | Element | Meaning
    ----------------------------------------------------------------------------
    C             | Integer | 8-bit unsigned (unsigned char)
    S             | Integer | 16-bit unsigned, native endian (uint16_t)
    L             | Integer | 32-bit unsigned, native endian (uint32_t)
    Q             | Integer | 64-bit unsigned, native endian (uint64_t)
    J             | Integer | pointer width unsigned, native endian (uintptr_t)
                  |         | (J is available since Ruby 2.3.)
                  |         |
    c             | Integer | 8-bit signed (signed char)
    s             | Integer | 16-bit signed, native endian (int16_t)
    l             | Integer | 32-bit signed, native endian (int32_t)
    q             | Integer | 64-bit signed, native endian (int64_t)
    j             | Integer | pointer width signed, native endian (intptr_t)
                  |         | (j is available since Ruby 2.3.)
                  |         |
    S_ S!         | Integer | unsigned short, native endian
    I I_ I!       | Integer | unsigned int, native endian
    L_ L!         | Integer | unsigned long, native endian
    Q_ Q!         | Integer | unsigned long long, native endian (ArgumentError
                  |         | if the platform has no long long type.)
                  |         | (Q_ and Q! is available since Ruby 2.1.)
    J!            | Integer | uintptr_t, native endian (same with J)
                  |         | (J! is available since Ruby 2.3.)
                  |         |
    s_ s!         | Integer | signed short, native endian
    i i_ i!       | Integer | signed int, native endian
    l_ l!         | Integer | signed long, native endian
    q_ q!         | Integer | signed long long, native endian (ArgumentError
                  |         | if the platform has no long long type.)
                  |         | (q_ and q! is available since Ruby 2.1.)
    j!            | Integer | intptr_t, native endian (same with j)
                  |         | (j! is available since Ruby 2.3.)
                  |         |
    S> s> S!> s!> | Integer | same as the directives without ">" except
    L> l> L!> l!> |         | big endian
    I!> i!>       |         | (available since Ruby 1.9.3)
    Q> q> Q!> q!> |         | "S>" is the same as "n"
    J> j> J!> j!> |         | "L>" is the same as "N"
                  |         |
    S< s< S!< s!< | Integer | same as the directives without "<" except
    L< l< L!< l!< |         | little endian
    I!< i!<       |         | (available since Ruby 1.9.3)
    Q< q< Q!< q!< |         | "S<" is the same as "v"
    J< j< J!< j!< |         | "L<" is the same as "V"
                  |         |
    n             | Integer | 16-bit unsigned, network (big-endian) byte order
    N             | Integer | 32-bit unsigned, network (big-endian) byte order
    v             | Integer | 16-bit unsigned, VAX (little-endian) byte order
    V             | Integer | 32-bit unsigned, VAX (little-endian) byte order
                  |         |
    U             | Integer | UTF-8 character
    w             | Integer | BER-compressed integer

    Float        | Array   |
    Directive    | Element | Meaning
    ---------------------------------------------------------------------------
    D d          | Float   | double-precision, native format
    F f          | Float   | single-precision, native format
    E            | Float   | double-precision, little-endian byte order
    e            | Float   | single-precision, little-endian byte order
    G            | Float   | double-precision, network (big-endian) byte order
    g            | Float   | single-precision, network (big-endian) byte order

    String       | Array   |
    Directive    | Element | Meaning
    ---------------------------------------------------------------------------
    A            | String  | arbitrary binary string (space padded, count is width)
    a            | String  | arbitrary binary string (null padded, count is width)
    Z            | String  | same as ``a'', except that null is added with *
    B            | String  | bit string (MSB first)
    b            | String  | bit string (LSB first)
    H            | String  | hex string (high nibble first)
    h            | String  | hex string (low nibble first)
    u            | String  | UU-encoded string
    M            | String  | quoted printable, MIME encoding (see also RFC2045)
                 |         | (text mode but input must use LF and output LF)
    m            | String  | base64 encoded string (see RFC 2045)
                 |         | (if count is 0, no line feed are added, see RFC 4648)
                 |         | (count specifies input bytes between each LF,
                 |         | rounded down to nearest multiple of 3)
    P            | String  | pointer to a structure (fixed-length string)
    p            | String  | pointer to a null-terminated string

    Misc.        | Array   |
    Directive    | Element | Meaning
    ---------------------------------------------------------------------------
    @            | ---     | moves to absolute position
    X            | ---     | back up a byte
    x            | ---     | null byte

;T;0;;;I"	pack;F;I"
Array;T;[o;;I"%::string fmt, ?buffer: ::String?;T;I"String;To;;I"—When invoked with a block, yield all permutations of elements of `self`;
returns `self`. The order of permutations is indeterminate.

When a block and an in-range positive Integer argument `n` (`0 < n <=
self.size`) are given, calls the block with all `n`-tuple permutations of
`self`.

Example:
    a = [0, 1, 2]
    a.permutation(2) {|permutation| p permutation }

Output:
    [0, 1]
    [0, 2]
    [1, 0]
    [1, 2]
    [2, 0]
    [2, 1]

Another example:
    a = [0, 1, 2]
    a.permutation(3) {|permutation| p permutation }

Output:
    [0, 1, 2]
    [0, 2, 1]
    [1, 0, 2]
    [1, 2, 0]
    [2, 0, 1]
    [2, 1, 0]

When `n` is zero, calls the block once with a new empty Array:
    a = [0, 1, 2]
    a.permutation(0) {|permutation| p permutation }

Output:
    []

When `n` is out of range (negative or larger than `self.size`), does not call
the block:
    a = [0, 1, 2]
    a.permutation(-1) {|permutation| fail 'Cannot happen' }
    a.permutation(4) {|permutation| fail 'Cannot happen' }

When a block given but no argument, behaves the same as
`a.permutation(a.size)`:
    a = [0, 1, 2]
    a.permutation {|permutation| p permutation }

Output:
    [0, 1, 2]
    [0, 2, 1]
    [1, 0, 2]
    [1, 2, 0]
    [2, 0, 1]
    [2, 1, 0]

Returns a new Enumerator if no block given:
    a = [0, 1, 2]
    a.permutation # => #<Enumerator: [0, 1, 2]:permutation>
    a.permutation(2) # => #<Enumerator: [0, 1, 2]:permutation(2)>

;T;0;;;I"permutation;F;I"
Array;T;[o;;I"?::int n;T;I"-Enumerator[::Array[Elem], ::Array[Elem]];To;;I"?::int n;T;I"Array[Elem];To;;I"GRemoves and returns trailing elements.

When no argument is given and `self` is not empty, removes and returns the
last element:
    a = [:foo, 'bar', 2]
    a.pop # => 2
    a # => [:foo, "bar"]

Returns `nil` if the array is empty.

When a non-negative Integer argument `n` is given and is in range, removes and
returns the last `n` elements in a new Array:
    a = [:foo, 'bar', 2]
    a.pop(2) # => ["bar", 2]

If `n` is positive and out of range, removes and returns all elements:
    a = [:foo, 'bar', 2]
    a.pop(50) # => [:foo, "bar", 2]

Related: #push, #shift, #unshift.

;T;0;;;I"pop;F;I"
Array;T;[o;;I" ;F;I"
Elem?;To;;I"::int n;T;I"Array[Elem];To;;I"©Computes and returns or yields all combinations of elements from all the
Arrays, including both `self` and `other_arrays`.
*   The number of combinations is the product of the sizes of all the arrays,
    including both `self` and `other_arrays`.
*   The order of the returned combinations is indeterminate.


When no block is given, returns the combinations as an Array of Arrays:
    a = [0, 1, 2]
    a1 = [3, 4]
    a2 = [5, 6]
    p = a.product(a1)
    p.size # => 6 # a.size * a1.size
    p # => [[0, 3], [0, 4], [1, 3], [1, 4], [2, 3], [2, 4]]
    p = a.product(a1, a2)
    p.size # => 12 # a.size * a1.size * a2.size
    p # => [[0, 3, 5], [0, 3, 6], [0, 4, 5], [0, 4, 6], [1, 3, 5], [1, 3, 6], [1, 4, 5], [1, 4, 6], [2, 3, 5], [2, 3, 6], [2, 4, 5], [2, 4, 6]]

If any argument is an empty Array, returns an empty Array.

If no argument is given, returns an Array of 1-element Arrays, each containing
an element of `self`:
    a.product # => [[0], [1], [2]]

When a block is given, yields each combination as an Array; returns `self`:
    a.product(a1) {|combination| p combination }

Output:
    [0, 3]
    [0, 4]
    [1, 3]
    [1, 4]
    [2, 3]
    [2, 4]

If any argument is an empty Array, does not call the block:
    a.product(a1, a2, []) {|combination| fail 'Cannot happen' }

If no argument is given, yields each element of `self` as a 1-element Array:
    a.product {|combination| p combination }

Output:
    [0]
    [1]
    [2]

;T;0;;;I"product;F;I"
Array;T;[	o;;I" ;F;I"Array[[ Elem ]];To;;I"::Array[X] other_ary;T;I"Array[[ Elem, X ]];To;;I"1::Array[X] other_ary1, ::Array[Y] other_ary2;T;I"Array[[ Elem, X, Y ]];To;;I"*::Array[U] other_arys;T;I"Array[::Array[Elem | U]];To;;I"¼Appends trailing elements.

Appends each argument in `objects` to `self`;  returns `self`:
    a = [:foo, 'bar', 2]
    a.push(:baz, :bat) # => [:foo, "bar", 2, :baz, :bat]

Appends each argument as one element, even if it is another Array:
    a = [:foo, 'bar', 2]
    a1 = a.push([:baz, :bat], [:bam, :bad])
    a1 # => [:foo, "bar", 2, [:baz, :bat], [:bam, :bad]]

Array#append is an alias for Array#push.

Related: #pop, #shift, #unshift.

;T;0;;;I"	push;F;I"
Array;T;[o;;I"*Elem obj;T;I"	self;To;;I"{Removes each element for which the block returns a truthy value.

Returns `self` if any elements removed:
    a = [:foo, 'bar', 2, 'bat']
    a.reject! {|element| element.to_s.start_with?('b') } # => [:foo, 2]

Returns `nil` if no elements removed.

Returns a new Enumerator if no block given:
    a = [:foo, 'bar', 2]
    a.reject! # => #<Enumerator: [:foo, "bar", 2]:reject!>

;T;0;;;I"reject!;F;I"
Array;T;[o;;I" ;F;I"
self?;To;;I" ;F;I"Enumerator[Elem, self?];To;;I",Calls the block with each repeated combination of length `n` of the elements
of `self`; each combination is an Array; returns `self`. The order of the
combinations is indeterminate.

When a block and a positive Integer argument `n` are given, calls the block
with each `n`-tuple repeated combination of the elements of `self`. The number
of combinations is `(n+1)(n+2)/2`.

`n` = 1:
    a = [0, 1, 2]
    a.repeated_combination(1) {|combination| p combination }

Output:
    [0]
    [1]
    [2]

`n` = 2:
    a.repeated_combination(2) {|combination| p combination }

Output:
    [0, 0]
    [0, 1]
    [0, 2]
    [1, 1]
    [1, 2]
    [2, 2]

If `n` is zero, calls the block once with an empty Array.

If `n` is negative, does not call the block:
    a.repeated_combination(-1) {|combination| fail 'Cannot happen' }

Returns a new Enumerator if no block given:
    a = [0, 1, 2]
    a.repeated_combination(2) # => #<Enumerator: [0, 1, 2]:combination(2)>

Using Enumerators, it's convenient to show the combinations and counts for
some values of `n`:
    e = a.repeated_combination(0)
    e.size # => 1
    e.to_a # => [[]]
    e = a.repeated_combination(1)
    e.size # => 3
    e.to_a # => [[0], [1], [2]]
    e = a.repeated_combination(2)
    e.size # => 6
    e.to_a # => [[0, 0], [0, 1], [0, 2], [1, 1], [1, 2], [2, 2]]

;T;0;;;I"repeated_combination;F;I"
Array;T;[o;;I"::int n;T;I"	self;To;;I"::int n;T;I"$Enumerator[::Array[Elem], self];To;;I"eCalls the block with each repeated permutation of length `n` of the elements
of `self`; each permutation is an Array; returns `self`. The order of the
permutations is indeterminate.

When a block and a positive Integer argument `n` are given, calls the block
with each `n`-tuple repeated permutation of the elements of `self`. The number
of permutations is `self.size**n`.

`n` = 1:
    a = [0, 1, 2]
    a.repeated_permutation(1) {|permutation| p permutation }

Output:
    [0]
    [1]
    [2]

`n` = 2:
    a.repeated_permutation(2) {|permutation| p permutation }

Output:
    [0, 0]
    [0, 1]
    [0, 2]
    [1, 0]
    [1, 1]
    [1, 2]
    [2, 0]
    [2, 1]
    [2, 2]

If `n` is zero, calls the block once with an empty Array.

If `n` is negative, does not call the block:
    a.repeated_permutation(-1) {|permutation| fail 'Cannot happen' }

Returns a new Enumerator if no block given:
    a = [0, 1, 2]
    a.repeated_permutation(2) # => #<Enumerator: [0, 1, 2]:permutation(2)>

Using Enumerators, it's convenient to show the permutations and counts for
some values of `n`:
    e = a.repeated_permutation(0)
    e.size # => 1
    e.to_a # => [[]]
    e = a.repeated_permutation(1)
    e.size # => 3
    e.to_a # => [[0], [1], [2]]
    e = a.repeated_permutation(2)
    e.size # => 9
    e.to_a # => [[0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [2, 0], [2, 1], [2, 2]]

;T;0;;;I"repeated_permutation;F;I"
Array;T;[o;;I"::int n;T;I"	self;To;;I"::int n;T;I"$Enumerator[::Array[Elem], self];To;;I"¢Replaces the content of `self` with the content of `other_array`; returns
`self`:
    a = [:foo, 'bar', 2]
    a.replace(['foo', :bar, 3]) # => ["foo", :bar, 3]

;T;0;;;I"replace;F;I"
Array;T;[o;;I"::Array[Elem];T;I"	self;To;;I"–Returns a new Array with the elements of `self` in reverse order.
    a = ['foo', 'bar', 'two']
    a1 = a.reverse
    a1 # => ["two", "bar", "foo"]

;T;0;;;I"reverse;F;I"
Array;T;[o;;I" ;F;I"Array[Elem];To;;I"hReverses `self` in place:
    a = ['foo', 'bar', 'two']
    a.reverse! # => ["two", "bar", "foo"]

;T;0;;;I"reverse!;F;I"
Array;T;[o;;I" ;F;I"Array[Elem];To;;I"ûIterates backwards over array elements.

When a block given, passes, in reverse order, each element to the block;
returns `self`:
    a = [:foo, 'bar', 2]
    a.reverse_each {|element|  puts "#{element.class} #{element}" }

Output:
    Integer 2
    String bar
    Symbol foo

Allows the array to be modified during iteration:
    a = [:foo, 'bar', 2]
    a.reverse_each {|element| puts element; a.clear if element.to_s.start_with?('b') }

Output:
    2
    bar

When no block given, returns a new Enumerator:
    a = [:foo, 'bar', 2]
    e = a.reverse_each
    e # => #<Enumerator: [:foo, "bar", 2]:reverse_each>
    a1 = e.each {|element|  puts "#{element.class} #{element}" }

Output:
    Integer 2
    String bar
    Symbol foo

Related: #each, #each_index.

;T;0;;;I"reverse_each;F;I"
Array;T;[o;;I" ;F;I"	self;To;;I" ;F;I"Enumerator[Elem, self];To;;I"5Returns the index of the last element for which `object == element`.

When argument `object` is given but no block, returns the index of the last
such element found:
    a = [:foo, 'bar', 2, 'bar']
    a.rindex('bar') # => 3

Returns `nil` if no such object found.

When a block is given but no argument, calls the block with each successive
element; returns the index of the last element for which the block returns a
truthy value:
    a = [:foo, 'bar', 2, 'bar']
    a.rindex {|element| element == 'bar' } # => 3

Returns `nil` if the block never returns a truthy value.

When neither an argument nor a block is given, returns a new Enumerator:

    a = [:foo, 'bar', 2, 'bar']
    e = a.rindex
    e # => #<Enumerator: [:foo, "bar", 2, "bar"]:rindex>
    e.each {|element| element == 'bar' } # => 3

Related: #index.

;T;0;;;I"rindex;F;I"
Array;T;[o;;I"untyped obj;T;I"Integer?;To;;I" ;F;I"Integer?;To;;I" ;F;I"!Enumerator[Elem, ::Integer?];To;;I"VReturns a new Array formed from `self` with elements rotated from one end to
the other.

When no argument given, returns a new Array that is like `self`, except that
the first element has been rotated to the last position:
    a = [:foo, 'bar', 2, 'bar']
    a1 = a.rotate
    a1 # => ["bar", 2, "bar", :foo]

When given a non-negative Integer `count`, returns a new Array with `count`
elements rotated from the beginning to the end:
    a = [:foo, 'bar', 2]
    a1 = a.rotate(2)
    a1 # => [2, :foo, "bar"]

If `count` is large, uses `count % array.size` as the count:
    a = [:foo, 'bar', 2]
    a1 = a.rotate(20)
    a1 # => [2, :foo, "bar"]

If `count` is zero, returns a copy of `self`, unmodified:
    a = [:foo, 'bar', 2]
    a1 = a.rotate(0)
    a1 # => [:foo, "bar", 2]

When given a negative Integer `count`, rotates in the opposite direction, from
end to beginning:
    a = [:foo, 'bar', 2]
    a1 = a.rotate(-2)
    a1 # => ["bar", 2, :foo]

If `count` is small (far from zero), uses `count % array.size` as the count:
    a = [:foo, 'bar', 2]
    a1 = a.rotate(-5)
    a1 # => ["bar", 2, :foo]

;T;0;;;I"rotate;F;I"
Array;T;[o;;I"?::int count;T;I"Array[Elem];To;;I"ÎRotates `self` in place by moving elements from one end to the other; returns
`self`.

When no argument given, rotates the first element to the last position:
    a = [:foo, 'bar', 2, 'bar']
    a.rotate! # => ["bar", 2, "bar", :foo]

When given a non-negative Integer `count`, rotates `count` elements from the
beginning to the end:
    a = [:foo, 'bar', 2]
    a.rotate!(2)
    a # => [2, :foo, "bar"]

If `count` is large, uses `count % array.size` as the count:
    a = [:foo, 'bar', 2]
    a.rotate!(20)
    a # => [2, :foo, "bar"]

If `count` is zero, returns `self` unmodified:
    a = [:foo, 'bar', 2]
    a.rotate!(0)
    a # => [:foo, "bar", 2]

When given a negative Integer `count`, rotates in the opposite direction, from
end to beginning:
    a = [:foo, 'bar', 2]
    a.rotate!(-2)
    a # => ["bar", 2, :foo]

If `count` is small (far from zero), uses `count % array.size` as the count:
    a = [:foo, 'bar', 2]
    a.rotate!(-5)
    a # => ["bar", 2, :foo]

;T;0;;;I"rotate!;F;I"
Array;T;[o;;I"?::int count;T;I"	self;To;;I"Returns random elements from `self`.

When no arguments are given, returns a random element from `self`:
    a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    a.sample # => 3
    a.sample # => 8

If `self` is empty, returns `nil`.

When argument `n` is given, returns a new Array containing `n` random elements
from `self`:
    a.sample(3) # => [8, 9, 2]
    a.sample(6) # => [9, 6, 10, 3, 1, 4]

Returns no more than `a.size` elements (because no new duplicates are
introduced):
    a.sample(a.size * 2) # => [6, 4, 1, 8, 5, 9, 10, 2, 3, 7]

But `self` may contain duplicates:
    a = [1, 1, 1, 2, 2, 3]
    a.sample(a.size * 2) # => [1, 1, 3, 2, 1, 2]

The argument `n` must be a non-negative numeric value. The order of the result
array is unrelated to the order of `self`. Returns a new empty Array if `self`
is empty.

The optional `random` argument will be used as the random number generator:
    a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    a.sample(random: Random.new(1))     #=> 6
    a.sample(4, random: Random.new(1))  #=> [6, 10, 9, 2]

;T;0;;;I"sample;F;I"
Array;T;[o;;I"?random: ::_Rand rng;T;I"
Elem?;To;;I""::int n, ?random: ::_Rand rng;T;I"Array[Elem];To;;I"ÊCalls the block, if given, with each element of `self`; returns a new Array
containing those elements of `self` for which the block returns a truthy
value:
    a = [:foo, 'bar', 2, :bam]
    a1 = a.select {|element| element.to_s.start_with?('b') }
    a1 # => ["bar", :bam]

Returns a new Enumerator if no block given:
    a = [:foo, 'bar', 2, :bam]
    a.select # => #<Enumerator: [:foo, "bar", 2, :bam]:select>

Array#filter is an alias for Array#select.

;T;0;;;I"select;F;I"
Array;T;[o;;I" ;F;I"Array[Elem];To;;I" ;F;I"$Enumerator[Elem, ::Array[Elem]];To;;I"
Calls the block, if given  with each element of `self`; removes from `self`
those elements for which the block returns `false` or `nil`.

Returns `self` if any elements were removed:
    a = [:foo, 'bar', 2, :bam]
    a.select! {|element| element.to_s.start_with?('b') } # => ["bar", :bam]

Returns `nil` if no elements were removed.

Returns a new Enumerator if no block given:
    a = [:foo, 'bar', 2, :bam]
    a.select! # => #<Enumerator: [:foo, "bar", 2, :bam]:select!>

Array#filter! is an alias for Array#select!.

;T;0;;;I"select!;F;I"
Array;T;[o;;I" ;F;I"
self?;To;;I" ;F;I"Enumerator[Elem, self?];To;;I"¤Removes and returns leading elements.

When no argument is given, removes and returns the first element:
    a = [:foo, 'bar', 2]
    a.shift # => :foo
    a # => ['bar', 2]

Returns `nil` if `self` is empty.

When positive Integer argument `n` is given, removes the first `n` elements;
returns those elements in a new Array:
    a = [:foo, 'bar', 2]
    a.shift(2) # => [:foo, 'bar']
    a # => [2]

If `n` is as large as or larger than `self.length`, removes all elements;
returns those elements in a new Array:
    a = [:foo, 'bar', 2]
    a.shift(3) # => [:foo, 'bar', 2]

If `n` is zero, returns a new empty Array; `self` is unmodified.

Related: #push, #pop, #unshift.

;T;0;;;I"
shift;F;I"
Array;T;[o;;I" ;F;I"
Elem?;To;;I"::int n;T;I"Array[Elem];To;;I"Returns a new array with elements of `self` shuffled.
    a = [1, 2, 3] #=> [1, 2, 3]
    a.shuffle     #=> [2, 3, 1]
    a             #=> [1, 2, 3]

The optional `random` argument will be used as the random number generator:
    a.shuffle(random: Random.new(1))  #=> [1, 3, 2]

;T;0;;;I"shuffle;F;I"
Array;T;[o;;I"?random: ::_Rand rng;T;I"Array[Elem];To;;I"Shuffles the elements of `self` in place.
    a = [1, 2, 3] #=> [1, 2, 3]
    a.shuffle!    #=> [2, 3, 1]
    a             #=> [2, 3, 1]

The optional `random` argument will be used as the random number generator:
    a.shuffle!(random: Random.new(1))  #=> [1, 3, 2]

;T;0;;;I"shuffle!;F;I"
Array;T;[o;;I"?random: ::_Rand rng;T;I"	self;To;;I"D
Returns elements from `self`; does not modify `self`.

When a single Integer argument `index` is given, returns the element at offset
`index`:
    a = [:foo, 'bar', 2]
    a[0] # => :foo
    a[2] # => 2
    a # => [:foo, "bar", 2]

If `index` is negative, counts relative to the end of `self`:
    a = [:foo, 'bar', 2]
    a[-1] # => 2
    a[-2] # => "bar"

If `index` is out of range, returns `nil`.

When two Integer arguments `start` and `length` are given, returns a new Array
of size `length` containing successive elements beginning at offset `start`:
    a = [:foo, 'bar', 2]
    a[0, 2] # => [:foo, "bar"]
    a[1, 2] # => ["bar", 2]

If `start + length` is greater than `self.length`, returns all elements from
offset `start` to the end:
    a = [:foo, 'bar', 2]
    a[0, 4] # => [:foo, "bar", 2]
    a[1, 3] # => ["bar", 2]
    a[2, 2] # => [2]

If `start == self.size` and `length >= 0`, returns a new empty Array.

If `length` is negative, returns `nil`.

When a single Range argument `range` is given, treats `range.min` as `start`
above and `range.size` as `length` above:
    a = [:foo, 'bar', 2]
    a[0..1] # => [:foo, "bar"]
    a[1..2] # => ["bar", 2]

Special case: If `range.start == a.size`, returns a new empty Array.

If `range.end` is negative, calculates the end index from the end:
    a = [:foo, 'bar', 2]
    a[0..-1] # => [:foo, "bar", 2]
    a[0..-2] # => [:foo, "bar"]
    a[0..-3] # => [:foo]

If `range.start` is negative, calculates the start index from the end:
    a = [:foo, 'bar', 2]
    a[-1..2] # => [2]
    a[-2..2] # => ["bar", 2]
    a[-3..2] # => [:foo, "bar", 2]

If `range.start` is larger than the array size, returns `nil`.
    a = [:foo, 'bar', 2]
    a[4..1] # => nil
    a[4..0] # => nil
    a[4..-1] # => nil

When a single Enumerator::ArithmeticSequence argument `aseq` is given, returns
an Array of elements corresponding to the indexes produced by the sequence.
    a = ['--', 'data1', '--', 'data2', '--', 'data3']
    a[(1..).step(2)] # => ["data1", "data2", "data3"]

Unlike slicing with range, if the start or the end of the arithmetic sequence
is larger than array size, throws RangeError.
    a = ['--', 'data1', '--', 'data2', '--', 'data3']
    a[(1..11).step(2)]
    # RangeError (((1..11).step(2)) out of range)
    a[(7..).step(2)]
    # RangeError (((7..).step(2)) out of range)

If given a single argument, and its type is not one of the listed, tries to
convert it to Integer, and raises if it is impossible:
    a = [:foo, 'bar', 2]
    # Raises TypeError (no implicit conversion of Symbol into Integer):
    a[:foo]

Array#slice is an alias for Array#[].

;T;0;;;I"
slice;F;I"
Array;T;[o;;I"::int index;T;I"
Elem?;To;;I"::int start, ::int length;T;I"Array[Elem]?;To;;I"::Range[::Integer] range;T;I"Array[Elem]?;To;;I"7Removes and returns elements from `self`.

When the only argument is an Integer `n`, removes and returns the *nth*
element in `self`:
    a = [:foo, 'bar', 2]
    a.slice!(1) # => "bar"
    a # => [:foo, 2]

If `n` is negative, counts backwards from the end of `self`:
    a = [:foo, 'bar', 2]
    a.slice!(-1) # => 2
    a # => [:foo, "bar"]

If `n` is out of range, returns `nil`.

When the only arguments are Integers `start` and `length`, removes `length`
elements from `self` beginning at offset  `start`; returns the deleted objects
in a new Array:
    a = [:foo, 'bar', 2]
    a.slice!(0, 2) # => [:foo, "bar"]
    a # => [2]

If `start + length` exceeds the array size, removes and returns all elements
from offset `start` to the end:
    a = [:foo, 'bar', 2]
    a.slice!(1, 50) # => ["bar", 2]
    a # => [:foo]

If `start == a.size` and `length` is non-negative, returns a new empty Array.

If `length` is negative, returns `nil`.

When the only argument is a Range object `range`, treats `range.min` as
`start` above and `range.size` as `length` above:
    a = [:foo, 'bar', 2]
     a.slice!(1..2) # => ["bar", 2]
    a # => [:foo]

If `range.start == a.size`, returns a new empty Array.

If `range.start` is larger than the array size, returns `nil`.

If `range.end` is negative, counts backwards from the end of the array:
    a = [:foo, 'bar', 2]
    a.slice!(0..-2) # => [:foo, "bar"]
    a # => [2]

If `range.start` is negative, calculates the start index backwards from the
end of the array:
    a = [:foo, 'bar', 2]
    a.slice!(-2..2) # => ["bar", 2]
    a # => [:foo]

;T;0;;;I"slice!;F;I"
Array;T;[o;;I"::int index;T;I"
Elem?;To;;I"::int start, ::int length;T;I"Array[Elem]?;To;;I"::Range[::Integer] range;T;I"Array[Elem]?;To;;I"êReturns a new Array whose elements are those from `self`, sorted.

With no block, compares elements using operator `<=>` (see Comparable):
    a = 'abcde'.split('').shuffle
    a # => ["e", "b", "d", "a", "c"]
    a1 = a.sort
    a1 # => ["a", "b", "c", "d", "e"]

With a block, calls the block with each element pair; for each element pair
`a` and `b`, the block should return an integer:
*   Negative when `b` is to follow `a`.
*   Zero when `a` and `b` are equivalent.
*   Positive when `a` is to follow `b`.


Example:
    a = 'abcde'.split('').shuffle
    a # => ["e", "b", "d", "a", "c"]
    a1 = a.sort {|a, b| a <=> b }
    a1 # => ["a", "b", "c", "d", "e"]
    a2 = a.sort {|a, b| b <=> a }
    a2 # => ["e", "d", "c", "b", "a"]

When the block returns zero, the order for `a` and `b` is indeterminate, and
may be unstable:
    a = 'abcde'.split('').shuffle
    a # => ["e", "b", "d", "a", "c"]
    a1 = a.sort {|a, b| 0 }
    a1 # =>  ["c", "e", "b", "d", "a"]

Related: Enumerable#sort_by.

;T;0;;;I"	sort;F;I"
Array;T;[o;;I" ;F;I"Array[Elem];To;;I" ;F;I"Array[Elem];To;;I"§Returns `self` with its elements sorted in place.

With no block, compares elements using operator `<=>` (see Comparable):
    a = 'abcde'.split('').shuffle
    a # => ["e", "b", "d", "a", "c"]
    a.sort!
    a # => ["a", "b", "c", "d", "e"]

With a block, calls the block with each element pair; for each element pair
`a` and `b`, the block should return an integer:
*   Negative when `b` is to follow `a`.
*   Zero when `a` and `b` are equivalent.
*   Positive when `a` is to follow `b`.


Example:
    a = 'abcde'.split('').shuffle
    a # => ["e", "b", "d", "a", "c"]
    a.sort! {|a, b| a <=> b }
    a # => ["a", "b", "c", "d", "e"]
    a.sort! {|a, b| b <=> a }
    a # => ["e", "d", "c", "b", "a"]

When the block returns zero, the order for `a` and `b` is indeterminate, and
may be unstable:
    a = 'abcde'.split('').shuffle
    a # => ["e", "b", "d", "a", "c"]
    a.sort! {|a, b| 0 }
    a # => ["d", "e", "c", "a", "b"]

;T;0;;;I"
sort!;F;I"
Array;T;[o;;I" ;F;I"	self;To;;I" ;F;I"	self;To;;I"cSorts the elements of `self` in place, using an ordering determined by the
block; returns self.

Calls the block with each successive element; sorts elements based on the
values returned from the block.

For duplicates returned by the block, the ordering is indeterminate, and may
be unstable.

This example sorts strings based on their sizes:
    a = ['aaaa', 'bbb', 'cc', 'd']
    a.sort_by! {|element| element.size }
    a # => ["d", "cc", "bbb", "aaaa"]

Returns a new Enumerator if no block given:

    a = ['aaaa', 'bbb', 'cc', 'd']
    a.sort_by! # => #<Enumerator: ["aaaa", "bbb", "cc", "d"]:sort_by!>

;T;0;;;I"sort_by!;F;I"
Array;T;[o;;I" ;F;I"Array[Elem];To;;I" ;F;I"$Enumerator[Elem, ::Array[Elem]];To;;I"›When no block is given, returns the object equivalent to:
    sum = init
    array.each {|element| sum += element }
    sum

For example, `[e1, e2, e3].sum` returns `init + e1 + e2 + e3`.

Examples:
    a = [0, 1, 2, 3]
    a.sum # => 6
    a.sum(100) # => 106

The elements need not be numeric, but must be `+`-compatible with each other
and with `init`:
    a = ['abc', 'def', 'ghi']
    a.sum('jkl') # => "jklabcdefghi"

When a block is given, it is called with each element and the block's return
value (instead of the element itself) is used as the addend:
    a = ['zero', 1, :two]
    s = a.sum('Coerced and concatenated: ') {|element| element.to_s }
    s # => "Coerced and concatenated: zero1two"

Notes:
*   Array#join and Array#flatten may be faster than Array#sum for an Array of
    Strings or an Array of Arrays.
*   Array#sum method may not respect method redefinition of "+" methods such
    as Integer#+.

;T;0;;;I"sum;F;I"
Array;T;[o;;I"?untyped init;T;I"untyped;To;;I"?untyped init;T;I"untyped;To;;I"Returns a new Array containing the first `n` element of `self`, where `n` is a
non-negative Integer; does not modify `self`.

Examples:
    a = [0, 1, 2, 3, 4, 5]
    a.take(1) # => [0]
    a.take(2) # => [0, 1]
    a.take(50) # => [0, 1, 2, 3, 4, 5]
    a # => [0, 1, 2, 3, 4, 5]

;T;0;;;I"	take;F;I"
Array;T;[o;;I"::int n;T;I"Array[Elem];To;;I"OReturns a new Array containing zero or more leading elements of `self`; does
not modify `self`.

With a block given, calls the block with each successive element of `self`;
stops if the block returns `false` or `nil`; returns a new Array containing
those elements for which the block returned a truthy value:
    a = [0, 1, 2, 3, 4, 5]
    a.take_while {|element| element < 3 } # => [0, 1, 2]
    a.take_while {|element| true } # => [0, 1, 2, 3, 4, 5]
    a # => [0, 1, 2, 3, 4, 5]

With no block given, returns a new Enumerator:
    [0, 1].take_while # => #<Enumerator: [0, 1]:take_while>

;T;0;;;I"take_while;F;I"
Array;T;[o;;I" ;F;I"Array[Elem];To;;I" ;F;I"$Enumerator[Elem, ::Array[Elem]];To;;I"šWhen `self` is an instance of Array, returns `self`:
    a = [:foo, 'bar', 2]
    a.to_a # => [:foo, "bar", 2]

Otherwise, returns a new Array containing the elements of `self`:
    class MyArray < Array; end
    a = MyArray.new(['foo', 'bar', 'two'])
    a.instance_of?(Array) # => false
    a.kind_of?(Array) # => true
    a1 = a.to_a
    a1 # => ["foo", "bar", "two"]
    a1.class # => Array # Not MyArray

;T;0;;;I"	to_a;F;I"
Array;T;[o;;I" ;F;I"Array[Elem];To;;I"Returns `self`.

;T;0;;;I"to_ary;F;I"
Array;T;[o;;I" ;F;I"	self;To;;I"‘Returns a new Hash formed from `self`.

When a block is given, calls the block with each array element; the block must
return a 2-element Array whose two elements form a key-value pair in the
returned Hash:
    a = ['foo', :bar, 1, [2, 3], {baz: 4}]
    h = a.to_h {|item| [item, item] }
    h # => {"foo"=>"foo", :bar=>:bar, 1=>1, [2, 3]=>[2, 3], {:baz=>4}=>{:baz=>4}}

When no block is given, `self` must be an Array of 2-element sub-arrays, each
sub-array is formed into a key-value pair in the new Hash:
    [].to_h # => {}
    a = [['foo', 'zero'], ['bar', 'one'], ['baz', 'two']]
    h = a.to_h
    h # => {"foo"=>"zero", "bar"=>"one", "baz"=>"two"}

;T;0;;;I"	to_h;F;I"
Array;T;[o;;I" ;F;I"Hash[untyped, untyped];To;;I" ;F;I"Hash[T, S];To;;I"ÊTransposes the rows and columns in an Array of Arrays; the nested Arrays must
all be the same size:
    a = [[:a0, :a1], [:b0, :b1], [:c0, :c1]]
    a.transpose # => [[:a0, :b0, :c0], [:a1, :b1, :c1]]

;T;0;;;I"transpose;F;I"
Array;T;[o;;I" ;F;I"Array[::Array[untyped]];To;;I"Returns a new Array that is the union of `self` and all given Arrays
`other_arrays`; duplicates are removed;  order is preserved;  items are
compared using `eql?`:
    [0, 1, 2, 3].union([4, 5], [6, 7]) # => [0, 1, 2, 3, 4, 5, 6, 7]
    [0, 1, 1].union([2, 1], [3, 1]) # => [0, 1, 2, 3]
    [0, 1, 2, 3].union([3, 2], [1, 0]) # => [0, 1, 2, 3]

Returns a copy of `self` if no arguments given.

Related: Array#|.

;T;0;;;I"
union;F;I"
Array;T;[o;;I"*::Array[T] other_arys;T;I"Array[T | Elem];To;;I"-Returns a new Array containing those elements from `self` that are not
duplicates, the first occurrence always being retained.

With no block given, identifies and omits duplicates using method `eql?` to
compare.
    a = [0, 0, 1, 1, 2, 2]
    a.uniq # => [0, 1, 2]

With a block given, calls the block for each element; identifies (using method
`eql?`) and omits duplicate values, that is, those elements for which the
block returns the same value:
    a = ['a', 'aa', 'aaa', 'b', 'bb', 'bbb']
    a.uniq {|element| element.size } # => ["a", "aa", "aaa"]

;T;0;;;I"	uniq;F;I"
Array;T;[o;;I" ;F;I"Array[Elem];To;;I" ;F;I"Array[Elem];To;;I"ÀRemoves duplicate elements from `self`, the first occurrence always being
retained; returns `self` if any elements removed, `nil` otherwise.

With no block given, identifies and removes elements using method `eql?` to
compare.

Returns `self` if any elements removed:
    a = [0, 0, 1, 1, 2, 2]
    a.uniq! # => [0, 1, 2]

Returns `nil` if no elements removed.

With a block given, calls the block for each element; identifies (using method
`eql?`) and removes elements for which the block returns duplicate values.

Returns `self` if any elements removed:
    a = ['a', 'aa', 'aaa', 'b', 'bb', 'bbb']
    a.uniq! {|element| element.size } # => ['a', 'aa', 'aaa']

Returns `nil` if no elements removed.

;T;0;;;I"
uniq!;F;I"
Array;T;[o;;I" ;F;I"
self?;To;;I" ;F;I"
self?;To;;I"ËPrepends the given `objects` to `self`:
    a = [:foo, 'bar', 2]
    a.unshift(:bam, :bat) # => [:bam, :bat, :foo, "bar", 2]

Array#prepend is an alias for Array#unshift.

Related: #push, #pop, #shift.

;T;0;;;I"unshift;F;I"
Array;T;[o;;I"*Elem obj;T;I"	self;To;;I"&Returns a new Array whose elements are the elements of `self` at the given
Integer or Range `indexes`.

For each positive `index`, returns the element at offset `index`:
    a = [:foo, 'bar', 2]
    a.values_at(0, 2) # => [:foo, 2]
    a.values_at(0..1) # => [:foo, "bar"]

The given `indexes` may be in any order, and may repeat:
    a = [:foo, 'bar', 2]
    a.values_at(2, 0, 1, 0, 2) # => [2, :foo, "bar", :foo, 2]
    a.values_at(1, 0..2) # => ["bar", :foo, "bar", 2]

Assigns `nil` for an `index` that is too large:
    a = [:foo, 'bar', 2]
    a.values_at(0, 3, 1, 3) # => [:foo, nil, "bar", nil]

Returns a new empty Array if no arguments given.

For each negative `index`, counts backward from the end of the array:
    a = [:foo, 'bar', 2]
    a.values_at(-1, -3) # => [2, :foo]

Assigns `nil` for an `index` that is too small:
    a = [:foo, 'bar', 2]
    a.values_at(0, -5, 1, -6, 2) # => [:foo, nil, "bar", nil, 2]

The given `indexes` may have a mixture of signs:
    a = [:foo, 'bar', 2]
    a.values_at(0, -2, 1, -1) # => [:foo, "bar", "bar", 2]

;T;0;;;I"values_at;F;I"
Array;T;[o;;I")*::int | ::Range[::Integer] selector;T;I"Array[Elem?];To;;I"mWhen no block given, returns a new Array `new_array` of size `self.size` whose
elements are Arrays.

Each nested array `new_array[n]` is of size `other_arrays.size+1`, and
contains:
*   The *nth* element of `self`.
*   The *nth* element of each of the `other_arrays`.


If all `other_arrays` and `self` are the same size:
    a = [:a0, :a1, :a2, :a3]
    b = [:b0, :b1, :b2, :b3]
    c = [:c0, :c1, :c2, :c3]
    d = a.zip(b, c)
    d # => [[:a0, :b0, :c0], [:a1, :b1, :c1], [:a2, :b2, :c2], [:a3, :b3, :c3]]

If any array in `other_arrays` is smaller than `self`, fills to `self.size`
with `nil`:
    a = [:a0, :a1, :a2, :a3]
    b = [:b0, :b1, :b2]
    c = [:c0, :c1]
    d = a.zip(b, c)
    d # => [[:a0, :b0, :c0], [:a1, :b1, :c1], [:a2, :b2, nil], [:a3, nil, nil]]

If any array in `other_arrays` is larger than `self`, its trailing elements
are ignored:
    a = [:a0, :a1, :a2, :a3]
    b = [:b0, :b1, :b2, :b3, :b4]
    c = [:c0, :c1, :c2, :c3, :c4, :c5]
    d = a.zip(b, c)
    d # => [[:a0, :b0, :c0], [:a1, :b1, :c1], [:a2, :b2, :c2], [:a3, :b3, :c3]]

When a block is given, calls the block with each of the sub-arrays (formed as
above); returns nil
    a = [:a0, :a1, :a2, :a3]
    b = [:b0, :b1, :b2, :b3]
    c = [:c0, :c1, :c2, :c3]
    a.zip(b, c) {|sub_array| p sub_array} # => nil

Output:
    [:a0, :b0, :c0]
    [:a1, :b1, :c1]
    [:a2, :b2, :c2]
    [:a3, :b3, :c3]

;T;0;;;I"zip;F;I"
Array;T;[	o;;I"::Array[U] arg;T;I"Array[[ Elem, U? ]];To;;I"1::Array[untyped] arg, *::Array[untyped] args;T;I"Array[::Array[untyped]];To;;I"::Array[U] arg;T;I"	void;To;;I"1::Array[untyped] arg, *::Array[untyped] args;T;I"	void;To;;I"Returns the union of `array` and Array `other_array`; duplicates are removed;
order is preserved; items are compared using `eql?`:
    [0, 1] | [2, 3] # => [0, 1, 2, 3]
    [0, 1, 1] | [2, 2, 3] # => [0, 1, 2, 3]
    [0, 1, 2] | [3, 2, 1, 0] # => [0, 1, 2, 3]

Related: Array#union.

;T;0;;;I"|;F;I"
Array;T;[o;;I"::Array[T] other_ary;T;I"Array[Elem | T];To;;I"¢Replaces the content of `self` with the content of `other_array`; returns
`self`:
    a = [:foo, 'bar', 2]
    a.replace(['foo', :bar, 3]) # => ["foo", :bar, 3]

;T;0;;;I"initialize_copy;F;I"
Array;T;[o;;I"self other_ary;T;I"	void;To; ;0;0;	I"
Array;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"LCalculates the set of unambiguous abbreviations for the strings in `self`.

    require 'abbrev'
    %w{ car cone }.abbrev
    #=> {"car"=>"car", "ca"=>"car", "cone"=>"cone", "con"=>"cone", "co"=>"cone"}

The optional `pattern` parameter is a pattern or a string. Only input strings
that match the pattern or start with the string are included in the output
hash.

    %w{ fast boat day }.abbrev(/^.a/)
    #=> {"fast"=>"fast", "fas"=>"fast", "fa"=>"fast", "day"=>"day", "da"=>"day"}

    Abbrev.abbrev(%w{car box cone}, "ca")
    #=> {"car"=>"car", "ca"=>"car"}

See also Abbrev.abbrev

;T;0;;;I"abbrev;F;I"
Array;T;[o;;I"?::String | ::Regexp | nil;T;I"Hash[::String, ::String];To; ;0;0;	I"
Array;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"ÉReturns a JSON string containing a JSON array, that is generated from
this Array instance.
_state_ is a JSON::State object, that can also be used to configure the
produced JSON string output further.

;T;0;;;I"to_json;F;I"
Array;T;[o;;I"?::JSON::State state;T;I"String;To; ;0;0;	I"
Array;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"¯Builds a command line string from an argument list `array` joining all
elements escaped for the Bourne shell and separated by a space.

See Shellwords.shelljoin for details.

;T;0;;;I"shelljoin;F;I"
Array;T;[o;;I" ;F;I"String;To; ;I"ÎBasicObject is the parent class of all classes in Ruby.  It's an explicit
blank class.

BasicObject can be used for creating object hierarchies independent of Ruby's
object hierarchy, proxy objects like the Delegator class, or other uses where
namespace pollution from Ruby's methods and classes must be avoided.

To avoid polluting BasicObject for other users an appropriately named subclass
of BasicObject should be created instead of directly modifying BasicObject:

    class MyObjectSystem < BasicObject
    end

BasicObject does not include Kernel (for methods like `puts`) and BasicObject
is outside of the namespace of the standard library so common classes will not
be found without using a full class path.

A variety of strategies can be used to provide useful portions of the standard
library to subclasses of BasicObject.  A subclass could `include Kernel` to
obtain `puts`, `exit`, etc.  A custom Kernel-like module could be created and
included or delegation can be used via #method_missing:

    class MyObjectSystem < BasicObject
      DELEGATE = [:puts, :p]

      def method_missing(name, *args, &block)
        return super unless DELEGATE.include? name
        ::Kernel.send(name, *args, &block)
      end

      def respond_to_missing?(name, include_private = false)
        DELEGATE.include?(name) or super
      end
    end

Access to classes and modules from the Ruby standard library can be obtained
in a BasicObject subclass by referencing the desired constant from the root
like `::File` or `::Enumerator`. Like #method_missing, #const_missing can be
used to delegate constant lookup to `Object`:

    class MyObjectSystem < BasicObject
      def self.const_missing(name)
        ::Object.const_get(name)
      end
    end

### What's Here

These are the methods defined for BasicObject:

    ::new
:       Returns a new BasicObject instance.

    [!](#method-i-21)
:       Returns the boolean negation of `self`: `true` or `false`.

    [!=](#method-i-21-3D)
:       Returns whether `self` and the given object are *not* equal.

    [==](#method-i-3D-3D)
:       Returns whether `self` and the given object are equivalent.

    [__id__](#method-i-__id__)
:       Returns the integer object identifier for `self`.

    [__send__](#method-i-__send__)
:       Calls the method identified by the given symbol.

    #equal?
:       Returns whether `self` and the given object are the same object.

    #instance_eval
:       Evaluates the given string or block in the context of `self`.

    #instance_exec
:       Executes the given block in the context of `self`, passing the given
        arguments.

    #method_missing
:       Method called when an undefined method is called on `self`.

    #singleton_method_added
:       Method called when a singleton method is added to `self`.

    #singleton_method_removed
:       Method called when a singleton method is added removed from `self`.

    #singleton_method_undefined
:       Method called when a singleton method is undefined in `self`.

;T;0;	I"BasicObject;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"Boolean negate.

;T;0;;;I"!;F;I"BasicObject;T;[o;;I" ;F;I"	bool;To;;I"BReturns true if two objects are not-equal, otherwise false.

;T;0;;;I"!=;F;I"BasicObject;T;[o;;I"untyped other;T;I"	bool;To;;I"€Equality --- At the Object level, #== returns `true` only if `obj` and `other`
are the same object.  Typically, this method is overridden in descendant
classes to provide class-specific meaning.

Unlike #==, the #equal? method should never be overridden by subclasses as it
is used to determine object identity (that is, `a.equal?(b)` if and only if
`a` is the same object as `b`):

    obj = "a"
    other = obj.dup

    obj == other      #=> true
    obj.equal? other  #=> false
    obj.equal? obj    #=> true

The #eql? method returns `true` if `obj` and `other` refer to the same hash
key.  This is used by Hash to test members for equality.  For any pair of
objects where #eql? returns `true`, the #hash value of both objects must be
equal. So any subclass that overrides #eql? should also override #hash
appropriately.

For objects of class Object, #eql?  is synonymous with #==.  Subclasses
normally continue this tradition by aliasing #eql? to their overridden #==
method, but there are exceptions. Numeric types, for example, perform type
conversion across #==, but not across #eql?, so:

    1 == 1.0     #=> true
    1.eql? 1.0   #=> false

;T;0;;;I"==;F;I"BasicObject;T;[o;;I"untyped other;T;I"	bool;To;;I"íReturns an integer identifier for `obj`.

The same number will be returned on all calls to `object_id` for a given
object, and no two active objects will share an id.

Note: that some objects of builtin classes are reused for optimization. This
is the case for immediate values and frozen string literals.

BasicObject implements +__id__+, Kernel implements `object_id`.

Immediate values are not passed by reference but are passed by value: `nil`,
`true`, `false`, Fixnums, Symbols, and some Floats.

    Object.new.object_id  == Object.new.object_id  # => false
    (21 * 2).object_id    == (21 * 2).object_id    # => true
    "hello".object_id     == "hello".object_id     # => false
    "hi".freeze.object_id == "hi".freeze.object_id # => true

;T;0;;;I"__id__;F;I"BasicObject;T;[o;;I" ;F;I"Integer;To;;I"ûInvokes the method identified by *symbol*, passing it any arguments specified.
When the method is identified by a string, the string is converted to a
symbol.

BasicObject implements +__send__+, Kernel implements `send`. `__send__` is
safer than `send` when *obj* has the same method name like `Socket`. See also
`public_send`.

    class Klass
      def hello(*args)
        "Hello " + args.join(' ')
      end
    end
    k = Klass.new
    k.send :hello, "gentle", "readers"   #=> "Hello gentle readers"

;T;0;;;I"__send__;F;I"BasicObject;T;[o;;I",::String | ::Symbol arg0, *untyped args;T;I"untyped;To;;I"€Equality --- At the Object level, #== returns `true` only if `obj` and `other`
are the same object.  Typically, this method is overridden in descendant
classes to provide class-specific meaning.

Unlike #==, the #equal? method should never be overridden by subclasses as it
is used to determine object identity (that is, `a.equal?(b)` if and only if
`a` is the same object as `b`):

    obj = "a"
    other = obj.dup

    obj == other      #=> true
    obj.equal? other  #=> false
    obj.equal? obj    #=> true

The #eql? method returns `true` if `obj` and `other` refer to the same hash
key.  This is used by Hash to test members for equality.  For any pair of
objects where #eql? returns `true`, the #hash value of both objects must be
equal. So any subclass that overrides #eql? should also override #hash
appropriately.

For objects of class Object, #eql?  is synonymous with #==.  Subclasses
normally continue this tradition by aliasing #eql? to their overridden #==
method, but there are exceptions. Numeric types, for example, perform type
conversion across #==, but not across #eql?, so:

    1 == 1.0     #=> true
    1.eql? 1.0   #=> false

;T;0;;;I"equal?;F;I"BasicObject;T;[o;;I"untyped other;T;I"	bool;To;;I"œEvaluates a string containing Ruby source code, or the given block, within the
context of the receiver (*obj*). In order to set the context, the variable
`self` is set to *obj* while the code is executing, giving the code access to
*obj*'s instance variables and private methods.

When `instance_eval` is given a block, *obj* is also passed in as the block's
only argument.

When `instance_eval` is given a `String`, the optional second and third
parameters supply a filename and starting line number that are used when
reporting compilation errors.

    class KlassWithSecret
      def initialize
        @secret = 99
      end
      private
      def the_secret
        "Ssssh! The secret is #{@secret}."
      end
    end
    k = KlassWithSecret.new
    k.instance_eval { @secret }          #=> 99
    k.instance_eval { the_secret }       #=> "Ssssh! The secret is 99."
    k.instance_eval {|obj| obj == self } #=> true

;T;0;;;I"instance_eval;F;I"BasicObject;T;[o;;I"4::String, ?::String filename, ?::Integer lineno;T;I"untyped;To;;I" ;F;I"U;Fo;;I"ªExecutes the given block within the context of the receiver (*obj*). In order
to set the context, the variable `self` is set to *obj* while the code is
executing, giving the code access to *obj*'s instance variables.  Arguments
are passed as block parameters.

    class KlassWithSecret
      def initialize
        @secret = 99
      end
    end
    k = KlassWithSecret.new
    k.instance_exec(5) {|x| @secret+x }   #=> 104

;T;0;;;I"instance_exec;F;I"BasicObject;T;[o;;I"*V args;T;I"U;Fo;;I"!Returns a new BasicObject.

;T;0;;;I"initialize;F;I"BasicObject;T;[o;;I" ;F;I"	void;To;;I"ÜInvoked by Ruby when *obj* is sent a message it cannot handle. *symbol* is the
symbol for the method called, and *args* are any arguments that were passed to
it. By default, the interpreter raises an error when this method is called.
However, it is possible to override the method to provide more dynamic
behavior. If it is decided that a particular method should not be handled,
then *super* should be called, so that ancestors can pick up the missing
method. The example below creates a class `Roman`, which responds to methods
with names consisting of roman numerals, returning the corresponding integer
values.

    class Roman
      def roman_to_int(str)
        # ...
      end

      def method_missing(symbol, *args)
        str = symbol.id2name
        begin
          roman_to_int(str)
        rescue
          super(symbol, *args)
        end
      end
    end

    r = Roman.new
    r.iv      #=> 4
    r.xxiii   #=> 23
    r.mm      #=> 2000
    r.foo     #=> NoMethodError

;T;0;;;I"method_missing;F;I"BasicObject;T;[o;;I""::Symbol, *untyped, **untyped;T;I"untyped;To;;I"iInvoked as a callback whenever a singleton method is added to the receiver.

    module Chatty
      def Chatty.singleton_method_added(id)
        puts "Adding #{id.id2name}"
      end
      def self.one()     end
      def two()          end
      def Chatty.three() end
    end

*produces:*

    Adding singleton_method_added
    Adding one
    Adding three

;T;0;;;I"singleton_method_added;F;I"BasicObject;T;[o;;I"::Symbol;T;I"	void;To;;I"©Invoked as a callback whenever a singleton method is removed from the
receiver.

    module Chatty
      def Chatty.singleton_method_removed(id)
        puts "Removing #{id.id2name}"
      end
      def self.one()     end
      def two()          end
      def Chatty.three() end
      class << self
        remove_method :three
        remove_method :one
      end
    end

*produces:*

    Removing three
    Removing one

;T;0;;;I"singleton_method_removed;F;I"BasicObject;T;[o;;I"::Symbol;T;I"	void;To;;I"FInvoked as a callback whenever a singleton method is undefined in the
receiver.

    module Chatty
      def Chatty.singleton_method_undefined(id)
        puts "Undefining #{id.id2name}"
      end
      def Chatty.one()   end
      class << self
         undef_method(:one)
      end
    end

*produces:*

    Undefining one

;T;0;;;I"singleton_method_undefined;F;I"BasicObject;T;[o;;I"::Symbol;T;I"	void;To; ;I"’Objects of class Binding encapsulate the execution context at some particular
place in the code and retain this context for future use. The variables,
methods, value of `self`, and possibly an iterator block that can be accessed
in this context are all retained. Binding objects can be created using
Kernel#binding, and are made available to the callback of
Kernel#set_trace_func and instances of TracePoint.

These binding objects can be passed as the second argument of the Kernel#eval
method, establishing an environment for the evaluation.

    class Demo
      def initialize(n)
        @secret = n
      end
      def get_binding
        binding
      end
    end

    k1 = Demo.new(99)
    b1 = k1.get_binding
    k2 = Demo.new(-3)
    b2 = k2.get_binding

    eval("@secret", b1)   #=> 99
    eval("@secret", b2)   #=> -3
    eval("@secret")       #=> nil

Binding objects have no class-specific methods.

;T;0;	I"Binding;T;
[ ;[ ;0;[ ;[ ;0;0o;;0;0;;;I"
clone;F;I"Binding;T;[o;;I" ;F;I"	self;To;;I"-Evaluates the Ruby expression(s) in *string*, in the *binding*'s context.  If
the optional *filename* and *lineno* parameters are present, they will be used
when reporting syntax errors.

    def get_binding(param)
      binding
    end
    b = get_binding("hello")
    b.eval("param")   #=> "hello"

;T;0;;;I"	eval;F;I"Binding;T;[o;;I"9::String arg0, ?::String filename, ?::Integer lineno;T;I"untyped;To;;I"€Opens an IRB session where `binding.irb` is called which allows for
interactive debugging. You can call any methods or variables available in the
current scope, and mutate state if you need to.

Given a Ruby file called `potato.rb` containing the following code:

    class Potato
      def initialize
        @cooked = false
        binding.irb
        puts "Cooked potato: #{@cooked}"
      end
    end

    Potato.new

Running `ruby potato.rb` will open an IRB session where `binding.irb` is
called, and you will see the following:

    $ ruby potato.rb

    From: potato.rb @ line 4 :

        1: class Potato
        2:   def initialize
        3:     @cooked = false
     => 4:     binding.irb
        5:     puts "Cooked potato: #{@cooked}"
        6:   end
        7: end
        8:
        9: Potato.new

    irb(#<Potato:0x00007feea1916670>):001:0>

You can type any valid Ruby code and it will be evaluated in the current
context. This allows you to debug without having to run your code repeatedly:

    irb(#<Potato:0x00007feea1916670>):001:0> @cooked
    => false
    irb(#<Potato:0x00007feea1916670>):002:0> self.class
    => Potato
    irb(#<Potato:0x00007feea1916670>):003:0> caller.first
    => ".../2.5.1/lib/ruby/2.5.0/irb/workspace.rb:85:in `eval'"
    irb(#<Potato:0x00007feea1916670>):004:0> @cooked = true
    => true

You can exit the IRB session with the `exit` command. Note that exiting will
resume execution where `binding.irb` had paused it, as you can see from the
output printed to standard output in this example:

    irb(#<Potato:0x00007feea1916670>):005:0> exit
    Cooked potato: true

See IRB@IRB+Usage for more information.

;T;0;;;I"irb;F;I"Binding;T;[o;;I" ;F;I"	void;To;;I"3Returns `true` if a local variable `symbol` exists.

    def foo
      a = 1
      binding.local_variable_defined?(:a) #=> true
      binding.local_variable_defined?(:b) #=> false
    end

This method is the short version of the following code:

    binding.eval("defined?(#{symbol}) == 'local-variable'")

;T;0;;;I"local_variable_defined?;F;I"Binding;T;[o;;I"::String | ::Symbol symbol;T;I"	bool;To;;I"
Returns the value of the local variable `symbol`.

    def foo
      a = 1
      binding.local_variable_get(:a) #=> 1
      binding.local_variable_get(:b) #=> NameError
    end

This method is the short version of the following code:

    binding.eval("#{symbol}")

;T;0;;;I"local_variable_get;F;I"Binding;T;[o;;I"::String | ::Symbol symbol;T;I"untyped;To;;I"jSet local variable named `symbol` as `obj`.

    def foo
      a = 1
      bind = binding
      bind.local_variable_set(:a, 2) # set existing local variable `a'
      bind.local_variable_set(:b, 3) # create new local variable `b'
                                     # `b' exists only in binding

      p bind.local_variable_get(:a)  #=> 2
      p bind.local_variable_get(:b)  #=> 3
      p a                            #=> 2
      p b                            #=> NameError
    end

This method behaves similarly to the following code:

    binding.eval("#{symbol} = #{obj}")

if `obj` can be dumped in Ruby code.

;T;0;;;I"local_variable_set;F;I"Binding;T;[o;;I"&::String | ::Symbol symbol, U obj;T;I"U;Fo;;I"Returns the names of the binding's local variables as symbols.

    def foo
      a = 1
      2.times do |n|
        binding.local_variables #=> [:a, :n]
      end
    end

This method is the short version of the following code:

    binding.eval("local_variables")

;T;0;;;I"local_variables;F;I"Binding;T;[o;;I" ;F;I"Array[::Symbol];To;;I"8Returns the bound receiver of the binding object.

;T;0;;;I"receiver;F;I"Binding;T;[o;;I" ;F;I"untyped;To;;I"NReturns the Ruby source filename and line number of the binding object.

;T;0;;;I"source_location;F;I"Binding;T;[o;;I" ;F;I"[ ::String, ::Integer ];To; ;I"!(OtherClass)-----------...

;T;0;	I"
Class;T;
[ ;[ ;0;[ ;[ ;0;I"Module;To;;I"ŠCreates a new anonymous (unnamed) class with the given superclass (or Object
if no parameter is given). You can give a class a name by assigning the class
object to a constant.

If a block is given, it is passed the class object, and the block is evaluated
in the context of this class like #class_eval.

    fred = Class.new do
      def meth1
        "hello"
      end
      def meth2
        "bye"
      end
    end

    a = fred.new     #=> #<#<Class:0x100381890>:0x100376b98>
    a.meth1          #=> "hello"
    a.meth2          #=> "bye"

Assign the class to a constant (name starting uppercase) if you want to treat
it like a regular class.

;T;0;;;I"initialize;F;I"
Class;T;[o;;I"?::Class superclass;T;I"	void;To;;I"jAllocates space for a new object of *class*'s class and does not call
initialize on the new instance. The returned object must be an instance of
*class*.

    klass = Class.new do
      def initialize(*args)
        @initialized = true
      end

      def initialized?
        @initialized || false
      end
    end

    klass.allocate.initialized? #=> false

;T;0;;;I"allocate;F;I"
Class;T;[o;;I" ;F;I"untyped;To;;I"2Callback invoked whenever a subclass of the current class is created.

Example:

    class Foo
      def self.inherited(subclass)
        puts "New subclass: #{subclass}"
      end
    end

    class Bar < Foo
    end

    class Baz < Bar
    end

*produces:*

    New subclass: Bar
    New subclass: Baz

;T;0;;;I"inherited;F;I"
Class;T;[o;;I"::Class arg0;T;I"untyped;To;;I"ÞCalls #allocate to create a new object of *class*'s class, then invokes that
object's #initialize method, passing it *args*.  This is the method that ends
up getting called whenever an object is constructed using `.new`.

;T;0;;;I"new;F;I"
Class;T;[o;;I" ;F;I"untyped;To;;I"XReturns an array of classes where the receiver is the direct superclass of the
class, excluding singleton classes. The order of the returned array is not
defined.

    class A; end
    class B < A; end
    class C < B; end
    class D < A; end

    A.subclasses        #=> [D, B]
    B.subclasses        #=> [C]
    C.subclasses        #=> []

;T;0;;;I"subclasses;F;I"
Class;T;[o;;I" ;F;I"Array[::Class];To;;I"_Returns the superclass of *class*, or `nil`.

    File.superclass          #=> IO
    IO.superclass            #=> Object
    Object.superclass        #=> BasicObject
    class Foo; end
    class Bar < Foo; end
    Bar.superclass           #=> Foo

Returns nil when the given class does not have a parent class:

    BasicObject.superclass   #=> nil

;T;0;;;I"superclass;F;I"
Class;T;[o;;I" ;F;I"Class?;To:)Rucoa::Definitions::ModuleDefinition;I"ªThe Comparable mixin is used by classes whose objects may be ordered. The
class must define the `<=>` operator, which compares the receiver against
another object, returning a value less than 0, returning 0, or returning a
value greater than 0, depending on whether the receiver is less than, equal
to, or greater than the other object. If the other object is not comparable
then the `<=>` operator should return `nil`. Comparable uses `<=>` to
implement the conventional comparison operators (`<`, `<=`, `==`, `>=`, and
`>`) and the method `between?`.

    class SizeMatters
      include Comparable
      attr :str
      def <=>(other)
        str.size <=> other.str.size
      end
      def initialize(str)
        @str = str
      end
      def inspect
        @str
      end
    end

    s1 = SizeMatters.new("Z")
    s2 = SizeMatters.new("YY")
    s3 = SizeMatters.new("XXX")
    s4 = SizeMatters.new("WWWW")
    s5 = SizeMatters.new("VVVVV")

    s1 < s2                       #=> true
    s4.between?(s1, s3)           #=> false
    s4.between?(s3, s5)           #=> true
    [ s3, s2, s5, s4, s1 ].sort   #=> [Z, YY, XXX, WWWW, VVVVV]

## What's Here

Module Comparable provides these methods, all of which use method `<=>`:

    [<](#method-i-3C)
:       Returns whether `self` is less than the given object.

    [<=](#method-i-3C-3D)
:       Returns whether `self` is less than or equal to the given object.

    [==](#method-i-3D-3D)
:       Returns whether `self` is equal to the given object.

    [>](#method-i-3E)
:       Returns whether `self` is greater than or equal to the given object.

    [>=](#method-i-3E-3D)
:       Returns whether `self` is greater than the given object.

*   #between? Returns `true` if `self` is between two given objects.
    #clamp
:       For given objects `min` and `max`, or range `(min..max)`, returns:

    *   `min` if `(self <=> min) < 0`.
    *   `max` if `(self <=> max) > 0`.
    *   `self` otherwise.

;T;0;	I"Comparable;T;
[ ;[ ;0;[ ;[ o;;I"sCompares two objects based on the receiver's `<=>` method, returning true if
it returns a value less than 0.

;T;0;;;I"<;F;I"Comparable;T;[o;;I"untyped other;T;I"	bool;To;;I"Compares two objects based on the receiver's `<=>` method, returning true if
it returns a value less than or equal to 0.

;T;0;;;I"<=;F;I"Comparable;T;[o;;I"untyped other;T;I"	bool;To;;I"˜Compares two objects based on the receiver's `<=>` method, returning true if
it returns 0. Also returns true if *obj* and *other* are the same object.

;T;0;;;I"==;F;I"Comparable;T;[o;;I"untyped other;T;I"	bool;To;;I"vCompares two objects based on the receiver's `<=>` method, returning true if
it returns a value greater than 0.

;T;0;;;I">;F;I"Comparable;T;[o;;I"untyped other;T;I"	bool;To;;I"}Compares two objects based on the receiver's `<=>` method, returning true if
it returns a value greater than or equal to 0.

;T;0;;;I">=;F;I"Comparable;T;[o;;I"untyped other;T;I"	bool;To;;I"+Returns `false` if *obj* `<=>` *min* is less than zero or if *obj* `<=>` *max*
is greater than zero, `true` otherwise.

    3.between?(1, 5)               #=> true
    6.between?(1, 5)               #=> false
    'cat'.between?('ant', 'dog')   #=> true
    'gnu'.between?('ant', 'dog')   #=> false

;T;0;;;I"between?;F;I"Comparable;T;[o;;I"untyped min, untyped max;T;I"	bool;To;;I"îIn `(min, max)` form, returns *min* if *obj* `<=>` *min* is less than zero,
*max* if *obj* `<=>` *max* is greater than zero, and *obj* otherwise.

    12.clamp(0, 100)         #=> 12
    523.clamp(0, 100)        #=> 100
    -3.123.clamp(0, 100)     #=> 0

    'd'.clamp('a', 'f')      #=> 'd'
    'z'.clamp('a', 'f')      #=> 'f'

In `(range)` form, returns *range.begin* if *obj* `<=>` *range.begin* is less
than zero, *range.end* if *obj* `<=>` *range.end* is greater than zero, and
*obj* otherwise.

    12.clamp(0..100)         #=> 12
    523.clamp(0..100)        #=> 100
    -3.123.clamp(0..100)     #=> 0

    'd'.clamp('a'..'f')      #=> 'd'
    'z'.clamp('a'..'f')      #=> 'f'

If *range.begin* is `nil`, it is considered smaller than *obj*, and if
*range.end* is `nil`, it is considered greater than *obj*.

    -20.clamp(0..)           #=> 0
    523.clamp(..100)         #=> 100

When *range.end* is excluded and not `nil`, an exception is raised.

    100.clamp(0...100)       # ArgumentError

;T;0;;;I"
clamp;F;I"Comparable;T;[o;;I"A min, B max;T;I"self | A | B;To;;I"::Range[A];T;I"self | A;To; ;I"qA complex number can be represented as a paired real number with imaginary
unit; a+bi.  Where a is real part, b is imaginary part and i is imaginary
unit.  Real a equals complex a+0i mathematically.

You can create a Complex object explicitly with:

*   A [complex literal](doc/syntax/literals_rdoc.html#label-Complex+Literals).


You can convert certain objects to Complex objects with:

*   Method [Complex](Kernel.html#method-i-Complex).


Complex object can be created as literal, and also by using Kernel#Complex,
Complex::rect, Complex::polar or to_c method.

    2+1i                 #=> (2+1i)
    Complex(1)           #=> (1+0i)
    Complex(2, 3)        #=> (2+3i)
    Complex.polar(2, 3)  #=> (-1.9799849932008908+0.2822400161197344i)
    3.to_c               #=> (3+0i)

You can also create complex object from floating-point numbers or strings.

    Complex(0.3)         #=> (0.3+0i)
    Complex('0.3-0.5i')  #=> (0.3-0.5i)
    Complex('2/3+3/4i')  #=> ((2/3)+(3/4)*i)
    Complex('1@2')       #=> (-0.4161468365471424+0.9092974268256817i)

    0.3.to_c             #=> (0.3+0i)
    '0.3-0.5i'.to_c      #=> (0.3-0.5i)
    '2/3+3/4i'.to_c      #=> ((2/3)+(3/4)*i)
    '1@2'.to_c           #=> (-0.4161468365471424+0.9092974268256817i)

A complex object is either an exact or an inexact number.

    Complex(1, 1) / 2    #=> ((1/2)+(1/2)*i)
    Complex(1, 1) / 2.0  #=> (0.5+0.5i)

;T;0;	I"Complex;T;
[ ;[ ;0;[ ;[ ;0;I"Numeric;To;;I">Returns a complex object which denotes the given polar form.

    Complex.polar(3, 0)            #=> (3.0+0.0i)
    Complex.polar(3, Math::PI/2)   #=> (1.836909530733566e-16+3.0i)
    Complex.polar(3, Math::PI)     #=> (-3.0+3.673819061467132e-16i)
    Complex.polar(3, -Math::PI/2)  #=> (1.836909530733566e-16-3.0i)

;T;0;;;I"
polar;F;I"Complex;T;[o;;I"::Numeric, ?::Numeric;T;I"Complex;To;;I"tReturns a complex object which denotes the given rectangular form.

    Complex.rectangular(1, 2)  #=> (1+2i)

;T;0;;;I"	rect;F;I"Complex;T;[o;;I"::Numeric, ?::Numeric;T;I"Complex;To;;I"Performs multiplication.

    Complex(2, 3)  * Complex(2, 3)   #=> (-5+12i)
    Complex(900)   * Complex(1)      #=> (900+0i)
    Complex(-2, 9) * Complex(-9, 2)  #=> (0-85i)
    Complex(9, 8)  * 4               #=> (36+32i)
    Complex(20, 9) * 9.8             #=> (196.0+88.2i)

;T;0;;;I"*;F;I"Complex;T;[o;;I"::Numeric;T;I"Complex;To;;I"šPerforms exponentiation.

    Complex('i') ** 2              #=> (-1+0i)
    Complex(-8) ** Rational(1, 3)  #=> (1.0000000000000002+1.7320508075688772i)

;T;0;;;I"**;F;I"Complex;T;[o;;I"::Numeric;T;I"Complex;To;;I"Performs addition.

    Complex(2, 3)  + Complex(2, 3)   #=> (4+6i)
    Complex(900)   + Complex(1)      #=> (901+0i)
    Complex(-2, 9) + Complex(-9, 2)  #=> (-11+11i)
    Complex(9, 8)  + 4               #=> (13+8i)
    Complex(20, 9) + 9.8             #=> (29.8+9i)

;T;0;;;I"+;F;I"Complex;T;[o;;I"::Numeric;T;I"Complex;To;;0;0;;;I"+@;F;I"Complex;T;[o;;I" ;F;I"Complex;To;;I"Performs subtraction.

    Complex(2, 3)  - Complex(2, 3)   #=> (0+0i)
    Complex(900)   - Complex(1)      #=> (899+0i)
    Complex(-2, 9) - Complex(-9, 2)  #=> (7+7i)
    Complex(9, 8)  - 4               #=> (5+8i)
    Complex(20, 9) - 9.8             #=> (10.2+9i)

;T;0;;;I"-;F;I"Complex;T;[o;;I"::Numeric;T;I"Complex;To;;I"FReturns negation of the value.

    -Complex(1, 2)  #=> (-1-2i)

;T;0;;;I"-@;F;I"Complex;T;[o;;I" ;F;I"Complex;To;;I"QPerforms division.

    Complex(2, 3)  / Complex(2, 3)   #=> ((1/1)+(0/1)*i)
    Complex(900)   / Complex(1)      #=> ((900/1)+(0/1)*i)
    Complex(-2, 9) / Complex(-9, 2)  #=> ((36/85)-(77/85)*i)
    Complex(9, 8)  / 4               #=> ((9/4)+(2/1)*i)
    Complex(20, 9) / 9.8             #=> (2.0408163265306123+0.9183673469387754i)

;T;0;;;I"/;F;I"Complex;T;[o;;I"::Numeric;T;I"Complex;To;;0;0;;;I"<;F;I"Complex;T;[o;;I"::Numeric;T;I"bot;To;;0;0;;;I"<=;F;I"Complex;T;[o;;I"::Numeric;T;I"bot;To;;I"¨If `cmp`'s imaginary part is zero, and `object` is also a real number (or a
Complex number where the imaginary part is zero), compare the real part of
`cmp` to object.  Otherwise, return nil.

    Complex(2, 3)  <=> Complex(2, 3)   #=> nil
    Complex(2, 3)  <=> 1               #=> nil
    Complex(2)     <=> 1               #=> 1
    Complex(2)     <=> 2               #=> 0
    Complex(2)     <=> 3               #=> -1

;T;0;;;I"<=>;F;I"Complex;T;[o;;I"untyped;T;I"Integer?;To;;I"Returns true if cmp equals object numerically.

    Complex(2, 3)  == Complex(2, 3)   #=> true
    Complex(5)     == 5               #=> true
    Complex(0)     == 0.0             #=> true
    Complex('1/3') == 0.33            #=> false
    Complex('1/2') == '1/2'           #=> false

;T;0;;;I"==;F;I"Complex;T;[o;;I"untyped;T;I"	bool;To;;0;0;;;I">;F;I"Complex;T;[o;;I"::Numeric;T;I"bot;To;;0;0;;;I">=;F;I"Complex;T;[o;;I"::Numeric;T;I"bot;To;;I"zReturns the absolute part of its polar form.

    Complex(-1).abs         #=> 1
    Complex(3.0, -4.0).abs  #=> 5.0

;T;0;;;I"abs;F;I"Complex;T;[o;;I" ;F;I"Numeric;To;;I"vReturns square of the absolute value.

    Complex(-1).abs2         #=> 1
    Complex(3.0, -4.0).abs2  #=> 25.0

;T;0;;;I"	abs2;F;I"Complex;T;[o;;I" ;F;I"Numeric;To;;I"nReturns the angle part of its polar form.

    Complex.polar(3, Math::PI/2).arg  #=> 1.5707963267948966

;T;0;;;I"
angle;F;I"Complex;T;[o;;I" ;F;I"
Float;To;;0;0;;;I"	ceil;F;I"Complex;T;[o;;I"*untyped;T;I"bot;To;;0;0;;;I"coerce;F;I"Complex;T;[o;;I"::Numeric;T;I"[ ::Complex, ::Complex ];To;;I"NReturns the complex conjugate.

    Complex(1, 2).conjugate  #=> (1-2i)

;T;0;;;I"	conj;F;I"Complex;T;[o;;I" ;F;I"Complex;To;;I"NReturns the complex conjugate.

    Complex(1, 2).conjugate  #=> (1-2i)

;T;0;;;I"conjugate;F;I"Complex;T;[o;;I" ;F;I"Complex;To;;I"YReturns the denominator (lcm of both denominator - real and imag).

See numerator.

;T;0;;;I"denominator;F;I"Complex;T;[o;;I" ;F;I"Integer;To;;0;0;;;I"div;F;I"Complex;T;[o;;I"::Numeric;T;I"bot;To;;0;0;;;I"divmod;F;I"Complex;T;[o;;I"::Numeric;T;I"bot;To;;0;0;;;I"dup;F;I"Complex;T;[o;;I" ;F;I"	self;To;;0;0;;;I"	eql?;F;I"Complex;T;[o;;I"untyped;T;I"	bool;To;;I"Performs division as each part is a float, never returns a float.

    Complex(11, 22).fdiv(3)  #=> (3.6666666666666665+7.333333333333333i)

;T;0;;;I"	fdiv;F;I"Complex;T;[o;;I"::Numeric;T;I"Complex;To;;I"mReturns `true` if `cmp`'s real and imaginary parts are both finite numbers,
otherwise returns `false`.

;T;0;;;I"finite?;F;I"Complex;T;[o;;I" ;F;I"	bool;To;;0;0;;;I"
floor;F;I"Complex;T;[o;;I"?::Integer;T;I"bot;To;;I" ;T;0;;;I"	hash;F;I"Complex;T;[o;;I" ;F;I"Integer;To;;0;0;;;I"i;F;I"Complex;T;[o;;I" ;F;I"bot;To;;I"lReturns the imaginary part.

    Complex(7).imaginary      #=> 0
    Complex(9, -4).imaginary  #=> -4

;T;0;;;I"	imag;F;I"Complex;T;[o;;I" ;F;I"Numeric;To;;I"lReturns the imaginary part.

    Complex(7).imaginary      #=> 0
    Complex(9, -4).imaginary  #=> -4

;T;0;;;I"imaginary;F;I"Complex;T;[o;;I" ;F;I"Numeric;To;;I"ÔReturns `1` if `cmp`'s real or imaginary part is an infinite number, otherwise
returns `nil`.

    For example:

       (1+1i).infinite?                   #=> nil
       (Float::INFINITY + 1i).infinite?   #=> 1

;T;0;;;I"infinite?;F;I"Complex;T;[o;;I" ;F;I"Integer?;To;;I"iReturns the value as a string for inspection.

    Complex(2).inspect                       #=> "(2+0i)"
    Complex('-8/6').inspect                  #=> "((-4/3)+0i)"
    Complex('1/2i').inspect                  #=> "(0+(1/2)*i)"
    Complex(0, Float::INFINITY).inspect      #=> "(0+Infinity*i)"
    Complex(Float::NAN, Float::NAN).inspect  #=> "(NaN+NaN*i)"

;T;0;;;I"inspect;F;I"Complex;T;[o;;I" ;F;I"String;To;;0;0;;;I"integer?;F;I"Complex;T;[o;;I" ;F;I"	bool;To;;0;0;;;I"modulo;F;I"Complex;T;[o;;I"::Numeric;T;I"bot;To;;0;0;;;I"negative?;F;I"Complex;T;[o;;I" ;F;I"bot;To;;0;0;;;I"nonzero?;F;I"Complex;T;[o;;I" ;F;I"
self?;To;;I"«Returns the numerator.

        1   2       3+4i  <-  numerator
        - + -i  ->  ----
        2   3        6    <-  denominator

    c = Complex('1/2+2/3i')  #=> ((1/2)+(2/3)*i)
    n = c.numerator          #=> (3+4i)
    d = c.denominator        #=> 6
    n / d                    #=> ((1/2)+(2/3)*i)
    Complex(Rational(n.real, d), Rational(n.imag, d))
                             #=> ((1/2)+(2/3)*i)

See denominator.

;T;0;;;I"numerator;F;I"Complex;T;[o;;I" ;F;I"Complex;To;;I"qReturns an array; [cmp.abs, cmp.arg].

    Complex(1, 2).polar  #=> [2.23606797749979, 1.1071487177940904]

;T;0;;;I"
polar;F;I"Complex;T;[o;;I" ;F;I"[ ::Numeric, ::Float ];To;;0;0;;;I"positive?;F;I"Complex;T;[o;;I" ;F;I"bot;To;;I"QPerforms division.

    Complex(2, 3)  / Complex(2, 3)   #=> ((1/1)+(0/1)*i)
    Complex(900)   / Complex(1)      #=> ((900/1)+(0/1)*i)
    Complex(-2, 9) / Complex(-9, 2)  #=> ((36/85)-(77/85)*i)
    Complex(9, 8)  / 4               #=> ((9/4)+(2/1)*i)
    Complex(20, 9) / 9.8             #=> (2.0408163265306123+0.9183673469387754i)

;T;0;;;I"quo;F;I"Complex;T;[o;;I"::Numeric;T;I"Complex;To;;I"óReturns the value as a rational if possible (the imaginary part should be
exactly zero).

    Complex(1.0/3, 0).rationalize  #=> (1/3)
    Complex(1, 0.0).rationalize    # RangeError
    Complex(1, 2).rationalize      # RangeError

See to_r.

;T;0;;;I"rationalize;F;I"Complex;T;[o;;I"?::Numeric eps;T;I"Rational;To;;I"\Returns the real part.

    Complex(7).real      #=> 7
    Complex(9, -4).real  #=> 9

;T;0;;;I"	real;F;I"Complex;T;[o;;I" ;F;I"Numeric;To;;I"GReturns false, even if the complex number has no imaginary part.

;T;0;;;I"
real?;F;I"Complex;T;[o;;I" ;F;I"
false;Fo;;I"tReturns a complex object which denotes the given rectangular form.

    Complex.rectangular(1, 2)  #=> (1+2i)

;T;0;;;I"	rect;F;I"Complex;T;[o;;I" ;F;I"[ ::Numeric, ::Numeric ];To;;0;0;;;I"reminder;F;I"Complex;T;[o;;I"::Numeric;T;I"bot;To;;0;0;;;I"
round;F;I"Complex;T;[o;;I"*untyped;T;I"bot;To;;0;0;;;I"	step;F;I"Complex;T;[o;;I"*untyped;T;I"bot;To;;I"^Returns self.

    Complex(2).to_c      #=> (2+0i)
    Complex(-8, 6).to_c  #=> (-8+6i)

;T;0;;;I"	to_c;F;I"Complex;T;[o;;I" ;F;I"Complex;To;;I"ÈReturns the value as a float if possible (the imaginary part should be exactly
zero).

    Complex(1, 0).to_f    #=> 1.0
    Complex(1, 0.0).to_f  # RangeError
    Complex(1, 2).to_f    # RangeError

;T;0;;;I"	to_f;F;I"Complex;T;[o;;I" ;F;I"
Float;To;;I"ÉReturns the value as an integer if possible (the imaginary part should be
exactly zero).

    Complex(1, 0).to_i    #=> 1
    Complex(1, 0.0).to_i  # RangeError
    Complex(1, 2).to_i    # RangeError

;T;0;;;I"	to_i;F;I"Complex;T;[o;;I" ;F;I"Integer;To;;I"ßReturns the value as a rational if possible (the imaginary part should be
exactly zero).

    Complex(1, 0).to_r    #=> (1/1)
    Complex(1, 0.0).to_r  # RangeError
    Complex(1, 2).to_r    # RangeError

See rationalize.

;T;0;;;I"	to_r;F;I"Complex;T;[o;;I" ;F;I"Rational;To;;I"<Returns the value as a string.

    Complex(2).to_s                       #=> "2+0i"
    Complex('-8/6').to_s                  #=> "-4/3+0i"
    Complex('1/2i').to_s                  #=> "0+1/2i"
    Complex(0, Float::INFINITY).to_s      #=> "0+Infinity*i"
    Complex(Float::NAN, Float::NAN).to_s  #=> "NaN+NaN*i"

;T;0;;;I"	to_s;F;I"Complex;T;[o;;I" ;F;I"String;To;;0;0;;;I"truncate;F;I"Complex;T;[o;;I"?::Integer;T;I"bot;To;;0;0;;;I"
zero?;F;I"Complex;T;[o;;I" ;F;I"	bool;To; ;0;0;	I"Complex;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"|Returns the value as a BigDecimal.

The `precision` parameter is required for a rational complex number. This
parameter is used to determine the number of significant digits for the
result.

    require 'bigdecimal'
    require 'bigdecimal/util'

    Complex(0.1234567, 0).to_d(4)   # => 0.1235e0
    Complex(Rational(22, 7), 0).to_d(3)   # => 0.314e1

See also BigDecimal::new.

;T;0;;;I"	to_d;F;I"Complex;T;[o;;I"*untyped args;T;I"BigDecimal;To; ;0;0;	I"Complex;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"gDeserializes JSON string by converting Real value `r`, imaginary value `i`, to
a Complex object.

;T;0;;;I"json_create;F;I"Complex;T;[o;;I"2::Hash[::String, ::String | ::Numeric] object;T;I"instance;To;;I"XReturns a hash, that will be turned into a JSON object and represent this
object.

;T;0;;;I"as_json;F;I"Complex;T;[o;;I"*untyped;T;I")Hash[::String, ::String | ::Numeric];To;;I"cStores class name (Complex) along with real value `r` and imaginary value `i`
as JSON string

;T;0;;;I"to_json;F;I"Complex;T;[o;;I"?::JSON::State state;T;I"String;To; ;I"gObjects of class Dir are directory streams representing directories in the
underlying file system. They provide a variety of ways to list directories and
their contents. See also File.

The directory used in these examples contains the two regular files
(`config.h` and `main.rb`), the parent directory (`..`), and the directory
itself (`.`).

## What's Here

First, what's elsewhere. Class Dir:

*   Inherits from [class
    Object](Object.html#class-Object-label-What-27s+Here).
*   Includes [module
    Enumerable](Enumerable.html#module-Enumerable-label-What-27s+Here), which
    provides dozens of additional methods.


Here, class Dir provides methods that are useful for:

*   [Reading](#class-Dir-label-Reading)
*   [Setting](#class-Dir-label-Setting)
*   [Querying](#class-Dir-label-Querying)
*   [Iterating](#class-Dir-label-Iterating)
*   [Other](#class-Dir-label-Other)


### Reading

    #close
:       Closes the directory stream for `self`.

    #pos=
:       Sets the position in the directory stream for `self`.

    #read
:       Reads and returns the next entry in the directory stream for `self`.

    #rewind
:       Sets the position in the directory stream for `self` to the first
        entry.

    #seek
:       Sets the position in the directory stream for `self` the entry at the
        given offset.



### Setting

    ::chdir
:       Changes the working directory of the current process to the given
        directory.

    ::chroot
:       Changes the file-system root for the current process to the given
        directory.



### Querying

    ::[]
:       Same as ::glob without the ability to pass flags.

    ::children
:       Returns an array of names of the children (both files and directories)
        of the given directory, but not including `.` or `..`.

    ::empty?
:       Returns whether the given path is an empty directory.

    ::entries
:       Returns an array of names of the children (both files and directories)
        of the given directory, including `.` and `..`.

    ::exist?
:       Returns whether the given path is a directory.

    ::getwd (aliased as #pwd)
:       Returns the path to the current working directory.

    ::glob
:       Returns an array of file paths matching the given pattern and flags.

    ::home
:       Returns the home directory path for a given user or the current user.

    #children
:       Returns an array of names of the children (both files and directories)
        of `self`, but not including `.` or `..`.

    #fileno
:       Returns the integer file descriptor for `self`.

    #path (aliased as #to_path)
:       Returns the path used to create `self`.

    #tell (aliased as #pos)
:       Returns the integer position in the directory stream for `self`.



### Iterating

    ::each_child
:       Calls the given block with each entry in the given directory, but not
        including `.` or `..`.

    ::foreach
:       Calls the given block with each entryin the given directory, including
        `.` and `..`.

    #each
:       Calls the given block with each entry in `self`, including `.` and
        `..`.

    #each_child
:       Calls the given block with each entry in `self`, but not including `.`
        or `..`.



### Other

    ::mkdir
:       Creates a directory at the given path, with optional permissions.

    ::new
:       Returns a new Dir for the given path, with optional encoding.

    ::open
:       Same as ::new, but if a block is given, yields the Dir to the block,
        closing it upon block exit.

    ::unlink (aliased as ::delete and ::rmdir)
:       Removes the given directory.

    #inspect
:       Returns a string description of `self`.

;T;0;	I"Dir;T;
[ ;[I"Enumerable;T;0;[ ;[ ;0;0o;;I"¿Returns a new directory object for the named directory.

The optional *encoding* keyword argument specifies the encoding of the
directory. If not specified, the filesystem encoding is used.

;T;0;;;I"initialize;F;I"Dir;T;[o;;I"*::string, ?encoding: ::encoding | nil;T;I"	void;To;;I"=Equivalent to calling `Dir.glob([`*string,...*`], 0)`.

;T;0;;;I"[];F;I"Dir;T;[o;;I"(*::string patterns, ?base: ::string;T;I"Array[::String];To;;I"4Changes the current working directory of the process to the given string. When
called without an argument, changes the directory to the value of the
environment variable `HOME`, or `LOGDIR`. SystemCallError (probably
Errno::ENOENT) if the target directory does not exist.

If a block is given, it is passed the name of the new current directory, and
the block is executed with that as the current directory. The original working
directory is restored when the block exits. The return value of `chdir` is the
value of the block. `chdir` blocks can be nested, but in a multi-threaded
program an error will be raised if a thread attempts to open a `chdir` block
while another thread has one open or a call to `chdir` without a block occurs
inside a block passed to `chdir` (even in the same thread).

    Dir.chdir("/var/spool/mail")
    puts Dir.pwd
    Dir.chdir("/tmp") do
      puts Dir.pwd
      Dir.chdir("/usr") do
        puts Dir.pwd
      end
      puts Dir.pwd
    end
    puts Dir.pwd

*produces:*

    /var/spool/mail
    /tmp
    /usr
    /tmp
    /var/spool/mail

;T;0;;;I"
chdir;F;I"Dir;T;[o;;I"?::string;T;I"	void;To;;I"?::string;T;I"U;Fo;;I"fReturns an array containing all of the filenames except for "." and ".." in
the given directory. Will raise a SystemCallError if the named directory
doesn't exist.

The optional *encoding* keyword argument specifies the encoding of the
directory. If not specified, the filesystem encoding is used.

    Dir.children("testdir")   #=> ["config.h", "main.rb"]

;T;0;;;I"children;F;I"Dir;T;[o;;I"A::string dirname, ?encoding: ::string | ::Encoding | nil enc;T;I"Array[::String];To;;I"»Changes this process's idea of the file system root. Only a privileged process
may make this call. Not available on all platforms. On Unix systems, see
`chroot(2)` for more information.

;T;0;;;I"chroot;F;I"Dir;T;[o;;I"::string;T;I"	void;To;;I"fDeletes the named directory. Raises a subclass of SystemCallError if the
directory isn't empty.

;T;0;;;I"delete;F;I"Dir;T;[o;;I"::string;T;I"	void;To;;I"4Calls the block once for each entry except for "." and ".." in the named
directory, passing the filename of each entry as a parameter to the block.

If no block is given, an enumerator is returned instead.

    Dir.each_child("testdir") {|x| puts "Got #{x}" }

*produces:*

    Got config.h
    Got main.rb

;T;0;;;I"each_child;F;I"Dir;T;[o;;I"A::string dirname, ?encoding: ::string | ::Encoding | nil enc;T;I"Enumerator[::String, void];To;;I"A::string dirname, ?encoding: ::string | ::Encoding | nil enc;T;I"	void;To;;I"mReturns `true` if the named file is an empty directory, `false` if it is not a
directory or non-empty.

;T;0;;;I"empty?;F;I"Dir;T;[o;;I"::string path_name;T;I"	bool;To;;I"XReturns an array containing all of the filenames in the given directory. Will
raise a SystemCallError if the named directory doesn't exist.

The optional *encoding* keyword argument specifies the encoding of the
directory. If not specified, the filesystem encoding is used.

    Dir.entries("testdir")   #=> [".", "..", "config.h", "main.rb"]

;T;0;;;I"entries;F;I"Dir;T;[o;;I"6::string dirname, ?encoding: ::encoding | nil enc;T;I"Array[::String];To;;I"JReturns `true` if the named file is a directory, `false` otherwise.

;T;0;;;I"exist?;F;I"Dir;T;[o;;I"::string file;T;I"	bool;To;;I"µReturns the path to the current working directory of this process as a string.

    Dir.chdir("/tmp")   #=> 0
    Dir.getwd           #=> "/tmp"
    Dir.pwd             #=> "/tmp"

;T;0;;;I"
getwd;F;I"Dir;T;[o;;I" ;F;I"String;To;;I"%Expands `pattern`, which is a pattern string or an Array of pattern strings,
and returns an array containing the matching filenames. If a block is given,
calls the block once for each matching filename, passing the filename as a
parameter to the block.

The optional `base` keyword argument specifies the base directory for
interpreting relative pathnames instead of the current working directory. As
the results are not prefixed with the base directory name in this case, you
will need to prepend the base directory name if you want real paths.

The results which matched single wildcard or character set are sorted in
binary ascending order, unless `false` is given as the optional `sort` keyword
argument.  The order of an Array of pattern strings and braces are preserved.

Note that the pattern is not a regexp, it's closer to a shell glob. See
File::fnmatch for the meaning of the `flags` parameter. Case sensitivity
depends on your system (`File::FNM_CASEFOLD` is ignored).

`*`
:   Matches any file. Can be restricted by other values in the glob.
    Equivalent to `/.*/mx` in regexp.

    `*`
:       Matches all files
    `c*`
:       Matches all files beginning with `c`
    `*c`
:       Matches all files ending with `c`
    `*c*`
:       Match all files that have `c` in them (including at the beginning or
        end).


    Note, this will not match Unix-like hidden files (dotfiles).  In order to
    include those in the match results, you must use the File::FNM_DOTMATCH
    flag or something like `"{*,.*}"`.

`**`
:   Matches directories recursively if followed by `/`.  If this path segment
    contains any other characters, it is the same as the usual `*`.

`?`
:   Matches any one character. Equivalent to `/.{1}/` in regexp.

`[set]`
:   Matches any one character in `set`.  Behaves exactly like character sets
    in Regexp, including set negation (`[^a-z]`).

`{p,q}`
:   Matches either literal `p` or literal `q`. Equivalent to pattern
    alternation in regexp.

    Matching literals may be more than one character in length.  More than two
    literals may be specified.

`\`
:   Escapes the next metacharacter.

    Note that this means you cannot use backslash on windows as part of a
    glob, i.e.  `Dir["c:\\foo*"]` will not work, use `Dir["c:/foo*"]` instead.


Examples:

    Dir["config.?"]                     #=> ["config.h"]
    Dir.glob("config.?")                #=> ["config.h"]
    Dir.glob("*.[a-z][a-z]")            #=> ["main.rb"]
    Dir.glob("*.[^r]*")                 #=> ["config.h"]
    Dir.glob("*.{rb,h}")                #=> ["main.rb", "config.h"]
    Dir.glob("*")                       #=> ["config.h", "main.rb"]
    Dir.glob("*", File::FNM_DOTMATCH)   #=> [".", "config.h", "main.rb"]
    Dir.glob(["*.rb", "*.h"])           #=> ["main.rb", "config.h"]

    Dir.glob("**/*.rb")                 #=> ["main.rb",
                                        #    "lib/song.rb",
                                        #    "lib/song/karaoke.rb"]

    Dir.glob("**/*.rb", base: "lib")    #=> ["song.rb",
                                        #    "song/karaoke.rb"]

    Dir.glob("**/lib")                  #=> ["lib"]

    Dir.glob("**/lib/**/*.rb")          #=> ["lib/song.rb",
                                        #    "lib/song/karaoke.rb"]

    Dir.glob("**/lib/*.rb")             #=> ["lib/song.rb"]

;T;0;;;I"	glob;F;I"Dir;T;[o;;I"L::string | ::Array[::string] pattern, ?::Integer flags, ?base: ::string;T;I"Array[::String];To;;I"L::string | ::Array[::string] pattern, ?::Integer flags, ?base: ::string;T;I"	void;To;;I"QReturns the home directory of the current user or the named user if given.

;T;0;;;I"	home;F;I"Dir;T;[o;;I"?::string user;T;I"String;To;;I"Makes a new directory named by *string*, with permissions specified by the
optional parameter *anInteger*. The permissions may be modified by the value
of File::umask, and are ignored on NT. Raises a SystemCallError if the
directory cannot be created. See also the discussion of permissions in the
class documentation for File.

    Dir.mkdir(File.join(Dir.home, ".foo"), 0700) #=> 0

;T;0;;;I"
mkdir;F;I"Dir;T;[o;;I"%::string, ?::Integer permissions;T;I"	void;To;;I"RThe optional *encoding* keyword argument specifies the encoding of the
directory. If not specified, the filesystem encoding is used.

With no block, `open` is a synonym for Dir::new. If a block is present, it is
passed *aDir* as a parameter. The directory is closed at the end of the block,
and Dir::open returns the value of the block.

;T;0;;;I"	open;F;I"Dir;T;[o;;I"*::string, ?encoding: ::encoding | nil;T;I"Dir;To;;I"*::string, ?encoding: ::encoding | nil;T;I"U;Fo;;I"µReturns the path to the current working directory of this process as a string.

    Dir.chdir("/tmp")   #=> 0
    Dir.getwd           #=> "/tmp"
    Dir.pwd             #=> "/tmp"

;T;0;;;I"pwd;F;I"Dir;T;[o;;I" ;F;I"String;To;;I"¦Returns an array containing all of the filenames except for "." and ".." in
this directory.

    d = Dir.new("testdir")
    d.children   #=> ["config.h", "main.rb"]

;T;0;;;I"children;F;I"Dir;T;[o;;I" ;F;I"Array[::String];To;;I"”Closes the directory stream. Calling this method on closed Dir object is
ignored since Ruby 2.3.

    d = Dir.new("testdir")
    d.close   #=> nil

;T;0;;;I"
close;F;I"Dir;T;[o;;I" ;F;I"	void;To;;I"5Calls the block once for each entry in this directory, passing the filename of
each entry as a parameter to the block.

If no block is given, an enumerator is returned instead.

    d = Dir.new("testdir")
    d.each  {|x| puts "Got #{x}" }

*produces:*

    Got .
    Got ..
    Got config.h
    Got main.rb

;T;0;;;I"	each;F;I"Dir;T;[o;;I" ;F;I"	self;To;;I" ;F;I"Enumerator[::String, self];To;;I">Calls the block once for each entry except for "." and ".." in this directory,
passing the filename of each entry as a parameter to the block.

If no block is given, an enumerator is returned instead.

    d = Dir.new("testdir")
    d.each_child  {|x| puts "Got #{x}" }

*produces:*

    Got config.h
    Got main.rb

;T;0;;;I"each_child;F;I"Dir;T;[o;;I" ;F;I"	self;To;;I" ;F;I"Enumerator[::String, self];To;;I"ùReturns the file descriptor used in *dir*.

    d = Dir.new("..")
    d.fileno   #=> 8

This method uses dirfd() function defined by POSIX 2008. NotImplementedError
is raised on other platforms, such as Windows, which doesn't provide the
function.

;T;0;;;I"fileno;F;I"Dir;T;[o;;I" ;F;I"Integer;To;;I"2Return a string describing this Dir object.

;T;0;;;I"inspect;F;I"Dir;T;[o;;I" ;F;I"String;To;;I"mReturns the path parameter passed to *dir*'s constructor.

    d = Dir.new("..")
    d.path   #=> ".."

;T;0;;;I"	path;F;I"Dir;T;[o;;I" ;F;I"String?;To;;I"“Returns the current position in *dir*. See also Dir#seek.

    d = Dir.new("testdir")
    d.tell   #=> 0
    d.read   #=> "."
    d.tell   #=> 12

;T;0;;;I"pos;F;I"Dir;T;[o;;I" ;F;I"Integer;To;;I"(Synonym for Dir#seek, but returns the position parameter.

    d = Dir.new("testdir")   #=> #<Dir:0x401b3c40>
    d.read                   #=> "."
    i = d.pos                #=> 12
    d.read                   #=> ".."
    d.pos = i                #=> 12
    d.read                   #=> ".."

;T;0;;;I"	pos=;F;I"Dir;T;[o;;I"::Integer pos;T;I"Integer;To;;I"ÈReads the next entry from *dir* and returns it as a string. Returns `nil` at
the end of the stream.

    d = Dir.new("testdir")
    d.read   #=> "."
    d.read   #=> ".."
    d.read   #=> "config.h"

;T;0;;;I"	read;F;I"Dir;T;[o;;I" ;F;I"String?;To;;I"–Repositions *dir* to the first entry.

    d = Dir.new("testdir")
    d.read     #=> "."
    d.rewind   #=> #<Dir:0x401b3fb0>
    d.read     #=> "."

;T;0;;;I"rewind;F;I"Dir;T;[o;;I" ;F;I"	self;To;;I"VSeeks to a particular location in *dir*. *integer* must be a value returned by
Dir#tell.

    d = Dir.new("testdir")   #=> #<Dir:0x401b3c40>
    d.read                   #=> "."
    i = d.tell               #=> 12
    d.read                   #=> ".."
    d.seek(i)                #=> #<Dir:0x401b3c40>
    d.read                   #=> ".."

;T;0;;;I"	seek;F;I"Dir;T;[o;;I"::Integer;T;I"	self;To;;I"“Returns the current position in *dir*. See also Dir#seek.

    d = Dir.new("testdir")
    d.tell   #=> 0
    d.read   #=> "."
    d.tell   #=> 12

;T;0;;;I"	tell;F;I"Dir;T;[o;;I" ;F;I"Integer;To; ;0;0;	I"Dir;T;
[ ;[ ;0;[ ;[ ;0;0o;;I":Returns the operating system's temporary file path.

;T;0;;;I"tmpdir;F;I"Dir;T;[o;;I" ;F;I"String;To;;I"UDir.mktmpdir creates a temporary directory.

The directory is created with 0700 permission. Application should not change
the permission to make the temporary directory accessible from other users.

The prefix and suffix of the name of the directory is specified by the
optional first argument, *prefix_suffix*.
*   If it is not specified or nil, "d" is used as the prefix and no suffix is
    used.
*   If it is a string, it is used as the prefix and no suffix is used.
*   If it is an array, first element is used as the prefix and second element
    is used as a suffix.


    Dir.mktmpdir {|dir| dir is ".../d..." }
    Dir.mktmpdir("foo") {|dir| dir is ".../foo..." }
    Dir.mktmpdir(["foo", "bar"]) {|dir| dir is ".../foo...bar" }

The directory is created under Dir.tmpdir or the optional second argument
*tmpdir* if non-nil value is given.

    Dir.mktmpdir {|dir| dir is "#{Dir.tmpdir}/d..." }
    Dir.mktmpdir(nil, "/var/tmp") {|dir| dir is "/var/tmp/d..." }

If a block is given, it is yielded with the path of the directory. The
directory and its contents are removed using FileUtils.remove_entry before
Dir.mktmpdir returns. The value of the block is returned.

    Dir.mktmpdir {|dir|
      # use the directory...
      open("#{dir}/foo", "w") { something using the file }
    }

If a block is not given, The path of the directory is returned. In this case,
Dir.mktmpdir doesn't remove the directory.

    dir = Dir.mktmpdir
    begin
      # use the directory...
      open("#{dir}/foo", "w") { something using the file }
    ensure
      # remove the directory.
      FileUtils.remove_entry dir
    end

;T;0;;;I"mktmpdir;F;I"Dir;T;[o;;I"O?::String | [ ::String, ::String ] | nil, ?::String?, ?max_try: ::Integer?;T;I"String;To;;I"O?::String | [ ::String, ::String ] | nil, ?::String?, ?max_try: ::Integer?;T;I"X;Fo; ;I"ŽAn Encoding instance represents a character encoding usable in Ruby. It is
defined as a constant under the Encoding namespace. It has a name and
optionally, aliases:

    Encoding::ISO_8859_1.name
    #=> "ISO-8859-1"

    Encoding::ISO_8859_1.names
    #=> ["ISO-8859-1", "ISO8859-1"]

Ruby methods dealing with encodings return or accept Encoding instances as
arguments (when a method accepts an Encoding instance as an argument, it can
be passed an Encoding name or alias instead).

    "some string".encoding
    #=> #<Encoding:UTF-8>

    string = "some string".encode(Encoding::ISO_8859_1)
    #=> "some string"
    string.encoding
    #=> #<Encoding:ISO-8859-1>

    "some string".encode "ISO-8859-1"
    #=> "some string"

Encoding::ASCII_8BIT is a special encoding that is usually used for a byte
string, not a character string. But as the name insists, its characters in the
range of ASCII are considered as ASCII characters.  This is useful when you
use ASCII-8BIT characters with other ASCII compatible characters.

## Changing an encoding

The associated Encoding of a String can be changed in two different ways.

First, it is possible to set the Encoding of a string to a new Encoding
without changing the internal byte representation of the string, with
String#force_encoding. This is how you can tell Ruby the correct encoding of a
string.

    string
    #=> "R\xC3\xA9sum\xC3\xA9"
    string.encoding
    #=> #<Encoding:ISO-8859-1>
    string.force_encoding(Encoding::UTF_8)
    #=> "R\u00E9sum\u00E9"

Second, it is possible to transcode a string, i.e. translate its internal byte
representation to another encoding. Its associated encoding is also set to the
other encoding. See String#encode for the various forms of transcoding, and
the Encoding::Converter class for additional control over the transcoding
process.

    string
    #=> "R\u00E9sum\u00E9"
    string.encoding
    #=> #<Encoding:UTF-8>
    string = string.encode!(Encoding::ISO_8859_1)
    #=> "R\xE9sum\xE9"
    string.encoding
    #=> #<Encoding::ISO-8859-1>

## Script encoding

All Ruby script code has an associated Encoding which any String literal
created in the source code will be associated to.

The default script encoding is Encoding::UTF_8 after v2.0, but it can be
changed by a magic comment on the first line of the source code file (or
second line, if there is a shebang line on the first). The comment must
contain the word `coding` or `encoding`, followed by a colon, space and the
Encoding name or alias:

    # encoding: UTF-8

    "some string".encoding
    #=> #<Encoding:UTF-8>

The `__ENCODING__` keyword returns the script encoding of the file which the
keyword is written:

    # encoding: ISO-8859-1

    __ENCODING__
    #=> #<Encoding:ISO-8859-1>

`ruby -K` will change the default locale encoding, but this is not
recommended. Ruby source files should declare its script encoding by a magic
comment even when they only depend on US-ASCII strings or regular expressions.

## Locale encoding

The default encoding of the environment. Usually derived from locale.

see Encoding.locale_charmap, Encoding.find('locale')

## Filesystem encoding

The default encoding of strings from the filesystem of the environment. This
is used for strings of file names or paths.

see Encoding.find('filesystem')

## External encoding

Each IO object has an external encoding which indicates the encoding that Ruby
will use to read its data. By default Ruby sets the external encoding of an IO
object to the default external encoding. The default external encoding is set
by locale encoding or the interpreter `-E` option. Encoding.default_external
returns the current value of the external encoding.

    ENV["LANG"]
    #=> "UTF-8"
    Encoding.default_external
    #=> #<Encoding:UTF-8>

    $ ruby -E ISO-8859-1 -e "p Encoding.default_external"
    #<Encoding:ISO-8859-1>

    $ LANG=C ruby -e 'p Encoding.default_external'
    #<Encoding:US-ASCII>

The default external encoding may also be set through
Encoding.default_external=, but you should not do this as strings created
before and after the change will have inconsistent encodings.  Instead use
`ruby -E` to invoke ruby with the correct external encoding.

When you know that the actual encoding of the data of an IO object is not the
default external encoding, you can reset its external encoding with
IO#set_encoding or set it at IO object creation (see IO.new options).

## Internal encoding

To process the data of an IO object which has an encoding different from its
external encoding, you can set its internal encoding. Ruby will use this
internal encoding to transcode the data when it is read from the IO object.

Conversely, when data is written to the IO object it is transcoded from the
internal encoding to the external encoding of the IO object.

The internal encoding of an IO object can be set with IO#set_encoding or at IO
object creation (see IO.new options).

The internal encoding is optional and when not set, the Ruby default internal
encoding is used. If not explicitly set this default internal encoding is
`nil` meaning that by default, no transcoding occurs.

The default internal encoding can be set with the interpreter option `-E`.
Encoding.default_internal returns the current internal encoding.

    $ ruby -e 'p Encoding.default_internal'
    nil

    $ ruby -E ISO-8859-1:UTF-8 -e "p [Encoding.default_external, \
      Encoding.default_internal]"
    [#<Encoding:ISO-8859-1>, #<Encoding:UTF-8>]

The default internal encoding may also be set through
Encoding.default_internal=, but you should not do this as strings created
before and after the change will have inconsistent encodings.  Instead use
`ruby -E` to invoke ruby with the correct internal encoding.

## IO encoding example

In the following example a UTF-8 encoded string "Ru00E9sumu00E9" is transcoded
for output to ISO-8859-1 encoding, then read back in and transcoded to UTF-8:

    string = "R\u00E9sum\u00E9"

    open("transcoded.txt", "w:ISO-8859-1") do |io|
      io.write(string)
    end

    puts "raw text:"
    p File.binread("transcoded.txt")
    puts

    open("transcoded.txt", "r:ISO-8859-1:UTF-8") do |io|
      puts "transcoded text:"
      p io.read
    end

While writing the file, the internal encoding is not specified as it is only
necessary for reading.  While reading the file both the internal and external
encoding must be specified to obtain the correct result.

    $ ruby t.rb
    raw text:
    "R\xE9sum\xE9"

    transcoded text:
    "R\u00E9sum\u00E9"

;T;0;	I"Encoding;T;
[ ;[ ;0;[ ;[ ;0;I"Object;To;;I" Returns the hash of available encoding alias and original encoding name.

    Encoding.aliases
    #=> {"BINARY"=>"ASCII-8BIT", "ASCII"=>"US-ASCII", "ANSI_X3.4-1968"=>"US-ASCII",
          "SJIS"=>"Windows-31J", "eucJP"=>"EUC-JP", "CP932"=>"Windows-31J"}

;T;0;;;I"aliases;F;I"Encoding;T;[o;;I" ;F;I"Hash[::String, ::String];To;;I"{Checks the compatibility of two objects.

If the objects are both strings they are compatible when they are
concatenatable.  The encoding of the concatenated string will be returned if
they are compatible, nil if they are not.

    Encoding.compatible?("\xa1".force_encoding("iso-8859-1"), "b")
    #=> #<Encoding:ISO-8859-1>

    Encoding.compatible?(
      "\xa1".force_encoding("iso-8859-1"),
      "\xa1\xa1".force_encoding("euc-jp"))
    #=> nil

If the objects are non-strings their encodings are compatible when they have
an encoding and:
*   Either encoding is US-ASCII compatible
*   One of the encodings is a 7-bit encoding

;T;0;;;I"compatible?;F;I"Encoding;T;[o;;I"untyped obj1, untyped obj2;T;I"Encoding?;To;;I"ÂReturns default external encoding.

The default external encoding is used by default for strings created from the
following locations:

*   CSV
*   File data read from disk
*   SDBM
*   StringIO
*   Zlib::GzipReader
*   Zlib::GzipWriter
*   String#inspect
*   Regexp#inspect


While strings created from these locations will have this encoding, the
encoding may not be valid.  Be sure to check String#valid_encoding?.

File data written to disk will be transcoded to the default external encoding
when written, if default_internal is not nil.

The default external encoding is initialized by the -E option. If -E isn't
set, it is initialized to UTF-8 on Windows and the locale on other operating
systems.

;T;0;;;I"default_external;F;I"Encoding;T;[o;;I" ;F;I"Encoding;To;;I"ŒSets default external encoding.  You should not set Encoding::default_external
in ruby code as strings created before changing the value may have a different
encoding from strings created after the value was changed., instead you should
use `ruby -E` to invoke ruby with the correct default_external.

See Encoding::default_external for information on how the default external
encoding is used.

;T;0;;;I"default_external=;F;I"Encoding;T;[o;;I"::String arg0;T;I"String;To;;I"::Encoding arg0;T;I"Encoding;To;;I"ìReturns default internal encoding.  Strings will be transcoded to the default
internal encoding in the following places if the default internal encoding is
not nil:

*   CSV
*   Etc.sysconfdir and Etc.systmpdir
*   File data read from disk
*   File names from Dir
*   Integer#chr
*   String#inspect and Regexp#inspect
*   Strings returned from Readline
*   Strings returned from SDBM
*   Time#zone
*   Values from ENV
*   Values in ARGV including $PROGRAM_NAME


Additionally String#encode and String#encode! use the default internal
encoding if no encoding is given.

The script encoding (__ENCODING__), not default_internal, is used as the
encoding of created strings.

Encoding::default_internal is initialized with -E option or nil otherwise.

;T;0;;;I"default_internal;F;I"Encoding;T;[o;;I" ;F;I"Encoding?;To;;I"¶Sets default internal encoding or removes default internal encoding when
passed nil.  You should not set Encoding::default_internal in ruby code as
strings created before changing the value may have a different encoding from
strings created after the change.  Instead you should use `ruby -E` to invoke
ruby with the correct default_internal.

See Encoding::default_internal for information on how the default internal
encoding is used.

;T;0;;;I"default_internal=;F;I"Encoding;T;[o;;I"::String arg0;T;I"String?;To;;I"::Encoding arg0;T;I"Encoding?;To;;I"nil arg0;T;I"nil;To;;I"GSearch the encoding with specified *name*. *name* should be a string.

    Encoding.find("US-ASCII")  #=> #<Encoding:US-ASCII>

Names which this method accept are encoding names and aliases including
following special aliases

"external"
:   default external encoding
"internal"
:   default internal encoding
"locale"
:   locale encoding
"filesystem"
:   filesystem encoding


An ArgumentError is raised when no encoding with *name*. Only
`Encoding.find("internal")` however returns nil when no encoding named
"internal", in other words, when Ruby has no default internal encoding.

;T;0;;;I"	find;F;I"Encoding;T;[o;;I"::String | ::Encoding arg0;T;I"Encoding;To;;I"]Returns the list of loaded encodings.

    Encoding.list
    #=> [#<Encoding:ASCII-8BIT>, #<Encoding:UTF-8>,
          #<Encoding:ISO-2022-JP (dummy)>]

    Encoding.find("US-ASCII")
    #=> #<Encoding:US-ASCII>

    Encoding.list
    #=> [#<Encoding:ASCII-8BIT>, #<Encoding:UTF-8>,
          #<Encoding:US-ASCII>, #<Encoding:ISO-2022-JP (dummy)>]

;T;0;;;I"	list;F;I"Encoding;T;[o;;I" ;F;I"Array[::Encoding];To;;I"áReturns the list of available encoding names.

    Encoding.name_list
    #=> ["US-ASCII", "ASCII-8BIT", "UTF-8",
          "ISO-8859-1", "Shift_JIS", "EUC-JP",
          "Windows-31J",
          "BINARY", "CP932", "eucJP"]

;T;0;;;I"name_list;F;I"Encoding;T;[o;;I" ;F;I"Array[::String];To;;I"’Returns whether ASCII-compatible or not.

    Encoding::UTF_8.ascii_compatible?     #=> true
    Encoding::UTF_16BE.ascii_compatible?  #=> false

;T;0;;;I"ascii_compatible?;F;I"Encoding;T;[o;;I" ;F;I"	bool;To;;I"Returns true for dummy encodings. A dummy encoding is an encoding for which
character handling is not properly implemented. It is used for stateful
encodings.

    Encoding::ISO_2022_JP.dummy?       #=> true
    Encoding::UTF_8.dummy?             #=> false

;T;0;;;I"dummy?;F;I"Encoding;T;[o;;I" ;F;I"	bool;To;;I"ÄReturns a string which represents the encoding for programmers.

    Encoding::UTF_8.inspect       #=> "#<Encoding:UTF-8>"
    Encoding::ISO_2022_JP.inspect #=> "#<Encoding:ISO-2022-JP (dummy)>"

;T;0;;;I"inspect;F;I"Encoding;T;[o;;I" ;F;I"String;To;;I"SReturns the name of the encoding.

    Encoding::UTF_8.name      #=> "UTF-8"

;T;0;;;I"	name;F;I"Encoding;T;[o;;I" ;F;I"String;To;;I"•Returns the list of name and aliases of the encoding.

    Encoding::WINDOWS_31J.names  #=> ["Windows-31J", "CP932", "csWindows31J", "SJIS", "PCK"]

;T;0;;;I"
names;F;I"Encoding;T;[o;;I" ;F;I"Array[::String];To;;I"¹Returns a replicated encoding of *enc* whose name is *name*. The new encoding
should have the same byte structure of *enc*. If *name* is used by another
encoding, raise ArgumentError.

;T;0;;;I"replicate;F;I"Encoding;T;[o;;I"::String name;T;I"Encoding;To;;I"SReturns the name of the encoding.

    Encoding::UTF_8.name      #=> "UTF-8"

;T;0;;;I"	to_s;F;I"Encoding;T;[o;;I" ;F;I"String;To; ;I"!Encoding conversion class.

;T;0;	I"Encoding::Converter;T;
[ ;[ ;0;[ ;[ ;0;I"Object;To;;I"^Returns the corresponding ASCII compatible encoding.

Returns nil if the argument is an ASCII compatible encoding.

"corresponding ASCII compatible encoding" is an ASCII compatible encoding
which can represents exactly the same characters as the given ASCII
incompatible encoding. So, no conversion undefined error occurs when
converting between the two encodings.

    Encoding::Converter.asciicompat_encoding("ISO-2022-JP") #=> #<Encoding:stateless-ISO-2022-JP>
    Encoding::Converter.asciicompat_encoding("UTF-16BE") #=> #<Encoding:UTF-8>
    Encoding::Converter.asciicompat_encoding("UTF-8") #=> nil

;T;0;;;I"asciicompat_encoding;F;I"Encoding::Converter;T;[o;;I"(::Encoding::Converter::encoding enc;T;I"Encoding?;To;;I"MReturns a conversion path.

    p Encoding::Converter.search_convpath("ISO-8859-1", "EUC-JP")
    #=> [[#<Encoding:ISO-8859-1>, #<Encoding:UTF-8>],
    #    [#<Encoding:UTF-8>, #<Encoding:EUC-JP>]]

    p Encoding::Converter.search_convpath("ISO-8859-1", "EUC-JP", universal_newline: true)
    or
    p Encoding::Converter.search_convpath("ISO-8859-1", "EUC-JP", newline: :universal)
    #=> [[#<Encoding:ISO-8859-1>, #<Encoding:UTF-8>],
    #    [#<Encoding:UTF-8>, #<Encoding:EUC-JP>],
    #    "universal_newline"]

    p Encoding::Converter.search_convpath("ISO-8859-1", "UTF-32BE", universal_newline: true)
    or
    p Encoding::Converter.search_convpath("ISO-8859-1", "UTF-32BE", newline: :universal)
    #=> [[#<Encoding:ISO-8859-1>, #<Encoding:UTF-8>],
    #    "universal_newline",
    #    [#<Encoding:UTF-8>, #<Encoding:UTF-32BE>]]

;T;0;;;I"search_convpath;F;I"Encoding::Converter;T;[o;;I"Î::Encoding::Converter::encoding source, ::Encoding::Converter::encoding destination, ?newline: :universal | :crlf | :cr, ?universal_newline: bool, ?crlf_newline: bool, ?cr_newline: bool, ?xml: :text | :attr;T;I")Encoding::Converter::conversion_path;To;;I" ;T;0;;;I"==;F;I"Encoding::Converter;T;[o;;I"	self;T;I"	bool;To;;I"ÃConvert source_string and return destination_string.

source_string is assumed as a part of source. i.e.  :partial_input=>true is
specified internally. finish method should be used last.

    ec = Encoding::Converter.new("utf-8", "euc-jp")
    puts ec.convert("\u3042").dump     #=> "\xA4\xA2"
    puts ec.finish.dump                #=> ""

    ec = Encoding::Converter.new("euc-jp", "utf-8")
    puts ec.convert("\xA4").dump       #=> ""
    puts ec.convert("\xA2").dump       #=> "\xE3\x81\x82"
    puts ec.finish.dump                #=> ""

    ec = Encoding::Converter.new("utf-8", "iso-2022-jp")
    puts ec.convert("\xE3").dump       #=> "".force_encoding("ISO-2022-JP")
    puts ec.convert("\x81").dump       #=> "".force_encoding("ISO-2022-JP")
    puts ec.convert("\x82").dump       #=> "\e$B$\"".force_encoding("ISO-2022-JP")
    puts ec.finish.dump                #=> "\e(B".force_encoding("ISO-2022-JP")

If a conversion error occur, Encoding::UndefinedConversionError or
Encoding::InvalidByteSequenceError is raised. Encoding::Converter#convert
doesn't supply methods to recover or restart from these exceptions. When you
want to handle these conversion errors, use
Encoding::Converter#primitive_convert.

;T;0;;;I"convert;F;I"Encoding::Converter;T;[o;;I"::String source;T;I"String;To;;I"TReturns the conversion path of ec.

The result is an array of conversions.

    ec = Encoding::Converter.new("ISO-8859-1", "EUC-JP", crlf_newline: true)
    p ec.convpath
    #=> [[#<Encoding:ISO-8859-1>, #<Encoding:UTF-8>],
    #    [#<Encoding:UTF-8>, #<Encoding:EUC-JP>],
    #    "crlf_newline"]

Each element of the array is a pair of encodings or a string. A pair means an
encoding conversion. A string means a decorator.

In the above example, [#<Encoding:ISO-8859-1>, #<Encoding:UTF-8>] means a
converter from ISO-8859-1 to UTF-8. "crlf_newline" means newline converter
from LF to CRLF.

;T;0;;;I"convpath;F;I"Encoding::Converter;T;[o;;I" ;F;I")Encoding::Converter::conversion_path;To;;I">Returns the destination encoding as an Encoding object.

;T;0;;;I"destination_encoding;F;I"Encoding::Converter;T;[o;;I" ;F;I"Encoding;To;;I"ÜFinishes the converter. It returns the last part of the converted string.

    ec = Encoding::Converter.new("utf-8", "iso-2022-jp")
    p ec.convert("\u3042")     #=> "\e$B$\""
    p ec.finish                #=> "\e(B"

;T;0;;;I"finish;F;I"Encoding::Converter;T;[o;;I" ;F;I"String;To;;I"Inserts string into the encoding converter. The string will be converted to
the destination encoding and output on later conversions.

If the destination encoding is stateful, string is converted according to the
state and the state is updated.

This method should be used only when a conversion error occurs.

    ec = Encoding::Converter.new("utf-8", "iso-8859-1")
    src = "HIRAGANA LETTER A is \u{3042}."
    dst = ""
    p ec.primitive_convert(src, dst)    #=> :undefined_conversion
    puts "[#{dst.dump}, #{src.dump}]"   #=> ["HIRAGANA LETTER A is ", "."]
    ec.insert_output("<err>")
    p ec.primitive_convert(src, dst)    #=> :finished
    puts "[#{dst.dump}, #{src.dump}]"   #=> ["HIRAGANA LETTER A is <err>.", ""]

    ec = Encoding::Converter.new("utf-8", "iso-2022-jp")
    src = "\u{306F 3041 3068 2661 3002}" # U+2661 is not representable in iso-2022-jp
    dst = ""
    p ec.primitive_convert(src, dst)    #=> :undefined_conversion
    puts "[#{dst.dump}, #{src.dump}]"   #=> ["\e$B$O$!$H".force_encoding("ISO-2022-JP"), "\xE3\x80\x82"]
    ec.insert_output "?"                # state change required to output "?".
    p ec.primitive_convert(src, dst)    #=> :finished
    puts "[#{dst.dump}, #{src.dump}]"   #=> ["\e$B$O$!$H\e(B?\e$B!#\e(B".force_encoding("ISO-2022-JP"), ""]

;T;0;;;I"insert_output;F;I"Encoding::Converter;T;[o;;I"::String;T;I"nil;To;;I"¥Returns a printable version of *ec*

    ec = Encoding::Converter.new("iso-8859-1", "utf-8")
    puts ec.inspect    #=> #<Encoding::Converter: ISO-8859-1 to UTF-8>

;T;0;;;I"inspect;F;I"Encoding::Converter;T;[o;;I" ;F;I"String;To;;I"ÌReturns an exception object for the last conversion. Returns nil if the last
conversion did not produce an error.

"error" means that Encoding::InvalidByteSequenceError and
Encoding::UndefinedConversionError for Encoding::Converter#convert and
:invalid_byte_sequence, :incomplete_input and :undefined_conversion for
Encoding::Converter#primitive_convert.

    ec = Encoding::Converter.new("utf-8", "iso-8859-1")
    p ec.primitive_convert(src="\xf1abcd", dst="")       #=> :invalid_byte_sequence
    p ec.last_error      #=> #<Encoding::InvalidByteSequenceError: "\xF1" followed by "a" on UTF-8>
    p ec.primitive_convert(src, dst, nil, 1)             #=> :destination_buffer_full
    p ec.last_error      #=> nil

;T;0;;;I"last_error;F;I"Encoding::Converter;T;[o;;I" ;F;I"(Encoding::InvalidByteSequenceError?;To;;I" ;F;I"(Encoding::UndefinedConversionError?;To;;I"¸possible opt elements:
    hash form:
      :partial_input => true           # source buffer may be part of larger source
      :after_output => true            # stop conversion after output before input
    integer form:
      Encoding::Converter::PARTIAL_INPUT
      Encoding::Converter::AFTER_OUTPUT

possible results:
    :invalid_byte_sequence
    :incomplete_input
    :undefined_conversion
    :after_output
    :destination_buffer_full
    :source_buffer_empty
    :finished

primitive_convert converts source_buffer into destination_buffer.

source_buffer should be a string or nil. nil means an empty string.

destination_buffer should be a string.

destination_byteoffset should be an integer or nil. nil means the end of
destination_buffer. If it is omitted, nil is assumed.

destination_bytesize should be an integer or nil. nil means unlimited. If it
is omitted, nil is assumed.

opt should be nil, a hash or an integer. nil means no flags. If it is omitted,
nil is assumed.

primitive_convert converts the content of source_buffer from beginning and
store the result into destination_buffer.

destination_byteoffset and destination_bytesize specify the region which the
converted result is stored. destination_byteoffset specifies the start
position in destination_buffer in bytes. If destination_byteoffset is nil,
destination_buffer.bytesize is used for appending the result.
destination_bytesize specifies maximum number of bytes. If
destination_bytesize is nil, destination size is unlimited. After conversion,
destination_buffer is resized to destination_byteoffset + actually produced
number of bytes. Also destination_buffer's encoding is set to
destination_encoding.

primitive_convert drops the converted part of source_buffer. the dropped part
is converted in destination_buffer or buffered in Encoding::Converter object.

primitive_convert stops conversion when one of following condition met.
*   invalid byte sequence found in source buffer (:invalid_byte_sequence)
    `primitive_errinfo` and `last_error` methods returns the detail of the
    error.
*   unexpected end of source buffer (:incomplete_input) this occur only when
    :partial_input is not specified. `primitive_errinfo` and `last_error`
    methods returns the detail of the error.
*   character not representable in output encoding (:undefined_conversion)
    `primitive_errinfo` and `last_error` methods returns the detail of the
    error.
*   after some output is generated, before input is done (:after_output) this
    occur only when :after_output is specified.
*   destination buffer is full (:destination_buffer_full) this occur only when
    destination_bytesize is non-nil.
*   source buffer is empty (:source_buffer_empty) this occur only when
    :partial_input is specified.
*   conversion is finished (:finished)


example:
    ec = Encoding::Converter.new("UTF-8", "UTF-16BE")
    ret = ec.primitive_convert(src="pi", dst="", nil, 100)
    p [ret, src, dst] #=> [:finished, "", "\x00p\x00i"]

    ec = Encoding::Converter.new("UTF-8", "UTF-16BE")
    ret = ec.primitive_convert(src="pi", dst="", nil, 1)
    p [ret, src, dst] #=> [:destination_buffer_full, "i", "\x00"]
    ret = ec.primitive_convert(src, dst="", nil, 1)
    p [ret, src, dst] #=> [:destination_buffer_full, "", "p"]
    ret = ec.primitive_convert(src, dst="", nil, 1)
    p [ret, src, dst] #=> [:destination_buffer_full, "", "\x00"]
    ret = ec.primitive_convert(src, dst="", nil, 1)
    p [ret, src, dst] #=> [:finished, "", "i"]

;T;0;;;I"primitive_convert;F;I"Encoding::Converter;T;[o;;I"—::String? source, ::String destination, ?::Integer? destination_byteoffset, ?::Integer? destination_bytesize, ?partial_input: bool, ?after_output: bool;T;I"(Encoding::Converter::convert_result;To;;I"|::String? source, ::String destination, ?::Integer? destination_byteoffset, ?::Integer? destination_bytesize, ?::Integer opt;T;I"(Encoding::Converter::convert_result;To;;I"nprimitive_errinfo returns important information regarding the last error as a
5-element array:

    [result, enc1, enc2, error_bytes, readagain_bytes]

result is the last result of primitive_convert.

Other elements are only meaningful when result is :invalid_byte_sequence,
:incomplete_input or :undefined_conversion.

enc1 and enc2 indicate a conversion step as a pair of strings. For example, a
converter from EUC-JP to ISO-8859-1 converts a string as follows: EUC-JP ->
UTF-8 -> ISO-8859-1. So [enc1, enc2] is either ["EUC-JP", "UTF-8"] or
["UTF-8", "ISO-8859-1"].

error_bytes and readagain_bytes indicate the byte sequences which caused the
error. error_bytes is discarded portion. readagain_bytes is buffered portion
which is read again on next conversion.

Example:

    # \xff is invalid as EUC-JP.
    ec = Encoding::Converter.new("EUC-JP", "Shift_JIS")
    ec.primitive_convert(src="\xff", dst="", nil, 10)
    p ec.primitive_errinfo
    #=> [:invalid_byte_sequence, "EUC-JP", "Shift_JIS", "\xFF", ""]

    # HIRAGANA LETTER A (\xa4\xa2 in EUC-JP) is not representable in ISO-8859-1.
    # Since this error is occur in UTF-8 to ISO-8859-1 conversion,
    # error_bytes is HIRAGANA LETTER A in UTF-8 (\xE3\x81\x82).
    ec = Encoding::Converter.new("EUC-JP", "ISO-8859-1")
    ec.primitive_convert(src="\xa4\xa2", dst="", nil, 10)
    p ec.primitive_errinfo
    #=> [:undefined_conversion, "UTF-8", "ISO-8859-1", "\xE3\x81\x82", ""]

    # partial character is invalid
    ec = Encoding::Converter.new("EUC-JP", "ISO-8859-1")
    ec.primitive_convert(src="\xa4", dst="", nil, 10)
    p ec.primitive_errinfo
    #=> [:incomplete_input, "EUC-JP", "UTF-8", "\xA4", ""]

    # Encoding::Converter::PARTIAL_INPUT prevents invalid errors by
    # partial characters.
    ec = Encoding::Converter.new("EUC-JP", "ISO-8859-1")
    ec.primitive_convert(src="\xa4", dst="", nil, 10, Encoding::Converter::PARTIAL_INPUT)
    p ec.primitive_errinfo
    #=> [:source_buffer_empty, nil, nil, nil, nil]

    # \xd8\x00\x00@ is invalid as UTF-16BE because
    # no low surrogate after high surrogate (\xd8\x00).
    # It is detected by 3rd byte (\00) which is part of next character.
    # So the high surrogate (\xd8\x00) is discarded and
    # the 3rd byte is read again later.
    # Since the byte is buffered in ec, it is dropped from src.
    ec = Encoding::Converter.new("UTF-16BE", "UTF-8")
    ec.primitive_convert(src="\xd8\x00\x00@", dst="", nil, 10)
    p ec.primitive_errinfo
    #=> [:invalid_byte_sequence, "UTF-16BE", "UTF-8", "\xD8\x00", "\x00"]
    p src
    #=> "@"

    # Similar to UTF-16BE, \x00\xd8@\x00 is invalid as UTF-16LE.
    # The problem is detected by 4th byte.
    ec = Encoding::Converter.new("UTF-16LE", "UTF-8")
    ec.primitive_convert(src="\x00\xd8@\x00", dst="", nil, 10)
    p ec.primitive_errinfo
    #=> [:invalid_byte_sequence, "UTF-16LE", "UTF-8", "\x00\xD8", "@\x00"]
    p src
    #=> ""

;T;0;;;I"primitive_errinfo;F;I"Encoding::Converter;T;[o;;I" ;F;I"Z[ ::Encoding::Converter::convert_result, ::String?, ::String?, ::String?, ::String? ];To;;I"ëPut back the bytes which will be converted.

The bytes are caused by invalid_byte_sequence error. When
invalid_byte_sequence error, some bytes are discarded and some bytes are
buffered to be converted later. The latter bytes can be put back. It can be
observed by Encoding::InvalidByteSequenceError#readagain_bytes and
Encoding::Converter#primitive_errinfo.

    ec = Encoding::Converter.new("utf-16le", "iso-8859-1")
    src = "\x00\xd8\x61\x00"
    dst = ""
    p ec.primitive_convert(src, dst)   #=> :invalid_byte_sequence
    p ec.primitive_errinfo     #=> [:invalid_byte_sequence, "UTF-16LE", "UTF-8", "\x00\xD8", "a\x00"]
    p ec.putback               #=> "a\x00"
    p ec.putback               #=> ""          # no more bytes to put back

;T;0;;;I"putback;F;I"Encoding::Converter;T;[o;;I"?::Integer max_numbytes;T;I"String;To;;I"ÓReturns the replacement string.

    ec = Encoding::Converter.new("euc-jp", "us-ascii")
    p ec.replacement    #=> "?"

    ec = Encoding::Converter.new("euc-jp", "utf-8")
    p ec.replacement    #=> "\uFFFD"

;T;0;;;I"replacement;F;I"Encoding::Converter;T;[o;;I" ;F;I"String;To;;I"¾Sets the replacement string.

    ec = Encoding::Converter.new("utf-8", "us-ascii", :undef => :replace)
    ec.replacement = "<undef>"
    p ec.convert("a \u3042 b")      #=> "a <undef> b"

;T;0;;;I"replacement=;F;I"Encoding::Converter;T;[o;;I"::String str;T;I"String;To;;I"9Returns the source encoding as an Encoding object.

;T;0;;;I"source_encoding;F;I"Encoding::Converter;T;[o;;I" ;F;I"Encoding;To;;I"¾possible options elements:
    hash form:
      :invalid => nil            # raise error on invalid byte sequence (default)
      :invalid => :replace       # replace invalid byte sequence
      :undef => nil              # raise error on undefined conversion (default)
      :undef => :replace         # replace undefined conversion
      :replace => string         # replacement string ("?" or "\uFFFD" if not specified)
      :newline => :universal     # decorator for converting CRLF and CR to LF
      :newline => :crlf          # decorator for converting LF to CRLF
      :newline => :cr            # decorator for converting LF to CR
      :universal_newline => true # decorator for converting CRLF and CR to LF
      :crlf_newline => true      # decorator for converting LF to CRLF
      :cr_newline => true        # decorator for converting LF to CR
      :xml => :text              # escape as XML CharData.
      :xml => :attr              # escape as XML AttValue
    integer form:
      Encoding::Converter::INVALID_REPLACE
      Encoding::Converter::UNDEF_REPLACE
      Encoding::Converter::UNDEF_HEX_CHARREF
      Encoding::Converter::UNIVERSAL_NEWLINE_DECORATOR
      Encoding::Converter::CRLF_NEWLINE_DECORATOR
      Encoding::Converter::CR_NEWLINE_DECORATOR
      Encoding::Converter::XML_TEXT_DECORATOR
      Encoding::Converter::XML_ATTR_CONTENT_DECORATOR
      Encoding::Converter::XML_ATTR_QUOTE_DECORATOR

Encoding::Converter.new creates an instance of Encoding::Converter.

Source_encoding and destination_encoding should be a string or Encoding
object.

opt should be nil, a hash or an integer.

convpath should be an array. convpath may contain
*   two-element arrays which contain encodings or encoding names, or
*   strings representing decorator names.


Encoding::Converter.new optionally takes an option. The option should be a
hash or an integer. The option hash can contain :invalid => nil, etc. The
option integer should be logical-or of constants such as
Encoding::Converter::INVALID_REPLACE, etc.

:invalid => nil
:   Raise error on invalid byte sequence.  This is a default behavior.
:invalid => :replace
:   Replace invalid byte sequence by replacement string.
:undef => nil
:   Raise an error if a character in source_encoding is not defined in
    destination_encoding. This is a default behavior.
:undef => :replace
:   Replace undefined character in destination_encoding with replacement
    string.
:replace => string
:   Specify the replacement string. If not specified, "uFFFD" is used for
    Unicode encodings and "?" for others.
:universal_newline => true
:   Convert CRLF and CR to LF.
:crlf_newline => true
:   Convert LF to CRLF.
:cr_newline => true
:   Convert LF to CR.
:xml => :text
:   Escape as XML CharData. This form can be used as an HTML 4.0 #PCDATA.
    *   '&' -> '&amp;'
    *   '<' -> '&lt;'
    *   '>' -> '&gt;'
    *   undefined characters in destination_encoding -> hexadecimal CharRef
        such as &#xHH;

:xml => :attr
:   Escape as XML AttValue. The converted result is quoted as "...". This form
    can be used as an HTML 4.0 attribute value.
    *   '&' -> '&amp;'
    *   '<' -> '&lt;'
    *   '>' -> '&gt;'
    *   '"' -> '&quot;'
    *   undefined characters in destination_encoding -> hexadecimal CharRef
        such as &#xHH;



Examples:
    # UTF-16BE to UTF-8
    ec = Encoding::Converter.new("UTF-16BE", "UTF-8")

    # Usually, decorators such as newline conversion are inserted last.
    ec = Encoding::Converter.new("UTF-16BE", "UTF-8", :universal_newline => true)
    p ec.convpath #=> [[#<Encoding:UTF-16BE>, #<Encoding:UTF-8>],
                  #    "universal_newline"]

    # But, if the last encoding is ASCII incompatible,
    # decorators are inserted before the last conversion.
    ec = Encoding::Converter.new("UTF-8", "UTF-16BE", :crlf_newline => true)
    p ec.convpath #=> ["crlf_newline",
                  #    [#<Encoding:UTF-8>, #<Encoding:UTF-16BE>]]

    # Conversion path can be specified directly.
    ec = Encoding::Converter.new(["universal_newline", ["EUC-JP", "UTF-8"], ["UTF-8", "UTF-16BE"]])
    p ec.convpath #=> ["universal_newline",
                  #    [#<Encoding:EUC-JP>, #<Encoding:UTF-8>],
                  #    [#<Encoding:UTF-8>, #<Encoding:UTF-16BE>]]

;T;0;;;I"initialize;F;I"Encoding::Converter;T;[	o;;I"X::Encoding::Converter::encoding source, ::Encoding::Converter::encoding destination;T;I"	void;To;;I"::Encoding::Converter::encoding source, ::Encoding::Converter::encoding destination, ?invalid: :replace | nil, ?undef: :replace | nil, ?replace: ::String, ?newline: :universal | :crlf | :cr, ?universal_newline: bool, ?crlf_newline: bool, ?cr_newline: bool, ?xml: :text | :attr;T;I"	void;To;;I"h::Encoding::Converter::encoding source, ::Encoding::Converter::encoding destination, ::Integer opts;T;I"	void;To;;I"4::Encoding::Converter::conversion_path convpath;T;I"	void;To; ;I"oRaised by Encoding and String methods when the source encoding is incompatible
with the target encoding.

;T;0;	I"!Encoding::CompatibilityError;T;
[ ;[ ;0;[ ;[ ;0;I"EncodingError;To; ;I"fRaised by transcoding methods when a named encoding does not correspond with a
known converter.

;T;0;	I"%Encoding::ConverterNotFoundError;T;
[ ;[ ;0;[ ;[ ;0;I"EncodingError;To; ;I"ŽRaised by Encoding and String methods when the string being transcoded
contains a byte invalid for the either the source or target encoding.

;T;0;	I"'Encoding::InvalidByteSequenceError;T;
[ ;[ ;0;[ ;[ ;0;I"EncodingError;To;;I">Returns the destination encoding as an encoding object.

;T;0;;;I"destination_encoding;F;I"'Encoding::InvalidByteSequenceError;T;[o;;I" ;F;I"Encoding;To;;I"9Returns the destination encoding name as a string.

;T;0;;;I"destination_encoding_name;F;I"'Encoding::InvalidByteSequenceError;T;[o;;I" ;F;I"String;To;;I"¯Returns the discarded bytes when Encoding::InvalidByteSequenceError occurs.

    ec = Encoding::Converter.new("EUC-JP", "ISO-8859-1")
    begin
      ec.convert("abc\xA1\xFFdef")
    rescue Encoding::InvalidByteSequenceError
      p $!      #=> #<Encoding::InvalidByteSequenceError: "\xA1" followed by "\xFF" on EUC-JP>
      puts $!.error_bytes.dump          #=> "\xA1"
      puts $!.readagain_bytes.dump      #=> "\xFF"
    end

;T;0;;;I"error_bytes;F;I"'Encoding::InvalidByteSequenceError;T;[o;;I" ;F;I"String;To;;I"bReturns true if the invalid byte sequence error is caused by premature end of
string.

    ec = Encoding::Converter.new("EUC-JP", "ISO-8859-1")

    begin
      ec.convert("abc\xA1z")
    rescue Encoding::InvalidByteSequenceError
      p $!      #=> #<Encoding::InvalidByteSequenceError: "\xA1" followed by "z" on EUC-JP>
      p $!.incomplete_input?    #=> false
    end

    begin
      ec.convert("abc\xA1")
      ec.finish
    rescue Encoding::InvalidByteSequenceError
      p $!      #=> #<Encoding::InvalidByteSequenceError: incomplete "\xA1" on EUC-JP>
      p $!.incomplete_input?    #=> true
    end

;T;0;;;I"incomplete_input?;F;I"'Encoding::InvalidByteSequenceError;T;[o;;I" ;F;I"	bool;To;;I"YReturns the bytes to be read again when Encoding::InvalidByteSequenceError
occurs.

;T;0;;;I"readagain_bytes;F;I"'Encoding::InvalidByteSequenceError;T;[o;;I" ;F;I"String;To;;I"ŒReturns the source encoding as an encoding object.

Note that the result may not be equal to the source encoding of the encoding
converter if the conversion has multiple steps.

    ec = Encoding::Converter.new("ISO-8859-1", "EUC-JP") # ISO-8859-1 -> UTF-8 -> EUC-JP
    begin
      ec.convert("\xa0") # NO-BREAK SPACE, which is available in UTF-8 but not in EUC-JP.
    rescue Encoding::UndefinedConversionError
      p $!.source_encoding              #=> #<Encoding:UTF-8>
      p $!.destination_encoding         #=> #<Encoding:EUC-JP>
      p $!.source_encoding_name         #=> "UTF-8"
      p $!.destination_encoding_name    #=> "EUC-JP"
    end

;T;0;;;I"source_encoding;F;I"'Encoding::InvalidByteSequenceError;T;[o;;I" ;F;I"Encoding;To;;I"4Returns the source encoding name as a string.

;T;0;;;I"source_encoding_name;F;I"'Encoding::InvalidByteSequenceError;T;[o;;I" ;F;I"String;To; ;I"PRaised by Encoding and String methods when a transcoding operation fails.

;T;0;	I"'Encoding::UndefinedConversionError;T;
[ ;[ ;0;[ ;[ ;0;I"EncodingError;To;;I">Returns the destination encoding as an encoding object.

;T;0;;;I"destination_encoding;F;I"'Encoding::UndefinedConversionError;T;[o;;I" ;F;I"Encoding;To;;I"9Returns the destination encoding name as a string.

;T;0;;;I"destination_encoding_name;F;I"'Encoding::UndefinedConversionError;T;[o;;I" ;F;I"String;To;;I"JReturns the one-character string which cause
Encoding::UndefinedConversionError.

    ec = Encoding::Converter.new("ISO-8859-1", "EUC-JP")
    begin
      ec.convert("\xa0")
    rescue Encoding::UndefinedConversionError
      puts $!.error_char.dump   #=> "\xC2\xA0"
      p $!.error_char.encoding  #=> #<Encoding:UTF-8>
    end

;T;0;;;I"error_char;F;I"'Encoding::UndefinedConversionError;T;[o;;I" ;F;I"String;To;;I"ŒReturns the source encoding as an encoding object.

Note that the result may not be equal to the source encoding of the encoding
converter if the conversion has multiple steps.

    ec = Encoding::Converter.new("ISO-8859-1", "EUC-JP") # ISO-8859-1 -> UTF-8 -> EUC-JP
    begin
      ec.convert("\xa0") # NO-BREAK SPACE, which is available in UTF-8 but not in EUC-JP.
    rescue Encoding::UndefinedConversionError
      p $!.source_encoding              #=> #<Encoding:UTF-8>
      p $!.destination_encoding         #=> #<Encoding:EUC-JP>
      p $!.source_encoding_name         #=> "UTF-8"
      p $!.destination_encoding_name    #=> "EUC-JP"
    end

;T;0;;;I"source_encoding;F;I"'Encoding::UndefinedConversionError;T;[o;;I" ;F;I"Encoding;To;;I"4Returns the source encoding name as a string.

;T;0;;;I"source_encoding_name;F;I"'Encoding::UndefinedConversionError;T;[o;;I" ;F;I"String;To;;I"¦## What's Here

Module Enumerable provides methods that are useful to a collection class for:
*   [Querying](#module-Enumerable-label-Methods+for+Querying)
*   [Fetching](#module-Enumerable-label-Methods+for+Fetching)
*   [Searching](#module-Enumerable-label-Methods+for+Searching)
*   [Sorting](#module-Enumerable-label-Methods+for+Sorting)
*   [Iterating](#module-Enumerable-label-Methods+for+Iterating)
*   [And more....](#module-Enumerable-label-Other+Methods)


### Methods for Querying

These methods return information about the Enumerable other than the elements
themselves:

#include?, #member?
:   Returns `true` if self == object, `false` otherwise.
#all?
:   Returns `true` if all elements meet a specified criterion; `false`
    otherwise.
#any?
:   Returns `true` if any element meets a specified criterion; `false`
    otherwise.
#none?
:   Returns `true` if no element meets a specified criterion; `false`
    otherwise.
#one?
:   Returns `true` if exactly one element meets a specified criterion; `false`
    otherwise.
#count
:   Returns the count of elements, based on an argument or block criterion, if
    given.
#tally
:   Returns a new Hash containing the counts of occurrences of each element.


### Methods for Fetching

These methods return entries from the Enumerable, without modifying it:

*Leading, trailing, or all elements*:
#entries, #to_a
:   Returns all elements.
#first
:   Returns the first element or leading elements.
#take
:   Returns a specified number of leading elements.
#drop
:   Returns a specified number of trailing elements.
#take_while
:   Returns leading elements as specified by the given block.
#drop_while
:   Returns trailing elements as specified by the given block.


*Minimum and maximum value elements*:
#min
:   Returns the elements whose values are smallest among the elements, as
    determined by `<=>` or a given block.
#max
:   Returns the elements whose values are largest among the elements, as
    determined by `<=>` or a given block.
#minmax
:   Returns a 2-element Array containing the smallest and largest elements.
#min_by
:   Returns the smallest element, as determined by the given block.
#max_by
:   Returns the largest element, as determined by the given block.
#minmax_by
:   Returns the smallest and largest elements, as determined by the given
    block.


*Groups, slices, and partitions*:
#group_by
:   Returns a Hash that partitions the elements into groups.
#partition
:   Returns elements partitioned into two new Arrays, as determined by the
    given block.
#slice_after
:   Returns a new Enumerator whose entries are a partition of `self`, based
    either on a given `object` or a given block.
#slice_before
:   Returns a new Enumerator whose entries are a partition of `self`, based
    either on a given `object` or a given block.
#slice_when
:   Returns a new Enumerator whose entries are a partition of `self` based on
    the given block.
#chunk
:   Returns elements organized into chunks as specified by the given block.
#chunk_while
:   Returns elements organized into chunks as specified by the given block.


### Methods for Searching and Filtering

These methods return elements that meet a specified criterion.

#find, #detect
:   Returns an element selected by the block.
#find_all, #filter, #select
:   Returns elements selected by the block.
#find_index
:   Returns the index of an element selected by a given object or block.
#reject
:   Returns elements not rejected by the block.
#uniq
:   Returns elements that are not duplicates.


### Methods for Sorting

These methods return elements in sorted order.

#sort
:   Returns the elements, sorted by `<=>` or the given block.
#sort_by
:   Returns the elements, sorted by the given block.


### Methods for Iterating

#each_entry
:   Calls the block with each successive element (slightly different from
    #each).
#each_with_index
:   Calls the block with each successive element and its index.
#each_with_object
:   Calls the block with each successive element and a given object.
#each_slice
:   Calls the block with successive non-overlapping slices.
#each_cons
:   Calls the block with successive overlapping slices. (different from
    #each_slice).
#reverse_each
:   Calls the block with each successive element, in reverse order.


### Other Methods

#map, #collect
:   Returns objects returned by the block.
#filter_map
:   Returns truthy objects returned by the block.
#flat_map, #collect_concat
:   Returns flattened objects returned by the block.
#grep
:   Returns elements selected by a given object or objects returned by a given
    block.
#grep_v
:   Returns elements selected by a given object or objects returned by a given
    block.
#reduce, #inject
:   Returns the object formed by combining all elements.
#sum
:   Returns the sum of the elements, using method +++.
#zip
:   Combines each element with elements from other enumerables; returns the
    n-tuples or calls the block with each.
#cycle
:   Calls the block with each element, cycling repeatedly.


## Usage

To use module Enumerable in a collection class:

*   Include it:

        include Enumerable

*   Implement method `#each` which must yield successive elements of the
    collection. The method will be called by almost any Enumerable method.


Example:

    class Foo
      include Enumerable
      def each
        yield 1
        yield 1, 2
        yield
      end
    end
    Foo.new.each_entry{ |element| p element }

Output:

    1
    [1, 2]
    nil

## Enumerable in Ruby Core Classes
Some Ruby classes include Enumerable:
*   Array
*   Dir
*   Hash
*   IO
*   Range
*   Set
*   Struct

Virtually all methods in Enumerable call method `#each` in the including
class:
*   `Hash#each` yields the next key-value pair as a 2-element Array.
*   `Struct#each` yields the next name-value pair as a 2-element Array.
*   For the other classes above, `#each` yields the next object from the
    collection.


## About the Examples
The example code snippets for the Enumerable methods:
*   Always show the use of one or more Array-like classes (often Array
    itself).
*   Sometimes show the use of a Hash-like class. For some methods, though, the
    usage would not make sense, and so it is not shown.  Example: #tally would
    find exactly one of each Hash entry.

;T;0;	I"Enumerable;T;
[ ;[ ;0;[ ;[ o;;I"Returns whether every element meets a given criterion.

With no argument and no block, returns whether every element is truthy:

    (1..4).all?           # => true
    %w[a b c d].all?      # => true
    [1, 2, nil].all?      # => false
    ['a','b', false].all? # => false
    [].all?               # => true

With argument `pattern` and no block, returns whether for each element
`element`, `pattern === element`:

    (1..4).all?(Integer)                 # => true
    (1..4).all?(Numeric)                 # => true
    (1..4).all?(Float)                   # => false
    %w[bar baz bat bam].all?(/ba/)       # => true
    %w[bar baz bat bam].all?(/bar/)      # => false
    %w[bar baz bat bam].all?('ba')       # => false
    {foo: 0, bar: 1, baz: 2}.all?(Array) # => true
    {foo: 0, bar: 1, baz: 2}.all?(Hash)  # => false
    [].all?(Integer)                     # => true

With a block given, returns whether the block returns a truthy value for every
element:

    (1..4).all? {|element| element < 5 }                    # => true
    (1..4).all? {|element| element < 4 }                    # => false
    {foo: 0, bar: 1, baz: 2}.all? {|key, value| value < 3 } # => true
    {foo: 0, bar: 1, baz: 2}.all? {|key, value| value < 2 } # => false

Related: #any?, #none? #one?.

;T;0;;;I"	all?;F;I"Enumerable;T;[o;;I" ;F;I"	bool;To;;I" ;F;I"	bool;To;;I"×Returns whether any element meets a given criterion.

With no argument and no block, returns whether any element is truthy:

    (1..4).any?          # => true
    %w[a b c d].any?     # => true
    [1, false, nil].any? # => true
    [].any?              # => false

With argument `pattern` and no block, returns whether for any element
`element`, `pattern === element`:

    [nil, false, 0].any?(Integer)        # => true
    [nil, false, 0].any?(Numeric)        # => true
    [nil, false, 0].any?(Float)          # => false
    %w[bar baz bat bam].any?(/m/)        # => true
    %w[bar baz bat bam].any?(/foo/)      # => false
    %w[bar baz bat bam].any?('ba')       # => false
    {foo: 0, bar: 1, baz: 2}.any?(Array) # => true
    {foo: 0, bar: 1, baz: 2}.any?(Hash)  # => false
    [].any?(Integer)                     # => false

With a block given, returns whether the block returns a truthy value for any
element:

    (1..4).any? {|element| element < 2 }                    # => true
    (1..4).any? {|element| element < 1 }                    # => false
    {foo: 0, bar: 1, baz: 2}.any? {|key, value| value < 1 } # => true
    {foo: 0, bar: 1, baz: 2}.any? {|key, value| value < 0 } # => false

Related: #all?, #none?, #one?.

;T;0;;;I"	any?;F;I"Enumerable;T;[o;;I" ;F;I"	bool;To;;I" ;F;I"	bool;To;;I"mReturns an array of objects returned by the block.

With a block given, calls the block with successive elements; returns an array
of the objects returned by the block:

    (0..4).map {|i| i*i }                               # => [0, 1, 4, 9, 16]
    {foo: 0, bar: 1, baz: 2}.map {|key, value| value*2} # => [0, 2, 4]

With no block given, returns an Enumerator.

;T;0;;;I"collect;F;I"Enumerable;T;[o;;I" ;F;I"Array[U];To;;I" ;F;I"'Enumerator[Elem, ::Array[untyped]];To;;I"Returns an array of flattened objects returned by the block.

With a block given, calls the block with successive elements; returns a
flattened array of objects returned by the block:

    [0, 1, 2, 3].flat_map {|element| -element }                    # => [0, -1, -2, -3]
    [0, 1, 2, 3].flat_map {|element| [element, -element] }         # => [0, 0, 1, -1, 2, -2, 3, -3]
    [[0, 1], [2, 3]].flat_map {|e| e + [100] }                     # => [0, 1, 100, 2, 3, 100]
    {foo: 0, bar: 1, baz: 2}.flat_map {|key, value| [key, value] } # => [:foo, 0, :bar, 1, :baz, 2]

With no block given, returns an Enumerator.

Alias: #collect_concat.

;T;0;;;I"collect_concat;F;I"Enumerable;T;[o;;I" ;F;I"Array[U];To;;I" ;F;I"'Enumerator[Elem, ::Array[untyped]];To;;I"¥Returns an array of all non-`nil` elements:

    a = [nil, 0, nil, 'a', false, nil, false, nil, 'a', nil, 0, nil]
    a.compact # => [0, "a", false, false, "a", 0]

;T;0;;;I"compact;F;I"Enumerable;T;[o;;I" ;F;I"Array[Elem];To;;I"€Returns the count of elements, based on an argument or block criterion, if
given.

With no argument and no block given, returns the number of elements:

    [0, 1, 2].count                # => 3
    {foo: 0, bar: 1, baz: 2}.count # => 3

With argument `object` given, returns the number of elements that are `==` to
`object`:

    [0, 1, 2, 1].count(1)           # => 2

With a block given, calls the block with each element and returns the number
of elements for which the block returns a truthy value:

    [0, 1, 2, 3].count {|element| element < 2}              # => 2
    {foo: 0, bar: 1, baz: 2}.count {|key, value| value < 2} # => 2

;T;0;;;I"
count;F;I"Enumerable;T;[o;;I" ;F;I"Integer;To;;I"	Elem;T;I"Integer;To;;I" ;F;I"Integer;To;;I"ÍWhen called with positive integer argument `n` and a block, calls the block
with each element, then does so again, until it has done so `n` times; returns
`nil`:

    a = []
    (1..4).cycle(3) {|element| a.push(element) } # => nil
    a # => [1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]
    a = []
    ('a'..'d').cycle(2) {|element| a.push(element) }
    a # => ["a", "b", "c", "d", "a", "b", "c", "d"]
    a = []
    {foo: 0, bar: 1, baz: 2}.cycle(2) {|element| a.push(element) }
    a # => [[:foo, 0], [:bar, 1], [:baz, 2], [:foo, 0], [:bar, 1], [:baz, 2]]

If count is zero or negative, does not call the block.

When called with a block and `n` is `nil`, cycles forever.

When no block is given, returns an Enumerator.

;T;0;;;I"
cycle;F;I"Enumerable;T;[o;;I"?::Integer n;T;I"NilClass;To;;I"?::Integer n;T;I"!Enumerator[Elem, ::NilClass];To;;I"™Returns the first element for which the block returns a truthy value.

With a block given, calls the block with successive elements of the
collection; returns the first element for which the block returns a truthy
value:

    (0..9).find {|element| element > 2}                # => 3

If no such element is found, calls `if_none_proc` and returns its return
value.

    (0..9).find(proc {false}) {|element| element > 12} # => false
    {foo: 0, bar: 1, baz: 2}.find {|key, value| key.start_with?('b') }            # => [:bar, 1]
    {foo: 0, bar: 1, baz: 2}.find(proc {[]}) {|key, value| key.start_with?('c') } # => []

With no block given, returns an Enumerator.

;T;0;;;I"detect;F;I"Enumerable;T;[o;;I"?::Proc ifnone;T;I"
Elem?;To;;I"?::Proc ifnone;T;I"Enumerator[Elem, Elem?];To;;I"DFor positive integer `n`, returns an array containing all but the first `n`
elements:

    r = (1..4)
    r.drop(3)  # => [4]
    r.drop(2)  # => [3, 4]
    r.drop(1)  # => [2, 3, 4]
    r.drop(0)  # => [1, 2, 3, 4]
    r.drop(50) # => []

    h = {foo: 0, bar: 1, baz: 2, bat: 3}
    h.drop(2) # => [[:baz, 2], [:bat, 3]]

;T;0;;;I"	drop;F;I"Enumerable;T;[o;;I"::Integer n;T;I"Array[Elem];To;;I"`Calls the block with successive elements as long as the block returns a truthy
value; returns an array of all elements after that point:

    (1..4).drop_while{|i| i < 3 } # => [3, 4]
    h = {foo: 0, bar: 1, baz: 2}
    a = h.drop_while{|element| key, value = *element; value < 2 }
    a # => [[:baz, 2]]

With no block given, returns an Enumerator.

;T;0;;;I"drop_while;F;I"Enumerable;T;[o;;I" ;F;I"Array[Elem];To;;I" ;F;I"$Enumerator[Elem, ::Array[Elem]];To;;I"­Calls the block with each successive overlapped `n`-tuple of elements; returns
`self`:

    a = []
    (1..5).each_cons(3) {|element| a.push(element) }
    a # => [[1, 2, 3], [2, 3, 4], [3, 4, 5]]

    a = []
    h = {foo: 0,  bar: 1, baz: 2, bam: 3}
    h.each_cons(2) {|element| a.push(element) }
    a # => [[[:foo, 0], [:bar, 1]], [[:bar, 1], [:baz, 2]], [[:baz, 2], [:bam, 3]]]

With no block given, returns an Enumerator.

;T;0;;;I"each_cons;F;I"Enumerable;T;[o;;I"::Integer n;T;I"	self;To;;I"::Integer n;T;I"$Enumerator[::Array[Elem], self];To;;I"UWith a block given, calls the block with each element and its index; returns
`self`:

    h = {}
    (1..4).each_with_index {|element, i| h[element] = i } # => 1..4
    h # => {1=>0, 2=>1, 3=>2, 4=>3}

    h = {}
    %w[a b c d].each_with_index {|element, i| h[element] = i }
    # => ["a", "b", "c", "d"]
    h # => {"a"=>0, "b"=>1, "c"=>2, "d"=>3}

    a = []
    h = {foo: 0, bar: 1, baz: 2}
    h.each_with_index {|element, i| a.push([i, element]) }
    # => {:foo=>0, :bar=>1, :baz=>2}
    a # => [[0, [:foo, 0]], [1, [:bar, 1]], [2, [:baz, 2]]]

With no block given, returns an Enumerator.

;T;0;;;I"each_with_index;F;I"Enumerable;T;[o;;I" ;F;I"	self;To;;I" ;F;I"*Enumerator[[ Elem, ::Integer ], self];To;;I"9Calls the block once for each element, passing both the element and the given
object:

    (1..4).each_with_object([]) {|i, a| a.push(i**2) } # => [1, 4, 9, 16]
    h.each_with_object({}) {|element, h| k, v = *element; h[v] = k }
    # => {0=>:foo, 1=>:bar, 2=>:baz}

With no block given, returns an Enumerator.

;T;0;;;I"each_with_object;F;I"Enumerable;T;[o;;I"
U obj;T;I"U;Fo;;I"
U obj;T;I"Enumerator[[ Elem, U ], U];To;;I"Returns an array containing the items in `self`:

    (0..4).to_a # => [0, 1, 2, 3, 4]

Enumerable#entries is an alias for Enumerable#to_a.

;T;0;;;I"entries;F;I"Enumerable;T;[o;;I" ;F;I"Array[Elem];To;;I"¹Returns an array containing elements selected by the block.

With a block given, calls the block with successive elements; returns an array
of those elements for which the block returns a truthy value:

    (0..9).select {|element| element % 3 == 0 } # => [0, 3, 6, 9]
    a = {foo: 0, bar: 1, baz: 2}.select {|key, value| key.start_with?('b') }
    a # => {:bar=>1, :baz=>2}

With no block given, returns an Enumerator.

Related: #reject.

;T;0;;;I"find_all;F;I"Enumerable;T;[o;;I" ;F;I"Array[Elem];To;;I" ;F;I"$Enumerator[Elem, ::Array[Elem]];To;;I"cReturns the index of the first element that meets a specified criterion, or
`nil` if no such element is found.

With argument `object` given, returns the index of the first element that is
`==` `object`:

    ['a', 'b', 'c', 'b'].find_index('b') # => 1

With a block given, calls the block with successive elements; returns the
first element for which the block returns a truthy value:

    ['a', 'b', 'c', 'b'].find_index {|element| element.start_with?('b') } # => 1
    {foo: 0, bar: 1, baz: 2}.find_index {|key, value| value > 1 }         # => 2

With no argument and no block given, returns an Enumerator.

;T;0;;;I"find_index;F;I"Enumerable;T;[o;;I"untyped value;T;I"Integer?;To;;I" ;F;I"Integer?;To;;I" ;F;I"!Enumerator[Elem, ::Integer?];To;;I"ŸReturns the first element or elements.

With no argument, returns the first element, or `nil` if there is none:

    (1..4).first                   # => 1
    %w[a b c].first                # => "a"
    {foo: 1, bar: 1, baz: 2}.first # => [:foo, 1]
    [].first                       # => nil

With integer argument `n`, returns an array containing the first `n` elements
that exist:

    (1..4).first(2)                   # => [1, 2]
    %w[a b c d].first(3)              # => ["a", "b", "c"]
    %w[a b c d].first(50)             # => ["a", "b", "c", "d"]
    {foo: 1, bar: 1, baz: 2}.first(2) # => [[:foo, 1], [:bar, 1]]
    [].first(2)                       # => []

;T;0;;;I"
first;F;I"Enumerable;T;[o;;I" ;F;I"
Elem?;To;;I"::_ToInt n;T;I"Array[Elem];To;;I"‚Returns an array of objects based elements of `self` that match the given
pattern.

With no block given, returns an array containing each element for which
`pattern === element` is `true`:

    a = ['foo', 'bar', 'car', 'moo']
    a.grep(/ar/)                   # => ["bar", "car"]
    (1..10).grep(3..8)             # => [3, 4, 5, 6, 7, 8]
    ['a', 'b', 0, 1].grep(Integer) # => [0, 1]

With a block given, calls the block with each matching element and returns an
array containing each object returned by the block:

    a = ['foo', 'bar', 'car', 'moo']
    a.grep(/ar/) {|element| element.upcase } # => ["BAR", "CAR"]

Related: #grep_v.

;T;0;;;I"	grep;F;I"Enumerable;T;[o;;I"untyped arg0;T;I"Array[Elem];To;;I"untyped arg0;T;I"Array[U];To;;I"—Returns an array of objects based on elements of `self` that *don't* match the
given pattern.

With no block given, returns an array containing each element for which
`pattern === element` is `false`:

    a = ['foo', 'bar', 'car', 'moo']
    a.grep_v(/ar/)                   # => ["foo", "moo"]
    (1..10).grep_v(3..8)             # => [1, 2, 9, 10]
    ['a', 'b', 0, 1].grep_v(Integer) # => ["a", "b"]

With a block given, calls the block with each non-matching element and returns
an array containing each object returned by the block:

    a = ['foo', 'bar', 'car', 'moo']
    a.grep_v(/ar/) {|element| element.upcase } # => ["FOO", "MOO"]

Related: #grep.

;T;0;;;I"grep_v;F;I"Enumerable;T;[o;;I"untyped;T;I"Array[Elem];To;;I"untyped;T;I"Array[U];To;;I"ÊWith a block given returns a hash:

*   Each key is a return value from the block.
*   Each value is an array of those elements for which the block returned that
    key.


Examples:

    g = (1..6).group_by {|i| i%3 }
    g # => {1=>[1, 4], 2=>[2, 5], 0=>[3, 6]}
    h = {foo: 0, bar: 1, baz: 0, bat: 1}
    g = h.group_by {|key, value| value }
    g # => {0=>[[:foo, 0], [:baz, 0]], 1=>[[:bar, 1], [:bat, 1]]}

With no block given, returns an Enumerator.

;T;0;;;I"group_by;F;I"Enumerable;T;[o;;I" ;F;I"Hash[U, ::Array[Elem]];To;;I" ;F;I"$Enumerator[Elem, ::Array[Elem]];To;;I"-Returns whether for any element `object == element`:

    (1..4).include?(2)                       # => true
    (1..4).include?(5)                       # => false
    (1..4).include?('2')                     # => false
    %w[a b c d].include?('b')                # => true
    %w[a b c d].include?('2')                # => false
    {foo: 0, bar: 1, baz: 2}.include?(:foo)  # => true
    {foo: 0, bar: 1, baz: 2}.include?('foo') # => false
    {foo: 0, bar: 1, baz: 2}.include?(0)     # => false

Enumerable#member? is an alias for Enumerable#include?.

;T;0;;;I"include?;F;I"Enumerable;T;[o;;I"Elem arg0;T;I"	bool;To;;I":Returns an object formed from operands via either:

*   A method named by `symbol`.
*   A block to which each operand is passed.


With method-name argument `symbol`, combines operands using the method:

    # Sum, without initial_operand.
    (1..4).inject(:+)     # => 10
    # Sum, with initial_operand.
    (1..4).inject(10, :+) # => 20

With a block, passes each operand to the block:

    # Sum of squares, without initial_operand.
    (1..4).inject {|sum, n| sum + n*n }    # => 30
    # Sum of squares, with initial_operand.
    (1..4).inject(2) {|sum, n| sum + n*n } # => 32

**Operands**

If argument `initial_operand` is not given, the operands for `inject` are
simply the elements of `self`. Example calls and their operands:

    `(1..4).inject(:+)`
:       `[1, 2, 3, 4]`.

    `(1...4).inject(:+)`
:       `[1, 2, 3]`.

    `('a'..'d').inject(:+)`
:       `['a', 'b', 'c', 'd']`.

    `('a'...'d').inject(:+)`
:       `['a', 'b', 'c']`.



Examples with first operand (which is `self.first`) of various types:

    # Integer.
    (1..4).inject(:+)                # => 10
    # Float.
    [1.0, 2, 3, 4].inject(:+)        # => 10.0
    # Character.
    ('a'..'d').inject(:+)            # => "abcd"
    # Complex.
    [Complex(1, 2), 3, 4].inject(:+) # => (8+2i)

If argument `initial_operand` is given, the operands for `inject` are that
value plus the elements of `self`. Example calls their operands:

    `(1..4).inject(10, :+)`
:       `[10, 1, 2, 3, 4]`.

    `(1...4).inject(10, :+)`
:       `[10, 1, 2, 3]`.

    `('a'..'d').inject('e', :+)`
:       `['e', 'a', 'b', 'c', 'd']`.

    `('a'...'d').inject('e', :+)`
:       `['e', 'a', 'b', 'c']`.



Examples with `initial_operand` of various types:

    # Integer.
    (1..4).inject(2, :+)               # => 12
    # Float.
    (1..4).inject(2.0, :+)             # => 12.0
    # String.
    ('a'..'d').inject('foo', :+)       # => "fooabcd"
    # Array.
    %w[a b c].inject(['x'], :push)     # => ["x", "a", "b", "c"]
    # Complex.
    (1..4).inject(Complex(2, 2), :+)   # => (12+2i)

**Combination by Given \Method**

If the method-name argument `symbol` is given, the operands are combined by
that method:

*   The first and second operands are combined.
*   That result is combined with the third operand.
*   That result is combined with the fourth operand.
*   And so on.


The return value from `inject` is the result of the last combination.

This call to `inject` computes the sum of the operands:

    (1..4).inject(:+) # => 10

Examples with various methods:

    # Integer addition.
    (1..4).inject(:+)                # => 10
    # Integer multiplication.
    (1..4).inject(:*)                # => 24
    # Character range concatenation.
    ('a'..'d').inject('', :+)        # => "abcd"
    # String array concatenation.
    %w[foo bar baz].inject('', :+)   # => "foobarbaz"
    # Hash update.
    h = [{foo: 0, bar: 1}, {baz: 2}, {bat: 3}].inject(:update)
    h # => {:foo=>0, :bar=>1, :baz=>2, :bat=>3}
    # Hash conversion to nested arrays.
    h = {foo: 0, bar: 1}.inject([], :push)
    h # => [[:foo, 0], [:bar, 1]]

**Combination by Given Block**

If a block is given, the operands are passed to the block:

*   The first call passes the first and second operands.
*   The second call passes the result of the first call, along with the third
    operand.
*   The third call passes the result of the second call, along with the fourth
    operand.
*   And so on.


The return value from `inject` is the return value from the last block call.

This call to `inject` gives a block that writes the memo and element, and also
sums the elements:

    (1..4).inject do |memo, element|
      p "Memo: #{memo}; element: #{element}"
      memo + element
    end # => 10

Output:

    "Memo: 1; element: 2"
    "Memo: 3; element: 3"
    "Memo: 6; element: 4"

Enumerable#reduce is an alias for Enumerable#inject.

;T;0;;;I"inject;F;I"Enumerable;T;[	o;;I""untyped init, ::Symbol method;T;I"untyped;To;;I"::Symbol method;T;I"untyped;To;;I"A initial;T;I"A;Fo;;I" ;F;I"	Elem;Fo;;I"LReturns the element with the maximum element according to a given criterion.
The ordering of equal elements is indeterminate and may be unstable.

With no argument and no block, returns the maximum element, using the
elements' own method `<=>` for comparison:

    (1..4).max                   # => 4
    (-4..-1).max                 # => -1
    %w[d c b a].max              # => "d"
    {foo: 0, bar: 1, baz: 2}.max # => [:foo, 0]
    [].max                       # => nil

With positive integer argument `n` given, and no block, returns an array
containing the first `n` maximum elements that exist:

    (1..4).max(2)                   # => [4, 3]
    (-4..-1).max(2)                # => [-1, -2]
    %w[d c b a].max(2)              # => ["d", "c"]
    {foo: 0, bar: 1, baz: 2}.max(2) # => [[:foo, 0], [:baz, 2]]
    [].max(2)                       # => []

With a block given, the block determines the maximum elements. The block is
called with two elements `a` and `b`, and must return:

*   A negative integer if `a < b`.
*   Zero if `a == b`.
*   A positive integer if `a > b`.


With a block given and no argument, returns the maximum element as determined
by the block:

    %w[xxx x xxxx xx].max {|a, b| a.size <=> b.size } # => "xxxx"
    h = {foo: 0, bar: 1, baz: 2}
    h.max {|pair1, pair2| pair1[1] <=> pair2[1] }     # => [:baz, 2]
    [].max {|a, b| a <=> b }                          # => nil

With a block given and positive integer argument `n` given, returns an array
containing the first `n` maximum elements that exist, as determined by the
block.

    %w[xxx x xxxx xx].max(2) {|a, b| a.size <=> b.size } # => ["xxxx", "xxx"]
    h = {foo: 0, bar: 1, baz: 2}
    h.max(2) {|pair1, pair2| pair1[1] <=> pair2[1] }
    # => [[:baz, 2], [:bar, 1]]
    [].max(2) {|a, b| a <=> b }                          # => []

Related: #min, #minmax, #max_by.

;T;0;;;I"max;F;I"Enumerable;T;[	o;;I" ;F;I"
Elem?;To;;I" ;F;I"
Elem?;To;;I"::Integer arg0;T;I"Array[Elem];To;;I"::Integer arg0;T;I"Array[Elem];To;;I"½Returns the elements for which the block returns the maximum values.

With a block given and no argument, returns the element for which the block
returns the maximum value:

    (1..4).max_by {|element| -element }                    # => 1
    %w[a b c d].max_by {|element| -element.ord }           # => "a"
    {foo: 0, bar: 1, baz: 2}.max_by {|key, value| -value } # => [:foo, 0]
    [].max_by {|element| -element }                        # => nil

With a block given and positive integer argument `n` given, returns an array
containing the `n` elements for which the block returns maximum values:

    (1..4).max_by(2) {|element| -element }
    # => [1, 2]
    %w[a b c d].max_by(2) {|element| -element.ord }
    # => ["a", "b"]
    {foo: 0, bar: 1, baz: 2}.max_by(2) {|key, value| -value }
    # => [[:foo, 0], [:bar, 1]]
    [].max_by(2) {|element| -element }
    # => []

Returns an Enumerator if no block is given.

Related: #max, #minmax, #min_by.

;T;0;;;I"max_by;F;I"Enumerable;T;[	o;;I" ;F;I"Enumerator[Elem, Elem?];To;;I" ;F;I"
Elem?;To;;I"::Integer arg0;T;I"$Enumerator[Elem, ::Array[Elem]];To;;I"::Integer arg0;T;I"Array[Elem];To;;I"BReturns the element with the minimum element according to a given criterion.
The ordering of equal elements is indeterminate and may be unstable.

With no argument and no block, returns the minimum element, using the
elements' own method `<=>` for comparison:

    (1..4).min                   # => 1
    (-4..-1).min                 # => -4
    %w[d c b a].min              # => "a"
    {foo: 0, bar: 1, baz: 2}.min # => [:bar, 1]
    [].min                       # => nil

With positive integer argument `n` given, and no block, returns an array
containing the first `n` minimum elements that exist:

    (1..4).min(2)                   # => [1, 2]
    (-4..-1).min(2)                 # => [-4, -3]
    %w[d c b a].min(2)              # => ["a", "b"]
    {foo: 0, bar: 1, baz: 2}.min(2) # => [[:bar, 1], [:baz, 2]]
    [].min(2)                       # => []

With a block given, the block determines the minimum elements. The block is
called with two elements `a` and `b`, and must return:

*   A negative integer if `a < b`.
*   Zero if `a == b`.
*   A positive integer if `a > b`.


With a block given and no argument, returns the minimum element as determined
by the block:

    %w[xxx x xxxx xx].min {|a, b| a.size <=> b.size } # => "x"
    h = {foo: 0, bar: 1, baz: 2}
    h.min {|pair1, pair2| pair1[1] <=> pair2[1] } # => [:foo, 0]
    [].min {|a, b| a <=> b }                          # => nil

With a block given and positive integer argument `n` given, returns an array
containing the first `n` minimum elements that exist, as determined by the
block.

    %w[xxx x xxxx xx].min(2) {|a, b| a.size <=> b.size } # => ["x", "xx"]
    h = {foo: 0, bar: 1, baz: 2}
    h.min(2) {|pair1, pair2| pair1[1] <=> pair2[1] }
    # => [[:foo, 0], [:bar, 1]]
    [].min(2) {|a, b| a <=> b }                          # => []

Related: #min_by, #minmax, #max.

;T;0;;;I"min;F;I"Enumerable;T;[	o;;I" ;F;I"
Elem?;To;;I" ;F;I"
Elem?;To;;I"::Integer arg0;T;I"Array[Elem];To;;I"::Integer arg0;T;I"Array[Elem];To;;I"½Returns the elements for which the block returns the minimum values.

With a block given and no argument, returns the element for which the block
returns the minimum value:

    (1..4).min_by {|element| -element }                    # => 4
    %w[a b c d].min_by {|element| -element.ord }           # => "d"
    {foo: 0, bar: 1, baz: 2}.min_by {|key, value| -value } # => [:baz, 2]
    [].min_by {|element| -element }                        # => nil

With a block given and positive integer argument `n` given, returns an array
containing the `n` elements for which the block returns minimum values:

    (1..4).min_by(2) {|element| -element }
    # => [4, 3]
    %w[a b c d].min_by(2) {|element| -element.ord }
    # => ["d", "c"]
    {foo: 0, bar: 1, baz: 2}.min_by(2) {|key, value| -value }
    # => [[:baz, 2], [:bar, 1]]
    [].min_by(2) {|element| -element }
    # => []

Returns an Enumerator if no block is given.

Related: #min, #minmax, #max_by.

;T;0;;;I"min_by;F;I"Enumerable;T;[	o;;I" ;F;I"Enumerator[Elem, Elem?];To;;I" ;F;I"
Elem?;To;;I"::Integer arg0;T;I"$Enumerator[Elem, ::Array[Elem]];To;;I"::Integer arg0;T;I"Array[Elem];To;;I"¾Returns a 2-element array containing the minimum and maximum elements
according to a given criterion. The ordering of equal elements is
indeterminate and may be unstable.

With no argument and no block, returns the minimum and maximum elements, using
the elements' own method `<=>` for comparison:

    (1..4).minmax                   # => [1, 4]
    (-4..-1).minmax                 # => [-4, -1]
    %w[d c b a].minmax              # => ["a", "d"]
    {foo: 0, bar: 1, baz: 2}.minmax # => [[:bar, 1], [:foo, 0]]
    [].minmax                       # => [nil, nil]

With a block given, returns the minimum and maximum elements as determined by
the block:

    %w[xxx x xxxx xx].minmax {|a, b| a.size <=> b.size } # => ["x", "xxxx"]
    h = {foo: 0, bar: 1, baz: 2}
    h.minmax {|pair1, pair2| pair1[1] <=> pair2[1] }
    # => [[:foo, 0], [:baz, 2]]
    [].minmax {|a, b| a <=> b }                          # => [nil, nil]

Related: #min, #max, #minmax_by.

;T;0;;;I"minmax;F;I"Enumerable;T;[o;;I" ;F;I"[ Elem?, Elem? ];To;;I" ;F;I"[ Elem?, Elem? ];To;;I"ÚReturns a 2-element array containing the elements for which the block returns
minimum and maximum values:

    (1..4).minmax_by {|element| -element }
    # => [4, 1]
    %w[a b c d].minmax_by {|element| -element.ord }
    # => ["d", "a"]
    {foo: 0, bar: 1, baz: 2}.minmax_by {|key, value| -value }
    # => [[:baz, 2], [:foo, 0]]
    [].minmax_by {|element| -element }
    # => [nil, nil]

Returns an Enumerator if no block is given.

Related: #max_by, #minmax, #min_by.

;T;0;;;I"minmax_by;F;I"Enumerable;T;[o;;I" ;F;I"[ Elem?, Elem? ];To;;I" ;F;I"[ Elem?, Elem? ];To;;I"¦Returns whether no element meets a given criterion.

With no argument and no block, returns whether no element is truthy:

    (1..4).none?           # => false
    [nil, false].none?     # => true
    {foo: 0}.none?         # => false
    {foo: 0, bar: 1}.none? # => false
    [].none?               # => true

With argument `pattern` and no block, returns whether for no element
`element`, `pattern === element`:

    [nil, false, 1.1].none?(Integer)      # => true
    %w[bar baz bat bam].none?(/m/)        # => false
    %w[bar baz bat bam].none?(/foo/)      # => true
    %w[bar baz bat bam].none?('ba')       # => true
    {foo: 0, bar: 1, baz: 2}.none?(Hash)  # => true
    {foo: 0}.none?(Array)                 # => false
    [].none?(Integer)                     # => true

With a block given, returns whether the block returns a truthy value for no
element:

    (1..4).none? {|element| element < 1 }                     # => true
    (1..4).none? {|element| element < 2 }                     # => false
    {foo: 0, bar: 1, baz: 2}.none? {|key, value| value < 0 }  # => true
    {foo: 0, bar: 1, baz: 2}.none? {|key, value| value < 1 } # => false

Related: #one?, #all?, #any?.

;T;0;;;I"
none?;F;I"Enumerable;T;[o;;I" ;F;I"	bool;To;;I" ;F;I"	bool;To;;I"HReturns whether exactly one element meets a given criterion.

With no argument and no block, returns whether exactly one element is truthy:

    (1..1).one?           # => true
    [1, nil, false].one?  # => true
    (1..4).one?           # => false
    {foo: 0}.one?         # => true
    {foo: 0, bar: 1}.one? # => false
    [].one?               # => false

With argument `pattern` and no block, returns whether for exactly one element
`element`, `pattern === element`:

    [nil, false, 0].one?(Integer)        # => true
    [nil, false, 0].one?(Numeric)        # => true
    [nil, false, 0].one?(Float)          # => false
    %w[bar baz bat bam].one?(/m/)        # => true
    %w[bar baz bat bam].one?(/foo/)      # => false
    %w[bar baz bat bam].one?('ba')       # => false
    {foo: 0, bar: 1, baz: 2}.one?(Array) # => false
    {foo: 0}.one?(Array)                 # => true
    [].one?(Integer)                     # => false

With a block given, returns whether the block returns a truthy value for
exactly one element:

    (1..4).one? {|element| element < 2 }                     # => true
    (1..4).one? {|element| element < 1 }                     # => false
    {foo: 0, bar: 1, baz: 2}.one? {|key, value| value < 1 }  # => true
    {foo: 0, bar: 1, baz: 2}.one? {|key, value| value < 2 } # => false

Related: #none?, #all?, #any?.

;T;0;;;I"	one?;F;I"Enumerable;T;[o;;I" ;F;I"	bool;To;;I" ;F;I"	bool;To;;I"¨With a block given, returns an array of two arrays:

*   The first having those elements for which the block returns a truthy
    value.
*   The other having all other elements.


Examples:

    p = (1..4).partition {|i| i.even? }
    p # => [[2, 4], [1, 3]]
    p = ('a'..'d').partition {|c| c < 'c' }
    p # => [["a", "b"], ["c", "d"]]
    h = {foo: 0, bar: 1, baz: 2, bat: 3}
    p = h.partition {|key, value| key.start_with?('b') }
    p # => [[[:bar, 1], [:baz, 2], [:bat, 3]], [[:foo, 0]]]
    p = h.partition {|key, value| value < 2 }
    p # => [[[:foo, 0], [:bar, 1]], [[:baz, 2], [:bat, 3]]]

With no block given, returns an Enumerator.

Related: Enumerable#group_by.

;T;0;;;I"partition;F;I"Enumerable;T;[o;;I" ;F;I"%[ ::Array[Elem], ::Array[Elem] ];To;;I" ;F;I"7Enumerator[Elem, [ ::Array[Elem], ::Array[Elem] ]];To;;I"¾Returns an array of objects rejected by the block.

With a block given, calls the block with successive elements; returns an array
of those elements for which the block returns `nil` or `false`:

    (0..9).reject {|i| i * 2 if i.even? }                             # => [1, 3, 5, 7, 9]
    {foo: 0, bar: 1, baz: 2}.reject {|key, value| key if value.odd? } # => {:foo=>0, :baz=>2}

When no block given, returns an Enumerator.

Related: #select.

;T;0;;;I"reject;F;I"Enumerable;T;[o;;I" ;F;I"Array[Elem];To;;I" ;F;I"$Enumerator[Elem, ::Array[Elem]];To;;I"With a block given, calls the block with each element, but in reverse order;
returns `self`:

    a = []
    (1..4).reverse_each {|element| a.push(-element) } # => 1..4
    a # => [-4, -3, -2, -1]

    a = []
    %w[a b c d].reverse_each {|element| a.push(element) }
    # => ["a", "b", "c", "d"]
    a # => ["d", "c", "b", "a"]

    a = []
    h.reverse_each {|element| a.push(element) }
    # => {:foo=>0, :bar=>1, :baz=>2}
    a # => [[:baz, 2], [:bar, 1], [:foo, 0]]

With no block given, returns an Enumerator.

;T;0;;;I"reverse_each;F;I"Enumerable;T;[o;;I" ;F;I"	void;To;;I" ;F;I"Enumerator[Elem, void];To;;I"tReturns an array containing the sorted elements of `self`. The ordering of
equal elements is indeterminate and may be unstable.

With no block given, the sort compares using the elements' own method `<=>`:

    %w[b c a d].sort              # => ["a", "b", "c", "d"]
    {foo: 0, bar: 1, baz: 2}.sort # => [[:bar, 1], [:baz, 2], [:foo, 0]]

With a block given, comparisons in the block determine the ordering. The block
is called with two elements `a` and `b`, and must return:

*   A negative integer if `a < b`.
*   Zero if `a == b`.
*   A positive integer if `a > b`.


Examples:

    a = %w[b c a d]
    a.sort {|a, b| b <=> a } # => ["d", "c", "b", "a"]
    h = {foo: 0, bar: 1, baz: 2}
    h.sort {|a, b| b <=> a } # => [[:foo, 0], [:baz, 2], [:bar, 1]]

See also #sort_by. It implements a Schwartzian transform which is useful when
key computation or comparison is expensive.

;T;0;;;I"	sort;F;I"Enumerable;T;[o;;I" ;F;I"Array[Elem];To;;I" ;F;I"Array[Elem];To;;I"H
With a block given, returns an array of elements of `self`, sorted according
to the value returned by the block for each element. The ordering of equal
elements is indeterminate and may be unstable.

Examples:

    a = %w[xx xxx x xxxx]
    a.sort_by {|s| s.size }        # => ["x", "xx", "xxx", "xxxx"]
    a.sort_by {|s| -s.size }       # => ["xxxx", "xxx", "xx", "x"]
    h = {foo: 2, bar: 1, baz: 0}
    h.sort_by{|key, value| value } # => [[:baz, 0], [:bar, 1], [:foo, 2]]
    h.sort_by{|key, value| key }   # => [[:bar, 1], [:baz, 0], [:foo, 2]]

With no block given, returns an Enumerator.

The current implementation of #sort_by generates an array of tuples containing
the original collection element and the mapped value. This makes #sort_by
fairly expensive when the keysets are simple.

    require 'benchmark'

    a = (1..100000).map { rand(100000) }

    Benchmark.bm(10) do |b|
      b.report("Sort")    { a.sort }
      b.report("Sort by") { a.sort_by { |a| a } }
    end

*produces:*

    user     system      total        real
    Sort        0.180000   0.000000   0.180000 (  0.175469)
    Sort by     1.980000   0.040000   2.020000 (  2.013586)

However, consider the case where comparing the keys is a non-trivial
operation. The following code sorts some files on modification time using the
basic #sort method.

    files = Dir["*"]
    sorted = files.sort { |a, b| File.new(a).mtime <=> File.new(b).mtime }
    sorted   #=> ["mon", "tues", "wed", "thurs"]

This sort is inefficient: it generates two new File objects during every
comparison. A slightly better technique is to use the Kernel#test method to
generate the modification times directly.

    files = Dir["*"]
    sorted = files.sort { |a, b|
      test(?M, a) <=> test(?M, b)
    }
    sorted   #=> ["mon", "tues", "wed", "thurs"]

This still generates many unnecessary Time objects. A more efficient technique
is to cache the sort keys (modification times in this case) before the sort.
Perl users often call this approach a Schwartzian transform, after Randal
Schwartz. We construct a temporary array, where each element is an array
containing our sort key along with the filename. We sort this array, and then
extract the filename from the result.

    sorted = Dir["*"].collect { |f|
       [test(?M, f), f]
    }.sort.collect { |f| f[1] }
    sorted   #=> ["mon", "tues", "wed", "thurs"]

This is exactly what #sort_by does internally.

    sorted = Dir["*"].sort_by { |f| test(?M, f) }
    sorted   #=> ["mon", "tues", "wed", "thurs"]

To produce the reverse of a specific order, the following can be used:

    ary.sort_by { ... }.reverse!

;T;0;;;I"sort_by;F;I"Enumerable;T;[o;;I" ;F;I"Array[Elem];To;;I" ;F;I"$Enumerator[Elem, ::Array[Elem]];To;;I"ÓFor non-negative integer `n`, returns the first `n` elements:

    r = (1..4)
    r.take(2) # => [1, 2]
    r.take(0) # => []

    h = {foo: 0, bar: 1, baz: 2, bat: 3}
    h.take(2) # => [[:foo, 0], [:bar, 1]]

;T;0;;;I"	take;F;I"Enumerable;T;[o;;I"::Integer n;T;I"Array[Elem];To;;I"eCalls the block with successive elements as long as the block returns a truthy
value; returns an array of all elements up to that point:

    (1..4).take_while{|i| i < 3 } # => [1, 2]
    h = {foo: 0, bar: 1, baz: 2}
    h.take_while{|element| key, value = *element; value < 2 }
    # => [[:foo, 0], [:bar, 1]]

With no block given, returns an Enumerator.

;T;0;;;I"take_while;F;I"Enumerable;T;[o;;I" ;F;I"Array[Elem];To;;I" ;F;I"$Enumerator[Elem, ::Array[Elem]];To;;I"When `self` consists of 2-element arrays, returns a hash each of whose entries
is the key-value pair formed from one of those arrays:

    [[:foo, 0], [:bar, 1], [:baz, 2]].to_h # => {:foo=>0, :bar=>1, :baz=>2}

When a block is given, the block is called with each element of `self`; the
block should return a 2-element array which becomes a key-value pair in the
returned hash:

    (0..3).to_h {|i| [i, i ** 2]} # => {0=>0, 1=>1, 2=>4, 3=>9}

Raises an exception if an element of `self` is not a 2-element array, and a
block is not passed.

;T;0;;;I"	to_h;F;I"Enumerable;T;[o;;I" ;F;I"Hash[untyped, untyped];To;;I" ;F;I"Hash[T, U];To;;I"¨Calls the block with each successive disjoint `n`-tuple of elements; returns
`self`:

    a = []
    (1..10).each_slice(3) {|tuple| a.push(tuple) }
    a # => [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]]

    a = []
    h = {foo: 0, bar: 1, baz: 2, bat: 3, bam: 4}
    h.each_slice(2) {|tuple| a.push(tuple) }
    a # => [[[:foo, 0], [:bar, 1]], [[:baz, 2], [:bat, 3]], [[:bam, 4]]]

With no block given, returns an Enumerator.

;T;0;;;I"each_slice;F;I"Enumerable;T;[o;;I"::Integer n;T;I"	self;To;;I"::Integer n;T;I"$Enumerator[::Array[Elem], self];To;;I"™Returns the first element for which the block returns a truthy value.

With a block given, calls the block with successive elements of the
collection; returns the first element for which the block returns a truthy
value:

    (0..9).find {|element| element > 2}                # => 3

If no such element is found, calls `if_none_proc` and returns its return
value.

    (0..9).find(proc {false}) {|element| element > 12} # => false
    {foo: 0, bar: 1, baz: 2}.find {|key, value| key.start_with?('b') }            # => [:bar, 1]
    {foo: 0, bar: 1, baz: 2}.find(proc {[]}) {|key, value| key.start_with?('c') } # => []

With no block given, returns an Enumerator.

;T;0;;;I"	find;F;I"Enumerable;T;[	o;;I" ;F;I"
Elem?;To;;I" ;F;I"Enumerator[Elem, Elem?];To;;I"&::Enumerable::_NotFound[T] ifnone;T;I"Elem | T;Fo;;I"&::Enumerable::_NotFound[T] ifnone;T;I"Enumerator[Elem, Elem | T];To;;I"Returns an array of flattened objects returned by the block.

With a block given, calls the block with successive elements; returns a
flattened array of objects returned by the block:

    [0, 1, 2, 3].flat_map {|element| -element }                    # => [0, -1, -2, -3]
    [0, 1, 2, 3].flat_map {|element| [element, -element] }         # => [0, 0, 1, -1, 2, -2, 3, -3]
    [[0, 1], [2, 3]].flat_map {|e| e + [100] }                     # => [0, 1, 100, 2, 3, 100]
    {foo: 0, bar: 1, baz: 2}.flat_map {|key, value| [key, value] } # => [:foo, 0, :bar, 1, :baz, 2]

With no block given, returns an Enumerator.

Alias: #collect_concat.

;T;0;;;I"flat_map;F;I"Enumerable;T;[o;;I" ;F;I"Array[U];To;;I" ;F;I"'Enumerator[Elem, ::Array[untyped]];To;;I"mReturns an array of objects returned by the block.

With a block given, calls the block with successive elements; returns an array
of the objects returned by the block:

    (0..4).map {|i| i*i }                               # => [0, 1, 4, 9, 16]
    {foo: 0, bar: 1, baz: 2}.map {|key, value| value*2} # => [0, 2, 4]

With no block given, returns an Enumerator.

;T;0;;;I"map;F;I"Enumerable;T;[o;;I" ;F;I"Array[U];To;;I" ;F;I"'Enumerator[Elem, ::Array[untyped]];To;;I"-Returns whether for any element `object == element`:

    (1..4).include?(2)                       # => true
    (1..4).include?(5)                       # => false
    (1..4).include?('2')                     # => false
    %w[a b c d].include?('b')                # => true
    %w[a b c d].include?('2')                # => false
    {foo: 0, bar: 1, baz: 2}.include?(:foo)  # => true
    {foo: 0, bar: 1, baz: 2}.include?('foo') # => false
    {foo: 0, bar: 1, baz: 2}.include?(0)     # => false

Enumerable#member? is an alias for Enumerable#include?.

;T;0;;;I"member?;F;I"Enumerable;T;[o;;I"Elem arg0;T;I"	bool;To;;I"Returns an array containing the items in `self`:

    (0..4).to_a # => [0, 1, 2, 3, 4]

Enumerable#entries is an alias for Enumerable#to_a.

;T;0;;;I"	to_a;F;I"Enumerable;T;[o;;I" ;F;I"Array[Elem];To;;I"ÞReturns an Enumerator::Lazy, which redefines most Enumerable methods to
postpone enumeration and enumerate values only on an as-needed basis.

### Example

The following program finds pythagorean triples:

    def pythagorean_triples
      (1..Float::INFINITY).lazy.flat_map {|z|
        (1..z).flat_map {|x|
          (x..z).select {|y|
            x**2 + y**2 == z**2
          }.map {|y|
            [x, y, z]
          }
        }
      }
    end
    # show first ten pythagorean triples
    p pythagorean_triples.take(10).force # take is lazy, so force is needed
    p pythagorean_triples.first(10)      # first is eager
    # show pythagorean triples less than 100
    p pythagorean_triples.take_while { |*, z| z < 100 }.force

;T;0;;;I"	lazy;F;I"Enumerable;T;[o;;I" ;F;I"!Enumerator::Lazy[Elem, void];To;;I"With no block, returns a new array containing only unique elements; the array
has no two elements `e0` and `e1` such that `e0.eql?(e1)`:

    %w[a b c c b a a b c].uniq       # => ["a", "b", "c"]
    [0, 1, 2, 2, 1, 0, 0, 1, 2].uniq # => [0, 1, 2]

With a block, returns a new array containing only for which the block returns
a unique value:

    a = [0, 1, 2, 3, 4, 5, 5, 4, 3, 2, 1]
    a.uniq {|i| i.even? ? i : 0 } # => [0, 2, 4]
    a = %w[a b c d e e d c b a a b c d e]
    a.uniq {|c| c < 'c' }         # => ["a", "c"]

;T;0;;;I"	uniq;F;I"Enumerable;T;[o;;I" ;F;I"Array[Elem];To;;I" ;F;I"Array[Elem];To;;I"‰With no block given, returns the sum of `initial_value` and the elements:

    (1..100).sum          # => 5050
    (1..100).sum(1)       # => 5051
    ('a'..'d').sum('foo') # => "fooabcd"

Generally, the sum is computed using methods `+` and `each`; for performance
optimizations, those methods may not be used, and so any redefinition of those
methods may not have effect here.

One such optimization: When possible, computes using Gauss's summation formula
*n(n+1)/2*:

    100 * (100 + 1) / 2 # => 5050

With a block given, calls the block with each element; returns the sum of
`initial_value` and the block return values:

    (1..4).sum {|i| i*i }                        # => 30
    (1..4).sum(100) {|i| i*i }                   # => 130
    h = {a: 0, b: 1, c: 2, d: 3, e: 4, f: 5}
    h.sum {|key, value| value.odd? ? value : 0 } # => 9
    ('a'..'f').sum('x') {|c| c < 'd' ? c : '' }  # => "xabc"

;T;0;;;I"sum;F;I"Enumerable;T;[	o;;I" ;F;I"Elem | ::Integer;Fo;;I" ;F;I"Integer | T;To;;I"?T arg0;T;I"Elem | T;Fo;;I"?U arg0;T;I"U;Fo;;I"µReturns an array containing truthy elements returned by the block.

With a block given, calls the block with successive elements; returns an array
containing each truthy value returned by the block:

    (0..9).filter_map {|i| i * 2 if i.even? }                              # => [0, 4, 8, 12, 16]
    {foo: 0, bar: 1, baz: 2}.filter_map {|key, value| key if value.even? } # => [:foo, :baz]

When no block given, returns an Enumerator.

;T;0;;;I"filter_map;F;I"Enumerable;T;[o;;I" ;F;I"Array[U];To;;I" ;F;I"'Enumerator[Elem, ::Array[untyped]];To;;I"‘Returns an enumerator object generated from this enumerator and given
enumerables.

    e = (1..3).chain([4, 5])
    e.to_a #=> [1, 2, 3, 4, 5]

;T;0;;;I"
chain;F;I"Enumerable;T;[o;;I"*self enumerables;T;I"Enumerator::Chain[Elem];To;;I"²Returns a hash containing the counts of equal elements:

*   Each key is an element of `self`.
*   Each value is the number elements equal to that key.


With no argument:

    %w[a b c b c a c b].tally # => {"a"=>2, "b"=>3, "c"=>3}

With a hash argument, that hash is used for the tally (instead of a new hash),
and is returned; this may be useful for accumulating tallies across multiple
enumerables:

    hash = {}
    hash = %w[a c d b c a].tally(hash)
    hash # => {"a"=>2, "c"=>2, "d"=>1, "b"=>1}
    hash = %w[b a z].tally(hash)
    hash # => {"a"=>3, "c"=>2, "d"=>1, "b"=>2, "z"=>1}
    hash = %w[b a m].tally(hash)
    hash # => {"a"=>4, "c"=>2, "d"=>1, "b"=>3, "z"=>1, "m"=> 1}

;T;0;;;I"
tally;F;I"Enumerable;T;[o;;I""?::Hash[Elem, ::Integer] hash;T;I"Hash[Elem, ::Integer];To;;I"rCalls the given block with each element, converting multiple values from yield
to an array; returns `self`:

    a = []
    (1..4).each_entry {|element| a.push(element) } # => 1..4
    a # => [1, 2, 3, 4]

    a = []
    h = {foo: 0, bar: 1, baz:2}
    h.each_entry {|element| a.push(element) }
    # => {:foo=>0, :bar=>1, :baz=>2}
    a # => [[:foo, 0], [:bar, 1], [:baz, 2]]

    class Foo
      include Enumerable
      def each
        yield 1
        yield 1, 2
        yield
      end
    end
    Foo.new.each_entry {|yielded| p yielded }

Output:

    1
    [1, 2]
    nil

With no block given, returns an Enumerator.

;T;0;;;I"each_entry;F;I"Enumerable;T;[o;;I" ;F;I"Enumerator[Elem, self];To;;I" ;F;I"	self;To;;I"ÕWith no block given, returns a new array `new_array` of size self.size whose
elements are arrays. Each nested array `new_array[n]` is of size
`other_enums.size+1`, and contains:

*   The `n`-th element of self.
*   The `n`-th element of each of the `other_enums`.


If all `other_enums` and self are the same size, all elements are included in
the result, and there is no `nil`-filling:

    a = [:a0, :a1, :a2, :a3]
    b = [:b0, :b1, :b2, :b3]
    c = [:c0, :c1, :c2, :c3]
    d = a.zip(b, c)
    d # => [[:a0, :b0, :c0], [:a1, :b1, :c1], [:a2, :b2, :c2], [:a3, :b3, :c3]]

    f = {foo: 0, bar: 1, baz: 2}
    g = {goo: 3, gar: 4, gaz: 5}
    h = {hoo: 6, har: 7, haz: 8}
    d = f.zip(g, h)
    d # => [
      #      [[:foo, 0], [:goo, 3], [:hoo, 6]],
      #      [[:bar, 1], [:gar, 4], [:har, 7]],
      #      [[:baz, 2], [:gaz, 5], [:haz, 8]]
      #    ]

If any enumerable in other_enums is smaller than self, fills to `self.size`
with `nil`:

    a = [:a0, :a1, :a2, :a3]
    b = [:b0, :b1, :b2]
    c = [:c0, :c1]
    d = a.zip(b, c)
    d # => [[:a0, :b0, :c0], [:a1, :b1, :c1], [:a2, :b2, nil], [:a3, nil, nil]]

If any enumerable in other_enums is larger than self, its trailing elements
are ignored:

    a = [:a0, :a1, :a2, :a3]
    b = [:b0, :b1, :b2, :b3, :b4]
    c = [:c0, :c1, :c2, :c3, :c4, :c5]
    d = a.zip(b, c)
    d # => [[:a0, :b0, :c0], [:a1, :b1, :c1], [:a2, :b2, :c2], [:a3, :b3, :c3]]

When a block is given, calls the block with each of the sub-arrays (formed as
above); returns nil:

    a = [:a0, :a1, :a2, :a3]
    b = [:b0, :b1, :b2, :b3]
    c = [:c0, :c1, :c2, :c3]
    a.zip(b, c) {|sub_array| p sub_array} # => nil

Output:

    [:a0, :b0, :c0]
    [:a1, :b1, :c1]
    [:a2, :b2, :c2]
    [:a3, :b3, :c3]

;T;0;;;I"zip;F;I"Enumerable;T;[o;;I"::Enumerable[Elem2] enum;T;I"!Array[[ Elem, Elem2 | nil ]];To;;I"::Enumerable[Elem2];T;I"nil;To;;I"ÕEach element in the returned enumerator is a 2-element array consisting of:

*   A value returned by the block.
*   An array ("chunk") containing the element for which that value was
    returned, and all following elements for which the block returned the same
    value:


So that:

*   Each block return value that is different from its predecessor begins a
    new chunk.
*   Each block return value that is the same as its predecessor continues the
    same chunk.


Example:

    e = (0..10).chunk {|i| (i / 3).floor } # => #<Enumerator: ...>
    # The enumerator elements.
    e.next # => [0, [0, 1, 2]]
    e.next # => [1, [3, 4, 5]]
    e.next # => [2, [6, 7, 8]]
    e.next # => [3, [9, 10]]

Method `chunk` is especially useful for an enumerable that is already sorted.
This example counts words for each initial letter in a large array of words:

    # Get sorted words from a web page.
    url = 'https://raw.githubusercontent.com/eneko/data-repository/master/data/words.txt'
    words = URI::open(url).readlines
    # Make chunks, one for each letter.
    e = words.chunk {|word| word.upcase[0] } # => #<Enumerator: ...>
    # Display 'A' through 'F'.
    e.each {|c, words| p [c, words.length]; break if c == 'F' }

Output:

    ["A", 17096]
    ["B", 11070]
    ["C", 19901]
    ["D", 10896]
    ["E", 8736]
    ["F", 6860]

You can use the special symbol `:_alone` to force an element into its own
separate chuck:

    a = [0, 0, 1, 1]
    e = a.chunk{|i| i.even? ? :_alone : true }
    e.to_a # => [[:_alone, [0]], [:_alone, [0]], [true, [1, 1]]]

For example, you can put each line that contains a URL into its own chunk:

    pattern = /http/
    open(filename) { |f|
      f.chunk { |line| line =~ pattern ? :_alone : true }.each { |key, lines|
        pp lines
      }
    }

You can use the special symbol `:_separator` or `nil` to force an element to
be ignored (not included in any chunk):

    a = [0, 0, -1, 1, 1]
    e = a.chunk{|i| i < 0 ? :_separator : true }
    e.to_a # => [[true, [0, 0]], [true, [1, 1]]]

Note that the separator does end the chunk:

    a = [0, 0, -1, 1, -1, 1]
    e = a.chunk{|i| i < 0 ? :_separator : true }
    e.to_a # => [[true, [0, 0]], [true, [1]], [true, [1]]]

For example, the sequence of hyphens in svn log can be eliminated as follows:

    sep = "-"*72 + "\n"
    IO.popen("svn log README") { |f|
      f.chunk { |line|
        line != sep || nil
      }.each { |_, lines|
        pp lines
      }
    }
    #=> ["r20018 | knu | 2008-10-29 13:20:42 +0900 (Wed, 29 Oct 2008) | 2 lines\n",
    #    "\n",
    #    "* README, README.ja: Update the portability section.\n",
    #    "\n"]
    #   ["r16725 | knu | 2008-05-31 23:34:23 +0900 (Sat, 31 May 2008) | 2 lines\n",
    #    "\n",
    #    "* README, README.ja: Add a note about default C flags.\n",
    #    "\n"]
    #   ...

Paragraphs separated by empty lines can be parsed as follows:

    File.foreach("README").chunk { |line|
      /\A\s*\z/ !~ line || nil
    }.each { |_, lines|
      pp lines
    }

;T;0;;;I"
chunk;F;I"Enumerable;T;[o;;I" ;F;I"+Enumerator[[ U, ::Array[Elem] ], void];To;;I" ;F;I"EEnumerator[Elem, ::Enumerator[[ untyped, ::Array[Elem] ], void]];To;;I"ªThe returned Enumerator uses the block to partition elements into arrays
("chunks"); it calls the block with each element and its successor; begins a
new chunk if and only if the block returns a truthy value:

Example:

    a = [1, 2, 4, 9, 10, 11, 12, 15, 16, 19, 20, 21]
    e = a.chunk_while {|i, j| j == i + 1 }
    e.each {|array| p array }

Output:

    [1, 2]
    [4]
    [9, 10, 11, 12]
    [15, 16]
    [19, 20, 21]

;T;0;;;I"chunk_while;F;I"Enumerable;T;[o;;I" ;F;I"$Enumerator[::Array[Elem], void];To;;I"mThe returned enumerator uses the block to partition elements into arrays
("slices"); it calls the block with each element and its successor; begins a
new slice if and only if the block returns a truthy value:

    a = [0, 1, 2, 4, 5, 6, 8, 9]
    e = a.slice_when {|i, j| j != i + 1 }
    e.each {|array| p array }

Output:

    [0, 1, 2]
    [4, 5, 6]
    [8, 9]

;T;0;;;I"slice_when;F;I"Enumerable;T;[o;;I" ;F;I"$Enumerator[::Array[Elem], void];To;;I"ïWith argument `pattern`, returns an enumerator that uses the pattern to
partition elements into arrays ("slices"). An element ends the current slice
if `element === pattern`:

    a = %w[foo bar fop for baz fob fog bam foy]
    e = a.slice_after(/ba/) # => #<Enumerator: ...>
    e.each {|array| p array }

Output:

    ["foo", "bar"]
    ["fop", "for", "baz"]
    ["fob", "fog", "bam"]
    ["foy"]

With a block, returns an enumerator that uses the block to partition elements
into arrays. An element ends the current slice if its block return is a truthy
value:

    e = (1..20).slice_after {|i| i % 4 == 2 } # => #<Enumerator: ...>
    e.each {|array| p array }

Output:

    [1, 2]
    [3, 4, 5, 6]
    [7, 8, 9, 10]
    [11, 12, 13, 14]
    [15, 16, 17, 18]
    [19, 20]

Other methods of the Enumerator class and Enumerable module, such as `map`,
etc., are also usable.

For example, continuation lines (lines end with backslash) can be concatenated
as follows:

    lines = ["foo\n", "bar\\\n", "baz\n", "\n", "qux\n"]
    e = lines.slice_after(/(?<!\\)\n\z/)
    p e.to_a
    #=> [["foo\n"], ["bar\\\n", "baz\n"], ["\n"], ["qux\n"]]
    p e.map {|ll| ll[0...-1].map {|l| l.sub(/\\\n\z/, "") }.join + ll.last }
    #=>["foo\n", "barbaz\n", "\n", "qux\n"]

;T;0;;;I"slice_after;F;I"Enumerable;T;[o;;I"untyped pattern;T;I"$Enumerator[::Array[Elem], void];To;;I" ;F;I"$Enumerator[::Array[Elem], void];To;;I"With argument `pattern`, returns an enumerator that uses the pattern to
partition elements into arrays ("slices"). An element begins a new slice if
`element === pattern` (or if it is the first element).

    a = %w[foo bar fop for baz fob fog bam foy]
    e = a.slice_before(/ba/) # => #<Enumerator: ...>
    e.each {|array| p array }

Output:

    ["foo"]
    ["bar", "fop", "for"]
    ["baz", "fob", "fog"]
    ["bam", "foy"]

With a block, returns an enumerator that uses the block to partition elements
into arrays. An element begins a new slice if its block return is a truthy
value (or if it is the first element):

    e = (1..20).slice_before {|i| i % 4 == 2 } # => #<Enumerator: ...>
    e.each {|array| p array }

Output:

    [1]
    [2, 3, 4, 5]
    [6, 7, 8, 9]
    [10, 11, 12, 13]
    [14, 15, 16, 17]
    [18, 19, 20]

Other methods of the Enumerator class and Enumerable module, such as `to_a`,
`map`, etc., are also usable.

For example, iteration over ChangeLog entries can be implemented as follows:

    # iterate over ChangeLog entries.
    open("ChangeLog") { |f|
      f.slice_before(/\A\S/).each { |e| pp e }
    }

    # same as above.  block is used instead of pattern argument.
    open("ChangeLog") { |f|
      f.slice_before { |line| /\A\S/ === line }.each { |e| pp e }
    }

"svn proplist -R" produces multiline output for each file. They can be chunked
as follows:

    IO.popen([{"LC_ALL"=>"C"}, "svn", "proplist", "-R"]) { |f|
      f.lines.slice_before(/\AProp/).each { |lines| p lines }
    }
    #=> ["Properties on '.':\n", "  svn:ignore\n", "  svk:merge\n"]
    #   ["Properties on 'goruby.c':\n", "  svn:eol-style\n"]
    #   ["Properties on 'complex.c':\n", "  svn:mime-type\n", "  svn:eol-style\n"]
    #   ["Properties on 'regparse.c':\n", "  svn:eol-style\n"]
    #   ...

If the block needs to maintain state over multiple elements, local variables
can be used. For example, three or more consecutive increasing numbers can be
squashed as follows (see `chunk_while` for a better way):

    a = [0, 2, 3, 4, 6, 7, 9]
    prev = a[0]
    p a.slice_before { |e|
      prev, prev2 = e, prev
      prev2 + 1 != e
    }.map { |es|
      es.length <= 2 ? es.join(",") : "#{es.first}-#{es.last}"
    }.join(",")
    #=> "0,2-4,6,7,9"

However local variables should be used carefully if the result enumerator is
enumerated twice or more. The local variables should be initialized for each
enumeration. Enumerator.new can be used to do it.

    # Word wrapping.  This assumes all characters have same width.
    def wordwrap(words, maxwidth)
      Enumerator.new {|y|
        # cols is initialized in Enumerator.new.
        cols = 0
        words.slice_before { |w|
          cols += 1 if cols != 0
          cols += w.length
          if maxwidth < cols
            cols = w.length
            true
          else
            false
          end
        }.each {|ws| y.yield ws }
      }
    end
    text = (1..20).to_a.join(" ")
    enum = wordwrap(text.split(/\s+/), 10)
    puts "-"*10
    enum.each { |ws| puts ws.join(" ") } # first enumeration.
    puts "-"*10
    enum.each { |ws| puts ws.join(" ") } # second enumeration generates same result as the first.
    puts "-"*10
    #=> ----------
    #   1 2 3 4 5
    #   6 7 8 9 10
    #   11 12 13
    #   14 15 16
    #   17 18 19
    #   20
    #   ----------
    #   1 2 3 4 5
    #   6 7 8 9 10
    #   11 12 13
    #   14 15 16
    #   17 18 19
    #   20
    #   ----------

mbox contains series of mails which start with Unix From line. So each mail
can be extracted by slice before Unix From line.

    # parse mbox
    open("mbox") { |f|
      f.slice_before { |line|
        line.start_with? "From "
      }.each { |mail|
        unix_from = mail.shift
        i = mail.index("\n")
        header = mail[0...i]
        body = mail[(i+1)..-1]
        body.pop if body.last == "\n"
        fields = header.slice_before { |line| !" \t".include?(line[0]) }.to_a
        p unix_from
        pp fields
        pp body
      }
    }

    # split mails in mbox (slice before Unix From line after an empty line)
    open("mbox") { |f|
      emp = true
      f.slice_before { |line|
        prevemp = emp
        emp = line == "\n"
        prevemp && line.start_with?("From ")
      }.each { |mail|
        mail.pop if mail.last == "\n"
        pp mail
      }
    }

;T;0;;;I"slice_before;F;I"Enumerable;T;[o;;I"untyped pattern;T;I"$Enumerator[::Array[Elem], void];To;;I" ;F;I"$Enumerator[::Array[Elem], void];To;;0;0;	I"Enumerable;T;
[ ;[ ;0;[ ;[ o;;I"pMakes a set from the enumerable object with given arguments.
Needs to `require "set"` to use this method.

;T;0;;;I"to_set;F;I"Enumerable;T;[o;;I" ;F;I"Set[Elem];To; ;I"Å	A class which allows both internal and external iteration.

An Enumerator can be created by the following methods.
*   Object#to_enum
*   Object#enum_for
*   Enumerator.new


Most methods have two forms: a block form where the contents are evaluated for
each item in the enumeration, and a non-block form which returns a new
Enumerator wrapping the iteration.

    enumerator = %w(one two three).each
    puts enumerator.class # => Enumerator

    enumerator.each_with_object("foo") do |item, obj|
      puts "#{obj}: #{item}"
    end

    # foo: one
    # foo: two
    # foo: three

    enum_with_obj = enumerator.each_with_object("foo")
    puts enum_with_obj.class # => Enumerator

    enum_with_obj.each do |item, obj|
      puts "#{obj}: #{item}"
    end

    # foo: one
    # foo: two
    # foo: three

This allows you to chain Enumerators together.  For example, you can map a
list's elements to strings containing the index and the element as a string
via:

    puts %w[foo bar baz].map.with_index { |w, i| "#{i}:#{w}" }
    # => ["0:foo", "1:bar", "2:baz"]

An Enumerator can also be used as an external iterator. For example,
Enumerator#next returns the next value of the iterator or raises StopIteration
if the Enumerator is at the end.

    e = [1,2,3].each   # returns an enumerator object.
    puts e.next   # => 1
    puts e.next   # => 2
    puts e.next   # => 3
    puts e.next   # raises StopIteration

Note that enumeration sequence by `next`, `next_values`, `peek` and
`peek_values` do not affect other non-external enumeration methods, unless the
underlying iteration method itself has side-effect, e.g. IO#each_line.

Moreover, implementation typically uses fibers so performance could be slower
and exception stacktraces different than expected.

You can use this to implement an internal iterator as follows:

    def ext_each(e)
      while true
        begin
          vs = e.next_values
        rescue StopIteration
          return $!.result
        end
        y = yield(*vs)
        e.feed y
      end
    end

    o = Object.new

    def o.each
      puts yield
      puts yield(1)
      puts yield(1, 2)
      3
    end

    # use o.each as an internal iterator directly.
    puts o.each {|*x| puts x; [:b, *x] }
    # => [], [:b], [1], [:b, 1], [1, 2], [:b, 1, 2], 3

    # convert o.each to an external iterator for
    # implementing an internal iterator.
    puts ext_each(o.to_enum) {|*x| puts x; [:b, *x] }
    # => [], [:b], [1], [:b, 1], [1, 2], [:b, 1, 2], 3

;T;0;	I"Enumerator;T;
[ ;[I"Enumerable;T;0;[ ;[ ;0;I"Object;To;;I"bIterates over the block according to how this Enumerator was constructed. If
no block and no arguments are given, returns self.

### Examples

    "Hello, world!".scan(/\w+/)                     #=> ["Hello", "world"]
    "Hello, world!".to_enum(:scan, /\w+/).to_a      #=> ["Hello", "world"]
    "Hello, world!".to_enum(:scan).each(/\w+/).to_a #=> ["Hello", "world"]

    obj = Object.new

    def obj.each_arg(a, b=:b, *rest)
      yield a
      yield b
      yield rest
      :method_returned
    end

    enum = obj.to_enum :each_arg, :a, :x

    enum.each.to_a                  #=> [:a, :x, []]
    enum.each.equal?(enum)          #=> true
    enum.each { |elm| elm }         #=> :method_returned

    enum.each(:y, :z).to_a          #=> [:a, :x, [:y, :z]]
    enum.each(:y, :z).equal?(enum)  #=> false
    enum.each(:y, :z) { |elm| elm } #=> :method_returned

;T;0;;;I"	each;F;I"Enumerator;T;[o;;I" ;F;I"Return;Fo;;I" ;F;I"	self;To;;I"„Sets the value to be returned by the next yield inside `e`.

If the value is not set, the yield returns nil.

This value is cleared after being yielded.

    # Array#map passes the array's elements to "yield" and collects the
    # results of "yield" as an array.
    # Following example shows that "next" returns the passed elements and
    # values passed to "feed" are collected as an array which can be
    # obtained by StopIteration#result.
    e = [1,2,3].map
    p e.next           #=> 1
    e.feed "a"
    p e.next           #=> 2
    e.feed "b"
    p e.next           #=> 3
    e.feed "c"
    begin
      e.next
    rescue StopIteration
      p $!.result      #=> ["a", "b", "c"]
    end

    o = Object.new
    def o.each
      x = yield         # (2) blocks
      p x               # (5) => "foo"
      x = yield         # (6) blocks
      p x               # (8) => nil
      x = yield         # (9) blocks
      p x               # not reached w/o another e.next
    end

    e = o.to_enum
    e.next              # (1)
    e.feed "foo"        # (3)
    e.next              # (4)
    e.next              # (7)
                        # (10)

;T;0;;;I"	feed;F;I"Enumerator;T;[o;;I"Elem arg0;T;I"NilClass;To;;I"HCreates a new Enumerator object, which can be used as an Enumerable.

Iteration is defined by the given block, in which a "yielder" object, given as
block parameter, can be used to yield a value by calling the `yield` method
(aliased as `<<`):

    fib = Enumerator.new do |y|
      a = b = 1
      loop do
        y << a
        a, b = b, a + b
      end
    end

    fib.take(10) # => [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]

The optional parameter can be used to specify how to calculate the size in a
lazy fashion (see Enumerator#size). It can either be a value or a callable
object.

;T;0;;;I"initialize;F;I"Enumerator;T;[o;;I"?::Integer arg0;T;I"	void;To;;I"*Creates a printable version of *e*.

;T;0;;;I"inspect;F;I"Enumerator;T;[o;;I" ;F;I"String;To;;I"YReturns the next object in the enumerator, and move the internal position
forward.  When the position reached at the end, StopIteration is raised.

### Example

    a = [1,2,3]
    e = a.to_enum
    p e.next   #=> 1
    p e.next   #=> 2
    p e.next   #=> 3
    p e.next   #raises StopIteration

See class-level notes about external iterators.

;T;0;;;I"	next;F;I"Enumerator;T;[o;;I" ;F;I"	Elem;Fo;;I"uReturns the next object as an array in the enumerator, and move the internal
position forward.  When the position reached at the end, StopIteration is
raised.

See class-level notes about external iterators.

This method can be used to distinguish `yield` and `yield nil`.

### Example

    o = Object.new
    def o.each
      yield
      yield 1
      yield 1, 2
      yield nil
      yield [1, 2]
    end
    e = o.to_enum
    p e.next_values
    p e.next_values
    p e.next_values
    p e.next_values
    p e.next_values
    e = o.to_enum
    p e.next
    p e.next
    p e.next
    p e.next
    p e.next

    ## yield args       next_values      next
    #  yield            []               nil
    #  yield 1          [1]              1
    #  yield 1, 2       [1, 2]           [1, 2]
    #  yield nil        [nil]            nil
    #  yield [1, 2]     [[1, 2]]         [1, 2]

;T;0;;;I"next_values;F;I"Enumerator;T;[o;;I" ;F;I"Array[Elem];To;;I"¡Returns the next object in the enumerator, but doesn't move the internal
position forward.  If the position is already at the end, StopIteration is
raised.

See class-level notes about external iterators.

### Example

    a = [1,2,3]
    e = a.to_enum
    p e.next   #=> 1
    p e.peek   #=> 2
    p e.peek   #=> 2
    p e.peek   #=> 2
    p e.next   #=> 2
    p e.next   #=> 3
    p e.peek   #raises StopIteration

;T;0;;;I"	peek;F;I"Enumerator;T;[o;;I" ;F;I"	Elem;Fo;;I"-Returns the next object as an array, similar to Enumerator#next_values, but
doesn't move the internal position forward.  If the position is already at the
end, StopIteration is raised.

See class-level notes about external iterators.

### Example

    o = Object.new
    def o.each
      yield
      yield 1
      yield 1, 2
    end
    e = o.to_enum
    p e.peek_values    #=> []
    e.next
    p e.peek_values    #=> [1]
    p e.peek_values    #=> [1]
    e.next
    p e.peek_values    #=> [1, 2]
    e.next
    p e.peek_values    # raises StopIteration

;T;0;;;I"peek_values;F;I"Enumerator;T;[o;;I" ;F;I"Array[Elem];To;;I"~Rewinds the enumeration sequence to the beginning.

If the enclosed object responds to a "rewind" method, it is called.

;T;0;;;I"rewind;F;I"Enumerator;T;[o;;I" ;F;I"	self;To;;I"ÎReturns the size of the enumerator, or `nil` if it can't be calculated lazily.

    (1..100).to_a.permutation(4).size # => 94109400
    loop.size # => Float::INFINITY
    (1..100).drop_while.size # => nil

;T;0;;;I"	size;F;I"Enumerator;T;[o;;I" ;F;I"(::Integer | ::Float)?;To;;I"ÞIterates the given block for each element with an index, which starts from
`offset`.  If no block is given, returns a new Enumerator that includes the
index, starting from `offset`

`offset`
:   the starting index to use

;T;0;;;I"with_index;F;I"Enumerator;T;[o;;I"?::Integer offset;T;I"Return;Fo;;I"?::Integer offset;T;I",Enumerator[[ Elem, ::Integer ], Return];To;;I"²Iterates the given block for each element with an arbitrary object, `obj`, and
returns `obj`

If no block is given, returns a new Enumerator.

### Example

    to_three = Enumerator.new do |y|
      3.times do |x|
        y << x
      end
    end

    to_three_with_string = to_three.with_object("foo")
    to_three_with_string.each do |x,string|
      puts "#{string}: #{x}"
    end

    # => foo: 0
    # => foo: 1
    # => foo: 2

;T;0;;;I"with_object;F;I"Enumerator;T;[o;;I"
U obj;T;I"U;Fo;;I"
U obj;T;I"Enumerator[[ Elem, U ], U];To; ;I"Generator

;T;0;	I"Enumerator::Generator;T;
[ ;[I"Enumerable;T;0;[ ;[ ;0;I"Object;To;;0;0;;;I"	each;F;I"Enumerator::Generator;T;[o;;I" ;F;I"	void;To; ;I"	Enumerator::Lazy is a special type of Enumerator, that allows constructing
chains of operations without evaluating them immediately, and evaluating
values on as-needed basis. In order to do so it redefines most of Enumerable
methods so that they just construct another lazy enumerator.

Enumerator::Lazy can be constructed from any Enumerable with the
Enumerable#lazy method.

    lazy = (1..Float::INFINITY).lazy.select(&:odd?).drop(10).take_while { |i| i < 30 }
    # => #<Enumerator::Lazy: #<Enumerator::Lazy: #<Enumerator::Lazy: #<Enumerator::Lazy: 1..Infinity>:select>:drop(10)>:take_while>

The real enumeration is performed when any non-redefined Enumerable method is
called, like Enumerable#first or Enumerable#to_a (the latter is aliased as
#force for more semantic code):

    lazy.first(2)
    #=> [21, 23]

    lazy.force
    #=> [21, 23, 25, 27, 29]

Note that most Enumerable methods that could be called with or without a
block, on Enumerator::Lazy will always require a block:

    [1, 2, 3].map       #=> #<Enumerator: [1, 2, 3]:map>
    [1, 2, 3].lazy.map  # ArgumentError: tried to call lazy map without a block

This class allows idiomatic calculations on long or infinite sequences, as
well as chaining of calculations without constructing intermediate arrays.

Example for working with a slowly calculated sequence:

    require 'open-uri'

    # This will fetch all URLs before selecting
    # necessary data
    URLS.map { |u| JSON.parse(URI.open(u).read) }
      .select { |data| data.key?('stats') }
      .first(5)

    # This will fetch URLs one-by-one, only till
    # there is enough data to satisfy the condition
    URLS.lazy.map { |u| JSON.parse(URI.open(u).read) }
      .select { |data| data.key?('stats') }
      .first(5)

Ending a chain with ".eager" generates a non-lazy enumerator, which is
suitable for returning or passing to another method that expects a normal
enumerator.

    def active_items
      groups
        .lazy
        .flat_map(&:items)
        .reject(&:disabled)
        .eager
    end

    # This works lazily; if a checked item is found, it stops
    # iteration and does not look into remaining groups.
    first_checked = active_items.find(&:checked)

    # This returns an array of items like a normal enumerator does.
    all_checked = active_items.select(&:checked)

;T;0;	I"Enumerator::Lazy;T;
[ ;[ ;0;[ ;[ ;0;I"Enumerator;To;;I"JLike Enumerable#compact, but chains operation to be lazy-evaluated.

;T;0;;;I"compact;F;I"Enumerator::Lazy;T;[o;;I" ;F;I"#Enumerator::Lazy[Elem, Return];To; ;I"Yielder

;T;0;	I"Enumerator::Yielder;T;
[ ;[ ;0;[ ;[ ;0;I"Object;To;;0;0;;;I"<<;F;I"Enumerator::Yielder;T;[o;;I"untyped arg0;T;I"	void;To;;0;0;;;I"
yield;F;I"Enumerator::Yielder;T;[o;;I"*untyped arg0;T;I"	void;To;;I"/Returns a Proc object that takes arguments and yields them.

This method is implemented so that a Yielder object can be directly passed to
another method as a block argument.

    enum = Enumerator.new { |y|
      Dir.glob("*.rb") { |file|
        File.open(file) { |f| f.each_line(&y) }
      }
    }

;T;0;;;I"to_proc;F;I"Enumerator::Yielder;T;[o;;I" ;F;I"	Proc;To; ;I"ÆEnumerator::Chain is a subclass of Enumerator, which represents a chain of
enumerables that works as a single enumerator.

This type of objects can be created by Enumerable#chain and Enumerator#+.

;T;0;	I"Enumerator::Chain;T;
[ ;[I"Enumerable;T;0;[ ;[ ;0;I"Enumerator;To;;I"Iterates over the elements of the first enumerable by calling the "each"
method on it with the given arguments, then proceeds to the following
enumerables in sequence until all of the enumerables are exhausted.

If no block is given, returns an enumerator.

;T;0;;;I"	each;F;I"Enumerator::Chain;T;[o;;I" ;F;I"	void;To;;I"ëRuby exception objects are subclasses of Exception.  However, operating
systems typically report errors using plain integers. Module Errno is created
dynamically to map these operating system errors to Ruby classes, with each
error number generating its own subclass of SystemCallError.  As the subclass
is created in module Errno, its name will start `Errno::`.

The names of the `Errno::` classes depend on the environment in which Ruby
runs. On a typical Unix or Windows platform, there are Errno classes such as
Errno::EACCES, Errno::EAGAIN, Errno::EINTR, and so on.

The integer operating system error number corresponding to a particular error
is available as the class constant `Errno::`*error*`::Errno`.

    Errno::EACCES::Errno   #=> 13
    Errno::EAGAIN::Errno   #=> 11
    Errno::EINTR::Errno    #=> 4

The full list of operating system errors on your particular platform are
available as the constants of Errno.

    Errno.constants   #=> :E2BIG, :EACCES, :EADDRINUSE, :EADDRNOTAVAIL, ...

;T;0;	I"
Errno;T;
[ ;[ ;0;[ ;[ o; ;0;0;	I"Errno::E2BIG;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EACCES;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EADDRINUSE;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EADDRNOTAVAIL;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EADV;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EAFNOSUPPORT;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EAGAIN;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EALREADY;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EAUTH;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EBADE;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EBADF;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EBADFD;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EBADMSG;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EBADR;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EBADRPC;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EBADRQC;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EBADSLT;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EBFONT;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EBUSY;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ECANCELED;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ECAPMODE;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ECHILD;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ECHRNG;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ECOMM;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;I"aClient sent TCP reset (RST) before server has accepted the connection
requested by client.

;T;0;	I"Errno::ECONNABORTED;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ECONNREFUSED;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;I"0Remote host reset the connection request.

;T;0;	I"Errno::ECONNRESET;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EDEADLK;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EDEADLOCK;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EDESTADDRREQ;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EDOM;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EDOOFUS;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EDOTDOT;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EDQUOT;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EEXIST;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EFAULT;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EFBIG;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EFTYPE;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EHOSTDOWN;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EHOSTUNREACH;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EHWPOISON;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EIDRM;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EILSEQ;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EINPROGRESS;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EINTR;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EINVAL;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EIO;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EIPSEC;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EISCONN;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EISDIR;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EISNAM;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EKEYEXPIRED;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EKEYREJECTED;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EKEYREVOKED;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EL2HLT;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EL2NSYNC;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EL3HLT;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EL3RST;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ELIBACC;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ELIBBAD;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ELIBEXEC;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ELIBMAX;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ELIBSCN;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ELNRNG;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ELOOP;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EMEDIUMTYPE;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EMFILE;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EMLINK;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EMSGSIZE;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EMULTIHOP;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ENAMETOOLONG;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ENAVAIL;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ENEEDAUTH;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ENETDOWN;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ENETRESET;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ENETUNREACH;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ENFILE;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ENOANO;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ENOATTR;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ENOBUFS;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ENOCSI;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ENODATA;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ENODEV;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ENOENT;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ENOEXEC;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ENOKEY;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ENOLCK;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ENOLINK;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ENOMEDIUM;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ENOMEM;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ENOMSG;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ENONET;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ENOPKG;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ENOPROTOOPT;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ENOSPC;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ENOSR;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ENOSTR;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ENOSYS;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ENOTBLK;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ENOTCAPABLE;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ENOTCONN;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ENOTDIR;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ENOTEMPTY;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ENOTNAM;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ENOTRECOVERABLE;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ENOTSOCK;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ENOTSUP;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ENOTTY;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ENOTUNIQ;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ENXIO;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EOPNOTSUPP;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EOVERFLOW;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EOWNERDEAD;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EPERM;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EPFNOSUPPORT;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EPIPE;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EPROCLIM;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EPROCUNAVAIL;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EPROGMISMATCH;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EPROGUNAVAIL;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;I"Protocol error.

;T;0;	I"Errno::EPROTO;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EPROTONOSUPPORT;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EPROTOTYPE;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ERANGE;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EREMCHG;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EREMOTE;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EREMOTEIO;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ERESTART;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ERFKILL;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EROFS;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ERPCMISMATCH;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ESHUTDOWN;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ESOCKTNOSUPPORT;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ESPIPE;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ESRCH;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ESRMNT;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ESTALE;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ESTRPIPE;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ETIME;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ETIMEDOUT;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ETOOMANYREFS;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::ETXTBSY;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EUCLEAN;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EUNATCH;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EUSERS;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EWOULDBLOCK;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EXDEV;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;0;0;	I"Errno::EXFULL;T;
[ ;[ ;0;[ ;[ ;0;I"SystemCallError;To; ;I"„Raised when the arguments are wrong and there isn't a more specific Exception
class.

Ex: passing the wrong number of arguments

    [1, 2, 3].first(4, 5)

*raises the exception:*

    ArgumentError: wrong number of arguments (given 2, expected 1)

Ex: passing an argument that is not acceptable:

    [1, 2, 3].first(-4)

*raises the exception:*

    ArgumentError: negative array size

;T;0;	I"ArgumentError;T;
[ ;[ ;0;[ ;[ ;0;I"StandardError;To; ;I"‚The exception class which will be raised when pushing into a closed Queue.
See Thread::Queue#close and Thread::SizedQueue#close.

;T;0;	I"ClosedQueueError;T;
[ ;[ ;0;[ ;[ ;0;I"StopIteration;To; ;I";EncodingError is the base class for encoding errors.

;T;0;	I"EncodingError;T;
[ ;[ ;0;[ ;[ ;0;I"StandardError;To; ;I"_Raised by some IO operations when reaching the end of file. Many IO methods
exist in two forms,

one that returns `nil` when the end of file is reached, the other raises
`EOFError`.

`EOFError` is a subclass of `IOError`.

    file = File.open("/etc/hosts")
    file.read
    file.gets     #=> nil
    file.readline #=> EOFError: end of file reached

;T;0;	I"EOFError;T;
[ ;[ ;0;[ ;[ ;0;I"IOError;To; ;I"ÆRaised when attempting to convert special float values (in particular
`Infinity` or `NaN`) to numerical classes which don't support them.

    Float::INFINITY.to_r   #=> FloatDomainError: Infinity

;T;0;	I"FloatDomainError;T;
[ ;[ ;0;[ ;[ ;0;I"RangeError;To; ;I"œRaised when there is an attempt to modify a frozen object.

    [1, 2, 3].freeze << 4

*raises the exception:*

    FrozenError: can't modify frozen Array

;T;0;	I"FrozenError;T;
[ ;[ ;0;[ ;[ ;0;I"RuntimeError;To;;I"åConstruct a new FrozenError exception. If given the *receiver* parameter may
subsequently be examined using the FrozenError#receiver method.

    a = [].freeze
    raise FrozenError.new("can't modify frozen array", receiver: a)

;T;0;;;I"initialize;F;I"FrozenError;T;[o;;I""?::string? msg, ?receiver: T?;T;I"	void;To;;I"FReturn the receiver associated with this FrozenError exception.

;T;0;;;I"receiver;F;I"FrozenError;T;[o;;I" ;F;I"T?;To; ;I"»Raised when the given index is invalid.

    a = [:foo, :bar]
    a.fetch(0)   #=> :foo
    a[4]         #=> nil
    a.fetch(4)   #=> IndexError: index 4 outside of array bounds: -2...2

;T;0;	I"IndexError;T;
[ ;[ ;0;[ ;[ ;0;I"StandardError;To; ;I"Raised when the interrupt signal is received, typically because the user has
pressed Control-C (on most posix platforms). As such, it is a subclass of
`SignalException`.

    begin
      puts "Press ctrl-C when you get bored"
      loop {}
    rescue Interrupt => e
      puts "Note: You will typically use Signal.trap instead."
    end

*produces:*

    Press ctrl-C when you get bored

*then waits until it is interrupted with Control-C and then prints:*

    Note: You will typically use Signal.trap instead.

;T;0;	I"Interrupt;T;
[ ;[ ;0;[ ;[ ;0;I"SignalException;To;;0;0;;;I"initialize;F;I"Interrupt;T;[o;;I"?::string;T;I"	void;To; ;I"˜Raised when an IO operation fails.

    File.open("/etc/hosts") {|f| f << "example"}
      #=> IOError: not opened for writing

    File.open("/etc/hosts") {|f| f.close; f.read }
      #=> IOError: closed stream

Note that some IO failures raise `SystemCallError`s and these are not
subclasses of IOError:

    File.open("does/not/exist")
      #=> Errno::ENOENT: No such file or directory - does/not/exist

;T;0;	I"IOError;T;
[ ;[ ;0;[ ;[ ;0;I"StandardError;To; ;I"¸Raised when the specified key is not found. It is a subclass of IndexError.

    h = {"foo" => :bar}
    h.fetch("foo") #=> :bar
    h.fetch("baz") #=> KeyError: key not found: "baz"

;T;0;	I"KeyError;T;
[ ;[ ;0;[ ;[ ;0;I"IndexError;To;;I"UConstruct a new `KeyError` exception with the given message, receiver and key.

;T;0;;;I"initialize;F;I"KeyError;T;[o;;I"+?::string msg, ?receiver: R?, ?key: K?;T;I"	void;To;;I"5Return the key caused this KeyError exception.

;T;0;;;I"key;F;I"KeyError;T;[o;;I" ;F;I"K?;To;;I"CReturn the receiver associated with this KeyError exception.

;T;0;;;I"receiver;F;I"KeyError;T;[o;;I" ;F;I"R?;To; ;0;0;	I"KeyError;T;
[ ;[ ;0;[ ;[I"DidYouMean::Correctable;T;0;0o; ;I"ÖRaised when a file required (a Ruby script, extension library, ...) fails to
load.

    require 'this/file/does/not/exist'

*raises the exception:*

    LoadError: no such file to load -- this/file/does/not/exist

;T;0;	I"LoadError;T;
[ ;[ ;0;[ ;[ ;0;I"ScriptError;To;;I"the path failed to load

;T;0;;;I"	path;F;I"LoadError;T;[o;;I" ;F;I"String?;To; ;0;0;	I"LoadError;T;
[ ;[ ;0;[ ;[I"DidYouMean::Correctable;T;0;0o; ;I"Raised when Ruby can't yield as requested.

A typical scenario is attempting to yield when no block is given:

    def call_block
      yield 42
    end
    call_block

*raises the exception:*

    LocalJumpError: no block given (yield)

A more subtle example:

    def get_me_a_return
      Proc.new { return 42 }
    end
    get_me_a_return.call

*raises the exception:*

    LocalJumpError: unexpected return

;T;0;	I"LocalJumpError;T;
[ ;[ ;0;[ ;[ ;0;I"StandardError;To;;I"DReturns the exit value associated with this `LocalJumpError`.

;T;0;;;I"exit_value;F;I"LocalJumpError;T;[o;;I" ;F;I"untyped;To;;I"aThe reason this block was terminated: :break, :redo, :retry, :next, :return,
or :noreason.

;T;0;;;I"reason;F;I"LocalJumpError;T;[o;;I" ;F;I"Symbol;To; ;I";Raised when a given name is invalid or undefined.

    puts foo

*raises the exception:*

    NameError: undefined local variable or method `foo' for main:Object

Since constant names must start with a capital:

    Integer.const_set :answer, 42

*raises the exception:*

    NameError: wrong constant name answer

;T;0;	I"NameError;T;
[ ;[ ;0;[ ;[ ;0;I"StandardError;To;;I"‹Construct a new NameError exception. If given the *name* parameter may
subsequently be examined using the NameError#name method. *receiver* parameter
allows to pass object in context of which the error happened. Example:

    [1, 2, 3].method(:rject) # NameError with name "rject" and receiver: Array
    [1, 2, 3].singleton_method(:rject) # NameError with name "rject" and receiver: [1, 2, 3]

;T;0;;;I"initialize;F;I"NameError;T;[o;;I"2?::string msg, ?::String? name, ?receiver: T?;T;I"	void;To;;I"wReturn a list of the local variable names defined where this NameError
exception was raised.

Internal use only.

;T;0;;;I"local_variables;F;I"NameError;T;[o;;I" ;F;I"Array[::Symbol];To;;I"@Return the name associated with this NameError exception.

;T;0;;;I"	name;F;I"NameError;T;[o;;I" ;F;I"String?;To;;I"DReturn the receiver associated with this NameError exception.

;T;0;;;I"receiver;F;I"NameError;T;[o;;I" ;F;I"T?;To; ;0;0;	I"NameError;T;
[ ;[ ;0;[ ;[I"DidYouMean::Correctable;T;0;0o; ;0;0;	I"NoMatchingPatternError;T;
[ ;[ ;0;[ ;[ ;0;I"StandardError;To; ;0;0;	I"NoMatchingPatternKeyError;T;
[ ;[ ;0;[ ;[ ;0;I"NoMatchingPatternError;To;;I"eConstruct a new `NoMatchingPatternKeyError` exception with the given message,
matchee and key.

;T;0;;;I"initialize;F;I"NoMatchingPatternKeyError;T;[o;;I"*?::string message, matchee: M, key: K;T;I"	void;To;;I"SReturn the matchee associated with this NoMatchingPatternKeyError exception.

;T;0;;;I"matchee;F;I"NoMatchingPatternKeyError;T;[o;;I" ;F;I"M;Fo;;I"FReturn the key caused this NoMatchingPatternKeyError exception.

;T;0;;;I"key;F;I"NoMatchingPatternKeyError;T;[o;;I" ;F;I"K;Fo; ;I"+Raised when memory allocation fails.

;T;0;	I"NoMemoryError;T;
[ ;[ ;0;[ ;[ ;0;I"Exception;To; ;I"ëRaised when a method is called on a receiver which doesn't have it defined and
also fails to respond with `method_missing`.

    "hello".to_ary

*raises the exception:*

    NoMethodError: undefined method `to_ary' for "hello":String

;T;0;	I"NoMethodError;T;
[ ;[ ;0;[ ;[ ;0;I"NameError;To;;I"°Construct a NoMethodError exception for a method of the given name called with
the given arguments. The name may be accessed using the `#name` method on the
resulting object, and the arguments using the `#args` method.

If *private* argument were passed, it designates method was attempted to call
in private context, and can be accessed with `#private_call?` method.

*receiver* argument stores an object whose method was called.

;T;0;;;I"initialize;F;I"NoMethodError;T;[o;;I"a?::string? msg, ?::String? name, ?::Array[untyped] args, ?::boolish `private`, ?receiver: T?;T;I"	void;To;;I"PReturn the arguments passed in as the third parameter to the constructor.

;T;0;;;I"	args;F;I"NoMethodError;T;[o;;I" ;F;I"Array[untyped];To;;I">Return true if the caused method was called as private.

;T;0;;;I"private_call?;F;I"NoMethodError;T;[o;;I" ;F;I"	bool;To; ;I"KRaised when a feature is not implemented on the current platform. For example,
methods depending on the `fsync` or `fork` system calls may raise this
exception if the underlying operating system or Ruby runtime does not support
them.

Note that if `fork` raises a `NotImplementedError`, then `respond_to?(:fork)`
returns `false`.

;T;0;	I"NotImplementedError;T;
[ ;[ ;0;[ ;[ ;0;I"ScriptError;To; ;I"¤Raised when a given numerical value is out of range.

    [1, 2, 3].drop(1 << 100)

*raises the exception:*

    RangeError: bignum too big to convert into `long'

;T;0;	I"RangeError;T;
[ ;[ ;0;[ ;[ ;0;I"StandardError;To; ;I"¡Raised when given an invalid regexp expression.

    Regexp.new("?")

*raises the exception:*

    RegexpError: target of repeat operator is not specified: /?/

;T;0;	I"RegexpError;T;
[ ;[ ;0;[ ;[ ;0;I"StandardError;To; ;I"ÔA generic error class raised when an invalid operation is attempted.
Kernel#raise will raise a RuntimeError if no Exception class is specified.

    raise "ouch"

*raises the exception:*

    RuntimeError: ouch

;T;0;	I"RuntimeError;T;
[ ;[ ;0;[ ;[ ;0;I"StandardError;To; ;I"*ScriptError is the superclass for errors raised when a script can not be
executed because of a `LoadError`, `NotImplementedError` or a `SyntaxError`.
Note these type of `ScriptErrors` are not `StandardError` and will not be
rescued unless it is specified explicitly (or its ancestor `Exception`).

;T;0;	I"ScriptError;T;
[ ;[ ;0;[ ;[ ;0;I"Exception;To; ;I"'No longer used by internal code.

;T;0;	I"SecurityError;T;
[ ;[ ;0;[ ;[ ;0;I"Exception;To; ;I"Raised when a signal is received.

    begin
      Process.kill('HUP',Process.pid)
      sleep # wait for receiver to handle signal sent by Process.kill
    rescue SignalException => e
      puts "received Exception #{e}"
    end

*produces:*

    received Exception SIGHUP

;T;0;	I"SignalException;T;
[ ;[ ;0;[ ;[ ;0;I"Exception;To;;I"YConstruct a new SignalException object.  `sig_name` should be a known signal
name.

;T;0;;;I"initialize;F;I"SignalException;T;[o;;I"?::string sig_name;T;I"	void;To;;I")::int sig_number, ?::string sig_name;T;I"	void;To;;0;0;;;I"
signm;F;I"SignalException;T;[o;;I" ;F;I"String;To;;I"Returns a signal number.

;T;0;;;I"
signo;F;I"SignalException;T;[o;;I" ;F;I"Integer;To; ;I"€The most standard error types are subclasses of StandardError. A rescue clause
without an explicit Exception class will rescue all StandardErrors (and only
those).

    def foo
      raise "Oups"
    end
    foo rescue "Hello"   #=> "Hello"

On the other hand:

    require 'does/not/exist' rescue "Hi"

*raises the exception:*

    LoadError: no such file to load -- does/not/exist

;T;0;	I"StandardError;T;
[ ;[ ;0;[ ;[ ;0;I"Exception;To; ;I"çRaised to stop the iteration, in particular by Enumerator#next. It is rescued
by Kernel#loop.

    loop do
      puts "Hello"
      raise StopIteration
      puts "World"
    end
    puts "Done!"

*produces:*

    Hello
    Done!

;T;0;	I"StopIteration;T;
[ ;[ ;0;[ ;[ ;0;I"IndexError;To;;I"Returns the return value of the iterator.

    o = Object.new
    def o.each
      yield 1
      yield 2
      yield 3
      100
    end

    e = o.to_enum

    puts e.next                   #=> 1
    puts e.next                   #=> 2
    puts e.next                   #=> 3

    begin
      e.next
    rescue StopIteration => ex
      puts ex.result              #=> 100
    end

;T;0;;;I"result;F;I"StopIteration;T;[o;;I" ;F;I"untyped;To; ;I"±Raised when encountering Ruby code with an invalid syntax.

    eval("1+1=2")

*raises the exception:*

    SyntaxError: (eval):1: syntax error, unexpected '=', expecting $end

;T;0;	I"SyntaxError;T;
[ ;[ ;0;[ ;[ ;0;I"ScriptError;To;;I")Construct a SyntaxError exception.

;T;0;;;I"initialize;F;I"SyntaxError;T;[o;;I"?::string msg;T;I"	void;To; ;I">SystemCallError is the base class for all low-level platform-dependent errors.

The errors available on the current platform are subclasses of SystemCallError
and are defined in the Errno module.

    File.open("does/not/exist")

*raises the exception:*

    Errno::ENOENT: No such file or directory - does/not/exist

;T;0;	I"SystemCallError;T;
[ ;[ ;0;[ ;[ ;0;I"StandardError;To;;I"æIf *errno* corresponds to a known system error code, constructs the
appropriate Errno class for that error, otherwise constructs a generic
SystemCallError object. The error number is subsequently available via the
#errno method.

;T;0;;;I"initialize;F;I"SystemCallError;T;[o;;I""::string msg, ::Integer errno;T;I"SystemCallError;To;;I"}Return `true` if the receiver is a generic `SystemCallError`, or if the error
numbers `self` and *other* are the same.

;T;0;;;I"===;F;I"SystemCallError;T;[o;;I"untyped other;T;I"	bool;To;;I"2Return this SystemCallError's error number.

;T;0;;;I"
errno;F;I"SystemCallError;T;[o;;I" ;F;I"Integer;To; ;I"BRaised by `exit` to initiate the termination of the script.

;T;0;	I"SystemExit;T;
[ ;[ ;0;[ ;[ ;0;I"Exception;To;;I"”Create a new `SystemExit` exception with the given status and message. Status
is true, false, or an integer. If status is not given, true is used.

;T;0;;;I"initialize;F;I"SystemExit;T;[o;;I" ;F;I"	void;To;;I"::string msg;T;I"	void;To;;I"/true | false | ::int status, ?::string msg;T;I"	void;To;;I"@Return the status value associated with this system exit.

;T;0;;;I"status;F;I"SystemExit;T;[o;;I" ;F;I"Integer;To;;I"<Returns `true` if exiting successful, `false` if not.

;T;0;;;I"success?;F;I"SystemExit;T;[o;;I" ;F;I"	bool;To; ;I"µRaised in case of a stack overflow.

    def me_myself_and_i
      me_myself_and_i
    end
    me_myself_and_i

*raises the exception:*

    SystemStackError: stack level too deep

;T;0;	I"SystemStackError;T;
[ ;[ ;0;[ ;[ ;0;I"Exception;To; ;I"øRaised when an invalid operation is attempted on a thread.

For example, when no other thread has been started:

    Thread.stop

This will raises the following exception:

    ThreadError: stopping only thread
    note: use sleep to stop forever

;T;0;	I"ThreadError;T;
[ ;[ ;0;[ ;[ ;0;I"StandardError;To; ;I"¹Raised when encountering an object that is not of the expected type.

    [1, 2, 3].first("two")

*raises the exception:*

    TypeError: no implicit conversion of String into Integer

;T;0;	I"TypeError;T;
[ ;[ ;0;[ ;[ ;0;I"StandardError;To; ;I"¼Raised when `throw` is called with a *tag* which does not have corresponding
`catch` block.

    throw "foo", "bar"

*raises the exception:*

    UncaughtThrowError: uncaught throw "foo"

;T;0;	I"UncaughtThrowError;T;
[ ;[ ;0;[ ;[ ;0;I"ArgumentError;To;;I"àDocument-class: UncaughtThrowError

Raised when `throw` is called with a *tag* which does not have corresponding
`catch` block.

    throw "foo", "bar"

*raises the exception:*

    UncaughtThrowError: uncaught throw "foo"

;T;0;;;I"initialize;F;I"UncaughtThrowError;T;[o;;I"untyped tag, untyped value;T;I"	void;To;;I"2Return the tag object which was called for.

;T;0;;;I"tag;F;I"UncaughtThrowError;T;[o;;I" ;F;I"untyped;To;;I"8Returns formatted message with the inspected tag.

;T;0;;;I"	to_s;F;I"UncaughtThrowError;T;[o;;I" ;F;I"String;To;;I"4Return the return value which was called for.

;T;0;;;I"
value;F;I"UncaughtThrowError;T;[o;;I" ;F;I"untyped;To; ;I"Raised when attempting to divide an integer by 0.

    42 / 0   #=> ZeroDivisionError: divided by 0

Note that only division by an exact 0 will raise the exception:

    42 /  0.0   #=> Float::INFINITY
    42 / -0.0   #=> -Float::INFINITY
    0  /  0.0   #=> NaN

;T;0;	I"ZeroDivisionError;T;
[ ;[ ;0;[ ;[ ;0;I"StandardError;To; ;I"q	Class Exception and its subclasses are used to communicate between
Kernel#raise and `rescue` statements in `begin ... end` blocks.

An Exception object carries information about an exception:
*   Its type (the exception's class).
*   An optional descriptive message.
*   Optional backtrace information.


Some built-in subclasses of Exception have additional methods: e.g.,
NameError#name.

## Defaults

Two Ruby statements have default exception classes:
*   `raise`: defaults to RuntimeError.
*   `rescue`: defaults to StandardError.


## Global Variables

When an exception has been raised but not yet handled (in `rescue`, `ensure`,
`at_exit` and `END` blocks), two global variables are set:
*   `$!` contains the current exception.
*   `$@` contains its backtrace.


## Custom Exceptions

To provide additional or alternate information, a program may create custom
exception classes that derive from the built-in exception classes.

A good practice is for a library to create a single "generic" exception class
(typically a subclass of StandardError or RuntimeError) and have its other
exception classes derive from that class. This allows the user to rescue the
generic exception, thus catching all exceptions the library may raise even if
future versions of the library add new exception subclasses.

For example:

    class MyLibrary
      class Error < ::StandardError
      end

      class WidgetError < Error
      end

      class FrobError < Error
      end

    end

To handle both MyLibrary::WidgetError and MyLibrary::FrobError the library
user can rescue MyLibrary::Error.

## Built-In Exception Classes

The built-in subclasses of Exception are:

*   NoMemoryError
*   ScriptError
    *   LoadError
    *   NotImplementedError
    *   SyntaxError

*   SecurityError
*   SignalException
    *   Interrupt

*   StandardError
    *   ArgumentError
        *   UncaughtThrowError

    *   EncodingError
    *   FiberError
    *   IOError
        *   EOFError

    *   IndexError
        *   KeyError
        *   StopIteration
            *   ClosedQueueError


    *   LocalJumpError
    *   NameError
        *   NoMethodError

    *   RangeError
        *   FloatDomainError

    *   RegexpError
    *   RuntimeError
        *   FrozenError

    *   SystemCallError
        *   Errno::*

    *   ThreadError
    *   TypeError
    *   ZeroDivisionError

*   SystemExit
*   SystemStackError
*   fatal

;T;0;	I"Exception;T;
[ ;[ ;0;[ ;[ ;0;I"Object;To;;I"BReturns `true` if exception messages will be sent to a tty.

;T;0;;;I"to_tty?;F;I"Exception;T;[o;;I" ;F;I"	bool;To;;I"ÑWith no argument, or if the argument is the same as the receiver, return the
receiver. Otherwise, create a new exception object of the same class as the
receiver, but with a message equal to `string.to_str`.

;T;0;;;I"exception;F;I"Exception;T;[o;;I"?::String msg;T;I"Exception;To;;I"“Equality---If *obj* is not an Exception, returns `false`. Otherwise, returns
`true` if *exc* and *obj* share same class, messages, and backtrace.

;T;0;;;I"==;F;I"Exception;T;[o;;I"untyped arg0;T;I"	bool;To;;I"Returns any backtrace associated with the exception. The backtrace is an array
of strings, each containing either ``filename:lineNo: in `method''' or
``filename:lineNo.''

    def a
      raise "boom"
    end

    def b
      a()
    end

    begin
      b()
    rescue => detail
      print detail.backtrace.join("\n")
    end

*produces:*

    prog.rb:2:in `a'
    prog.rb:6:in `b'
    prog.rb:10

In the case no backtrace has been set, `nil` is returned

    ex = StandardError.new
    ex.backtrace
    #=> nil

;T;0;;;I"backtrace;F;I"Exception;T;[o;;I" ;F;I"Array[::String]?;To;;I"ÞReturns any backtrace associated with the exception. This method is similar to
Exception#backtrace, but the backtrace is an array of
Thread::Backtrace::Location.

This method is not affected by Exception#set_backtrace().

;T;0;;;I"backtrace_locations;F;I"Exception;T;[o;;I" ;F;I"*Array[::Thread::Backtrace::Location]?;To;;I"¥Returns the previous exception ($!) at the time this exception was raised.
This is useful for wrapping exceptions and retaining the original exception
information.

;T;0;;;I"
cause;F;I"Exception;T;[o;;I" ;F;I"Exception?;To;;I"ÑWith no argument, or if the argument is the same as the receiver, return the
receiver. Otherwise, create a new exception object of the same class as the
receiver, but with a message equal to `string.to_str`.

;T;0;;;I"exception;F;I"Exception;T;[o;;I" ;F;I"	self;To;;I"::String arg0;T;I"Exception;To;;I"IConstruct a new Exception object, optionally passing in a message.

;T;0;;;I"initialize;F;I"Exception;T;[o;;I"?::String arg0;T;I"	void;To;;I"6Return this exception's class name and message.

;T;0;;;I"inspect;F;I"Exception;T;[o;;I" ;F;I"String;To;;I"nReturns the result of invoking `exception.to_s`. Normally this returns the
exception's message or name.

;T;0;;;I"message;F;I"Exception;T;[o;;I" ;F;I"String;To;;I"­Sets the backtrace information associated with `exc`. The `backtrace` must be
an array of String objects or a single String in the format described in
Exception#backtrace.

;T;0;;;I"set_backtrace;F;I"Exception;T;[o;;I"&::String | ::Array[::String] arg0;T;I"Array[::String];To;;I"nil;T;I"nil;To;;I"WReturns exception's message (or the name of the exception if no message is
set).

;T;0;;;I"	to_s;F;I"Exception;T;[o;;I" ;F;I"String;To;;I"ÞReturns formatted string of *exception*. The returned string is formatted
using the same format that Ruby uses when printing an uncaught exceptions to
stderr.

If *highlight* is `true` the default error handler will send the messages to a
tty.

*order* must be either of `:top` or `:bottom`, and places the error message
and the innermost backtrace come at the top or the bottom.

The default values of these options depend on `$stderr` and its `tty?` at the
timing of a call.

;T;0;;;I"full_message;F;I"Exception;T;[o;;I"-?highlight: bool, ?order: :top | :bottom;T;I"String;To; ;0;0;	I"Exception;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"|Deserializes JSON string by constructing new Exception object with message `m`
and backtrace `b` serialized with `to_json`

;T;0;;;I"json_create;F;I"Exception;T;[o;;I"@::Hash[::String, ::String | ::Array[::String] | nil] object;T;I"instance;To;;I"XReturns a hash, that will be turned into a JSON object and represent this
object.

;T;0;;;I"as_json;F;I"Exception;T;[o;;I"*untyped;T;I"7Hash[::String, ::String | ::Array[::String] | nil];To;;I"\Stores class name (Exception) with message `m` and backtrace array `b` as JSON
string

;T;0;;;I"to_json;F;I"Exception;T;[o;;I"?::JSON::State state;T;I"String;To; ;I"áThe global value `false` is the only instance of class FalseClass and
represents a logically false value in boolean expressions. The class provides
operators allowing `false` to participate correctly in logical expressions.

;T;0;	I"FalseClass;T;
[ ;[ ;0;[ ;[ ;0;0o;;0;0;;;I"!;F;I"FalseClass;T;[o;;I" ;F;I"	true;Fo;;I"ŽAnd---Returns `false`. *obj* is always evaluated as it is the argument to a
method call---there is no short-circuit evaluation in this case.

;T;0;;;I"&;F;I"FalseClass;T;[o;;I"untyped obj;T;I"
false;Fo;;I"©Case Equality -- For class Object, effectively the same as calling `#==`, but
typically overridden by descendants to provide meaningful semantics in `case`
statements.

;T;0;;;I"===;F;I"FalseClass;T;[o;;I"
false;T;I"	true;Fo;;I"untyped obj;T;I"
false;Fo;;I"_Exclusive Or---If *obj* is `nil` or `false`, returns `false`; otherwise,
returns `true`.

;T;0;;;I"^;F;I"FalseClass;T;[o;;I"nil;T;I"
false;Fo;;I"
false;T;I"
false;Fo;;I"untyped obj;T;I"	true;Fo;;I"7The string representation of `false` is "false".

;T;0;;;I"	to_s;F;I"FalseClass;T;[o;;I" ;F;I""false";To;;I"KOr---Returns `false` if *obj* is `nil` or `false`; `true` otherwise.

;T;0;;;I"|;F;I"FalseClass;T;[o;;I"nil;T;I"
false;Fo;;I"
false;T;I"
false;Fo;;I"untyped obj;T;I"	true;Fo;;0;0;;;I"
clone;F;I"FalseClass;T;[o;;I"?freeze: true?;T;I"	self;To; ;0;0;	I"FalseClass;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"0Returns a JSON string for false: 'false'.

;T;0;;;I"to_json;F;I"FalseClass;T;[o;;I"?::JSON::State state;T;I"String;To; ;I"1
Fibers are primitives for implementing light weight cooperative concurrency in
Ruby. Basically they are a means of creating code blocks that can be paused
and resumed, much like threads. The main difference is that they are never
preempted and that the scheduling must be done by the programmer and not the
VM.

As opposed to other stackless light weight concurrency models, each fiber
comes with a stack.  This enables the fiber to be paused from deeply nested
function calls within the fiber block.  See the ruby(1) manpage to configure
the size of the fiber stack(s).

When a fiber is created it will not run automatically. Rather it must be
explicitly asked to run using the Fiber#resume method. The code running inside
the fiber can give up control by calling Fiber.yield in which case it yields
control back to caller (the caller of the Fiber#resume).

Upon yielding or termination the Fiber returns the value of the last executed
expression

For instance:

    fiber = Fiber.new do
      Fiber.yield 1
      2
    end

    puts fiber.resume
    puts fiber.resume
    puts fiber.resume

*produces*

    1
    2
    FiberError: dead fiber called

The Fiber#resume method accepts an arbitrary number of parameters, if it is
the first call to #resume then they will be passed as block arguments.
Otherwise they will be the return value of the call to Fiber.yield

Example:

    fiber = Fiber.new do |first|
      second = Fiber.yield first + 2
    end

    puts fiber.resume 10
    puts fiber.resume 1_000_000
    puts fiber.resume "The fiber will be dead before I can cause trouble"

*produces*

    12
    1000000
    FiberError: dead fiber called

## Non-blocking Fibers

The concept of *non-blocking fiber* was introduced in Ruby 3.0. A non-blocking
fiber, when reaching a operation that would normally block the fiber (like
`sleep`, or wait for another process or I/O) will yield control to other
fibers and allow the *scheduler* to handle blocking and waking up (resuming)
this fiber when it can proceed.

For a Fiber to behave as non-blocking, it need to be created in Fiber.new with
`blocking: false` (which is the default), and Fiber.scheduler should be set
with Fiber.set_scheduler. If Fiber.scheduler is not set in the current thread,
blocking and non-blocking fibers' behavior is identical.

Ruby doesn't provide a scheduler class: it is expected to be implemented by
the user and correspond to Fiber::SchedulerInterface.

There is also Fiber.schedule method, which is expected to immediately perform
the given block in a non-blocking manner. Its actual implementation is up to
the scheduler.

;T;0;	I"
Fiber;T;
[ ;[ ;0;[ ;[ ;0;I"Object;To;;I"&Yields control back to the context that resumed the fiber, passing along any
arguments that were passed to it. The fiber will resume processing at this
point when #resume is called next. Any arguments passed to the next #resume
will be the value that this Fiber.yield expression evaluates to.

;T;0;;;I"
yield;F;I"
Fiber;T;[o;;I"*untyped args;T;I"untyped;To;;I"›Creates new Fiber. Initially, the fiber is not running and can be resumed with
#resume. Arguments to the first #resume call will be passed to the block:

    f = Fiber.new do |initial|
       current = initial
       loop do
         puts "current: #{current.inspect}"
         current = Fiber.yield
       end
    end
    f.resume(100)     # prints: current: 100
    f.resume(1, 2, 3) # prints: current: [1, 2, 3]
    f.resume          # prints: current: nil
    # ... and so on ...

If `blocking: false` is passed to `Fiber.new`, *and* current thread has a
Fiber.scheduler defined, the Fiber becomes non-blocking (see "Non-blocking
Fibers" section in class docs).

;T;0;;;I"initialize;F;I"
Fiber;T;[o;;I" ;F;I"	void;To;;I"öResumes the fiber from the point at which the last Fiber.yield was called, or
starts running it if it is the first call to #resume. Arguments passed to
resume will be the value of the Fiber.yield expression or will be passed as
block parameters to the fiber's block if this is the first #resume.

Alternatively, when resume is called it evaluates to the arguments passed to
the next Fiber.yield statement inside the fiber's block or to the block value
if it runs to completion without any Fiber.yield

;T;0;;;I"resume;F;I"
Fiber;T;[o;;I"*untyped args;T;I"untyped;To;;I",Raises an exception in the fiber at the point at which the last `Fiber.yield`
was called. If the fiber has not been started or has already run to
completion, raises `FiberError`. If the fiber is yielding, it is resumed. If
it is transferring, it is transferred into. But if it is resuming, raises
`FiberError`.

With no arguments, raises a `RuntimeError`. With a single `String` argument,
raises a `RuntimeError` with the string as a message.  Otherwise, the first
parameter should be the name of an `Exception` class (or an object that
returns an `Exception` object when sent an `exception` message). The optional
second parameter sets the message associated with the exception, and the third
parameter is an array of callback information. Exceptions are caught by the
`rescue` clause of `begin...end` blocks.

;T;0;;;I"
raise;F;I"
Fiber;T;[o;;I" ;F;I"untyped;To;;I"::string message;T;I"untyped;To;;I"L::_Exception exception, ?::string message, ?::Array[::String] backtrace;T;I"untyped;To; ;0;0;	I"
Fiber;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"zReturns the current fiber. If you are not running in the context of a fiber
this method will return the root fiber.

;T;0;;;I"current;F;I"
Fiber;T;[o;;I" ;F;I"
Fiber;To;;I"šReturns true if the fiber can still be resumed (or transferred to). After
finishing execution of the fiber block this method will always return `false`.

;T;0;;;I"alive?;F;I"
Fiber;T;[o;;I" ;F;I"	bool;To;;I"‘Transfer control to another fiber, resuming it from where it last stopped or
starting it if it was not resumed before. The calling fiber will be suspended
much like in a call to Fiber.yield.

The fiber which receives the transfer call treats it much like a resume call.
Arguments passed to transfer are treated like those passed to resume.

The two style of control passing to and from fiber (one is #resume and
Fiber::yield, another is #transfer to and from fiber) can't be freely mixed.

*   If the Fiber's lifecycle had started with transfer, it will never be able
    to yield or be resumed control passing, only finish or transfer back. (It
    still can resume other fibers that are allowed to be resumed.)
*   If the Fiber's lifecycle had started with resume, it can yield or transfer
    to another Fiber, but can receive control back only the way compatible
    with the way it was given away: if it had transferred, it only can be
    transferred back, and if it had yielded, it only can be resumed back.
    After that, it again can transfer or yield.


If those rules are broken FiberError is raised.

For an individual Fiber design, yield/resume is easier to use (the Fiber just
gives away control, it doesn't need to think about who the control is given
to), while transfer is more flexible for complex cases, allowing to build
arbitrary graphs of Fibers dependent on each other.

Example:

    manager = nil # For local var to be visible inside worker block

    # This fiber would be started with transfer
    # It can't yield, and can't be resumed
    worker = Fiber.new { |work|
      puts "Worker: starts"
      puts "Worker: Performed #{work.inspect}, transferring back"
      # Fiber.yield     # this would raise FiberError: attempt to yield on a not resumed fiber
      # manager.resume  # this would raise FiberError: attempt to resume a resumed fiber (double resume)
      manager.transfer(work.capitalize)
    }

    # This fiber would be started with resume
    # It can yield or transfer, and can be transferred
    # back or resumed
    manager = Fiber.new {
      puts "Manager: starts"
      puts "Manager: transferring 'something' to worker"
      result = worker.transfer('something')
      puts "Manager: worker returned #{result.inspect}"
      # worker.resume    # this would raise FiberError: attempt to resume a transferring fiber
      Fiber.yield        # this is OK, the fiber transferred from and to, now it can yield
      puts "Manager: finished"
    }

    puts "Starting the manager"
    manager.resume
    puts "Resuming the manager"
    # manager.transfer  # this would raise FiberError: attempt to transfer to a yielding fiber
    manager.resume

*produces*

    Starting the manager
    Manager: starts
    Manager: transferring 'something' to worker
    Worker: starts
    Worker: Performed "something", transferring back
    Manager: worker returned "Something"
    Resuming the manager
    Manager: finished

;T;0;;;I"transfer;F;I"
Fiber;T;[o;;I"*untyped;T;I"untyped;To; ;I"'Raised when an invalid operation is attempted on a Fiber, in particular when
attempting to call/resume a dead fiber, attempting to yield from the root
fiber, or calling a fiber across threads.

    fiber = Fiber.new{}
    fiber.resume #=> nil
    fiber.resume #=> FiberError: dead fiber called

;T;0;	I"FiberError;T;
[ ;[ ;0;[ ;[ ;0;I"StandardError;To; ;I"™!A File is an abstraction of any file object accessible by the program and is
closely associated with class IO.  File includes the methods of module
FileTest as class methods, allowing you to write (for example)
`File.exist?("foo")`.

In the description of File methods, *permission bits* are a platform-specific
set of bits that indicate permissions of a file. On Unix-based systems,
permissions are viewed as a set of three octets, for the owner, the group, and
the rest of the world. For each of these entities, permissions may be set to
read, write, or execute the file:

The permission bits `0644` (in octal) would thus be interpreted as read/write
for owner, and read-only for group and other. Higher-order bits may also be
used to indicate the type of file (plain, directory, pipe, socket, and so on)
and various other special features. If the permissions are for a directory,
the meaning of the execute bit changes; when set the directory can be
searched.

On non-Posix operating systems, there may be only the ability to make a file
read-only or read-write. In this case, the remaining permission bits will be
synthesized to resemble typical values. For instance, on Windows NT the
default permission bits are `0644`, which means read/write for owner,
read-only for all others. The only change that can be made is to make the file
read-only, which is reported as `0444`.

Various constants for the methods in File can be found in File::Constants.

## What's Here

First, what's elsewhere. Class File:

*   Inherits from [class IO](IO.html#class-IO-label-What-27s+Here), in
    particular, methods for creating, reading, and writing files
*   Includes [module
    FileTest](FileTest.html#module-FileTest-label-What-27s+Here). which
    provides dozens of additional methods.


Here, class File provides methods that are useful for:

*   [Creating](#class-File-label-Creating)
*   [Querying](#class-File-label-Querying)
*   [Settings](#class-File-label-Settings)
*   [Other](#class-File-label-Other)


### Creating

    ::new
:       Opens the file at the given path; returns the file.

    ::open
:       Same as ::new, but when given a block will yield the file to the
        block, and close the file upon exiting the block.

    ::link
:       Creates a new name for an existing file using a hard link.

    ::mkfifo
:       Returns the FIFO file created at the given path.

    ::symlink
:       Creates a symbolic link for the given file path.



### Querying

*Paths*

    ::absolute_path
:       Returns the absolute file path for the given path.

    ::absolute_path?
:       Returns whether the given path is the absolute file path.

    ::basename
:       Returns the last component of the given file path.

    ::dirname
:       Returns all but the last component of the given file path.

    ::expand_path
:       Returns the absolute file path for the given path, expanding `~` for a
        home directory.

    ::extname
:       Returns the file extension for the given file path.

    ::fnmatch? (aliased as ::fnmatch)
:       Returns whether the given file path matches the given pattern.

    ::join
:       Joins path components into a single path string.

    ::path
:       Returns the string representation of the given path.

    ::readlink
:       Returns the path to the file at the given symbolic link.

    ::realdirpath
:       Returns the real path for the given file path, where the last
        component need not exist.

    ::realpath
:       Returns the real path for the given file path, where all components
        must exist.

    ::split
:       Returns an array of two strings: the directory name and basename of
        the file at the given path.

    #path (aliased as #to_path)
:       Returns the string representation of the given path.



*Times*

    ::atime
:       Returns a Time for the most recent access to the given file.

    ::birthtime
:       Returns a Time  for the creation of the given file.

    ::ctime
:       Returns a Time  for the metadata change of the given file.

    ::mtime
:       Returns a Time for the most recent data modification to the content of
        the given file.

    #atime
:       Returns a Time for the most recent access to `self`.

    #birthtime
:       Returns a Time  the creation for `self`.

    #ctime
:       Returns a Time for the metadata change of `self`.

    #mtime
:       Returns a Time for the most recent data modification to the content of
        `self`.



*Types*

    ::blockdev?
:       Returns whether the file at the given path is a block device.

    ::chardev?
:       Returns whether the file at the given path is a character device.

    ::directory?
:       Returns whether the file at the given path is a diretory.

    ::executable?
:       Returns whether the file at the given path is executable by the
        effective user and group of the current process.

    ::executable_real?
:       Returns whether the file at the given path is executable by the real
        user and group of the current process.

    ::exist?
:       Returns whether the file at the given path exists.

    ::file?
:       Returns whether the file at the given path is a regular file.

    ::ftype
:       Returns a string giving the type of the file at the given path.

    ::grpowned?
:       Returns whether the effective group of the current process owns the
        file at the given path.

    ::identical?
:       Returns whether the files at two given paths are identical.

    ::lstat
:       Returns the File::Stat object for the last symbolic link in the given
        path.

    ::owned?
:       Returns whether the effective user of the current process owns the
        file at the given path.

    ::pipe?
:       Returns whether the file at the given path is a pipe.

    ::readable?
:       Returns whether the file at the given path is readable by the
        effective user and group of the current process.

    ::readable_real?
:       Returns whether the file at the given path is readable by the real
        user and group of the current process.

    ::setgid?
:       Returns whether the setgid bit is set for the file at the given path.

    ::setuid?
:       Returns whether the setuid bit is set for the file at the given path.

    ::socket?
:       Returns whether the file at the given path is a socket.

    ::stat
:       Returns the File::Stat object for the file at the given path.

    ::sticky?
:       Returns whether the file at the given path has its sticky bit set.

    ::symlink?
:       Returns whether the file at the given path is a symbolic link.

    ::umask
:       Returns the umask value for the current process.

    ::world_readable?
:       Returns whether the file at the given path is readable by others.

    ::world_writable?
:       Returns whether the file at the given path is writable by others.

    ::writable?
:       Returns whether the file at the given path is writable by the
        effective user and group of the current process.

    ::writable_real?
:       Returns whether the file at the given path is writable by the real
        user and group of the current process.

    #lstat
:       Returns the File::Stat object for the last symbolic link in the path
        for `self`.



*Contents*

    ::empty? (aliased as ::zero?)
:       Returns whether the file at the given path exists and is empty.

    ::size
:       Returns the size (bytes) of the file at the given path.

    ::size?
:       Returns `nil` if there is no file at the given path, or if that file
        is empty; otherwise returns the file size (bytes).

    #size
:       Returns the size (bytes) of `self`.



### Settings

    ::chmod
:       Changes permissions of the file at the given path.

    ::chown
:       Change ownership of the file at the given path.

    ::lchmod
:       Changes permissions of the last symbolic link in the given path.

    ::lchown
:       Change ownership of the last symbolic in the given path.

    ::lutime
:       For each given file path, sets the access time and modification time
        of the last symbolic link in the path.

    ::rename
:       Moves the file at one given path to another given path.

    ::utime
:       Sets the access time and modification time of each file at the given
        paths.

    #flock
:       Locks or unlocks `self`.



### Other

    ::truncate
:       Truncates the file at the given file path to the given size.

    ::unlink (aliased as ::delete)
:       Deletes the file for each given file path.

    #truncate
:       Truncates `self` to the given size.

;T;0;	I"	File;T;
[ ;[ ;0;[ ;[ ;0;I"IO;To;;I"†Opens the file named by `filename` according to the given `mode` and returns a
new File object.

See IO.new for a description of `mode` and `opt`.

If a file is being created, permission bits may be given in `perm`.  These
mode and permission bits are platform dependent; on Unix systems, see open(2)
and chmod(2) man pages for details.

The new File object is buffered mode (or non-sync mode), unless `filename` is
a tty. See IO#flush, IO#fsync, IO#fdatasync, and IO#sync= about sync mode.

### Examples

    f = File.new("testfile", "r")
    f = File.new("newfile",  "w+")
    f = File.new("newfile", File::CREAT|File::TRUNC|File::RDWR, 0644)

;T;0;;;I"initialize;F;I"	File;T;[o;;I"P::string | ::_ToPath | ::int file_name, ?::string | ::int mode, ?::int perm;T;I"	File;To;;I"ŠConverts a pathname to an absolute pathname. Relative paths are referenced
from the current working directory of the process unless *dir_string* is
given, in which case it will be used as the starting point. If the given
pathname starts with a ```~`'' it is NOT expanded, it is treated as a normal
directory name.

    File.absolute_path("~oracle/bin")       #=> "<relative_path>/~oracle/bin"

;T;0;;;I"absolute_path;F;I"	File;T;[o;;I"E::string | ::_ToPath file_name, ?::string | ::_ToPath dir_string;T;I"String;To;;I"šReturns `true` if `file_name` is an absolute path, and `false` otherwise.

    File.absolute_path?("c:/foo")     #=> false (on Linux), true (on Windows)

;T;0;;;I"absolute_path?;F;I"	File;T;[o;;I"#::string | ::_ToPath file_name;T;I"	bool;To;;I"¤Returns the last access time for the named file as a Time object.

*file_name* can be an IO object.

    File.atime("testfile")   #=> Wed Apr 09 08:51:48 CDT 2003

;T;0;;;I"
atime;F;I"	File;T;[o;;I"*::string | ::_ToPath | ::IO file_name;T;I"	Time;To;;I"6Returns the last component of the filename given in *file_name* (after first
stripping trailing separators), which can be formed using both File::SEPARATOR
and File::ALT_SEPARATOR as the separator when File::ALT_SEPARATOR is not
`nil`. If *suffix* is given and present at the end of *file_name*, it is
removed. If *suffix* is ".*", any extension will be removed.

    File.basename("/home/gumby/work/ruby.rb")          #=> "ruby.rb"
    File.basename("/home/gumby/work/ruby.rb", ".rb")   #=> "ruby"
    File.basename("/home/gumby/work/ruby.rb", ".*")    #=> "ruby"

;T;0;;;I"basename;F;I"	File;T;[o;;I"5::string | ::_ToPath file_name, ?::string suffix;T;I"String;To;;I" ;T;0;;;I"birthtime;F;I"	File;T;[o;;I"*::string | ::_ToPath | ::IO file_name;T;I"	Time;To;;I"\Returns `true` if the named file is a block device.

*file_name* can be an IO object.

;T;0;;;I"blockdev?;F;I"	File;T;[o;;I"*::string | ::_ToPath | ::IO file_name;T;I"	bool;To;;I"`Returns `true` if the named file is a character device.

*file_name* can be an IO object.

;T;0;;;I"chardev?;F;I"	File;T;[o;;I"*::string | ::_ToPath | ::IO file_name;T;I"	bool;To;;I"4Changes permission bits on the named file(s) to the bit pattern represented by
*mode_int*. Actual effects are operating system dependent (see the beginning
of this section). On Unix systems, see `chmod(2)` for details. Returns the
number of files processed.

    File.chmod(0644, "testfile", "out")   #=> 2

;T;0;;;I"
chmod;F;I"	File;T;[o;;I"0::int mode, *::string | ::_ToPath file_name;T;I"Integer;To;;I"€Changes the owner and group of the named file(s) to the given numeric owner
and group id's. Only a process with superuser privileges may change the owner
of a file. The current owner of a file may change the file's group to any
group to which the owner belongs. A `nil` or -1 owner or group id is ignored.
Returns the number of files processed.

    File.chown(nil, 100, "testfile")

;T;0;;;I"
chown;F;I"	File;T;[o;;I"@::int? owner, ::int? group, *::string | ::_ToPath file_name;T;I"Integer;To;;I"*Returns the change time for the named file (the time at which directory
information about the file was changed, not the file itself).

*file_name* can be an IO object.

Note that on Windows (NTFS), returns creation time (birth time).

    File.ctime("testfile")   #=> Wed Apr 09 08:53:13 CDT 2003

;T;0;;;I"
ctime;F;I"	File;T;[o;;I"*::string | ::_ToPath | ::IO file_name;T;I"	Time;To;;I"®Returns `true` if the named file is a directory, or a symlink that points at a
directory, and `false` otherwise.

*file_name* can be an IO object.

    File.directory?(".")

;T;0;;;I"directory?;F;I"	File;T;[o;;I"%::string | ::_ToPath | ::IO path;T;I"	bool;To;;I"Returns all components of the filename given in *file_name* except the last
one (after first stripping trailing separators). The filename can be formed
using both File::SEPARATOR and File::ALT_SEPARATOR as the separator when
File::ALT_SEPARATOR is not `nil`.

    File.dirname("/home/gumby/work/ruby.rb")   #=> "/home/gumby/work"

If `level` is given, removes the last `level` components, not only one.

    File.dirname("/home/gumby/work/ruby.rb", 2) #=> "/home/gumby"
    File.dirname("/home/gumby/work/ruby.rb", 4) #=> "/"

;T;0;;;I"dirname;F;I"	File;T;[o;;I"5::string | ::_ToPath file_name, ?::Integer level;T;I"String;To;;I"«Returns `true` if the named file is executable by the effective user and group
id of this process. See eaccess(3).

Windows does not support execute permissions separately from read permissions.
On Windows, a file is only considered executable if it ends in .bat, .cmd,
.com, or .exe.

Note that some OS-level security features may cause this to return true even
though the file is not executable by the effective user/group.

;T;0;;;I"executable?;F;I"	File;T;[o;;I"#::string | ::_ToPath file_name;T;I"	bool;To;;I" Returns `true` if the named file is executable by the real user and group id
of this process. See access(3).

Windows does not support execute permissions separately from read permissions.
On Windows, a file is only considered executable if it ends in .bat, .cmd,
.com, or .exe.

Note that some OS-level security features may cause this to return true even
though the file is not executable by the real user/group.

;T;0;;;I"executable_real?;F;I"	File;T;[o;;I"#::string | ::_ToPath file_name;T;I"	bool;To;;I"’Return `true` if the named file exists.

*file_name* can be an IO object.

"file exists" means that stat() or fstat() system call is successful.

;T;0;;;I"exist?;F;I"	File;T;[o;;I"*::string | ::_ToPath | ::IO file_name;T;I"	bool;To;;I"àConverts a pathname to an absolute pathname. Relative paths are referenced
from the current working directory of the process unless `dir_string` is
given, in which case it will be used as the starting point. The given pathname
may start with a ```~`'', which expands to the process owner's home directory
(the environment variable `HOME` must be set correctly). ```~`*user*'' expands
to the named user's home directory.

    File.expand_path("~oracle/bin")           #=> "/home/oracle/bin"

A simple example of using `dir_string` is as follows.
    File.expand_path("ruby", "/usr/bin")      #=> "/usr/bin/ruby"

A more complex example which also resolves parent directory is as follows.
Suppose we are in bin/mygem and want the absolute path of lib/mygem.rb.

    File.expand_path("../../lib/mygem.rb", __FILE__)
    #=> ".../path/to/project/lib/mygem.rb"

So first it resolves the parent of __FILE__, that is bin/, then go to the
parent, the root of the project and appends `lib/mygem.rb`.

;T;0;;;I"expand_path;F;I"	File;T;[o;;I"E::string | ::_ToPath file_name, ?::string | ::_ToPath dir_string;T;I"String;To;;I"ÓReturns the extension (the portion of file name in `path` starting from the
last period).

If `path` is a dotfile, or starts with a period, then the starting dot is not
dealt with the start of the extension.

An empty string will also be returned when the period is the last character in
`path`.

On Windows, trailing dots are truncated.

    File.extname("test.rb")         #=> ".rb"
    File.extname("a/b/d/test.rb")   #=> ".rb"
    File.extname(".a/b/d/test.rb")  #=> ".rb"
    File.extname("foo.")            #=> "" on Windows
    File.extname("foo.")            #=> "." on non-Windows
    File.extname("test")            #=> ""
    File.extname(".profile")        #=> ""
    File.extname(".profile.sh")     #=> ".sh"

;T;0;;;I"extname;F;I"	File;T;[o;;I"::string | ::_ToPath path;T;I"String;To;;I"ÖReturns `true` if the named `file` exists and is a regular file.

`file` can be an IO object.

If the `file` argument is a symbolic link, it will resolve the symbolic link
and use the file referenced by the link.

;T;0;;;I"
file?;F;I"	File;T;[o;;I"%::string | ::_ToPath | ::IO file;T;I"	bool;To;;I"ÌReturns true if `path` matches against `pattern`.  The pattern is not a
regular expression; instead it follows rules similar to shell filename
globbing.  It may contain the following metacharacters:

`*`
:   Matches any file. Can be restricted by other values in the glob.
    Equivalent to `/.*/x` in regexp.

    `*`
:       Matches all regular files
    `c*`
:       Matches all files beginning with `c`
    `*c`
:       Matches all files ending with `c`
    `*c*`
:       Matches all files that have `c` in them (including at the beginning or
        end).


    To match hidden files (that start with a `.`) set the File::FNM_DOTMATCH
    flag.

`**`
:   Matches directories recursively or files expansively.

`?`
:   Matches any one character. Equivalent to `/.{1}/` in regexp.

`[set]`
:   Matches any one character in `set`.  Behaves exactly like character sets
    in Regexp, including set negation (`[^a-z]`).

`\`
:   Escapes the next metacharacter.

`{a,b}`
:   Matches pattern a and pattern b if File::FNM_EXTGLOB flag is enabled.
    Behaves like a Regexp union (`(?:a|b)`).


`flags` is a bitwise OR of the `FNM_XXX` constants. The same glob pattern and
flags are used by Dir::glob.

Examples:

    File.fnmatch('cat',       'cat')        #=> true  # match entire string
    File.fnmatch('cat',       'category')   #=> false # only match partial string

    File.fnmatch('c{at,ub}s', 'cats')                    #=> false # { } isn't supported by default
    File.fnmatch('c{at,ub}s', 'cats', File::FNM_EXTGLOB) #=> true  # { } is supported on FNM_EXTGLOB

    File.fnmatch('c?t',     'cat')          #=> true  # '?' match only 1 character
    File.fnmatch('c??t',    'cat')          #=> false # ditto
    File.fnmatch('c*',      'cats')         #=> true  # '*' match 0 or more characters
    File.fnmatch('c*t',     'c/a/b/t')      #=> true  # ditto
    File.fnmatch('ca[a-z]', 'cat')          #=> true  # inclusive bracket expression
    File.fnmatch('ca[^t]',  'cat')          #=> false # exclusive bracket expression ('^' or '!')

    File.fnmatch('cat', 'CAT')                     #=> false # case sensitive
    File.fnmatch('cat', 'CAT', File::FNM_CASEFOLD) #=> true  # case insensitive
    File.fnmatch('cat', 'CAT', File::FNM_SYSCASE)  #=> true or false # depends on the system default

    File.fnmatch('?',   '/', File::FNM_PATHNAME)  #=> false # wildcard doesn't match '/' on FNM_PATHNAME
    File.fnmatch('*',   '/', File::FNM_PATHNAME)  #=> false # ditto
    File.fnmatch('[/]', '/', File::FNM_PATHNAME)  #=> false # ditto

    File.fnmatch('\?',   '?')                       #=> true  # escaped wildcard becomes ordinary
    File.fnmatch('\a',   'a')                       #=> true  # escaped ordinary remains ordinary
    File.fnmatch('\a',   '\a', File::FNM_NOESCAPE)  #=> true  # FNM_NOESCAPE makes '\' ordinary
    File.fnmatch('[\?]', '?')                       #=> true  # can escape inside bracket expression

    File.fnmatch('*',   '.profile')                      #=> false # wildcard doesn't match leading
    File.fnmatch('*',   '.profile', File::FNM_DOTMATCH)  #=> true  # period by default.
    File.fnmatch('.*',  '.profile')                      #=> true

    File.fnmatch('**/*.rb', 'main.rb')                  #=> false
    File.fnmatch('**/*.rb', './main.rb')                #=> false
    File.fnmatch('**/*.rb', 'lib/song.rb')              #=> true
    File.fnmatch('**.rb', 'main.rb')                    #=> true
    File.fnmatch('**.rb', './main.rb')                  #=> false
    File.fnmatch('**.rb', 'lib/song.rb')                #=> true
    File.fnmatch('*',     'dave/.profile')              #=> true

    File.fnmatch('**/foo', 'a/b/c/foo', File::FNM_PATHNAME)     #=> true
    File.fnmatch('**/foo', '/a/b/c/foo', File::FNM_PATHNAME)    #=> true
    File.fnmatch('**/foo', 'c:/a/b/c/foo', File::FNM_PATHNAME)  #=> true
    File.fnmatch('**/foo', 'a/.b/c/foo', File::FNM_PATHNAME)    #=> false
    File.fnmatch('**/foo', 'a/.b/c/foo', File::FNM_PATHNAME | File::FNM_DOTMATCH) #=> true

;T;0;;;I"fnmatch;F;I"	File;T;[o;;I">::string pattern, ::string | ::_ToPath path, ?::int flags;T;I"	bool;To;;I"gIdentifies the type of the named file; the return string is one of ```file`'',
```directory`'', ```characterSpecial`'', ```blockSpecial`'', ```fifo`'',
```link`'', ```socket`'', or ```unknown`''.

    File.ftype("testfile")            #=> "file"
    File.ftype("/dev/tty")            #=> "characterSpecial"
    File.ftype("/tmp/.X11-unix/X0")   #=> "socket"

;T;0;;;I"
ftype;F;I"	File;T;[o;;I"#::string | ::_ToPath file_name;T;I"String;To;;I"³Returns `true` if the named file exists and the effective group id of the
calling process is the owner of the file. Returns `false` on Windows.

*file_name* can be an IO object.

;T;0;;;I"grpowned?;F;I"	File;T;[o;;I"*::string | ::_ToPath | ::IO file_name;T;I"	bool;To;;I"¥Returns `true` if the named files are identical.

*file_1* and *file_2* can be an IO object.

    open("a", "w") {}
    p File.identical?("a", "a")      #=> true
    p File.identical?("a", "./a")    #=> true
    File.link("a", "b")
    p File.identical?("a", "b")      #=> true
    File.symlink("a", "c")
    p File.identical?("a", "c")      #=> true
    open("d", "w") {}
    p File.identical?("a", "d")      #=> false

;T;0;;;I"identical?;F;I"	File;T;[o;;I"K::string | ::_ToPath | ::IO file_1, ::string | ::_ToPath | ::IO file_2;T;I"	bool;To;;I"Returns a new string formed by joining the strings using `"/"`.

    File.join("usr", "mail", "gumby")   #=> "usr/mail/gumby"

;T;0;;;I"	join;F;I"	File;T;[o;;I"*::string;T;I"String;To;;I"·Equivalent to File::chmod, but does not follow symbolic links (so it will
change the permissions associated with the link, not the file referenced by
the link). Often not available.

;T;0;;;I"lchmod;F;I"	File;T;[o;;I"0::int mode, *::string | ::_ToPath file_name;T;I"Integer;To;;I"ßEquivalent to File::chown, but does not follow symbolic links (so it will
change the owner associated with the link, not the file referenced by the
link). Often not available. Returns number of files in the argument list.

;T;0;;;I"lchown;F;I"	File;T;[o;;I"@::int? owner, ::int? group, *::string | ::_ToPath file_name;T;I"Integer;To;;I"*Creates a new name for an existing file using a hard link. Will not overwrite
*new_name* if it already exists (raising a subclass of SystemCallError). Not
available on all platforms.

    File.link("testfile", ".testfile")   #=> 0
    IO.readlines(".testfile")[0]         #=> "This is line one\n"

;T;0;;;I"	link;F;I"	File;T;[o;;I"A::string | ::_ToPath old_name, ::string | ::_ToPath new_name;T;I"0;Fo;;I"1Same as File::stat, but does not follow the last symbolic link. Instead,
reports on the link itself.

    File.symlink("testfile", "link2test")   #=> 0
    File.stat("testfile").size              #=> 66
    File.lstat("link2test").size            #=> 8
    File.stat("link2test").size             #=> 66

;T;0;;;I"
lstat;F;I"	File;T;[o;;I"#::string | ::_ToPath file_name;T;I"File::Stat;To;;I"Sets the access and modification times of each named file to the first two
arguments. If a file is a symlink, this method acts upon the link itself as
opposed to its referent; for the inverse behavior, see File.utime. Returns the
number of file names in the argument list.

;T;0;;;I"lutime;F;I"	File;T;[o;;I"X::Time | ::Numeric atime, ::Time | ::Numeric mtime, *::string | ::_ToPath file_name;T;I"Integer;To;;I"ÏCreates a FIFO special file with name *file_name*.  *mode* specifies the
FIFO's permissions. It is modified by the process's umask in the usual way:
the permissions of the created file are (mode & ~umask).

;T;0;;;I"mkfifo;F;I"	File;T;[o;;I"0::string | ::_ToPath file_name, ?::int mode;T;I"0;Fo;;I"¥Returns the modification time for the named file as a Time object.

*file_name* can be an IO object.

    File.mtime("testfile")   #=> Tue Apr 08 12:58:04 CDT 2003

;T;0;;;I"
mtime;F;I"	File;T;[o;;I"*::string | ::_ToPath | ::IO file_name;T;I"	Time;To;;I"áWith no associated block, File.open is a synonym for File.new. If the optional
code block is given, it will be passed the opened `file` as an argument and
the File object will automatically be closed when the block terminates.  The
value of the block will be returned from File.open.

If a file is being created, its initial permissions may be set using the
`perm` parameter.  See File.new for further discussion.

See IO.new for a description of the `mode` and `opt` parameters.

;T;0;;;I"	open;F;I"	File;T;[o;;I"P::string | ::_ToPath | ::int file_name, ?::string | ::int mode, ?::int perm;T;I"instance;To;;I"P::string | ::_ToPath | ::int file_name, ?::string | ::int mode, ?::int perm;T;I"T;Fo;;I"–Returns `true` if the named file exists and the effective used id of the
calling process is the owner of the file.

*file_name* can be an IO object.

;T;0;;;I"owned?;F;I"	File;T;[o;;I"*::string | ::_ToPath | ::IO file_name;T;I"	bool;To;;I"“Returns the string representation of the path

    File.path("/dev/null")          #=> "/dev/null"
    File.path(Pathname.new("/tmp")) #=> "/tmp"

;T;0;;;I"	path;F;I"	File;T;[o;;I"::string | ::_ToPath path;T;I"String;To;;I"TReturns `true` if the named file is a pipe.

*file_name* can be an IO object.

;T;0;;;I"
pipe?;F;I"	File;T;[o;;I"*::string | ::_ToPath | ::IO file_name;T;I"	bool;To;;I"ýReturns `true` if the named file is readable by the effective user and group
id of this process. See eaccess(3).

Note that some OS-level security features may cause this to return true even
though the file is not readable by the effective user/group.

;T;0;;;I"readable?;F;I"	File;T;[o;;I"#::string | ::_ToPath file_name;T;I"	bool;To;;I"òReturns `true` if the named file is readable by the real user and group id of
this process. See access(3).

Note that some OS-level security features may cause this to return true even
though the file is not readable by the real user/group.

;T;0;;;I"readable_real?;F;I"	File;T;[o;;I"#::string | ::_ToPath file_name;T;I"	bool;To;;I"ÊReturns the name of the file referenced by the given link. Not available on
all platforms.

    File.symlink("testfile", "link2test")   #=> 0
    File.readlink("link2test")              #=> "testfile"

;T;0;;;I"readlink;F;I"	File;T;[o;;I"#::string | ::_ToPath link_name;T;I"String;To;;I"FReturns the real (absolute) pathname of *pathname* in the actual filesystem.
The real pathname doesn't contain symlinks or useless dots.

If *dir_string* is given, it is used as a base directory for interpreting
relative pathname instead of the current directory.

The last component of the real pathname can be nonexistent.

;T;0;;;I"realdirpath;F;I"	File;T;[o;;I"D::string | ::_ToPath pathname, ?::string | ::_ToPath dir_string;T;I"String;To;;I"<Returns the real (absolute) pathname of *pathname* in the actual filesystem
not containing symlinks or useless dots.

If *dir_string* is given, it is used as a base directory for interpreting
relative pathname instead of the current directory.

All components of the pathname must exist when this method is called.

;T;0;;;I"realpath;F;I"	File;T;[o;;I"D::string | ::_ToPath pathname, ?::string | ::_ToPath dir_string;T;I"String;To;;I"Renames the given file to the new name. Raises a SystemCallError if the file
cannot be renamed.

    File.rename("afile", "afile.bak")   #=> 0

;T;0;;;I"rename;F;I"	File;T;[o;;I"A::string | ::_ToPath old_name, ::string | ::_ToPath new_name;T;I"0;Fo;;I"aReturns `true` if the named file has the setgid bit set.

*file_name* can be an IO object.

;T;0;;;I"setgid?;F;I"	File;T;[o;;I"*::string | ::_ToPath | ::IO file_name;T;I"	bool;To;;I"aReturns `true` if the named file has the setuid bit set.

*file_name* can be an IO object.

;T;0;;;I"setuid?;F;I"	File;T;[o;;I"*::string | ::_ToPath | ::IO file_name;T;I"	bool;To;;I"IReturns the size of `file_name`.

*file_name* can be an IO object.

;T;0;;;I"	size;F;I"	File;T;[o;;I"*::string | ::_ToPath | ::IO file_name;T;I"Integer;To;;I"€Returns `nil` if `file_name` doesn't exist or has zero size, the size of the
file otherwise.

*file_name* can be an IO object.

;T;0;;;I"
size?;F;I"	File;T;[o;;I"*::string | ::_ToPath | ::IO file_name;T;I"Integer?;To;;I"VReturns `true` if the named file is a socket.

*file_name* can be an IO object.

;T;0;;;I"socket?;F;I"	File;T;[o;;I"*::string | ::_ToPath | ::IO file_name;T;I"	bool;To;;I"ÝSplits the given string into a directory and a file component and returns them
in a two-element array. See also File::dirname and File::basename.

    File.split("/home/gumby/.profile")   #=> ["/home/gumby", ".profile"]

;T;0;;;I"
split;F;I"	File;T;[o;;I"#::string | ::_ToPath file_name;T;I"[ ::String, ::String ];To;;I"†Returns a File::Stat object for the named file (see File::Stat).

    File.stat("testfile").mtime   #=> Tue Apr 08 12:58:04 CDT 2003

;T;0;;;I"	stat;F;I"	File;T;[o;;I"#::string | ::_ToPath file_name;T;I"File::Stat;To;;I"aReturns `true` if the named file has the sticky bit set.

*file_name* can be an IO object.

;T;0;;;I"sticky?;F;I"	File;T;[o;;I"*::string | ::_ToPath | ::IO file_name;T;I"	bool;To;;I"ÓCreates a symbolic link called *new_name* for the existing file *old_name*.
Raises a NotImplemented exception on platforms that do not support symbolic
links.

    File.symlink("testfile", "link2test")   #=> 0

;T;0;;;I"symlink;F;I"	File;T;[o;;I"A::string | ::_ToPath old_name, ::string | ::_ToPath new_name;T;I"0;Fo;;I";Returns `true` if the named file is a symbolic link.

;T;0;;;I"symlink?;F;I"	File;T;[o;;I"#::string | ::_ToPath file_name;T;I"	bool;To;;I"Truncates the file *file_name* to be at most *integer* bytes long. Not
available on all platforms.

    f = File.new("out", "w")
    f.write("1234567890")     #=> 10
    f.close                   #=> nil
    File.truncate("out", 5)   #=> 0
    File.size("out")          #=> 5

;T;0;;;I"truncate;F;I"	File;T;[o;;I"1::string | ::_ToPath file_name, ::int length;T;I"0;Fo;;I"HReturns the current umask value for this process. If the optional argument is
given, set the umask to that value and return the previous value. Umask values
are *subtracted* from the default permissions, so a umask of `0222` would make
a file read-only for everyone.

    File.umask(0006)   #=> 18
    File.umask         #=> 6

;T;0;;;I"
umask;F;I"	File;T;[o;;I"?::int umask;T;I"Integer;To;;I"XDeletes the named files, returning the number of names passed as arguments.
Raises an exception on any error. Since the underlying implementation relies
on the `unlink(2)` system call, the type of exception raised depends on its
error type (see https://linux.die.net/man/2/unlink) and has the form of e.g.
Errno::ENOENT.

See also Dir::rmdir.

;T;0;;;I"unlink;F;I"	File;T;[o;;I"$*::string | ::_ToPath file_name;T;I"Integer;To;;I"Sets the access and modification times of each named file to the first two
arguments. If a file is a symlink, this method acts upon its referent rather
than the link itself; for the inverse behavior see File.lutime. Returns the
number of file names in the argument list.

;T;0;;;I"
utime;F;I"	File;T;[o;;I"X::Time | ::Numeric atime, ::Time | ::Numeric mtime, *::string | ::_ToPath file_name;T;I"Integer;To;;I"If *file_name* is readable by others, returns an integer representing the file
permission bits of *file_name*. Returns `nil` otherwise. The meaning of the
bits is platform dependent; on Unix systems, see `stat(2)`.

*file_name* can be an IO object.

    File.world_readable?("/etc/passwd")           #=> 420
    m = File.world_readable?("/etc/passwd")
    sprintf("%o", m)                              #=> "644"

;T;0;;;I"world_readable?;F;I"	File;T;[o;;I"*::string | ::_ToPath | ::IO file_name;T;I"Integer?;To;;I"–If *file_name* is writable by others, returns an integer representing the file
permission bits of *file_name*. Returns `nil` otherwise. The meaning of the
bits is platform dependent; on Unix systems, see `stat(2)`.

*file_name* can be an IO object.

    File.world_writable?("/tmp")                  #=> 511
    m = File.world_writable?("/tmp")
    sprintf("%o", m)                              #=> "777"

;T;0;;;I"world_writable?;F;I"	File;T;[o;;I"*::string | ::_ToPath | ::IO file_name;T;I"Integer?;To;;I"ýReturns `true` if the named file is writable by the effective user and group
id of this process. See eaccess(3).

Note that some OS-level security features may cause this to return true even
though the file is not writable by the effective user/group.

;T;0;;;I"writable?;F;I"	File;T;[o;;I"#::string | ::_ToPath file_name;T;I"	bool;To;;I"òReturns `true` if the named file is writable by the real user and group id of
this process. See access(3).

Note that some OS-level security features may cause this to return true even
though the file is not writable by the real user/group.

;T;0;;;I"writable_real?;F;I"	File;T;[o;;I"#::string | ::_ToPath file_name;T;I"	bool;To;;I"eReturns `true` if the named file exists and has a zero size.

*file_name* can be an IO object.

;T;0;;;I"
zero?;F;I"	File;T;[o;;I"*::string | ::_ToPath | ::IO file_name;T;I"	bool;To;;I"§Returns the last access time (a Time object) for *file*, or epoch if *file*
has not been accessed.

    File.new("testfile").atime   #=> Wed Dec 31 18:00:00 CST 1969

;T;0;;;I"
atime;F;I"	File;T;[o;;I" ;F;I"	Time;To;;I"°Returns the birth time for *file*.

    File.new("testfile").birthtime   #=> Wed Apr 09 08:53:14 CDT 2003

If the platform doesn't have birthtime, raises NotImplementedError.

;T;0;;;I"birthtime;F;I"	File;T;[o;;I" ;F;I"	Time;To;;I"Changes permission bits on *file* to the bit pattern represented by
*mode_int*. Actual effects are platform dependent; on Unix systems, see
`chmod(2)` for details. Follows symbolic links. Also see File#lchmod.

    f = File.new("out", "w");
    f.chmod(0644)   #=> 0

;T;0;;;I"
chmod;F;I"	File;T;[o;;I"::int mode;T;I"0 | nil;Fo;;I"Changes the owner and group of *file* to the given numeric owner and group
id's. Only a process with superuser privileges may change the owner of a file.
The current owner of a file may change the file's group to any group to which
the owner belongs. A `nil` or -1 owner or group id is ignored. Follows
symbolic links. See also File#lchown.

    File.new("testfile").chown(502, 1000)

;T;0;;;I"
chown;F;I"	File;T;[o;;I"::int? owner, ::int? group;T;I"0 | nil;Fo;;I"Returns the change time for *file* (that is, the time directory information
about the file was changed, not the file itself).

Note that on Windows (NTFS), returns creation time (birth time).

    File.new("testfile").ctime   #=> Wed Apr 09 08:53:14 CDT 2003

;T;0;;;I"
ctime;F;I"	File;T;[o;;I" ;F;I"	Time;To;;I"Locks or unlocks a file according to *locking_constant* (a logical *or* of the
values in the table below). Returns `false` if File::LOCK_NB is specified and
the operation would otherwise have blocked. Not available on all platforms.

Locking constants (in class File):

    LOCK_EX   | Exclusive lock. Only one process may hold an
              | exclusive lock for a given file at a time.
    ----------+------------------------------------------------
    LOCK_NB   | Don't block when locking. May be combined
              | with other lock options using logical or.
    ----------+------------------------------------------------
    LOCK_SH   | Shared lock. Multiple processes may each hold a
              | shared lock for a given file at the same time.
    ----------+------------------------------------------------
    LOCK_UN   | Unlock.

Example:

    # update a counter using write lock
    # don't use "w" because it truncates the file before lock.
    File.open("counter", File::RDWR|File::CREAT, 0644) {|f|
      f.flock(File::LOCK_EX)
      value = f.read.to_i + 1
      f.rewind
      f.write("#{value}\n")
      f.flush
      f.truncate(f.pos)
    }

    # read the counter using read lock
    File.open("counter", "r") {|f|
      f.flock(File::LOCK_SH)
      p f.read
    }

;T;0;;;I"
flock;F;I"	File;T;[o;;I"::int locking_constant;T;I"0 | false;Fo;;I"LSame as IO#stat, but does not follow the last symbolic link. Instead, reports
on the link itself.

    File.symlink("testfile", "link2test")   #=> 0
    File.stat("testfile").size              #=> 66
    f = File.new("link2test")
    f.lstat.size                            #=> 8
    f.stat.size                             #=> 66

;T;0;;;I"
lstat;F;I"	File;T;[o;;I" ;F;I"File::Stat | nil;To;;I"sReturns the modification time for *file*.

    File.new("testfile").mtime   #=> Wed Apr 09 08:53:14 CDT 2003

;T;0;;;I"
mtime;F;I"	File;T;[o;;I" ;F;I"	Time;To;;I"ÚReturns the pathname used to create *file* as a string. Does not normalize the
name.

The pathname may not point to the file corresponding to *file*. For instance,
the pathname becomes void when the file has been moved or deleted.

This method raises IOError for a *file* created using File::Constants::TMPFILE
because they don't have a pathname.

    File.new("testfile").path               #=> "testfile"
    File.new("/tmp/../tmp/xxx", "w").path   #=> "/tmp/../tmp/xxx"

;T;0;;;I"	path;F;I"	File;T;[o;;I" ;F;I"String;To;;I" ;T;0;;;I"	size;F;I"	File;T;[o;;I" ;F;I"Integer;To;;I"(Truncates *file* to at most *integer* bytes. The file must be opened for
writing. Not available on all platforms.

    f = File.new("out", "w")
    f.syswrite("1234567890")   #=> 10
    f.truncate(5)              #=> 0
    f.close()                  #=> nil
    File.size("out")           #=> 5

;T;0;;;I"truncate;F;I"	File;T;[o;;I"::int length;T;I"0;Fo;;0;0;	I"File::Constants;T;
[ ;[ ;0;[ ;[ o; ;I"¶Objects of class File::Stat encapsulate common status information for File
objects. The information is recorded at the moment the File::Stat object is
created; changes made to the file after that point will not be reflected.
File::Stat objects are returned by IO#stat, File::stat, File#lstat, and
File::lstat. Many of these methods return platform-specific values, and not
all values are meaningful on all systems. See also Kernel#test.

;T;0;	I"File::Stat;T;
[ ;[I"Comparable;T;0;[ ;[ ;0;I"Object;To;;I"kCreate a File::Stat object for the given file name (raising an exception if
the file doesn't exist).

;T;0;;;I"initialize;F;I"File::Stat;T;[o;;I"::String file;T;I"	void;To;;I"õCompares File::Stat objects by comparing their respective modification times.

`nil` is returned if `other_stat` is not a File::Stat object

    f1 = File.new("f1", "w")
    sleep 1
    f2 = File.new("f2", "w")
    f1.stat <=> f2.stat   #=> -1

;T;0;;;I"<=>;F;I"File::Stat;T;[o;;I"::File::Stat other;T;I"Integer;To;;I"untyped;T;I"nil;To;;I"ŒReturns the last access time for this file as an object of class Time.

    File.stat("testfile").atime   #=> Wed Dec 31 18:00:00 CST 1969

;T;0;;;I"
atime;F;I"File::Stat;T;[o;;I" ;F;I"	Time;To;;I" Returns the birth time for *stat*.

If the platform doesn't have birthtime, raises NotImplementedError.

    File.write("testfile", "foo")
    sleep 10
    File.write("testfile", "bar")
    sleep 10
    File.chmod(0644, "testfile")
    sleep 10
    File.read("testfile")
    File.stat("testfile").birthtime   #=> 2014-02-24 11:19:17 +0900
    File.stat("testfile").mtime       #=> 2014-02-24 11:19:27 +0900
    File.stat("testfile").ctime       #=> 2014-02-24 11:19:37 +0900
    File.stat("testfile").atime       #=> 2014-02-24 11:19:47 +0900

;T;0;;;I"birthtime;F;I"File::Stat;T;[o;;I" ;F;I"	Time;To;;I" Returns the native file system's block size. Will return `nil` on platforms
that don't support this information.

    File.stat("testfile").blksize   #=> 4096

;T;0;;;I"blksize;F;I"File::Stat;T;[o;;I" ;F;I"Integer?;To;;I"ÞReturns `true` if the file is a block device, `false` if it isn't or if the
operating system doesn't support this feature.

    File.stat("testfile").blockdev?    #=> false
    File.stat("/dev/hda1").blockdev?   #=> true

;T;0;;;I"blockdev?;F;I"File::Stat;T;[o;;I" ;F;I"	bool;To;;I"³Returns the number of native file system blocks allocated for this file, or
`nil` if the operating system doesn't support this feature.

    File.stat("testfile").blocks   #=> 2

;T;0;;;I"blocks;F;I"File::Stat;T;[o;;I" ;F;I"Integer?;To;;I"¯Returns `true` if the file is a character device, `false` if it isn't or if
the operating system doesn't support this feature.

    File.stat("/dev/tty").chardev?   #=> true

;T;0;;;I"chardev?;F;I"File::Stat;T;[o;;I" ;F;I"	bool;To;;I"Returns the change time for *stat* (that is, the time directory information
about the file was changed, not the file itself).

Note that on Windows (NTFS), returns creation time (birth time).

    File.stat("testfile").ctime   #=> Wed Apr 09 08:53:14 CDT 2003

;T;0;;;I"
ctime;F;I"File::Stat;T;[o;;I" ;F;I"	Time;To;;I"sReturns an integer representing the device on which *stat* resides.

    File.stat("testfile").dev   #=> 774

;T;0;;;I"dev;F;I"File::Stat;T;[o;;I" ;F;I"Integer;To;;I"ŽReturns the major part of `File_Stat#dev` or `nil`.

    File.stat("/dev/fd1").dev_major   #=> 2
    File.stat("/dev/tty").dev_major   #=> 5

;T;0;;;I"dev_major;F;I"File::Stat;T;[o;;I" ;F;I"Integer;To;;I"ŽReturns the minor part of `File_Stat#dev` or `nil`.

    File.stat("/dev/fd1").dev_minor   #=> 1
    File.stat("/dev/tty").dev_minor   #=> 0

;T;0;;;I"dev_minor;F;I"File::Stat;T;[o;;I" ;F;I"Integer;To;;I"®Returns `true` if the named file is a directory, or a symlink that points at a
directory, and `false` otherwise.

*file_name* can be an IO object.

    File.directory?(".")

;T;0;;;I"directory?;F;I"File::Stat;T;[o;;I" ;F;I"	bool;To;;I"òReturns `true` if *stat* is executable or if the operating system doesn't
distinguish executable files from nonexecutable files. The tests are made
using the effective owner of the process.

    File.stat("testfile").executable?   #=> false

;T;0;;;I"executable?;F;I"File::Stat;T;[o;;I" ;F;I"	bool;To;;I"LSame as `executable?`, but tests using the real owner of the process.

;T;0;;;I"executable_real?;F;I"File::Stat;T;[o;;I" ;F;I"	bool;To;;I"Returns `true` if *stat* is a regular file (not a device file, pipe, socket,
etc.).

    File.stat("testfile").file?   #=> true

;T;0;;;I"
file?;F;I"File::Stat;T;[o;;I" ;F;I"	bool;To;;I"øIdentifies the type of *stat*. The return string is one of: ```file`'',
```directory`'', ```characterSpecial`'', ```blockSpecial`'', ```fifo`'',
```link`'', ```socket`'', or ```unknown`''.

    File.stat("/dev/tty").ftype   #=> "characterSpecial"

;T;0;;;I"
ftype;F;I"File::Stat;T;[o;;I" ;F;I"String;To;;I"dReturns the numeric group id of the owner of *stat*.

    File.stat("testfile").gid   #=> 500

;T;0;;;I"gid;F;I"File::Stat;T;[o;;I" ;F;I"Integer;To;;I"äReturns true if the effective group id of the process is the same as the group
id of *stat*. On Windows NT, returns `false`.

    File.stat("testfile").grpowned?      #=> true
    File.stat("/etc/passwd").grpowned?   #=> false

;T;0;;;I"grpowned?;F;I"File::Stat;T;[o;;I" ;F;I"	bool;To;;I"XReturns the inode number for *stat*.

    File.stat("testfile").ino   #=> 1083669

;T;0;;;I"ino;F;I"File::Stat;T;[o;;I" ;F;I"Integer;To;;I"±Produce a nicely formatted description of *stat*.

    File.stat("/etc/passwd").inspect
       #=> "#<File::Stat dev=0xe000005, ino=1078078, mode=0100644,
       #    nlink=1, uid=0, gid=0, rdev=0x0, size=1374, blksize=4096,
       #    blocks=8, atime=Wed Dec 10 10:16:12 CST 2003,
       #    mtime=Fri Sep 12 15:41:41 CDT 2003,
       #    ctime=Mon Oct 27 11:20:27 CST 2003,
       #    birthtime=Mon Aug 04 08:13:49 CDT 2003>"

;T;0;;;I"inspect;F;I"File::Stat;T;[o;;I" ;F;I"String;To;;I"Returns an integer representing the permission bits of *stat*. The meaning of
the bits is platform dependent; on Unix systems, see `stat(2)`.

    File.chmod(0644, "testfile")   #=> 1
    s = File.stat("testfile")
    sprintf("%o", s.mode)          #=> "100644"

;T;0;;;I"	mode;F;I"File::Stat;T;[o;;I" ;F;I"Integer;To;;I"sReturns the modification time of *stat*.

    File.stat("testfile").mtime   #=> Wed Apr 09 08:53:14 CDT 2003

;T;0;;;I"
mtime;F;I"File::Stat;T;[o;;I" ;F;I"	Time;To;;I"ÄReturns the number of hard links to *stat*.

    File.stat("testfile").nlink             #=> 1
    File.link("testfile", "testfile.bak")   #=> 0
    File.stat("testfile").nlink             #=> 2

;T;0;;;I"
nlink;F;I"File::Stat;T;[o;;I" ;F;I"Integer;To;;I"¼Returns `true` if the effective user id of the process is the same as the
owner of *stat*.

    File.stat("testfile").owned?      #=> true
    File.stat("/etc/passwd").owned?   #=> false

;T;0;;;I"owned?;F;I"File::Stat;T;[o;;I" ;F;I"	bool;To;;I"eReturns `true` if the operating system supports pipes and *stat* is a pipe;
`false` otherwise.

;T;0;;;I"
pipe?;F;I"File::Stat;T;[o;;I" ;F;I"	bool;To;;I"âReturns an integer representing the device type on which *stat* resides.
Returns `nil` if the operating system doesn't support this feature.

    File.stat("/dev/fd1").rdev   #=> 513
    File.stat("/dev/tty").rdev   #=> 1280

;T;0;;;I"	rdev;F;I"File::Stat;T;[o;;I" ;F;I"Integer?;To;;I"‘Returns the major part of `File_Stat#rdev` or `nil`.

    File.stat("/dev/fd1").rdev_major   #=> 2
    File.stat("/dev/tty").rdev_major   #=> 5

;T;0;;;I"rdev_major;F;I"File::Stat;T;[o;;I" ;F;I"Integer;To;;I"‘Returns the minor part of `File_Stat#rdev` or `nil`.

    File.stat("/dev/fd1").rdev_minor   #=> 1
    File.stat("/dev/tty").rdev_minor   #=> 0

;T;0;;;I"rdev_minor;F;I"File::Stat;T;[o;;I" ;F;I"Integer;To;;I"€Returns `true` if *stat* is readable by the effective user id of this process.

    File.stat("testfile").readable?   #=> true

;T;0;;;I"readable?;F;I"File::Stat;T;[o;;I" ;F;I"	bool;To;;I"€Returns `true` if *stat* is readable by the real user id of this process.

    File.stat("testfile").readable_real?   #=> true

;T;0;;;I"readable_real?;F;I"File::Stat;T;[o;;I" ;F;I"	bool;To;;I"ÅReturns `true` if *stat* has the set-group-id permission bit set, `false` if
it doesn't or if the operating system doesn't support this feature.

    File.stat("/usr/sbin/lpc").setgid?   #=> true

;T;0;;;I"setgid?;F;I"File::Stat;T;[o;;I" ;F;I"	bool;To;;I"¾Returns `true` if *stat* has the set-user-id permission bit set, `false` if it
doesn't or if the operating system doesn't support this feature.

    File.stat("/bin/su").setuid?   #=> true

;T;0;;;I"setuid?;F;I"File::Stat;T;[o;;I" ;F;I"	bool;To;;I"TReturns the size of *stat* in bytes.

    File.stat("testfile").size   #=> 66

;T;0;;;I"	size;F;I"File::Stat;T;[o;;I" ;F;I"Integer;To;;I"¤Returns `nil` if *stat* is a zero-length file, the size of the file otherwise.

    File.stat("testfile").size?   #=> 66
    File.stat("/dev/null").size?  #=> nil

;T;0;;;I"
size?;F;I"File::Stat;T;[o;;I" ;F;I"Integer?;To;;I"£Returns `true` if *stat* is a socket, `false` if it isn't or if the operating
system doesn't support this feature.

    File.stat("testfile").socket?   #=> false

;T;0;;;I"socket?;F;I"File::Stat;T;[o;;I" ;F;I"	bool;To;;I"°Returns `true` if *stat* has its sticky bit set, `false` if it doesn't or if
the operating system doesn't support this feature.

    File.stat("testfile").sticky?   #=> false

;T;0;;;I"sticky?;F;I"File::Stat;T;[o;;I" ;F;I"	bool;To;;I"ˆReturns `true` if *stat* is a symbolic link, `false` if it isn't or if the
operating system doesn't support this feature. As File::stat automatically
follows symbolic links, #symlink? will always be `false` for an object
returned by File::stat.

    File.symlink("testfile", "alink")   #=> 0
    File.stat("alink").symlink?         #=> false
    File.lstat("alink").symlink?        #=> true

;T;0;;;I"symlink?;F;I"File::Stat;T;[o;;I" ;F;I"	bool;To;;I"cReturns the numeric user id of the owner of *stat*.

    File.stat("testfile").uid   #=> 501

;T;0;;;I"uid;F;I"File::Stat;T;[o;;I" ;F;I"Integer;To;;I"EIf *stat* is readable by others, returns an integer representing the file
permission bits of *stat*. Returns `nil` otherwise. The meaning of the bits is
platform dependent; on Unix systems, see `stat(2)`.

    m = File.stat("/etc/passwd").world_readable?  #=> 420
    sprintf("%o", m)                              #=> "644"

;T;0;;;I"world_readable?;F;I"File::Stat;T;[o;;I" ;F;I"Integer?;To;;I"EIf *stat* is writable by others, returns an integer representing the file
permission bits of *stat*. Returns `nil` otherwise. The meaning of the bits is
platform dependent; on Unix systems, see `stat(2)`.

    m = File.stat("/tmp").world_writable?         #=> 511
    sprintf("%o", m)                              #=> "777"

;T;0;;;I"world_writable?;F;I"File::Stat;T;[o;;I" ;F;I"Integer?;To;;I"€Returns `true` if *stat* is writable by the effective user id of this process.

    File.stat("testfile").writable?   #=> true

;T;0;;;I"writable?;F;I"File::Stat;T;[o;;I" ;F;I"	bool;To;;I"€Returns `true` if *stat* is writable by the real user id of this process.

    File.stat("testfile").writable_real?   #=> true

;T;0;;;I"writable_real?;F;I"File::Stat;T;[o;;I" ;F;I"	bool;To;;I"vReturns `true` if *stat* is a zero-length file; `false` otherwise.

    File.stat("testfile").zero?   #=> false

;T;0;;;I"
zero?;F;I"File::Stat;T;[o;;I" ;F;I"	bool;To;;I"íFileTest implements file test operations similar to those used in File::Stat.
It exists as a standalone module, and its methods are also insinuated into the
File class. (Note that this is not done by inclusion: the interpreter cheats).

;T;0;	I"FileTest;T;
[ ;[ ;0;[ ;[ o;;I"\Returns `true` if the named file is a block device.

*file_name* can be an IO object.

;T;0;:singleton_instance;I"blockdev?;F;I"FileTest;T;[o;;I"::String | ::IO file_name;T;I"	bool;To;;I"`Returns `true` if the named file is a character device.

*file_name* can be an IO object.

;T;0;;;I"chardev?;F;I"FileTest;T;[o;;I"::String | ::IO file_name;T;I"	bool;To;;I"®Returns `true` if the named file is a directory, or a symlink that points at a
directory, and `false` otherwise.

*file_name* can be an IO object.

    File.directory?(".")

;T;0;;;I"directory?;F;I"FileTest;T;[o;;I"::String | ::IO file_name;T;I"	bool;To;;I"eReturns `true` if the named file exists and has a zero size.

*file_name* can be an IO object.

;T;0;;;I"empty?;F;I"FileTest;T;[o;;I"::String | ::IO file_name;T;I"	bool;To;;I"«Returns `true` if the named file is executable by the effective user and group
id of this process. See eaccess(3).

Windows does not support execute permissions separately from read permissions.
On Windows, a file is only considered executable if it ends in .bat, .cmd,
.com, or .exe.

Note that some OS-level security features may cause this to return true even
though the file is not executable by the effective user/group.

;T;0;;;I"executable?;F;I"FileTest;T;[o;;I"::String file_name;T;I"	bool;To;;I" Returns `true` if the named file is executable by the real user and group id
of this process. See access(3).

Windows does not support execute permissions separately from read permissions.
On Windows, a file is only considered executable if it ends in .bat, .cmd,
.com, or .exe.

Note that some OS-level security features may cause this to return true even
though the file is not executable by the real user/group.

;T;0;;;I"executable_real?;F;I"FileTest;T;[o;;I"::String file_name;T;I"	bool;To;;I"’Return `true` if the named file exists.

*file_name* can be an IO object.

"file exists" means that stat() or fstat() system call is successful.

;T;0;;;I"exist?;F;I"FileTest;T;[o;;I"::String | ::IO file_name;T;I"	bool;To;;I"ÖReturns `true` if the named `file` exists and is a regular file.

`file` can be an IO object.

If the `file` argument is a symbolic link, it will resolve the symbolic link
and use the file referenced by the link.

;T;0;;;I"
file?;F;I"FileTest;T;[o;;I"::String | ::IO file;T;I"	bool;To;;I"³Returns `true` if the named file exists and the effective group id of the
calling process is the owner of the file. Returns `false` on Windows.

*file_name* can be an IO object.

;T;0;;;I"grpowned?;F;I"FileTest;T;[o;;I"::String | ::IO file_name;T;I"	bool;To;;I"¥Returns `true` if the named files are identical.

*file_1* and *file_2* can be an IO object.

    open("a", "w") {}
    p File.identical?("a", "a")      #=> true
    p File.identical?("a", "./a")    #=> true
    File.link("a", "b")
    p File.identical?("a", "b")      #=> true
    File.symlink("a", "c")
    p File.identical?("a", "c")      #=> true
    open("d", "w") {}
    p File.identical?("a", "d")      #=> false

;T;0;;;I"identical?;F;I"FileTest;T;[o;;I"3::String | ::IO file_1, ::String | ::IO file_2;T;I"	bool;To;;I"–Returns `true` if the named file exists and the effective used id of the
calling process is the owner of the file.

*file_name* can be an IO object.

;T;0;;;I"owned?;F;I"FileTest;T;[o;;I"::String | ::IO file_name;T;I"	bool;To;;I"TReturns `true` if the named file is a pipe.

*file_name* can be an IO object.

;T;0;;;I"
pipe?;F;I"FileTest;T;[o;;I"::String | ::IO file_name;T;I"	bool;To;;I"ýReturns `true` if the named file is readable by the effective user and group
id of this process. See eaccess(3).

Note that some OS-level security features may cause this to return true even
though the file is not readable by the effective user/group.

;T;0;;;I"readable?;F;I"FileTest;T;[o;;I"::String file_name;T;I"	bool;To;;I"òReturns `true` if the named file is readable by the real user and group id of
this process. See access(3).

Note that some OS-level security features may cause this to return true even
though the file is not readable by the real user/group.

;T;0;;;I"readable_real?;F;I"FileTest;T;[o;;I"::String file_name;T;I"	bool;To;;I"aReturns `true` if the named file has the setgid bit set.

*file_name* can be an IO object.

;T;0;;;I"setgid?;F;I"FileTest;T;[o;;I"::String | ::IO file_name;T;I"	bool;To;;I"aReturns `true` if the named file has the setuid bit set.

*file_name* can be an IO object.

;T;0;;;I"setuid?;F;I"FileTest;T;[o;;I"::String | ::IO file_name;T;I"	bool;To;;I"IReturns the size of `file_name`.

*file_name* can be an IO object.

;T;0;;;I"	size;F;I"FileTest;T;[o;;I"::String | ::IO file_name;T;I"Integer;To;;I"€Returns `nil` if `file_name` doesn't exist or has zero size, the size of the
file otherwise.

*file_name* can be an IO object.

;T;0;;;I"
size?;F;I"FileTest;T;[o;;I"::String | ::IO file_name;T;I"Integer?;To;;I"VReturns `true` if the named file is a socket.

*file_name* can be an IO object.

;T;0;;;I"socket?;F;I"FileTest;T;[o;;I"::String | ::IO file_name;T;I"	bool;To;;I"aReturns `true` if the named file has the sticky bit set.

*file_name* can be an IO object.

;T;0;;;I"sticky?;F;I"FileTest;T;[o;;I"::String | ::IO file_name;T;I"	bool;To;;I";Returns `true` if the named file is a symbolic link.

;T;0;;;I"symlink?;F;I"FileTest;T;[o;;I"::String file_name;T;I"	bool;To;;I"If *file_name* is readable by others, returns an integer representing the file
permission bits of *file_name*. Returns `nil` otherwise. The meaning of the
bits is platform dependent; on Unix systems, see `stat(2)`.

*file_name* can be an IO object.

    File.world_readable?("/etc/passwd")           #=> 420
    m = File.world_readable?("/etc/passwd")
    sprintf("%o", m)                              #=> "644"

;T;0;;;I"world_readable?;F;I"FileTest;T;[o;;I"::String | ::IO file_name;T;I"Integer?;To;;I"–If *file_name* is writable by others, returns an integer representing the file
permission bits of *file_name*. Returns `nil` otherwise. The meaning of the
bits is platform dependent; on Unix systems, see `stat(2)`.

*file_name* can be an IO object.

    File.world_writable?("/tmp")                  #=> 511
    m = File.world_writable?("/tmp")
    sprintf("%o", m)                              #=> "777"

;T;0;;;I"world_writable?;F;I"FileTest;T;[o;;I"::String | ::IO file_name;T;I"Integer?;To;;I"ýReturns `true` if the named file is writable by the effective user and group
id of this process. See eaccess(3).

Note that some OS-level security features may cause this to return true even
though the file is not writable by the effective user/group.

;T;0;;;I"writable?;F;I"FileTest;T;[o;;I"::String file_name;T;I"	bool;To;;I"òReturns `true` if the named file is writable by the real user and group id of
this process. See access(3).

Note that some OS-level security features may cause this to return true even
though the file is not writable by the real user/group.

;T;0;;;I"writable_real?;F;I"FileTest;T;[o;;I"::String file_name;T;I"	bool;To;;I"eReturns `true` if the named file exists and has a zero size.

*file_name* can be an IO object.

;T;0;;;I"
zero?;F;I"FileTest;T;[o;;I"::String | ::IO file_name;T;I"	bool;To; ;I"ÏA Float object represents a sometimes-inexact real number using the native
architecture's double-precision floating point representation.

Floating point has a different arithmetic and is an inexact number. So you
should know its esoteric system. See following:

*   https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html
*   https://github.com/rdp/ruby_tutorials_core/wiki/Ruby-Talk-FAQ#floats_impre
    cise
*   https://en.wikipedia.org/wiki/Floating_point#Accuracy_problems


You can create a Float object explicitly with:

*   A [floating-point
    literal](doc/syntax/literals_rdoc.html#label-Float+Literals).


You can convert certain objects to Floats with:

*   Method [Float](Kernel.html#method-i-Float).


## What's Here

First, what's elsewhere. Class Float:

*   Inherits from [class
    Numeric](Numeric.html#class-Numeric-label-What-27s+Here).


Here, class Float provides methods for:

*   [Querying](#class-Float-label-Querying)
*   [Comparing](#class-Float-label-Comparing)
*   [Converting](#class-Float-label-Converting)


### Querying

    #finite?
:       Returns whether `self` is finite.

    #hash
:       Returns the integer hash code for `self`.

    #infinite?
:       Returns whether `self` is infinite.

    #nan?
:       Returns whether `self` is a NaN (not-a-number).



### Comparing

    [<](#method-i-3C)
:       Returns whether `self` is less than the given value.

    [<=](#method-i-3C-3D)
:       Returns whether `self` is less than or equal to the given value.

    [<=>](#method-i-3C-3D-3E)
:       Returns a number indicating whether `self` is less than, equal to, or
        greater than the given value.

    [==](#method-i-3D-3D) (aliased as #=== and #eql>)
:       Returns whether `self` is equal to the given value.

    [>](#method-i-3E)
:       Returns whether `self` is greater than the given value.

    [>=](#method-i-3E-3D)
:       Returns whether `self` is greater than or equal to the given value.



### Converting

    #% (aliased as #modulo)
:       Returns `self` modulo the given value.

    #*
:       Returns the product of `self` and the given value.

    [**](#method-i-2A-2A)
:       Returns the value of `self` raised to the power of the given value.

    #+
:       Returns the sum of `self` and the given value.

    #-
:       Returns the difference of `self` and the given value.

    [/](#method-i-2F)
:       Returns the quotient of `self` and the given value.

    #ceil
:       Returns the smallest number greater than or equal to `self`.

    #coerce
:       Returns a 2-element array containing the given value converted to a
        Float and `self`

    #divmod
:       Returns a 2-element array containing the quotient and remainder
        results of dividing `self` by the given value.

    #fdiv
:       Returns the Float result of dividing `self` by the given value.

    #floor
:       Returns the greatest number smaller than or equal to `self`.

    #next_float
:       Returns the next-larger representable Float.

    #prev_float
:       Returns the next-smaller representable Float.

    #quo
:       Returns the quotient from dividing `self` by the given value.

    #round
:       Returns `self` rounded to the nearest value, to a given precision.

    #to_i (aliased as #to_int)
:       Returns `self` truncated to an Integer.

    #to_s (aliased as #inspect)
:       Returns a string containing the place-value representation of `self`
        in the given radix.

    #truncate
:       Returns `self` truncated to a given precision.

;T;0;	I"
Float;T;
[ ;[ ;0;[ ;[ ;0;I"Numeric;To;;I"Returns `self` modulo `other` as a float.

For float `f` and real number `r`, these expressions are equivalent:

    f % r
    f-r*(f/r).floor
    f.divmod(r)[1]

See Numeric#divmod.

Examples:

    10.0 % 2              # => 0.0
    10.0 % 3              # => 1.0
    10.0 % 4              # => 2.0

    10.0 % -2             # => 0.0
    10.0 % -3             # => -2.0
    10.0 % -4             # => -2.0

    10.0 % 4.0            # => 2.0
    10.0 % Rational(4, 1) # => 2.0

Float#modulo is an alias for Float#%.

;T;0;;;I"%;F;I"
Float;T;[	o;;I"::Integer;T;I"
Float;To;;I"::Float;T;I"
Float;To;;I"::Rational;T;I"
Float;To;;I"::Numeric;T;I"Numeric;To;;I"ÚReturns a new Float which is the product of `self` and `other`:

    f = 3.14
    f * 2              # => 6.28
    f * 2.0            # => 6.28
    f * Rational(1, 2) # => 1.57
    f * Complex(2, 0)  # => (6.28+0.0i)

;T;0;;;I"*;F;I"
Float;T;[o;;I"::Complex;T;I"Complex;To;;I"::Numeric;T;I"
Float;To;;I"Raises `self` to the power of `other`:

    f = 3.14
    f ** 2              # => 9.8596
    f ** -2             # => 0.1014239928597509
    f ** 2.1            # => 11.054834900588839
    f ** Rational(2, 1) # => 9.8596
    f ** Complex(2, 0)  # => (9.8596+0i)

;T;0;;;I"**;F;I"
Float;T;[o;;I"::Complex;T;I"Complex;To;;I"::Numeric;T;I"
Float;To;;I"Returns a new Float which is the sum of `self` and `other`:

    f = 3.14
    f + 1                 # => 4.140000000000001
    f + 1.0               # => 4.140000000000001
    f + Rational(1, 1)    # => 4.140000000000001
    f + Complex(1, 0)     # => (4.140000000000001+0i)

;T;0;;;I"+;F;I"
Float;T;[o;;I"::Complex;T;I"Complex;To;;I"::Numeric;T;I"
Float;To;;0;0;;;I"+@;F;I"
Float;T;[o;;I" ;F;I"
Float;To;;I"çReturns a new Float which is the difference of `self` and `other`:

    f = 3.14
    f - 1                 # => 2.14
    f - 1.0               # => 2.14
    f - Rational(1, 1)    # => 2.14
    f - Complex(1, 0)     # => (2.14+0i)

;T;0;;;I"-;F;I"
Float;T;[o;;I"::Complex;T;I"Complex;To;;I"::Numeric;T;I"
Float;To;;I" Returns `float`, negated.

;T;0;;;I"-@;F;I"
Float;T;[o;;I" ;F;I"
Float;To;;I"áReturns a new Float which is the result of dividing `self` by `other`:

    f = 3.14
    f / 2              # => 1.57
    f / 2.0            # => 1.57
    f / Rational(2, 1) # => 1.57
    f / Complex(2, 0)  # => (1.57+0.0i)

;T;0;;;I"/;F;I"
Float;T;[o;;I"::Complex;T;I"Complex;To;;I"::Numeric;T;I"
Float;To;;I"Returns `true` if `self` is numerically less than `other`:

    2.0 < 3              # => true
    2.0 < 3.0            # => true
    2.0 < Rational(3, 1) # => true
    2.0 < 2.0            # => false

`Float::NAN < Float::NAN` returns an implementation-dependent value.

;T;0;;;I"<;F;I"
Float;T;[o;;I"::Numeric;T;I"	bool;To;;I"EReturns `true` if `self` is numerically less than or equal to `other`:

    2.0 <= 3              # => true
    2.0 <= 3.0            # => true
    2.0 <= Rational(3, 1) # => true
    2.0 <= 2.0            # => true
    2.0 <= 1.0            # => false

`Float::NAN <= Float::NAN` returns an implementation-dependent value.

;T;0;;;I"<=;F;I"
Float;T;[o;;I"::Numeric;T;I"	bool;To;;I"}Returns a value that depends on the numeric relation between `self` and
`other`:

*   -1, if `self` is less than `other`.
*   0, if `self` is equal to `other`.
*   1, if `self` is greater than `other`.
*   `nil`, if the two values are incommensurate.


Examples:

    2.0 <=> 2              # => 0
    2.0 <=> 2.0            # => 0
    2.0 <=> Rational(2, 1) # => 0
    2.0 <=> Complex(2, 0)  # => 0
    2.0 <=> 1.9            # => 1
    2.0 <=> 2.1            # => -1
    2.0 <=> 'foo'          # => nil

This is the basis for the tests in the Comparable module.

`Float::NAN <=> Float::NAN` returns an implementation-dependent value.

;T;0;;;I"<=>;F;I"
Float;T;[o;;I"::Numeric;T;I"Integer?;To;;I"[Returns `true` if `other` has the same value as `self`, `false` otherwise:

    2.0 == 2              # => true
    2.0 == 2.0            # => true
    2.0 == Rational(2, 1) # => true
    2.0 == Complex(2, 0)  # => true

`Float::NAN == Float::NAN` returns an implementation-dependent value.

Related: Float#eql? (requires `other` to be a Float).

;T;0;;;I"==;F;I"
Float;T;[o;;I"untyped;T;I"	bool;To;;I"[Returns `true` if `other` has the same value as `self`, `false` otherwise:

    2.0 == 2              # => true
    2.0 == 2.0            # => true
    2.0 == Rational(2, 1) # => true
    2.0 == Complex(2, 0)  # => true

`Float::NAN == Float::NAN` returns an implementation-dependent value.

Related: Float#eql? (requires `other` to be a Float).

;T;0;;;I"===;F;I"
Float;T;[o;;I"untyped;T;I"	bool;To;;I"Returns `true` if `self` is numerically greater than `other`:

    2.0 > 1              # => true
    2.0 > 1.0            # => true
    2.0 > Rational(1, 2) # => true
    2.0 > 2.0            # => false

`Float::NAN > Float::NAN` returns an implementation-dependent value.

;T;0;;;I">;F;I"
Float;T;[o;;I"::Numeric;T;I"	bool;To;;I"HReturns `true` if `self` is numerically greater than or equal to `other`:

    2.0 >= 1              # => true
    2.0 >= 1.0            # => true
    2.0 >= Rational(1, 2) # => true
    2.0 >= 2.0            # => true
    2.0 >= 2.1            # => false

`Float::NAN >= Float::NAN` returns an implementation-dependent value.

;T;0;;;I">=;F;I"
Float;T;[o;;I"::Numeric;T;I"	bool;To;;I"¬Returns the absolute value of `float`.

    (-34.56).abs   #=> 34.56
    -34.56.abs     #=> 34.56
    34.56.abs      #=> 34.56

Float#magnitude is an alias for Float#abs.

;T;0;;;I"abs;F;I"
Float;T;[o;;I" ;F;I"
Float;To;;0;0;;;I"	abs2;F;I"
Float;T;[o;;I" ;F;I"
Float;To;;I"8Returns 0 if the value is positive, pi otherwise.

;T;0;;;I"
angle;F;I"
Float;T;[o;;I" ;F;I"Integer | ::Float;To;;I"øReturns the smallest number greater than or equal to `self` with a precision
of `ndigits` decimal digits.

When `ndigits` is positive, returns a float with `ndigits` digits after the
decimal point (as available):

    f = 12345.6789
    f.ceil(1) # => 12345.7
    f.ceil(3) # => 12345.679
    f = -12345.6789
    f.ceil(1) # => -12345.6
    f.ceil(3) # => -12345.678

When `ndigits` is non-positive, returns an integer with at least `ndigits.abs`
trailing zeros:

    f = 12345.6789
    f.ceil(0)  # => 12346
    f.ceil(-3) # => 13000
    f = -12345.6789
    f.ceil(0)  # => -12345
    f.ceil(-3) # => -12000

Note that the limited precision of floating-point arithmetic may lead to
surprising results:

    (2.1 / 0.7).ceil  #=> 4 (!)

Related: Float#floor.

;T;0;;;I"	ceil;F;I"
Float;T;[o;;I" ;F;I"Integer;To;;I"::int digits;T;I"Integer | ::Float;To;;I"`Returns a 2-element array containing `other` converted to a Float and `self`:

    f = 3.14                 # => 3.14
    f.coerce(2)              # => [2.0, 3.14]
    f.coerce(2.0)            # => [2.0, 3.14]
    f.coerce(Rational(1, 2)) # => [0.5, 3.14]
    f.coerce(Complex(1, 0))  # => [1.0, 3.14]

Raises an exception if a type conversion fails.

;T;0;;;I"coerce;F;I"
Float;T;[o;;I"::Numeric;T;I"[ ::Float, ::Float ];To;;0;0;;;I"	conj;F;I"
Float;T;[o;;I" ;F;I"
Float;To;;0;0;;;I"conjugate;F;I"
Float;T;[o;;I" ;F;I"
Float;To;;I"nReturns the denominator (always positive).  The result is machine dependent.

See also Float#numerator.

;T;0;;;I"denominator;F;I"
Float;T;[o;;I" ;F;I"Integer;To;;0;0;;;I"div;F;I"
Float;T;[o;;I"::Numeric;T;I"Integer;To;;I"eReturns a 2-element array `[q, r]`, where

    q = (self/other).floor      # Quotient
    r = self % other            # Remainder

Examples:

    11.0.divmod(4)              # => [2, 3.0]
    11.0.divmod(-4)             # => [-3, -1.0]
    -11.0.divmod(4)             # => [-3, 1.0]
    -11.0.divmod(-4)            # => [2, -3.0]

    12.0.divmod(4)              # => [3, 0.0]
    12.0.divmod(-4)             # => [-3, 0.0]
    -12.0.divmod(4)             # => [-3, -0.0]
    -12.0.divmod(-4)            # => [3, -0.0]

    13.0.divmod(4.0)            # => [3, 1.0]
    13.0.divmod(Rational(4, 1)) # => [3, 1.0]

;T;0;;;I"divmod;F;I"
Float;T;[o;;I"::Numeric;T;I"[ ::Numeric, ::Numeric ];To;;0;0;;;I"dup;F;I"
Float;T;[o;;I" ;F;I"	self;To;;I"šReturns `true` if `other` is a Float with the same value as `self`, `false`
otherwise:

    2.0.eql?(2.0)            # => true
    2.0.eql?(1.0)            # => false
    2.0.eql?(1)              # => false
    2.0.eql?(Rational(2, 1)) # => false
    2.0.eql?(Complex(2, 0))  # => false

`Float::NAN.eql?(Float::NAN)` returns an implementation-dependent value.

Related: Float#== (performs type conversions).

;T;0;;;I"	eql?;F;I"
Float;T;[o;;I"untyped;T;I"	bool;To;;I"Returns the quotient from dividing `self` by `other`:

    f = 3.14
    f.quo(2)              # => 1.57
    f.quo(-2)             # => -1.57
    f.quo(Rational(2, 1)) # => 1.57
    f.quo(Complex(2, 0))  # => (1.57+0.0i)

Float#fdiv is an alias for Float#quo.

;T;0;;;I"	fdiv;F;I"
Float;T;[o;;I"::Complex;T;I"Complex;To;;I"::Numeric;T;I"
Float;To;;I":Returns `true` if `self` is not `Infinity`, `-Infinity`, or `Nan`, `false`
otherwise:

    f = 2.0      # => 2.0
    f.finite?    # => true
    f = 1.0/0.0  # => Infinity
    f.finite?    # => false
    f = -1.0/0.0 # => -Infinity
    f.finite?    # => false
    f = 0.0/0.0  # => NaN
    f.finite?    # => false

;T;0;;;I"finite?;F;I"
Float;T;[o;;I" ;F;I"	bool;To;;I"üReturns the largest number less than or equal to `self` with a precision of
`ndigits` decimal digits.

When `ndigits` is positive, returns a float with `ndigits` digits after the
decimal point (as available):

    f = 12345.6789
    f.floor(1) # => 12345.6
    f.floor(3) # => 12345.678
    f = -12345.6789
    f.floor(1) # => -12345.7
    f.floor(3) # => -12345.679

When `ndigits` is non-positive, returns an integer with at least `ndigits.abs`
trailing zeros:

    f = 12345.6789
    f.floor(0)  # => 12345
    f.floor(-3) # => 12000
    f = -12345.6789
    f.floor(0)  # => -12346
    f.floor(-3) # => -13000

Note that the limited precision of floating-point arithmetic may lead to
surprising results:

    (0.3 / 0.1).floor  #=> 2 (!)

Related: Float#ceil.

;T;0;;;I"
floor;F;I"
Float;T;[o;;I" ;F;I"Integer;To;;I"::int digits;T;I"Integer | ::Numeric;To;;I"HReturns the integer hash value for `self`.

See also Object#hash.

;T;0;;;I"	hash;F;I"
Float;T;[o;;I" ;F;I"Integer;To;;0;0;;;I"i;F;I"
Float;T;[o;;I" ;F;I"Complex;To;;0;0;;;I"	imag;F;I"
Float;T;[o;;I" ;F;I"Integer;To;;0;0;;;I"imaginary;F;I"
Float;T;[o;;I" ;F;I"Integer;To;;I"GReturns:

*   1, if `self` is `Infinity`.
*   -1 if `self` is `-Infinity`.
*   `nil`, otherwise.


Examples:

    f = 1.0/0.0  # => Infinity
    f.infinite?  # => 1
    f = -1.0/0.0 # => -Infinity
    f.infinite?  # => -1
    f = 1.0      # => 1.0
    f.infinite?  # => nil
    f = 0.0/0.0  # => NaN
    f.infinite?  # => nil

;T;0;;;I"infinite?;F;I"
Float;T;[o;;I" ;F;I"Integer?;To;;0;0;;;I"integer?;F;I"
Float;T;[o;;I" ;F;I"	bool;To;;I"Returns `self` modulo `other` as a float.

For float `f` and real number `r`, these expressions are equivalent:

    f % r
    f-r*(f/r).floor
    f.divmod(r)[1]

See Numeric#divmod.

Examples:

    10.0 % 2              # => 0.0
    10.0 % 3              # => 1.0
    10.0 % 4              # => 2.0

    10.0 % -2             # => 0.0
    10.0 % -3             # => -2.0
    10.0 % -4             # => -2.0

    10.0 % 4.0            # => 2.0
    10.0 % Rational(4, 1) # => 2.0

Float#modulo is an alias for Float#%.

;T;0;;;I"modulo;F;I"
Float;T;[o;;I"::Numeric;T;I"
Float;To;;I" Returns `true` if `self` is a NaN, `false` otherwise.

    f = -1.0     #=> -1.0
    f.nan?       #=> false
    f = 0.0/0.0  #=> NaN
    f.nan?       #=> true

;T;0;;;I"	nan?;F;I"
Float;T;[o;;I" ;F;I"	bool;To;;I"0Returns `true` if `float` is less than 0.

;T;0;;;I"negative?;F;I"
Float;T;[o;;I" ;F;I"	bool;To;;I"öReturns the next-larger representable Float.

These examples show the internally stored values (64-bit hexadecimal) for each
Float `f` and for the corresponding `f.next_float`:

    f = 0.0      # 0x0000000000000000
    f.next_float # 0x0000000000000001

    f = 0.01     # 0x3f847ae147ae147b
    f.next_float # 0x3f847ae147ae147c

In the remaining examples here, the output is shown in the usual way (result
`to_s`):

    0.01.next_float    # => 0.010000000000000002
    1.0.next_float     # => 1.0000000000000002
    100.0.next_float   # => 100.00000000000001

    f = 0.01
    (0..3).each_with_index {|i| printf "%2d %-20a %s\n", i, f, f.to_s; f = f.next_float }

Output:

     0 0x1.47ae147ae147bp-7 0.01
     1 0x1.47ae147ae147cp-7 0.010000000000000002
     2 0x1.47ae147ae147dp-7 0.010000000000000004
     3 0x1.47ae147ae147ep-7 0.010000000000000005

    f = 0.0; 100.times { f += 0.1 }
    f                           # => 9.99999999999998       # should be 10.0 in the ideal world.
    10-f                        # => 1.9539925233402755e-14 # the floating point error.
    10.0.next_float-10          # => 1.7763568394002505e-15 # 1 ulp (unit in the last place).
    (10-f)/(10.0.next_float-10) # => 11.0                   # the error is 11 ulp.
    (10-f)/(10*Float::EPSILON)  # => 8.8                    # approximation of the above.
    "%a" % 10                   # => "0x1.4p+3"
    "%a" % f                    # => "0x1.3fffffffffff5p+3" # the last hex digit is 5.  16 - 5 = 11 ulp.

Related: Float#prev_float

;T;0;;;I"next_float;F;I"
Float;T;[o;;I" ;F;I"
Float;To;;0;0;;;I"nonzero?;F;I"
Float;T;[o;;I" ;F;I"
self?;To;;I"ÖReturns the numerator.  The result is machine dependent.

    n = 0.3.numerator    #=> 5404319552844595
    d = 0.3.denominator  #=> 18014398509481984
    n.fdiv(d)            #=> 0.3

See also Float#denominator.

;T;0;;;I"numerator;F;I"
Float;T;[o;;I" ;F;I"Integer;To;;0;0;;;I"
polar;F;I"
Float;T;[o;;I" ;F;I"%[ ::Float, ::Integer | ::Float ];To;;I"3Returns `true` if `float` is greater than 0.

;T;0;;;I"positive?;F;I"
Float;T;[o;;I" ;F;I"	bool;To;;I"mReturns the next-smaller representable Float.

These examples show the internally stored values (64-bit hexadecimal) for each
Float `f` and for the corresponding `f.pev_float`:

    f = 5e-324   # 0x0000000000000001
    f.prev_float # 0x0000000000000000

    f = 0.01     # 0x3f847ae147ae147b
    f.prev_float # 0x3f847ae147ae147a

In the remaining examples here, the output is shown in the usual way (result
`to_s`):

    0.01.prev_float   # => 0.009999999999999998
    1.0.prev_float    # => 0.9999999999999999
    100.0.prev_float  # => 99.99999999999999

    f = 0.01
    (0..3).each_with_index {|i| printf "%2d %-20a %s\n", i, f, f.to_s; f = f.prev_float }

Output:

    0 0x1.47ae147ae147bp-7 0.01
    1 0x1.47ae147ae147ap-7 0.009999999999999998
    2 0x1.47ae147ae1479p-7 0.009999999999999997
    3 0x1.47ae147ae1478p-7 0.009999999999999995

Related: Float#next_float.

;T;0;;;I"prev_float;F;I"
Float;T;[o;;I" ;F;I"
Float;To;;I"Returns the quotient from dividing `self` by `other`:

    f = 3.14
    f.quo(2)              # => 1.57
    f.quo(-2)             # => -1.57
    f.quo(Rational(2, 1)) # => 1.57
    f.quo(Complex(2, 0))  # => (1.57+0.0i)

Float#fdiv is an alias for Float#quo.

;T;0;;;I"quo;F;I"
Float;T;[o;;I"::Complex;T;I"Complex;To;;I"::Numeric;T;I"
Float;To;;I"4Returns a simpler approximation of the value (flt-|eps| <= result <=
flt+|eps|).  If the optional argument `eps` is not given, it will be chosen
automatically.

    0.3.rationalize          #=> (3/10)
    1.333.rationalize        #=> (1333/1000)
    1.333.rationalize(0.01)  #=> (4/3)

See also Float#to_r.

;T;0;;;I"rationalize;F;I"
Float;T;[o;;I"?::Numeric eps;T;I"Rational;To;;0;0;;;I"	real;F;I"
Float;T;[o;;I" ;F;I"
Float;To;;0;0;;;I"
real?;F;I"
Float;T;[o;;I" ;F;I"	true;Fo;;0;0;;;I"	rect;F;I"
Float;T;[o;;I" ;F;I"[ ::Float, ::Numeric ];To;;0;0;;;I"remainder;F;I"
Float;T;[o;;I"::Numeric;T;I"
Float;To;;I"JReturns `self` rounded to the nearest value with a precision of `ndigits`
decimal digits.

When `ndigits` is non-negative, returns a float with `ndigits` after the
decimal point (as available):

    f = 12345.6789
    f.round(1) # => 12345.7
    f.round(3) # => 12345.679
    f = -12345.6789
    f.round(1) # => -12345.7
    f.round(3) # => -12345.679

When `ndigits` is negative, returns an integer with at least `ndigits.abs`
trailing zeros:

    f = 12345.6789
    f.round(0)  # => 12346
    f.round(-3) # => 12000
    f = -12345.6789
    f.round(0)  # => -12346
    f.round(-3) # => -12000

If keyword argument `half` is given, and `self` is equidistant from the two
candidate values, the rounding is according to the given `half` value:

*   `:up` or `nil`: round away from zero:

        2.5.round(half: :up)      # => 3
        3.5.round(half: :up)      # => 4
        (-2.5).round(half: :up)   # => -3

*   `:down`: round toward zero:

        2.5.round(half: :down)    # => 2
        3.5.round(half: :down)    # => 3
        (-2.5).round(half: :down) # => -2

*   `:even`: round toward the candidate whose last nonzero digit is even:

        2.5.round(half: :even)    # => 2
        3.5.round(half: :even)    # => 4
        (-2.5).round(half: :even) # => -2


Raises and exception if the value for `half` is invalid.

Related: Float#truncate.

;T;0;;;I"
round;F;I"
Float;T;[o;;I"?half: :up | :down | :even;T;I"Integer;To;;I"-::int digits, ?half: :up | :down | :even;T;I"Integer | ::Float;To;;0;0;;;I"	step;F;I"
Float;T;[	o;;I"&?::Numeric limit, ?::Numeric step;T;I"	self;To;;I"&?::Numeric limit, ?::Numeric step;T;I"Enumerator[::Float, self];To;;I"#?by: ::Numeric, ?to: ::Numeric;T;I"	self;To;;I"#?by: ::Numeric, ?to: ::Numeric;T;I"Enumerator[::Float, self];To;;0;0;;;I"	to_c;F;I"
Float;T;[o;;I" ;F;I"Complex;To;;I"8Since `float` is already a Float, returns `self`.

;T;0;;;I"	to_f;F;I"
Float;T;[o;;I" ;F;I"
Float;To;;I"Returns `self` truncated to an Integer.

    1.2.to_i    # => 1
    (-1.2).to_i # => -1

Note that the limited precision of floating-point arithmetic may lead to
surprising results:

    (0.3 / 0.1).to_i  # => 2 (!)

Float#to_int is an alias for Float#to_i.

;T;0;;;I"	to_i;F;I"
Float;T;[o;;I" ;F;I"Integer;To;;I"™Returns the value as a rational.

    2.0.to_r    #=> (2/1)
    2.5.to_r    #=> (5/2)
    -0.75.to_r  #=> (-3/4)
    0.0.to_r    #=> (0/1)
    0.3.to_r    #=> (5404319552844595/18014398509481984)

NOTE: 0.3.to_r isn't the same as "0.3".to_r.  The latter is equivalent to
"3/10".to_r, but the former isn't so.

    0.3.to_r   == 3/10r  #=> false
    "0.3".to_r == 3/10r  #=> true

See also Float#rationalize.

;T;0;;;I"	to_r;F;I"
Float;T;[o;;I" ;F;I"Rational;To;;I"ßReturns a string containing a representation of `self`; depending of the value
of `self`, the string representation may contain:

*   A fixed-point number.
*   A number in "scientific notation" (containing an exponent).
*   'Infinity'.
*   '-Infinity'.
*   'NaN' (indicating not-a-number).

    3.14.to_s         # => "3.14" (10.1**50).to_s   # =>
    "1.644631821843879e+50" (10.1**500).to_s  # => "Infinity"
    (-10.1**500).to_s # => "-Infinity" (0.0/0.0).to_s    # => "NaN"

;T;0;;;I"	to_s;F;I"
Float;T;[o;;I" ;F;I"String;To;;I"Returns `self` truncated (toward zero) to a precision of `ndigits` decimal
digits.

When `ndigits` is positive, returns a float with `ndigits` digits after the
decimal point (as available):

    f = 12345.6789
    f.truncate(1) # => 12345.6
    f.truncate(3) # => 12345.678
    f = -12345.6789
    f.truncate(1) # => -12345.6
    f.truncate(3) # => -12345.678

When `ndigits` is negative, returns an integer with at least `ndigits.abs`
trailing zeros:

    f = 12345.6789
    f.truncate(0)  # => 12345
    f.truncate(-3) # => 12000
    f = -12345.6789
    f.truncate(0)  # => -12345
    f.truncate(-3) # => -12000

Note that the limited precision of floating-point arithmetic may lead to
surprising results:

    (0.3 / 0.1).truncate  #=> 2 (!)

Related: Float#round.

;T;0;;;I"truncate;F;I"
Float;T;[o;;I" ;F;I"Integer;To;;I"::Integer ndigits;T;I"Integer | ::Float;To;;I"(Returns `true` if `float` is 0.0.

;T;0;;;I"
zero?;F;I"
Float;T;[o;;I" ;F;I"	bool;To; ;0;0;	I"
Float;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"@Returns the value of `float` as a BigDecimal. The `precision` parameter is
used to determine the number of significant digits for the result (the default
is Float::DIG).

    require 'bigdecimal'
    require 'bigdecimal/util'

    0.5.to_d         # => 0.5e0
    1.234.to_d(2)    # => 0.12e1

See also BigDecimal::new.

;T;0;;;I"	to_d;F;I"
Float;T;[o;;I"?::Integer precision;T;I"BigDecimal;To; ;0;0;	I"
Float;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"BReturns a JSON string representation for this Float number.

;T;0;;;I"to_json;F;I"
Float;T;[o;;I"?::JSON::State state;T;I"String;To;;I"ûThe GC module provides an interface to Ruby's mark and sweep garbage
collection mechanism.

Some of the underlying methods are also available via the ObjectSpace module.

You may obtain information about the operation of the GC through GC::Profiler.

;T;0;	I"GC;T;
[ ;[ ;0;[ ;[ o;;I"nThe number of times GC occurred.

It returns the number of times GC occurred since the process started.

;T;0;;;I"
count;F;I"GC;T;[o;;I" ;F;I"Integer;To;;I"‘Disables garbage collection, returning `true` if garbage collection was
already disabled.

    GC.disable   #=> false
    GC.disable   #=> true

;T;0;;;I"disable;F;I"GC;T;[o;;I" ;F;I"	bool;To;;I"®Enables garbage collection, returning `true` if garbage collection was
previously disabled.

    GC.disable   #=> false
    GC.enable    #=> true
    GC.enable    #=> false

;T;0;;;I"enable;F;I"GC;T;[o;;I" ;F;I"	bool;To;;I"ïInitiates garbage collection, even if manually disabled.

This method is defined with keyword arguments that default to true:

    def GC.start(full_mark: true, immediate_sweep: true); end

Use full_mark: false to perform a minor GC. Use immediate_sweep: false to
defer sweeping (use lazy sweep).

Note: These keyword arguments are implementation and version dependent. They
are not guaranteed to be future-compatible, and may be ignored if the
underlying implementation does not support them.

;T;0;;;I"
start;F;I"GC;T;[o;;I"|?immediate_sweep: ::boolish immediate_sweep, ?immediate_mark: ::boolish immediate_mark, ?full_mark: ::boolish full_mark;T;I"nil;To;;I"·
Returns a Hash containing information about the GC.

The contents of the hash are implementation specific and may change in the
future without notice.

The hash includes information about internal statistics about GC such as:

count
:   The total number of garbage collections ran since application start (count
    includes both minor and major garbage collections)
heap_allocated_pages
:   The total number of `:heap_eden_pages` + `:heap_tomb_pages`
heap_sorted_length
:   The number of pages that can fit into the buffer that holds references to
    all pages
heap_allocatable_pages
:   The total number of pages the application could allocate without
    additional GC
heap_available_slots
:   The total number of slots in all `:heap_allocated_pages`
heap_live_slots
:   The total number of slots which contain live objects
heap_free_slots
:   The total number of slots which do not contain live objects
heap_final_slots
:   The total number of slots with pending finalizers to be run
heap_marked_slots
:   The total number of objects marked in the last GC
heap_eden_pages
:   The total number of pages which contain at least one live slot
heap_tomb_pages
:   The total number of pages which do not contain any live slots
total_allocated_pages
:   The cumulative number of pages allocated since application start
total_freed_pages
:   The cumulative number of pages freed since application start
total_allocated_objects
:   The cumulative number of objects allocated since application start
total_freed_objects
:   The cumulative number of objects freed since application start
malloc_increase_bytes
:   Amount of memory allocated on the heap for objects. Decreased by any GC
malloc_increase_bytes_limit
:   When `:malloc_increase_bytes` crosses this limit, GC is triggered
minor_gc_count
:   The total number of minor garbage collections run since process start
major_gc_count
:   The total number of major garbage collections run since process start
remembered_wb_unprotected_objects
:   The total number of objects without write barriers
remembered_wb_unprotected_objects_limit
:   When `:remembered_wb_unprotected_objects` crosses this limit, major GC is
    triggered
old_objects
:   Number of live, old objects which have survived at least 3 garbage
    collections
old_objects_limit
:   When `:old_objects` crosses this limit, major GC is triggered
oldmalloc_increase_bytes
:   Amount of memory allocated on the heap for objects. Decreased by major GC
oldmalloc_increase_bytes_limit
:   When `:old_malloc_increase_bytes` crosses this limit, major GC is
    triggered


If the optional argument, hash, is given, it is overwritten and returned. This
is intended to avoid probe effect.

This method is only expected to work on CRuby.

;T;0;;;I"	stat;F;I"GC;T;[o;;I"&?::Hash[::Symbol, ::Integer] arg0;T;I"Hash[::Symbol, ::Integer];To;;I"?::Symbol arg0;T;I"Integer;To;;I"0Returns current status of GC stress mode.

;T;0;;;I"stress;F;I"GC;T;[o;;I" ;F;I")Integer | ::TrueClass | ::FalseClass;To;;I"{Updates the GC stress mode.

When stress mode is enabled, the GC is invoked at every GC opportunity: all
memory and object allocations.

Enabling stress mode will degrade performance, it is only for debugging.

flag can be true, false, or an integer bit-ORed following flags.
    0x01:: no major GC
    0x02:: no immediate sweep
    0x04:: full mark after malloc/calloc/realloc

;T;0;;;I"stress=;F;I"GC;T;[o;;I"0::Integer | ::TrueClass | ::FalseClass flag;T;I")Integer | ::TrueClass | ::FalseClass;To;;I"5Return measured GC total time in nano seconds.

;T;0;;;I"total_time;F;I"GC;T;[o;;I" ;F;I"Integer;To;;I"§This function compacts objects together in Ruby's heap.  It eliminates unused
space (or fragmentation) in the heap by moving objects in to that unused
space.  This function returns a hash which contains statistics about which
objects were moved.  See `GC.latest_gc_info` for details about compaction
statistics.

This method is implementation specific and not expected to be implemented in
any implementation besides MRI.

;T;0;;;I"compact;F;I"GC;T;[o;;I" ;F;I"HHash[:considered | :moved, ::Hash[::Symbol | ::Integer, ::Integer]];To;;I"Verify compaction reference consistency.

This method is implementation specific.  During compaction, objects that were
moved are replaced with T_MOVED objects.  No object should have a reference to
a T_MOVED object after compaction.

This function doubles the heap to ensure room to move all objects, compacts
the heap to make sure everything moves, updates all references, then performs
a full GC.  If any object contains a reference to a T_MOVED object, that
object should be pushed on the mark stack, and will make a SEGV.

;T;0;;;I"!verify_compaction_references;F;I"GC;T;[o;;I" ;F;I"HHash[:considered | :moved, ::Hash[::Symbol | ::Integer, ::Integer]];To;;I"Verify internal consistency.

This method is implementation specific. Now this method checks generational
consistency if RGenGC is supported.

;T;0;;;I" verify_internal_consistency;F;I"GC;T;[o;;I" ;F;I"nil;To;;I" ;T;0;;;I"/verify_transient_heap_internal_consistency;F;I"GC;T;[o;;I" ;F;I"nil;To;;I"²Returns information about the most recent garbage collection.

If the optional argument, hash, is given, it is overwritten and returned. This
is intended to avoid probe effect.

;T;0;;;I"latest_gc_info;F;I"GC;T;[o;;I" ;F;I"Hash[::Symbol, untyped];To;;I"?::Hash[K, untyped] hash;T;I" Hash[::Symbol | K, untyped];To;;I"::Symbol key;T;I"untyped;To;;I" ;T;0;;;I"garbage_collect;F;I"GC;T;[o;;I"|?immediate_sweep: ::boolish immediate_sweep, ?immediate_mark: ::boolish immediate_mark, ?full_mark: ::boolish full_mark;T;I"nil;To;;I"The GC profiler provides access to information on GC runs including time,
length and object space size.

Example:

    GC::Profiler.enable

    require 'rdoc/rdoc'

    GC::Profiler.report

    GC::Profiler.disable

See also GC.count, GC.malloc_allocated_size and GC.malloc_allocations

;T;0;	I"GC::Profiler;T;
[ ;[ ;0;[ ;[ o;;I"#Clears the GC profiler data.

;T;0;;;I"
clear;F;I"GC::Profiler;T;[o;;I" ;F;I"	void;To;;I"Stops the GC profiler.

;T;0;;;I"disable;F;I"GC::Profiler;T;[o;;I" ;F;I"	void;To;;I"Starts the GC profiler.

;T;0;;;I"enable;F;I"GC::Profiler;T;[o;;I" ;F;I"	void;To;;I"-The current status of GC profile mode.

;T;0;;;I"enabled?;F;I"GC::Profiler;T;[o;;I" ;F;I"	bool;To;;I"øReturns an Array of individual raw profile data Hashes ordered from earliest
to latest by `:GC_INVOKE_TIME`.

For example:

    [
      {
         :GC_TIME=>1.3000000000000858e-05,
         :GC_INVOKE_TIME=>0.010634999999999999,
         :HEAP_USE_SIZE=>289640,
         :HEAP_TOTAL_SIZE=>588960,
         :HEAP_TOTAL_OBJECTS=>14724,
         :GC_IS_MARKED=>false
      },
      # ...
    ]

The keys mean:

`:GC_TIME`
:   Time elapsed in seconds for this GC run
`:GC_INVOKE_TIME`
:   Time elapsed in seconds from startup to when the GC was invoked
`:HEAP_USE_SIZE`
:   Total bytes of heap used
`:HEAP_TOTAL_SIZE`
:   Total size of heap in bytes
`:HEAP_TOTAL_OBJECTS`
:   Total number of objects
`:GC_IS_MARKED`
:   Returns `true` if the GC is in mark phase


If ruby was built with `GC_PROFILE_MORE_DETAIL`, you will also have access to
the following hash keys:

`:GC_MARK_TIME`
`:GC_SWEEP_TIME`
`:ALLOCATE_INCREASE`
`:ALLOCATE_LIMIT`
`:HEAP_USE_PAGES`
`:HEAP_LIVE_OBJECTS`
`:HEAP_FREE_OBJECTS`
`:HAVE_FINALIZE`
:

;T;0;;;I"raw_data;F;I"GC::Profiler;T;[o;;I" ;F;I"%Array[::Hash[::Symbol, untyped]];To;;I"JWrites the GC::Profiler.result to `$stdout` or the given IO object.

;T;0;;;I"report;F;I"GC::Profiler;T;[o;;I"?::IO io;T;I"	void;To;;I"3Returns a profile data report such as:

    GC 1 invokes.
    Index    Invoke Time(sec)       Use Size(byte)     Total Size(byte)         Total Object                    GC time(ms)
        1               0.012               159240               212940                10647         0.00000000000001530000

;T;0;;;I"result;F;I"GC::Profiler;T;[o;;I" ;F;I"String;To;;I"<The total time used for garbage collection in seconds

;T;0;;;I"total_time;F;I"GC::Profiler;T;[o;;I" ;F;I"
Float;To; ;I"²:A Hash maps each of its unique keys to a specific value.

A Hash has certain similarities to an Array, but:
*   An Array index is always an Integer.
*   A Hash key can be (almost) any object.


### Hash Data Syntax

The older syntax for Hash data uses the "hash rocket," `=>`:

    h = {:foo => 0, :bar => 1, :baz => 2}
    h # => {:foo=>0, :bar=>1, :baz=>2}

Alternatively, but only for a Hash key that's a Symbol, you can use a newer
JSON-style syntax, where each bareword becomes a Symbol:

    h = {foo: 0, bar: 1, baz: 2}
    h # => {:foo=>0, :bar=>1, :baz=>2}

You can also use a String in place of a bareword:

    h = {'foo': 0, 'bar': 1, 'baz': 2}
    h # => {:foo=>0, :bar=>1, :baz=>2}

And you can mix the styles:

    h = {foo: 0, :bar => 1, 'baz': 2}
    h # => {:foo=>0, :bar=>1, :baz=>2}

But it's an error to try the JSON-style syntax for a key that's not a bareword
or a String:

    # Raises SyntaxError (syntax error, unexpected ':', expecting =>):
    h = {0: 'zero'}

Hash value can be omitted, meaning that value will be fetched from the context
by the name of the key:

    x = 0
    y = 100
    h = {x:, y:}
    h # => {:x=>0, :y=>100}

### Common Uses

You can use a Hash to give names to objects:

    person = {name: 'Matz', language: 'Ruby'}
    person # => {:name=>"Matz", :language=>"Ruby"}

You can use a Hash to give names to method arguments:

    def some_method(hash)
      p hash
    end
    some_method({foo: 0, bar: 1, baz: 2}) # => {:foo=>0, :bar=>1, :baz=>2}

Note: when the last argument in a method call is a Hash, the curly braces may
be omitted:

    some_method(foo: 0, bar: 1, baz: 2) # => {:foo=>0, :bar=>1, :baz=>2}

You can use a Hash to initialize an object:

    class Dev
      attr_accessor :name, :language
      def initialize(hash)
        self.name = hash[:name]
        self.language = hash[:language]
      end
    end
    matz = Dev.new(name: 'Matz', language: 'Ruby')
    matz # => #<Dev: @name="Matz", @language="Ruby">

### Creating a Hash

You can create a Hash object explicitly with:

*   A [hash literal](doc/syntax/literals_rdoc.html#label-Hash+Literals).


You can convert certain objects to Hashes with:

*   Method [Hash](Kernel.html#method-i-Hash).


You can create a Hash by calling method Hash.new.

Create an empty Hash:

    h = Hash.new
    h # => {}
    h.class # => Hash

You can create a Hash by calling method Hash.[].

Create an empty Hash:

    h = Hash[]
    h # => {}

Create a Hash with initial entries:

    h = Hash[foo: 0, bar: 1, baz: 2]
    h # => {:foo=>0, :bar=>1, :baz=>2}

You can create a Hash by using its literal form (curly braces).

Create an empty Hash:

    h = {}
    h # => {}

Create a Hash with initial entries:

    h = {foo: 0, bar: 1, baz: 2}
    h # => {:foo=>0, :bar=>1, :baz=>2}

### Hash Value Basics

The simplest way to retrieve a Hash value (instance method #[]):

    h = {foo: 0, bar: 1, baz: 2}
    h[:foo] # => 0

The simplest way to create or update a Hash value (instance method #[]=):

    h = {foo: 0, bar: 1, baz: 2}
    h[:bat] = 3 # => 3
    h # => {:foo=>0, :bar=>1, :baz=>2, :bat=>3}
    h[:foo] = 4 # => 4
    h # => {:foo=>4, :bar=>1, :baz=>2, :bat=>3}

The simplest way to delete a Hash entry (instance method #delete):

    h = {foo: 0, bar: 1, baz: 2}
    h.delete(:bar) # => 1
    h # => {:foo=>0, :baz=>2}

### Entry Order

A Hash object presents its entries in the order of their creation. This is
seen in:

*   Iterative methods such as `each`, `each_key`, `each_pair`, `each_value`.
*   Other order-sensitive methods such as `shift`, `keys`, `values`.
*   The String returned by method `inspect`.


A new Hash has its initial ordering per the given entries:

    h = Hash[foo: 0, bar: 1]
    h # => {:foo=>0, :bar=>1}

New entries are added at the end:

    h[:baz] = 2
    h # => {:foo=>0, :bar=>1, :baz=>2}

Updating a value does not affect the order:

    h[:baz] = 3
    h # => {:foo=>0, :bar=>1, :baz=>3}

But re-creating a deleted entry can affect the order:

    h.delete(:foo)
    h[:foo] = 5
    h # => {:bar=>1, :baz=>3, :foo=>5}

### Hash Keys

#### Hash Key Equivalence

Two objects are treated as the same hash key when their `hash` value is
identical and the two objects are `eql?` to each other.

#### Modifying an Active Hash Key

Modifying a Hash key while it is in use damages the hash's index.

This Hash has keys that are Arrays:

    a0 = [ :foo, :bar ]
    a1 = [ :baz, :bat ]
    h = {a0 => 0, a1 => 1}
    h.include?(a0) # => true
    h[a0] # => 0
    a0.hash # => 110002110

Modifying array element `a0[0]` changes its hash value:

    a0[0] = :bam
    a0.hash # => 1069447059

And damages the Hash index:

    h.include?(a0) # => false
    h[a0] # => nil

You can repair the hash index using method `rehash`:

    h.rehash # => {[:bam, :bar]=>0, [:baz, :bat]=>1}
    h.include?(a0) # => true
    h[a0] # => 0

A String key is always safe. That's because an unfrozen String passed as a key
will be replaced by a duplicated and frozen String:

    s = 'foo'
    s.frozen? # => false
    h = {s => 0}
    first_key = h.keys.first
    first_key.frozen? # => true

#### User-Defined Hash Keys

To be useable as a Hash key, objects must implement the methods `hash` and
`eql?`. Note: this requirement does not apply if the Hash uses
#compare_by_identity since comparison will then rely on the keys' object id
instead of `hash` and `eql?`.

Object defines basic implementation for `hash` and `eq?` that makes each
object a distinct key. Typically, user-defined classes will want to override
these methods to provide meaningful behavior, or for example inherit Struct
that has useful definitions for these.

A typical implementation of `hash` is based on the object's data while `eql?`
is usually aliased to the overridden `==` method:

    class Book
      attr_reader :author, :title

      def initialize(author, title)
        @author = author
        @title = title
      end

      def ==(other)
        self.class === other &&
          other.author == @author &&
          other.title == @title
      end

      alias eql? ==

      def hash
        @author.hash ^ @title.hash # XOR
      end
    end

    book1 = Book.new 'matz', 'Ruby in a Nutshell'
    book2 = Book.new 'matz', 'Ruby in a Nutshell'

    reviews = {}

    reviews[book1] = 'Great reference!'
    reviews[book2] = 'Nice and compact!'

    reviews.length #=> 1

### Default Values

The methods #[], #values_at and #dig need to return the value associated to a
certain key. When that key is not found, that value will be determined by its
default proc (if any) or else its default (initially `nil`).

You can retrieve the default value with method #default:

    h = Hash.new
    h.default # => nil

You can set the default value by passing an argument to method Hash.new or
with method #default=

    h = Hash.new(-1)
    h.default # => -1
    h.default = 0
    h.default # => 0

This default value is returned for #[], #values_at and #dig when a key is not
found:

    counts = {foo: 42}
    counts.default # => nil (default)
    counts[:foo] = 42
    counts[:bar] # => nil
    counts.default = 0
    counts[:bar] # => 0
    counts.values_at(:foo, :bar, :baz) # => [42, 0, 0]
    counts.dig(:bar) # => 0

Note that the default value is used without being duplicated. It is not
advised to set the default value to a mutable object:

    synonyms = Hash.new([])
    synonyms[:hello] # => []
    synonyms[:hello] << :hi # => [:hi], but this mutates the default!
    synonyms.default # => [:hi]
    synonyms[:world] << :universe
    synonyms[:world] # => [:hi, :universe], oops
    synonyms.keys # => [], oops

To use a mutable object as default, it is recommended to use a default proc

#### Default Proc

When the default proc for a Hash is set (i.e., not `nil`), the default value
returned by method #[] is determined by the default proc alone.

You can retrieve the default proc with method #default_proc:

    h = Hash.new
    h.default_proc # => nil

You can set the default proc by calling Hash.new with a block or calling the
method #default_proc=

    h = Hash.new { |hash, key| "Default value for #{key}" }
    h.default_proc.class # => Proc
    h.default_proc = proc { |hash, key| "Default value for #{key.inspect}" }
    h.default_proc.class # => Proc

When the default proc is set (i.e., not `nil`) and method #[] is called with
with a non-existent key, #[] calls the default proc with both the Hash object
itself and the missing key, then returns the proc's return value:

    h = Hash.new { |hash, key| "Default value for #{key}" }
    h[:nosuch] # => "Default value for nosuch"

Note that in the example above no entry for key `:nosuch` is created:

    h.include?(:nosuch) # => false

However, the proc itself can add a new entry:

    synonyms = Hash.new { |hash, key| hash[key] = [] }
    synonyms.include?(:hello) # => false
    synonyms[:hello] << :hi # => [:hi]
    synonyms[:world] << :universe # => [:universe]
    synonyms.keys # => [:hello, :world]

Note that setting the default proc will clear the default value and vice
versa.

### What's Here

First, what's elsewhere. Class Hash:

*   Inherits from [class
    Object](Object.html#class-Object-label-What-27s+Here).
*   Includes [module
    Enumerable](Enumerable.html#module-Enumerable-label-What-27s+Here), which
    provides dozens of additional methods.


Here, class Hash provides methods that are useful for:

*   [Creating a Hash](#class-Hash-label-Methods+for+Creating+a+Hash)
*   [Setting Hash State](#class-Hash-label-Methods+for+Setting+Hash+State)
*   [Querying](#class-Hash-label-Methods+for+Querying)
*   [Comparing](#class-Hash-label-Methods+for+Comparing)
*   [Fetching](#class-Hash-label-Methods+for+Fetching)
*   [Assigning](#class-Hash-label-Methods+for+Assigning)
*   [Deleting](#class-Hash-label-Methods+for+Deleting)
*   [Iterating](#class-Hash-label-Methods+for+Iterating)
*   [Converting](#class-Hash-label-Methods+for+Converting)
*   [Transforming Keys and
    Values](#class-Hash-label-Methods+for+Transforming+Keys+and+Values)
*   [And more....](#class-Hash-label-Other+Methods)


Class Hash also includes methods from module Enumerable.

#### Methods for Creating a Hash

::[]
:   Returns a new hash populated with given objects.
::new
:   Returns a new empty hash.
::try_convert
:   Returns a new hash created from a given object.


#### Methods for Setting Hash State

#compare_by_identity
:   Sets `self` to consider only identity in comparing keys.
#default=
:   Sets the default to a given value.
#default_proc=
:   Sets the default proc to a given proc.
#rehash
:   Rebuilds the hash table by recomputing the hash index for each key.


#### Methods for Querying

#any?
:   Returns whether any element satisfies a given criterion.
#compare_by_identity?
:   Returns whether the hash considers only identity when comparing keys.
#default
:   Returns the default value, or the default value for a given key.
#default_proc
:   Returns the default proc.
#empty?
:   Returns whether there are no entries.
#eql?
:   Returns whether a given object is equal to `self`.
#hash
:   Returns the integer hash code.
#has_value?
:   Returns whether a given object is a value in `self`.
#include?, #has_key?, #member?, #key?
:   Returns whether a given object is a key in `self`.
#length, #size
:   Returns the count of entries.
#value?
:   Returns whether a given object is a value in `self`.


#### Methods for Comparing

[#<](#method-i-3C)
:   Returns whether `self` is a proper subset of a given object.
[#<=](#method-i-3C-3D)
:   Returns whether `self` is a subset of a given object.
[#==](#method-i-3D-3D)
:   Returns whether a given object is equal to `self`.
[#>](#method-i-3E)
:   Returns whether `self` is a proper superset of a given object
[#>=](#method-i-3E-3D)
:   Returns whether `self` is a proper superset of a given object.


#### Methods for Fetching

#[]
:   Returns the value associated with a given key.
#assoc
:   Returns a 2-element array containing a given key and its value.
#dig
:   Returns the object in nested objects that is specified by a given key and
    additional arguments.
#fetch
:   Returns the value for a given key.
#fetch_values
:   Returns array containing the values associated with given keys.
#key
:   Returns the key for the first-found entry with a given value.
#keys
:   Returns an array containing all keys in `self`.
#rassoc
:   Returns a 2-element array consisting of the key and value of the
    first-found entry having a given value.
#values
:   Returns an array containing all values in `self`/
#values_at
:   Returns an array containing values for given keys.


#### Methods for Assigning

#[]=, #store
:   Associates a given key with a given value.
#merge
:   Returns the hash formed by merging each given hash into a copy of `self`.
#merge!, #update
:   Merges each given hash into `self`.
#replace
:   Replaces the entire contents of `self` with the contents of a givan hash.


#### Methods for Deleting

These methods remove entries from `self`:

#clear
:   Removes all entries from `self`.
#compact!
:   Removes all `nil`-valued entries from `self`.
#delete
:   Removes the entry for a given key.
#delete_if
:   Removes entries selected by a given block.
#filter!, #select!
:   Keep only those entries selected by a given block.
#keep_if
:   Keep only those entries selected by a given block.
#reject!
:   Removes entries selected by a given block.
#shift
:   Removes and returns the first entry.


These methods return a copy of `self` with some entries removed:

#compact
:   Returns a copy of `self` with all `nil`-valued entries removed.
#except
:   Returns a copy of `self` with entries removed for specified keys.
#filter, #select
:   Returns a copy of `self` with only those entries selected by a given
    block.
#reject
:   Returns a copy of `self` with entries removed as specified by a given
    block.
#slice
:   Returns a hash containing the entries for given keys.


#### Methods for Iterating
#each, #each_pair
:   Calls a given block with each key-value pair.
#each_key
:   Calls a given block with each key.
#each_value
:   Calls a given block with each value.


#### Methods for Converting

#inspect, #to_s
:   Returns a new String containing the hash entries.
#to_a
:   Returns a new array of 2-element arrays; each nested array contains a
    key-value pair from `self`.
#to_h
:   Returns `self` if a Hash; if a subclass of Hash, returns a Hash containing
    the entries from `self`.
#to_hash
:   Returns `self`.
#to_proc
:   Returns a proc that maps a given key to its value.


#### Methods for Transforming Keys and Values

#transform_keys
:   Returns a copy of `self` with modified keys.
#transform_keys!
:   Modifies keys in `self`
#transform_values
:   Returns a copy of `self` with modified values.
#transform_values!
:   Modifies values in `self`.


#### Other Methods
#flatten
:   Returns an array that is a 1-dimensional flattening of `self`.
#invert
:   Returns a hash with the each key-value pair inverted.

;T;0;	I"	Hash;T;
[ ;[I"Enumerable;T;0;[ ;[ ;0;I"Object;To;;I"DReturns a new Hash object populated with the given objects, if any. See
Hash::new.

With no argument, returns a new empty Hash.

When the single given argument is a Hash, returns a new Hash populated with
the entries from the given Hash, excluding the default value or proc.

    h = {foo: 0, bar: 1, baz: 2}
    Hash[h] # => {:foo=>0, :bar=>1, :baz=>2}

When the single given argument is an Array of 2-element Arrays, returns a new
Hash object wherein each 2-element array forms a key-value entry:

    Hash[ [ [:foo, 0], [:bar, 1] ] ] # => {:foo=>0, :bar=>1}

When the argument count is an even number; returns a new Hash object wherein
each successive pair of arguments has become a key-value entry:

    Hash[:foo, 0, :bar, 1] # => {:foo=>0, :bar=>1}

Raises an exception if the argument list does not conform to any of the above.

;T;0;;;I"[];F;I"	Hash;T;[o;;I"::_ToHash[U, V];T;I"Hash[U, V];To;;I"::Array[[ U, V ]];T;I"Hash[U, V];To;;I"*untyped;T;I"Hash[untyped, untyped];To;;I"ûIf `obj` is a Hash object, returns `obj`.

Otherwise if `obj` responds to `:to_hash`, calls `obj.to_hash` and returns the
result.

Returns `nil` if `obj` does not respond to `:to_hash`

Raises an exception unless `obj.to_hash` returns a Hash object.

;T;0;;;I"try_convert;F;I"	Hash;T;[o;;I"::_ToHash[U, V];T;I"Hash[U, V];To;;I"untyped;T;I"!Hash[untyped, untyped] | nil;To;;I"ÑReturns `true` if `hash` is a proper subset of `other_hash`, `false`
otherwise:
    h1 = {foo: 0, bar: 1}
    h2 = {foo: 0, bar: 1, baz: 2}
    h1 < h2 # => true
    h2 < h1 # => false
    h1 < h1 # => false

;T;0;;;I"<;F;I"	Hash;T;[o;;I"::Hash[A, B];T;I"	bool;To;;I"ÌReturns `true` if `hash` is a subset of `other_hash`, `false` otherwise:
    h1 = {foo: 0, bar: 1}
    h2 = {foo: 0, bar: 1, baz: 2}
    h1 <= h2 # => true
    h2 <= h1 # => false
    h1 <= h1 # => true

;T;0;;;I"<=;F;I"	Hash;T;[o;;I"::Hash[A, B];T;I"	bool;To;;I"Returns `true` if all of the following are true:
*   `object` is a Hash object.
*   `hash` and `object` have the same keys (regardless of order).
*   For each key `key`, `hash[key] == object[key]`.


Otherwise, returns `false`.

Equal:
    h1 = {foo: 0, bar: 1, baz: 2}
    h2 = {foo: 0, bar: 1, baz: 2}
    h1 == h2 # => true
    h3 = {baz: 2, bar: 1, foo: 0}
    h1 == h3 # => true

;T;0;;;I"==;F;I"	Hash;T;[o;;I"untyped other;T;I"	bool;To;;I"ÓReturns `true` if `hash` is a proper superset of `other_hash`, `false`
otherwise:
    h1 = {foo: 0, bar: 1, baz: 2}
    h2 = {foo: 0, bar: 1}
    h1 > h2 # => true
    h2 > h1 # => false
    h1 > h1 # => false

;T;0;;;I">;F;I"	Hash;T;[o;;I"::Hash[A, B];T;I"	bool;To;;I"ÎReturns `true` if `hash` is a superset of `other_hash`, `false` otherwise:
    h1 = {foo: 0, bar: 1, baz: 2}
    h2 = {foo: 0, bar: 1}
    h1 >= h2 # => true
    h2 >= h1 # => false
    h1 >= h1 # => true

;T;0;;;I">=;F;I"	Hash;T;[o;;I"::Hash[A, B];T;I"	bool;To;;I"Returns the value associated with the given `key`, if found:
    h = {foo: 0, bar: 1, baz: 2}
    h[:foo] # => 0

If `key` is not found, returns a default value (see [Default
Values](#class-Hash-label-Default+Values)):
    h = {foo: 0, bar: 1, baz: 2}
    h[:nosuch] # => nil

;T;0;;;I"[];F;I"	Hash;T;[o;;I"K arg0;T;I"V;Fo;;I"vHash#store is an alias for Hash#[]=.

Associates the given `value` with the given `key`; returns `value`.

If the given `key` exists, replaces its value with the given `value`; the
ordering is not affected (see [Entry Order](#class-Hash-label-Entry+Order)):
    h = {foo: 0, bar: 1}
    h[:foo] = 2 # => 2
    h.store(:bar, 3) # => 3
    h # => {:foo=>2, :bar=>3}

If `key` does not exist, adds the `key` and `value`; the new entry is last in
the order (see [Entry Order](#class-Hash-label-Entry+Order)):
    h = {foo: 0, bar: 1}
    h[:baz] = 2 # => 2
    h.store(:bat, 3) # => 3
    h # => {:foo=>0, :bar=>1, :baz=>2, :bat=>3}

;T;0;;;I"[]=;F;I"	Hash;T;[o;;I"K arg0, V arg1;T;I"V;Fo;;I"¡Returns `true` if any element satisfies a given criterion; `false` otherwise.

With no argument and no block, returns `true` if `self` is non-empty; `false`
if empty.

With argument `object` and no block, returns `true` if for any key `key`
`h.assoc(key) == object`:
    h = {foo: 0, bar: 1, baz: 2}
    h.any?([:bar, 1]) # => true
    h.any?([:bar, 0]) # => false
    h.any?([:baz, 1]) # => false

With no argument and a block, calls the block with each key-value pair;
returns `true` if the block returns any truthy value, `false` otherwise:
    h = {foo: 0, bar: 1, baz: 2}
    h.any? {|key, value| value < 3 } # => true
    h.any? {|key, value| value > 3 } # => false

;T;0;;;I"	any?;F;I"	Hash;T;[o;;I" ;F;I"	bool;To;;I"untyped pattern;T;I"	bool;To;;I" ;F;I"	bool;To;;I"ÇIf the given `key` is found, returns a 2-element Array containing that key and
its value:
    h = {foo: 0, bar: 1, baz: 2}
    h.assoc(:bar) # => [:bar, 1]

Returns `nil` if key `key` is not found.

;T;0;;;I"
assoc;F;I"	Hash;T;[o;;I"K arg0;T;I"[ K, V ]?;To;;I"0Removes all hash entries; returns `self`.

;T;0;;;I"
clear;F;I"	Hash;T;[o;;I" ;F;I"	self;To;;I" Returns a copy of `self` with all `nil`-valued entries removed:
    h = {foo: 0, bar: nil, baz: 2, bat: nil}
    h1 = h.compact
    h1 # => {:foo=>0, :baz=>2}

;T;0;;;I"compact;F;I"	Hash;T;[o;;I" ;F;I"Hash[K, V];To;;I"ÅReturns `self` with all its `nil`-valued entries removed (in place):
    h = {foo: 0, bar: nil, baz: 2, bat: nil}
    h.compact! # => {:foo=>0, :baz=>2}

Returns `nil` if no entries were removed.

;T;0;;;I"compact!;F;I"	Hash;T;[o;;I" ;F;I"
self?;To;;I"iSets `self` to consider only identity in comparing keys; two keys are
considered the same only if they are the same object; returns `self`.

By default, these two object are considered to be the same key, so `s1` will
overwrite `s0`:
    s0 = 'x'
    s1 = 'x'
    h = {}
    h.compare_by_identity? # => false
    h[s0] = 0
    h[s1] = 1
    h # => {"x"=>1}

After calling #compare_by_identity, the keys are considered to be different,
and therefore do not overwrite each other:
    h = {}
    h.compare_by_identity # => {}
    h.compare_by_identity? # => true
    h[s0] = 0
    h[s1] = 1
    h # => {"x"=>0, "x"=>1}

;T;0;;;I"compare_by_identity;F;I"	Hash;T;[o;;I" ;F;I"	self;To;;I"QReturns `true` if #compare_by_identity has been called, `false` otherwise.

;T;0;;;I"compare_by_identity?;F;I"	Hash;T;[o;;I" ;F;I"	bool;To;;I" ;T;0;;;I"deconstruct_keys;F;I"	Hash;T;[o;;I"::Array[K] | nil;T;I"	self;To;;I"òReturns the default value for the given `key`. The returned value will be
determined either by the default proc or by the default value. See [Default
Values](#class-Hash-label-Default+Values).

With no argument, returns the current default value:
    h = {}
    h.default # => nil

If `key` is given, returns the default value for `key`, regardless of whether
that key exists:
    h = Hash.new { |hash, key| hash[key] = "No key #{key}"}
    h[:foo] = "Hello"
    h.default(:foo) # => "No key foo"

;T;0;;;I"default;F;I"	Hash;T;[o;;I"?K arg0;T;I"V?;To;;I"ÊSets the default value to `value`; returns `value`:
    h = {}
    h.default # => nil
    h.default = false # => false
    h.default # => false

See [Default Values](#class-Hash-label-Default+Values).

;T;0;;;I"default=;F;I"	Hash;T;[o;;I"V arg0;T;I"V;Fo;;I"íReturns the default proc for `self` (see [Default
Values](#class-Hash-label-Default+Values)):
    h = {}
    h.default_proc # => nil
    h.default_proc = proc {|hash, key| "Default value for #{key}" }
    h.default_proc.class # => Proc

;T;0;;;I"default_proc;F;I"	Hash;T;[o;;I" ;F;I"Proc | nil;To;;I"+Sets the default proc for `self` to `proc`: (see [Default
Values](#class-Hash-label-Default+Values)):
    h = {}
    h.default_proc # => nil
    h.default_proc = proc { |hash, key| "Default value for #{key}" }
    h.default_proc.class # => Proc
    h.default_proc = nil
    h.default_proc # => nil

;T;0;;;I"default_proc=;F;I"	Hash;T;[o;;I"::Proc | ::_ToProc | nil;T;I"Proc | ::_ToProc | nil;To;;I"%Deletes the entry for the given `key` and returns its associated value.

If no block is given and `key` is found, deletes the entry and returns the
associated value:
    h = {foo: 0, bar: 1, baz: 2}
    h.delete(:bar) # => 1
    h # => {:foo=>0, :baz=>2}

If no block given and `key` is not found, returns `nil`.

If a block is given and `key` is found, ignores the block, deletes the entry,
and returns the associated value:
    h = {foo: 0, bar: 1, baz: 2}
    h.delete(:baz) { |key| raise 'Will never happen'} # => 2
    h # => {:foo=>0, :bar=>1}

If a block is given and `key` is not found, calls the block and returns the
block's return value:
    h = {foo: 0, bar: 1, baz: 2}
    h.delete(:nosuch) { |key| "Key #{key} not found" } # => "Key nosuch not found"
    h # => {:foo=>0, :bar=>1, :baz=>2}

;T;0;;;I"delete;F;I"	Hash;T;[o;;I"K arg0;T;I"V?;To;;I"K arg0;T;I"
U | V;Fo;;I"¸If a block given, calls the block with each key-value pair; deletes each entry
for which the block returns a truthy value; returns `self`:
    h = {foo: 0, bar: 1, baz: 2}
    h.delete_if {|key, value| value > 0 } # => {:foo=>0}

If no block given, returns a new Enumerator:
    h = {foo: 0, bar: 1, baz: 2}
    e = h.delete_if # => #<Enumerator: {:foo=>0, :bar=>1, :baz=>2}:delete_if>
    e.each { |key, value| value > 0 } # => {:foo=>0}

;T;0;;;I"delete_if;F;I"	Hash;T;[o;;I" ;F;I"	self;To;;I" ;F;I"Enumerator[[ K, V ], self];To;;I"Finds and returns the object in nested objects that is specified by `key` and
`identifiers`. The nested objects may be instances of various classes. See
[Dig Methods](rdoc-ref:dig_methods.rdoc).

Nested Hashes:
    h = {foo: {bar: {baz: 2}}}
    h.dig(:foo) # => {:bar=>{:baz=>2}}
    h.dig(:foo, :bar) # => {:baz=>2}
    h.dig(:foo, :bar, :baz) # => 2
    h.dig(:foo, :bar, :BAZ) # => nil

Nested Hashes and Arrays:
    h = {foo: {bar: [:a, :b, :c]}}
    h.dig(:foo, :bar, 2) # => :c

This method will use the [default values](#class-Hash-label-Default+Values)
for keys that are not present:
    h = {foo: {bar: [:a, :b, :c]}}
    h.dig(:hello) # => nil
    h.default_proc = -> (hash, _key) { hash }
    h.dig(:hello, :world) # => h
    h.dig(:hello, :world, :foo, :bar, 2) # => :c

;T;0;;;I"dig;F;I"	Hash;T;[o;;I"K, *untyped;T;I"untyped;To;;I"4Hash#each is an alias for Hash#each_pair.

Calls the given block with each key-value pair; returns `self`:
    h = {foo: 0, bar: 1, baz: 2}
    h.each_pair {|key, value| puts "#{key}: #{value}"} # => {:foo=>0, :bar=>1, :baz=>2}

Output:
    foo: 0
    bar: 1
    baz: 2

Returns a new Enumerator if no block given:
    h = {foo: 0, bar: 1, baz: 2}
    e = h.each_pair # => #<Enumerator: {:foo=>0, :bar=>1, :baz=>2}:each_pair>
    h1 = e.each {|key, value| puts "#{key}: #{value}"}
    h1 # => {:foo=>0, :bar=>1, :baz=>2}

Output:
    foo: 0
    bar: 1
    baz: 2

;T;0;;;I"	each;F;I"	Hash;T;[o;;I" ;F;I"	self;To;;I" ;F;I"Enumerator[[ K, V ], self];To;;I"ÀCalls the given block with each key; returns `self`:
    h = {foo: 0, bar: 1, baz: 2}
    h.each_key {|key| puts key }  # => {:foo=>0, :bar=>1, :baz=>2}

Output:
    foo
    bar
    baz

Returns a new Enumerator if no block given:
    h = {foo: 0, bar: 1, baz: 2}
    e = h.each_key # => #<Enumerator: {:foo=>0, :bar=>1, :baz=>2}:each_key>
    h1 = e.each {|key| puts key }
    h1 # => {:foo=>0, :bar=>1, :baz=>2}

Output:
    foo
    bar
    baz

;T;0;;;I"each_key;F;I"	Hash;T;[o;;I" ;F;I"Hash[K, V];To;;I" ;F;I"Enumerator[K, self];To;;I"ÃCalls the given block with each value; returns `self`:
    h = {foo: 0, bar: 1, baz: 2}
    h.each_value {|value| puts value } # => {:foo=>0, :bar=>1, :baz=>2}

Output:
    0
    1
    2

Returns a new Enumerator if no block given:
    h = {foo: 0, bar: 1, baz: 2}
    e = h.each_value # => #<Enumerator: {:foo=>0, :bar=>1, :baz=>2}:each_value>
    h1 = e.each {|value| puts value }
    h1 # => {:foo=>0, :bar=>1, :baz=>2}

Output:
    0
    1
    2

;T;0;;;I"each_value;F;I"	Hash;T;[o;;I" ;F;I"	self;To;;I" ;F;I"Enumerator[V, self];To;;I"ˆReturns `true` if there are no hash entries, `false` otherwise:
    {}.empty? # => true
    {foo: 0, bar: 1, baz: 2}.empty? # => false

;T;0;;;I"empty?;F;I"	Hash;T;[o;;I" ;F;I"	bool;To;;I"„Returns `true` if all of the following are true:
*   `object` is a Hash object.
*   `hash` and `object` have the same keys (regardless of order).
*   For each key `key`, `h[key] eql? object[key]`.


Otherwise, returns `false`.

Equal:
    h1 = {foo: 0, bar: 1, baz: 2}
    h2 = {foo: 0, bar: 1, baz: 2}
    h1.eql? h2 # => true
    h3 = {baz: 2, bar: 1, foo: 0}
    h1.eql? h3 # => true

;T;0;;;I"	eql?;F;I"	Hash;T;[o;;I"untyped;T;I"	bool;To;;I"ÂReturns a new Hash excluding entries for the given `keys`:
    h = { a: 100, b: 200, c: 300 }
    h.except(:a)          #=> {:b=>200, :c=>300}

Any given `keys` that are not found are ignored.

;T;0;;;I"except;F;I"	Hash;T;[o;;I"*K;T;I"Hash[K, V];To;;I"*Returns the value for the given `key`, if found.
    h = {foo: 0, bar: 1, baz: 2}
    h.fetch(:bar) # => 1

If `key` is not found and no block was given, returns `default_value`:
    {}.fetch(:nosuch, :default) # => :default

If `key` is not found and a block was given, yields `key` to the block and
returns the block's return value:
    {}.fetch(:nosuch) {|key| "No key #{key}"} # => "No key nosuch"

Raises KeyError if neither `default_value` nor a block was given.

Note that this method does not use the values of either #default or
#default_proc.

;T;0;;;I"
fetch;F;I"	Hash;T;[o;;I"K arg0;T;I"V;Fo;;I"K arg0, X arg1;T;I"
V | X;Fo;;I"K arg0;T;I"
V | X;Fo;;I""Returns a new Array containing the values associated with the given keys
*keys:
    h = {foo: 0, bar: 1, baz: 2}
    h.fetch_values(:baz, :foo) # => [2, 0]

Returns a new empty Array if no arguments given.

When a block is given, calls the block with each missing key, treating the
block's return value as the value for that key:
    h = {foo: 0, bar: 1, baz: 2}
    values = h.fetch_values(:bar, :foo, :bad, :bam) {|key| key.to_s}
    values # => [1, 0, "bad", "bam"]

When no block is given, raises an exception if any given key is not found.

;T;0;;;I"fetch_values;F;I"	Hash;T;[o;;I"*K;T;I"Array[V];To;;I"*K;T;I"Array[V | X];To;;I"¼Hash#filter is an alias for Hash#select.

Returns a new Hash object whose entries are those for which the block returns
a truthy value:
    h = {foo: 0, bar: 1, baz: 2}
    h.select {|key, value| value < 2 } # => {:foo=>0, :bar=>1}

Returns a new Enumerator if no block given:
    h = {foo: 0, bar: 1, baz: 2}
    e = h.select # => #<Enumerator: {:foo=>0, :bar=>1, :baz=>2}:select>
    e.each {|key, value| value < 2 } # => {:foo=>0, :bar=>1}

;T;0;;;I"filter;F;I"	Hash;T;[o;;I" ;F;I"Hash[K, V];To;;I" ;F;I"'Enumerator[[ K, V ], ::Hash[K, V]];To;;I"ãHash#filter! is an alias for Hash#select!.

Returns `self`, whose entries are those for which the block returns a truthy
value:
    h = {foo: 0, bar: 1, baz: 2}
    h.select! {|key, value| value < 2 }  => {:foo=>0, :bar=>1}

Returns `nil` if no entries were removed.

Returns a new Enumerator if no block given:
    h = {foo: 0, bar: 1, baz: 2}
    e = h.select!  # => #<Enumerator: {:foo=>0, :bar=>1, :baz=>2}:select!>
    e.each { |key, value| value < 2 } # => {:foo=>0, :bar=>1}

;T;0;;;I"filter!;F;I"	Hash;T;[o;;I" ;F;I"
self?;To;;I" ;F;I" Enumerator[[ K, V ], self?];To;;I"áReturns a new Array object that is a 1-dimensional flattening of `self`.

---

By default, nested Arrays are not flattened:
    h = {foo: 0, bar: [:bat, 3], baz: 2}
    h.flatten # => [:foo, 0, :bar, [:bat, 3], :baz, 2]

Takes the depth of recursive flattening from Integer argument `level`:
    h = {foo: 0, bar: [:bat, [:baz, [:bat, ]]]}
    h.flatten(1) # => [:foo, 0, :bar, [:bat, [:baz, [:bat]]]]
    h.flatten(2) # => [:foo, 0, :bar, :bat, [:baz, [:bat]]]
    h.flatten(3) # => [:foo, 0, :bar, :bat, :baz, [:bat]]
    h.flatten(4) # => [:foo, 0, :bar, :bat, :baz, :bat]

When `level` is negative, flattens all nested Arrays:
    h = {foo: 0, bar: [:bat, [:baz, [:bat, ]]]}
    h.flatten(-1) # => [:foo, 0, :bar, :bat, :baz, :bat]
    h.flatten(-2) # => [:foo, 0, :bar, :bat, :baz, :bat]

When `level` is zero, returns the equivalent of #to_a :
    h = {foo: 0, bar: [:bat, 3], baz: 2}
    h.flatten(0) # => [[:foo, 0], [:bar, [:bat, 3]], [:baz, 2]]
    h.flatten(0) == h.to_a # => true

;T;0;;;I"flatten;F;I"	Hash;T;[o;;I" ;F;I"Array[K | V];To;;I"1 level;T;I"Array[K | V];To;;I"::Integer level;T;I"Array[untyped];To;;I"ƒMethods #has_key?, #key?, and #member? are aliases for #include?.

Returns `true` if `key` is a key in `self`, otherwise `false`.

;T;0;;;I"has_key?;F;I"	Hash;T;[o;;I"K arg0;T;I"	bool;To;;I"vMethod #value? is an alias for #has_value?.

Returns `true` if `value` is a value in `self`, otherwise `false`.

;T;0;;;I"has_value?;F;I"	Hash;T;[o;;I"V arg0;T;I"	bool;To;;I"	Returns the Integer hash-code for the hash.

Two Hash objects have the same hash-code if their content is the same
(regardless or order):
    h1 = {foo: 0, bar: 1, baz: 2}
    h2 = {baz: 2, bar: 1, foo: 0}
    h2.hash == h1.hash # => true
    h2.eql? h1 # => true

;T;0;;;I"	hash;F;I"	Hash;T;[o;;I" ;F;I"Integer;To;;I"®Returns a new String containing the hash entries:
    h = {foo: 0, bar: 1, baz: 2}
    h.inspect # => "{:foo=>0, :bar=>1, :baz=>2}"

Hash#to_s is an alias for Hash#inspect.

;T;0;;;I"inspect;F;I"	Hash;T;[o;;I" ;F;I"String;To;;I"1Returns a new Hash object with the each key-value pair inverted:
    h = {foo: 0, bar: 1, baz: 2}
    h1 = h.invert
    h1 # => {0=>:foo, 1=>:bar, 2=>:baz}

Overwrites any repeated new keys: (see [Entry
Order](#class-Hash-label-Entry+Order)):
    h = {foo: 0, bar: 0, baz: 0}
    h.invert # => {0=>:baz}

;T;0;;;I"invert;F;I"	Hash;T;[o;;I" ;F;I"Hash[V, K];To;;I"ÜCalls the block for each key-value pair; retains the entry if the block
returns a truthy value; otherwise deletes the entry; returns `self`.
    h = {foo: 0, bar: 1, baz: 2}
    h.keep_if { |key, value| key.start_with?('b') } # => {:bar=>1, :baz=>2}

Returns a new Enumerator if no block given:
    h = {foo: 0, bar: 1, baz: 2}
    e = h.keep_if # => #<Enumerator: {:foo=>0, :bar=>1, :baz=>2}:keep_if>
    e.each { |key, value| key.start_with?('b') } # => {:bar=>1, :baz=>2}

;T;0;;;I"keep_if;F;I"	Hash;T;[o;;I" ;F;I"	self;To;;I" ;F;I"Enumerator[[ K, V ], self];To;;I"ïReturns the key for the first-found entry with the given `value` (see [Entry
Order](#class-Hash-label-Entry+Order)):
    h = {foo: 0, bar: 2, baz: 2}
    h.key(0) # => :foo
    h.key(2) # => :bar

Returns `nil` if so such value is found.

;T;0;;;I"key;F;I"	Hash;T;[o;;I"V;T;I"K?;To;;I"}Returns a new Array containing all keys in `self`:
    h = {foo: 0, bar: 1, baz: 2}
    h.keys # => [:foo, :bar, :baz]

;T;0;;;I"	keys;F;I"	Hash;T;[o;;I" ;F;I"Array[K];To;;I"|Returns the count of entries in `self`:
    {foo: 0, bar: 1, baz: 2}.length # => 3

Hash#length is an alias for Hash#size.

;T;0;;;I"length;F;I"	Hash;T;[o;;I" ;F;I"Integer;To;;I"œReturns the new Hash formed by merging each of `other_hashes` into a copy of
`self`.

Each argument in `other_hashes` must be a Hash.

---

With arguments and no block:
*   Returns the new Hash object formed by merging each successive Hash in
    `other_hashes` into `self`.
*   Each new-key entry is added at the end.
*   Each duplicate-key entry's value overwrites the previous value.


Example:
    h = {foo: 0, bar: 1, baz: 2}
    h1 = {bat: 3, bar: 4}
    h2 = {bam: 5, bat:6}
    h.merge(h1, h2) # => {:foo=>0, :bar=>4, :baz=>2, :bat=>6, :bam=>5}

With arguments and a block:
*   Returns a new Hash object that is the merge of `self` and each given hash.
*   The given hashes are merged left to right.
*   Each new-key entry is added at the end.
*   For each duplicate key:
    *   Calls the block with the key and the old and new values.
    *   The block's return value becomes the new value for the entry.



Example:
    h = {foo: 0, bar: 1, baz: 2}
    h1 = {bat: 3, bar: 4}
    h2 = {bam: 5, bat:6}
    h3 = h.merge(h1, h2) { |key, old_value, new_value| old_value + new_value }
    h3 # => {:foo=>0, :bar=>5, :baz=>2, :bat=>9, :bam=>5}

With no arguments:
*   Returns a copy of `self`.
*   The block, if given, is ignored.


Example:
    h = {foo: 0, bar: 1, baz: 2}
    h.merge # => {:foo=>0, :bar=>1, :baz=>2}
    h1 = h.merge { |key, old_value, new_value| raise 'Cannot happen' }
    h1 # => {:foo=>0, :bar=>1, :baz=>2}

;T;0;;;I"
merge;F;I"	Hash;T;[o;;I"*::Hash[A, B] other_hashes;T;I"Hash[A | K, B | V];To;;I"*::Hash[A, B] other_hashes;T;I"Hash[A | K, B | V | C];To;;I"“Merges each of `other_hashes` into `self`; returns `self`.

Each argument in `other_hashes` must be a Hash.

Method #update is an alias for #merge!.

With arguments and no block:
*   Returns `self`, after the given hashes are merged into it.
*   The given hashes are merged left to right.
*   Each new entry is added at the end.
*   Each duplicate-key entry's value overwrites the previous value.


Example:
    h = {foo: 0, bar: 1, baz: 2}
    h1 = {bat: 3, bar: 4}
    h2 = {bam: 5, bat:6}
    h.merge!(h1, h2) # => {:foo=>0, :bar=>4, :baz=>2, :bat=>6, :bam=>5}

With arguments and a block:
*   Returns `self`, after the given hashes are merged.
*   The given hashes are merged left to right.
*   Each new-key entry is added at the end.
*   For each duplicate key:
    *   Calls the block with the key and the old and new values.
    *   The block's return value becomes the new value for the entry.



Example:
    h = {foo: 0, bar: 1, baz: 2}
    h1 = {bat: 3, bar: 4}
    h2 = {bam: 5, bat:6}
    h3 = h.merge!(h1, h2) { |key, old_value, new_value| old_value + new_value }
    h3 # => {:foo=>0, :bar=>5, :baz=>2, :bat=>9, :bam=>5}

With no arguments:
*   Returns `self`, unmodified.
*   The block, if given, is ignored.


Example:
    h = {foo: 0, bar: 1, baz: 2}
    h.merge # => {:foo=>0, :bar=>1, :baz=>2}
    h1 = h.merge! { |key, old_value, new_value| raise 'Cannot happen' }
    h1 # => {:foo=>0, :bar=>1, :baz=>2}

;T;0;;;I"merge!;F;I"	Hash;T;[o;;I"*::Hash[K, V] other_hashes;T;I"	self;To;;I"*::Hash[K, V] other_hashes;T;I"	self;To;;I"Returns a new 2-element Array consisting of the key and value of the
first-found entry whose value is `==` to value (see [Entry
Order](#class-Hash-label-Entry+Order)):
    h = {foo: 0, bar: 1, baz: 1}
    h.rassoc(1) # => [:bar, 1]

Returns `nil` if no such value found.

;T;0;;;I"rassoc;F;I"	Hash;T;[o;;I"V;T;I"[ K, V ]?;To;;I"Rebuilds the hash table by recomputing the hash index for each key; returns
`self`.

The hash table becomes invalid if the hash value of a key has changed after
the entry was created. See [Modifying an Active Hash
Key](#class-Hash-label-Modifying+an+Active+Hash+Key).

;T;0;;;I"rehash;F;I"	Hash;T;[o;;I" ;F;I"	self;To;;I"ÀReturns a new Hash object whose entries are all those from `self` for which
the block returns `false` or `nil`:
    h = {foo: 0, bar: 1, baz: 2}
    h1 = h.reject {|key, value| key.start_with?('b') }
    h1 # => {:foo=>0}

Returns a new Enumerator if no block given:
    h = {foo: 0, bar: 1, baz: 2}
    e = h.reject # => #<Enumerator: {:foo=>0, :bar=>1, :baz=>2}:reject>
    h1 = e.each {|key, value| key.start_with?('b') }
    h1 # => {:foo=>0}

;T;0;;;I"reject;F;I"	Hash;T;[o;;I" ;F;I"'Enumerator[[ K, V ], ::Hash[K, V]];To;;I" ;F;I"Hash[K, V];To;;I"ºReturns `self`, whose remaining entries are those for which the block returns
`false` or `nil`:
    h = {foo: 0, bar: 1, baz: 2}
    h.reject! {|key, value| value < 2 } # => {:baz=>2}

Returns `nil` if no entries are removed.

Returns a new Enumerator if no block given:
    h = {foo: 0, bar: 1, baz: 2}
    e = h.reject! # => #<Enumerator: {:foo=>0, :bar=>1, :baz=>2}:reject!>
    e.each {|key, value| key.start_with?('b') } # => {:foo=>0}

;T;0;;;I"reject!;F;I"	Hash;T;[o;;I" ;F;I" Enumerator[[ K, V ], self?];To;;I" ;F;I"
self?;To;;I"´Replaces the entire contents of `self` with the contents of `other_hash`;
returns `self`:
    h = {foo: 0, bar: 1, baz: 2}
    h.replace({bat: 3, bam: 4}) # => {:bat=>3, :bam=>4}

;T;0;;;I"replace;F;I"	Hash;T;[o;;I"::Hash[K, V];T;I"	self;To;;I"VRemoves the first hash entry (see [Entry
Order](#class-Hash-label-Entry+Order)); returns a 2-element Array containing
the removed key and value:
    h = {foo: 0, bar: 1, baz: 2}
    h.shift # => [:foo, 0]
    h # => {:bar=>1, :baz=>2}

Returns the default value if the hash is empty (see [Default
Values](#class-Hash-label-Default+Values)).

;T;0;;;I"
shift;F;I"	Hash;T;[o;;I" ;F;I"[ K, V ]?;To;;I"ËReturns a new Hash object containing the entries for the given `keys`:
    h = {foo: 0, bar: 1, baz: 2}
    h.slice(:baz, :foo) # => {:baz=>2, :foo=>0}

Any given `keys` that are not found are ignored.

;T;0;;;I"
slice;F;I"	Hash;T;[o;;I"*K;T;I"Hash[K, V];To;;I"½Returns a new Array of 2-element Array objects; each nested Array contains a
key-value pair from `self`:
    h = {foo: 0, bar: 1, baz: 2}
    h.to_a # => [[:foo, 0], [:bar, 1], [:baz, 2]]

;T;0;;;I"	to_a;F;I"	Hash;T;[o;;I" ;F;I"Array[[ K, V ]];To;;I"ºFor an instance of Hash, returns `self`.

For a subclass of Hash, returns a new Hash containing the content of `self`.

When a block is given, returns a new Hash object whose content is based on the
block; the block should return a 2-element Array object specifying the
key-value pair to be included in the returned Array:
    h = {foo: 0, bar: 1, baz: 2}
    h1 = h.to_h {|key, value| [value, key] }
    h1 # => {0=>:foo, 1=>:bar, 2=>:baz}

;T;0;;;I"	to_h;F;I"	Hash;T;[o;;I" ;F;I"Hash[K, V];To;;I" ;F;I"Hash[A, B];To;;I"Returns `self`.

;T;0;;;I"to_hash;F;I"	Hash;T;[o;;I" ;F;I"	self;To;;I"ÚReturns a Proc object that maps a key to its value:
    h = {foo: 0, bar: 1, baz: 2}
    proc = h.to_proc
    proc.class # => Proc
    proc.call(:foo) # => 0
    proc.call(:bar) # => 1
    proc.call(:nosuch) # => nil

;T;0;;;I"to_proc;F;I"	Hash;T;[o;;I" ;F;I"^(K) -> V?;To;;I"´Returns a new Hash object; each entry has:
*   A key provided by the block.
*   The value from `self`.


An optional hash argument can be provided to map keys to new keys. Any key not
given will be mapped using the provided block, or remain the same if no block
is given.

Transform keys:
    h = {foo: 0, bar: 1, baz: 2}
    h1 = h.transform_keys {|key| key.to_s }
    h1 # => {"foo"=>0, "bar"=>1, "baz"=>2}

    h.transform_keys(foo: :bar, bar: :foo)
    #=> {bar: 0, foo: 1, baz: 2}

    h.transform_keys(foo: :hello, &:to_s)
    #=> {:hello=>0, "bar"=>1, "baz"=>2}

Overwrites values for duplicate keys:
    h = {foo: 0, bar: 1, baz: 2}
    h1 = h.transform_keys {|key| :bat }
    h1 # => {:bat=>2}

Returns a new Enumerator if no block given:
    h = {foo: 0, bar: 1, baz: 2}
    e = h.transform_keys # => #<Enumerator: {:foo=>0, :bar=>1, :baz=>2}:transform_keys>
    h1 = e.each { |key| key.to_s }
    h1 # => {"foo"=>0, "bar"=>1, "baz"=>2}

;T;0;;;I"transform_keys;F;I"	Hash;T;[o;;I" ;F;I"&Enumerator[K, ::Hash[untyped, V]];To;;I" ;F;I"Hash[A, V];To;;I"fSame as Hash#transform_keys but modifies the receiver in place instead of
returning a new hash.

;T;0;;;I"transform_keys!;F;I"	Hash;T;[o;;I" ;F;I"Enumerator[K, self];To;;I" ;F;I"	self;To;;I"öReturns a new Hash object; each entry has:
*   A key from `self`.
*   A value provided by the block.


Transform values:
    h = {foo: 0, bar: 1, baz: 2}
    h1 = h.transform_values {|value| value * 100}
    h1 # => {:foo=>0, :bar=>100, :baz=>200}

Returns a new Enumerator if no block given:
    h = {foo: 0, bar: 1, baz: 2}
    e = h.transform_values # => #<Enumerator: {:foo=>0, :bar=>1, :baz=>2}:transform_values>
    h1 = e.each { |value| value * 100}
    h1 # => {:foo=>0, :bar=>100, :baz=>200}

;T;0;;;I"transform_values;F;I"	Hash;T;[o;;I" ;F;I"&Enumerator[V, ::Hash[K, untyped]];To;;I" ;F;I"Hash[K, A];To;;I"ÕReturns `self`, whose keys are unchanged, and whose values are determined by
the given block.
    h = {foo: 0, bar: 1, baz: 2}
    h.transform_values! {|value| value * 100} # => {:foo=>0, :bar=>100, :baz=>200}

Returns a new Enumerator if no block given:
    h = {foo: 0, bar: 1, baz: 2}
    e = h.transform_values! # => #<Enumerator: {:foo=>0, :bar=>100, :baz=>200}:transform_values!>
    h1 = e.each {|value| value * 100}
    h1 # => {:foo=>0, :bar=>100, :baz=>200}

;T;0;;;I"transform_values!;F;I"	Hash;T;[o;;I" ;F;I"Enumerator[V, self];To;;I" ;F;I"	self;To;;I"xReturns a new Array containing all values in `self`:
    h = {foo: 0, bar: 1, baz: 2}
    h.values # => [0, 1, 2]

;T;0;;;I"values;F;I"	Hash;T;[o;;I" ;F;I"Array[V];To;;I"Returns a new Array containing values for the given `keys`:
    h = {foo: 0, bar: 1, baz: 2}
    h.values_at(:baz, :foo) # => [2, 0]

The [default values](#class-Hash-label-Default+Values) are returned for any
keys that are not found:
    h.values_at(:hello, :foo) # => [nil, 0]

;T;0;;;I"values_at;F;I"	Hash;T;[o;;I"*K arg0;T;I"Array[V?];To;;I"dReturns a new empty Hash object.

The initial default value and initial default proc for the new hash depend on
which form above was used. See [Default
Values](#class-Hash-label-Default+Values).

If neither an argument nor a block given, initializes both the default value
and the default proc to `nil`:
    h = Hash.new
    h.default # => nil
    h.default_proc # => nil

If argument `default_value` given but no block given, initializes the default
value to the given `default_value` and the default proc to `nil`:
    h = Hash.new(false)
    h.default # => false
    h.default_proc # => nil

If a block given but no argument, stores the block as the default proc and
sets the default value to `nil`:
    h = Hash.new {|hash, key| "Default value for #{key}" }
    h.default # => nil
    h.default_proc.class # => Proc
    h[:nosuch] # => "Default value for nosuch"

;T;0;;;I"initialize;F;I"	Hash;T;[o;;I" ;F;I"	void;To;;I"untyped default;T;I"	void;To;;I" ;F;I"	void;To;;I"´Replaces the entire contents of `self` with the contents of `other_hash`;
returns `self`:
    h = {foo: 0, bar: 1, baz: 2}
    h.replace({bat: 3, bam: 4}) # => {:bat=>3, :bam=>4}

;T;0;;;I"initialize_copy;F;I"	Hash;T;[o;;I"self object;T;I"	self;To; ;0;0;	I"	Hash;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"ÉReturns a JSON string containing a JSON object, that is generated from
this Hash instance.
_state_ is a JSON::State object, that can also be used to configure the
produced JSON string output further.

;T;0;;;I"to_json;F;I"	Hash;T;[o;;I"?::JSON::State state;T;I"String;To; ;I"An Integer object represents an integer value.

You can create an Integer object explicitly with:

*   An [integer
    literal](doc/syntax/literals_rdoc.html#label-Integer+Literals).


You can convert certain objects to Integers with:

*   Method [Integer](Kernel.html#method-i-Integer).


An attempt to add a singleton method to an instance of this class causes an
exception to be raised.

## What's Here

First, what's elsewhere. Class Integer:

*   Inherits from [class
    Numeric](Numeric.html#class-Numeric-label-What-27s+Here).


Here, class Integer provides methods for:

*   [Querying](#class-Integer-label-Querying)
*   [Comparing](#class-Integer-label-Comparing)
*   [Converting](#class-Integer-label-Converting)
*   [Other](#class-Integer-label-Other)


### Querying

    #allbits?
:       Returns whether all bits in `self` are set.

    #anybits?
:       Returns whether any bits in `self` are set.

    #nobits?
:       Returns whether no bits in `self` are set.



### Comparing

    [<](#method-i-3C)
:       Returns whether `self` is less than the given value.

    [<=](#method-i-3C-3D)
:       Returns whether `self` is less than or equal to the given value.

    [<=>](#method-i-3C-3D-3E)
:       Returns a number indicating whether `self` is less than, equal to, or
        greater than the given value.

    [==](#method-i-3D-3D) (aliased as #===)
:       Returns whether `self` is equal to the given value.

    [>](#method-i-3E)
:       Returns whether `self` is greater than the given value.

    [>=](#method-i-3E-3D)
:       Returns whether `self` is greater than or equal to the given value.



### Converting

    ::sqrt
:       Returns the integer square root of the given value.

    ::try_convert
:       Returns the given value converted to an Integer.

    #% (aliased as #modulo)
:       Returns `self` modulo the given value.

    [&](#method-i-26)
:       Returns the bitwise AND of `self` and the given value.

    #*
:       Returns the product of `self` and the given value.

    [**](#method-i-2A-2A)
:       Returns the value of `self` raised to the power of the given value.

    #+
:       Returns the sum of `self` and the given value.

    #-
:       Returns the difference of `self` and the given value.

    [/](#method-i-2F)
:       Returns the quotient of `self` and the given value.

    #<<
:       Returns the value of `self` after a leftward bit-shift.

    #>>
:       Returns the value of `self` after a rightward bit-shift.

    #[]
:       Returns a slice of bits from `self`.

    [^](#method-i-5E)
:       Returns the bitwise EXCLUSIVE OR of `self` and the given value.

    #ceil
:       Returns the smallest number greater than or equal to `self`.

    #chr
:       Returns a 1-character string containing the character represented by
        the value of `self`.

    #digits
:       Returns an array of integers representing the base-radix digits of
        `self`.

    #div
:       Returns the integer result of dividing `self` by the given value.

    #divmod
:       Returns a 2-element array containing the quotient and remainder
        results of dividing `self` by the given value.

    #fdiv
:       Returns the Float result of dividing `self` by the given value.

    #floor
:       Returns the greatest number smaller than or equal to `self`.

    #pow
:       Returns the modular exponentiation of `self`.

    #pred
:       Returns the integer predecessor of `self`.

    #remainder
:       Returns the remainder after dividing `self` by the given value.

    #round
:       Returns `self` rounded to the nearest value with the given precision.

    #succ (aliased as #next)
:       Returns the integer successor of `self`.

    #to_f
:       Returns `self` converted to a Float.

    #to_s (aliased as #inspect)
:       Returns a string containing the place-value representation of `self`
        in the given radix.

    #truncate
:       Returns `self` truncated to the given precision.

    [/](#method-i-7C)
:       Returns the bitwise OR of `self` and the given value.



### Other

    #downto
:       Calls the given block with each integer value from `self` down to the
        given value.

    #times
:       Calls the given block `self` times with each integer in `(0..self-1)`.

    #upto
:       Calls the given block with each integer value from `self` up to the
        given value.

;T;0;	I"Integer;T;
[ ;[ ;0;[ ;[ ;0;I"Numeric;To;;I"ŽReturns the integer square root of the non-negative integer `n`, which is the
largest non-negative integer less than or equal to the square root of
`numeric`.

    Integer.sqrt(0)       # => 0
    Integer.sqrt(1)       # => 1
    Integer.sqrt(24)      # => 4
    Integer.sqrt(25)      # => 5
    Integer.sqrt(10**400) # => 10**200

If `numeric` is not an Integer, it is converted to an Integer:

    Integer.sqrt(Complex(4, 0))  # => 2
    Integer.sqrt(Rational(4, 1)) # => 2
    Integer.sqrt(4.0)            # => 2
    Integer.sqrt(3.14159)        # => 1

This method is equivalent to `Math.sqrt(numeric).floor`, except that the
result of the latter code may differ from the true value due to the limited
precision of floating point arithmetic.

    Integer.sqrt(10**46)    # => 100000000000000000000000
    Math.sqrt(10**46).floor # => 99999999999999991611392

Raises an exception if `numeric` is negative.

;T;0;;;I"	sqrt;F;I"Integer;T;[o;;I"::int n;T;I"Integer;To;;I"}If `object` is an Integer object, returns `object`.
    Integer.try_convert(1) # => 1

Otherwise if `object` responds to `:to_int`, calls `object.to_int` and returns
the result.
    Integer.try_convert(1.25) # => 1

Returns `nil` if `object` does not respond to `:to_int`
    Integer.try_convert([]) # => nil

Raises an exception unless `object.to_int` returns an Integer object.

;T;0;;;I"try_convert;F;I"Integer;T;[o;;I"
::int;T;I"Integer;To;;I"untyped;T;I"Integer?;To;;I"ùReturns `self` modulo `other` as a real number.

For integer `n` and real number `r`, these expressions are equivalent:

    n % r
    n-r*(n/r).floor
    n.divmod(r)[1]

See Numeric#divmod.

Examples:

    10 % 2              # => 0
    10 % 3              # => 1
    10 % 4              # => 2

    10 % -2             # => 0
    10 % -3             # => -2
    10 % -4             # => -2

    10 % 3.0            # => 1.0
    10 % Rational(3, 1) # => (1/1)

Integer#modulo is an alias for Integer#%.

;T;0;;;I"%;F;I"Integer;T;[	o;;I"::Float;T;I"
Float;To;;I"::Rational;T;I"Rational;To;;I"::Integer;T;I"Integer;To;;I"::Numeric;T;I"Numeric;To;;I"Bitwise AND; each bit in the result is 1 if both corresponding bits in `self`
and `other` are 1, 0 otherwise:

    "%04b" % (0b0101 & 0b0110) # => "0100"

Raises an exception if `other` is not an Integer.

Related: Integer#| (bitwise OR), Integer#^ (bitwise EXCLUSIVE OR).

;T;0;;;I"&;F;I"Integer;T;[o;;I"::Integer;T;I"Integer;To;;I"ÜPerforms multiplication:

    4 * 2              # => 8
    4 * -2             # => -8
    -4 * 2             # => -8
    4 * 2.0            # => 8.0
    4 * Rational(1, 3) # => (4/3)
    4 * Complex(2, 0)  # => (8+0i)

;T;0;;;I"*;F;I"Integer;T;[	o;;I"::Float;T;I"
Float;To;;I"::Rational;T;I"Rational;To;;I"::Complex;T;I"Complex;To;;I"::Integer;T;I"Integer;To;;I"'Raises `self` to the power of `numeric`:

    2 ** 3              # => 8
    2 ** -3             # => (1/8)
    -2 ** 3             # => -8
    -2 ** -3            # => (-1/8)
    2 ** 3.3            # => 9.849155306759329
    2 ** Rational(3, 1) # => (8/1)
    2 ** Complex(3, 0)  # => (8+0i)

;T;0;;;I"**;F;I"Integer;T;[	o;;I"::Integer;T;I"Numeric;To;;I"::Float;T;I"Numeric;To;;I"::Rational;T;I"Numeric;To;;I"::Complex;T;I"Complex;To;;I"ÕPerforms addition:

    2 + 2              # => 4
    -2 + 2             # => 0
    -2 + -2            # => -4
    2 + 2.0            # => 4.0
    2 + Rational(2, 1) # => (4/1)
    2 + Complex(2, 0)  # => (4+0i)

;T;0;;;I"+;F;I"Integer;T;[	o;;I"::Integer;T;I"Integer;To;;I"::Float;T;I"
Float;To;;I"::Rational;T;I"Rational;To;;I"::Complex;T;I"Complex;To;;0;0;;;I"+@;F;I"Integer;T;[o;;I" ;F;I"Integer;To;;I"ÙPerforms subtraction:

    4 - 2              # => 2
    -4 - 2             # => -6
    -4 - -2            # => -2
    4 - 2.0            # => 2.0
    4 - Rational(2, 1) # => (2/1)
    4 - Complex(2, 0)  # => (2+0i)

;T;0;;;I"-;F;I"Integer;T;[	o;;I"::Integer;T;I"Integer;To;;I"::Float;T;I"
Float;To;;I"::Rational;T;I"Rational;To;;I"::Complex;T;I"Complex;To;;I"Returns `int`, negated.

;T;0;;;I"-@;F;I"Integer;T;[o;;I" ;F;I"Integer;To;;I"€Performs division; for integer `numeric`, truncates the result to an integer:

     4 / 3              # => 1
     4 / -3             # => -2
     -4 / 3             # => -2
     -4 / -3            # => 1

    For other +numeric+, returns non-integer result:

     4 / 3.0            # => 1.3333333333333333
     4 / Rational(3, 1) # => (4/3)
     4 / Complex(3, 0)  # => ((4/3)+0i)

;T;0;;;I"/;F;I"Integer;T;[	o;;I"::Integer;T;I"Integer;To;;I"::Float;T;I"
Float;To;;I"::Rational;T;I"Rational;To;;I"::Complex;T;I"Complex;To;;I"4Returns `true` if the value of `self` is less than that of `other`:

      1 < 0              # => false
      1 < 1              # => false
      1 < 2              # => true
      1 < 0.5            # => false
      1 < Rational(1, 2) # => false

    Raises an exception if the comparison cannot be made.

;T;0;;;I"<;F;I"Integer;T;[o;;I"::Numeric;T;I"	bool;To;;I"3Returns `self` with bits shifted `count` positions to the left, or to the
right if `count` is negative:

    n = 0b11110000
    "%08b" % (n << 1)  # => "111100000"
    "%08b" % (n << 3)  # => "11110000000"
    "%08b" % (n << -1) # => "01111000"
    "%08b" % (n << -3) # => "00011110"

Related: Integer#>>.

;T;0;;;I"<<;F;I"Integer;T;[o;;I"
::int;T;I"Integer;To;;I"6Returns `true` if the value of `self` is less than or equal to that of
`other`:

    1 <= 0              # => false
    1 <= 1              # => true
    1 <= 2              # => true
    1 <= 0.5            # => false
    1 <= Rational(1, 2) # => false

Raises an exception if the comparison cannot be made.

;T;0;;;I"<=;F;I"Integer;T;[o;;I"::Numeric;T;I"	bool;To;;I"çReturns:

*   -1, if `self` is less than `other`.
*   0, if `self` is equal to `other`.
*   1, if `self` is greater then `other`.
*   `nil`, if `self` and `other` are incomparable.


Examples:

    1 <=> 2              # => -1
    1 <=> 1              # => 0
    1 <=> 0              # => 1
    1 <=> 'foo'          # => nil

    1 <=> 1.0            # => 0
    1 <=> Rational(1, 1) # => 0
    1 <=> Complex(1, 0)  # => 0

This method is the basis for comparisons in module Comparable.

;T;0;;;I"<=>;F;I"Integer;T;[o;;I"::Integer | ::Rational;T;I"Integer;To;;I"untyped;T;I"Integer?;To;;I"åReturns `true` if `self` is numerically equal to `other`; `false` otherwise.

    1 == 2     #=> false
    1 == 1.0   #=> true

Related: Integer#eql? (requires `other` to be an Integer).

Integer#=== is an alias for Integer#==.

;T;0;;;I"==;F;I"Integer;T;[o;;I"untyped;T;I"	bool;To;;I"åReturns `true` if `self` is numerically equal to `other`; `false` otherwise.

    1 == 2     #=> false
    1 == 1.0   #=> true

Related: Integer#eql? (requires `other` to be an Integer).

Integer#=== is an alias for Integer#==.

;T;0;;;I"===;F;I"Integer;T;[o;;I"untyped;T;I"	bool;To;;I"5Returns `true` if the value of `self` is greater than that of `other`:

      1 > 0              # => true
      1 > 1              # => false
      1 > 2              # => false
      1 > 0.5            # => true
      1 > Rational(1, 2) # => true

    Raises an exception if the comparison cannot be made.

;T;0;;;I">;F;I"Integer;T;[o;;I"::Numeric;T;I"	bool;To;;I"7Returns `true` if the value of `self` is greater than or equal to that of
`other`:

    1 >= 0              # => true
    1 >= 1              # => true
    1 >= 2              # => false
    1 >= 0.5            # => true
    1 >= Rational(1, 2) # => true

Raises an exception if the comparison cannot be made.

;T;0;;;I">=;F;I"Integer;T;[o;;I"::Numeric;T;I"	bool;To;;I"3Returns `self` with bits shifted `count` positions to the right, or to the
left if `count` is negative:

    n = 0b11110000
    "%08b" % (n >> 1)  # => "01111000"
    "%08b" % (n >> 3)  # => "00011110"
    "%08b" % (n >> -1) # => "111100000"
    "%08b" % (n >> -3) # => "11110000000"

Related: Integer#<<.

;T;0;;;I">>;F;I"Integer;T;[o;;I"
::int;T;I"Integer;To;;I"šReturns a slice of bits from `self`.

With argument `offset`, returns the bit at the given offset, where offset 0
refers to the least significant bit:

    n = 0b10 # => 2
    n[0]     # => 0
    n[1]     # => 1
    n[2]     # => 0
    n[3]     # => 0

In principle, `n[i]` is equivalent to `(n >> i) & 1`. Thus, negative index
always returns zero:

    255[-1] # => 0

With arguments `offset` and `size`, returns `size` bits from `self`, beginning
at `offset` and including bits of greater significance:

    n = 0b111000       # => 56
    "%010b" % n[0, 10] # => "0000111000"
    "%010b" % n[4, 10] # => "0000000011"

With argument `range`, returns `range.size` bits from `self`, beginning at
`range.begin` and including bits of greater significance:

    n = 0b111000      # => 56
    "%010b" % n[0..9] # => "0000111000"
    "%010b" % n[4..9] # => "0000000011"

Raises an exception if the slice cannot be constructed.

;T;0;;;I"[];F;I"Integer;T;[o;;I"
::int;T;I"Integer;To;;I"::int i, ::int len;T;I"Integer;To;;I"::Range[::int];T;I"Integer;To;;I"Bitwise EXCLUSIVE OR; each bit in the result is 1 if the corresponding bits in
`self` and `other` are different, 0 otherwise:

    "%04b" % (0b0101 ^ 0b0110) # => "0011"

Raises an exception if `other` is not an Integer.

Related: Integer#& (bitwise AND), Integer#| (bitwise OR).

;T;0;;;I"^;F;I"Integer;T;[o;;I"::Integer;T;I"Integer;To;;I"®Returns the absolute value of `int`.

    (-12345).abs   #=> 12345
    -12345.abs     #=> 12345
    12345.abs      #=> 12345

Integer#magnitude is an alias for Integer#abs.

;T;0;;;I"abs;F;I"Integer;T;[o;;I" ;F;I"Integer;To;;0;0;;;I"	abs2;F;I"Integer;T;[o;;I" ;F;I"Integer;To;;I"wReturns `true` if all bits that are set (=1) in `mask` are also set in `self`;
returns `false` otherwise.

Example values:

    0b1010101  self
    0b1010100  mask
    0b1010100  self & mask
         true  self.allbits?(mask)

    0b1010100  self
    0b1010101  mask
    0b1010100  self & mask
        false  self.allbits?(mask)

Related: Integer#anybits?, Integer#nobits?.

;T;0;;;I"allbits?;F;I"Integer;T;[o;;I"::int mask;T;I"	bool;To;;0;0;;;I"
angle;F;I"Integer;T;[o;;I" ;F;I"Integer | ::Float;To;;I"|Returns `true` if any bit that is set (=1) in `mask` is also set in `self`;
returns `false` otherwise.

Example values:

    0b10000010  self
    0b11111111  mask
    0b10000010  self & mask
          true  self.anybits?(mask)

    0b00000000  self
    0b11111111  mask
    0b00000000  self & mask
         false  self.anybits?(mask)

Related: Integer#allbits?, Integer#nobits?.

;T;0;;;I"anybits?;F;I"Integer;T;[o;;I"::int mask;T;I"	bool;To;;I" Returns the number of bits of the value of `int`.

"Number of bits" means the bit position of the highest bit which is different
from the sign bit (where the least significant bit has bit position 1). If
there is no such bit (zero or minus one), zero is returned.

I.e. this method returns *ceil(log2(int < 0 ? -int : int+1))*.

    (-2**1000-1).bit_length   #=> 1001
    (-2**1000).bit_length     #=> 1000
    (-2**1000+1).bit_length   #=> 1000
    (-2**12-1).bit_length     #=> 13
    (-2**12).bit_length       #=> 12
    (-2**12+1).bit_length     #=> 12
    -0x101.bit_length         #=> 9
    -0x100.bit_length         #=> 8
    -0xff.bit_length          #=> 8
    -2.bit_length             #=> 1
    -1.bit_length             #=> 0
    0.bit_length              #=> 0
    1.bit_length              #=> 1
    0xff.bit_length           #=> 8
    0x100.bit_length          #=> 9
    (2**12-1).bit_length      #=> 12
    (2**12).bit_length        #=> 13
    (2**12+1).bit_length      #=> 13
    (2**1000-1).bit_length    #=> 1000
    (2**1000).bit_length      #=> 1001
    (2**1000+1).bit_length    #=> 1001

This method can be used to detect overflow in Array#pack as follows:

    if n.bit_length < 32
      [n].pack("l") # no overflow
    else
      raise "overflow"
    end

;T;0;;;I"bit_length;F;I"Integer;T;[o;;I" ;F;I"Integer;To;;I"ÊReturns the smallest number greater than or equal to `self` with a precision
of `ndigits` decimal digits.

When the precision is negative, the returned value is an integer with at least
`ndigits.abs` trailing zeros:

    555.ceil(-1)  # => 560
    555.ceil(-2)  # => 600
    -555.ceil(-2) # => -500
    555.ceil(-3)  # => 1000

Returns `self` when `ndigits` is zero or positive.

    555.ceil     # => 555
    555.ceil(50) # => 555

Related: Integer#floor.

;T;0;;;I"	ceil;F;I"Integer;T;[o;;I" ;F;I"Integer;To;;I"::int digits;T;I"Integer | ::Float;To;;I"’Returns a 1-character string containing the character represented by the value
of `self`, according to the given `encoding`.

    65.chr                   # => "A"
    0..chr                   # => "\x00"
    255.chr                  # => "\xFF"
    string = 255.chr(Encoding::UTF_8)
    string.encoding          # => Encoding::UTF_8

Raises an exception if `self` is negative.

Related: Integer#ord.

;T;0;;;I"chr;F;I"Integer;T;[o;;I"?::encoding;T;I"String;To;;I"Returns an array with both a `numeric` and a `big` represented as Bignum
objects.

This is achieved by converting `numeric` to a Bignum.

A TypeError is raised if the `numeric` is not a Fixnum or Bignum type.

    (0x3FFFFFFFFFFFFFFF+1).coerce(42)   #=> [42, 4611686018427387904]

;T;0;;;I"coerce;F;I"Integer;T;[o;;I"::Numeric;T;I"[ ::Numeric, ::Numeric ];To;;0;0;;;I"	conj;F;I"Integer;T;[o;;I" ;F;I"Integer;To;;0;0;;;I"conjugate;F;I"Integer;T;[o;;I" ;F;I"Integer;To;;I"Returns 1.

;T;0;;;I"denominator;F;I"Integer;T;[o;;I" ;F;I"Integer;To;;I"XReturns an array of integers representing the `base`-radix digits of `self`;
the first element of the array represents the least significant digit:

    12345.digits      # => [5, 4, 3, 2, 1]
    12345.digits(7)   # => [4, 6, 6, 0, 5]
    12345.digits(100) # => [45, 23, 1]

Raises an exception if `self` is negative or `base` is less than 2.

;T;0;;;I"digits;F;I"Integer;T;[o;;I"?::int base;T;I"Array[::Integer];To;;I"RPerforms integer division; returns the integer result of dividing `self` by
`numeric`:

      4.div(3)      # => 1
      4.div(-3)      # => -2
      -4.div(3)      # => -2
      -4.div(-3)      # => 1
      4.div(3.0)      # => 1
      4.div(Rational(3, 1))      # => 1

    Raises an exception if +numeric+ does not have method +div+.

;T;0;;;I"div;F;I"Integer;T;[o;;I"::Numeric;T;I"Integer;To;;I"=Returns a 2-element array `[q, r]`, where

    q = (self/other).floor    # Quotient
    r = self % other          # Remainder

Examples:

    11.divmod(4)              # => [2, 3]
    11.divmod(-4)             # => [-3, -1]
    -11.divmod(4)             # => [-3, 1]
    -11.divmod(-4)            # => [2, -3]

    12.divmod(4)              # => [3, 0]
    12.divmod(-4)             # => [-3, 0]
    -12.divmod(4)             # => [-3, 0]
    -12.divmod(-4)            # => [3, 0]

    13.divmod(4.0)            # => [3, 1.0]
    13.divmod(Rational(4, 1)) # => [3, (1/1)]

;T;0;;;I"divmod;F;I"Integer;T;[o;;I"::Integer;T;I"[ ::Integer, ::Integer ];To;;I"::Float;T;I"[ ::Float, ::Float ];To;;I"::Numeric;T;I"[ ::Numeric, ::Numeric ];To;;I"ÈCalls the given block with each integer value from `self` down to `limit`;
returns `self`:

    a = []
    10.downto(5) {|i| a << i }              # => 10
    a                                       # => [10, 9, 8, 7, 6, 5]
    a = []
    0.downto(-5) {|i| a << i }              # => 0
    a                                       # => [0, -1, -2, -3, -4, -5]
    4.downto(5) {|i| fail 'Cannot happen' } # => 4

With no block given, returns an Enumerator.

;T;0;;;I"downto;F;I"Integer;T;[o;;I"::Numeric limit;T;I"Integer;To;;I"::Numeric limit;T;I" Enumerator[::Integer, self];To;;0;0;;;I"dup;F;I"Integer;T;[o;;I" ;F;I"	self;To;;0;0;;;I"	eql?;F;I"Integer;T;[o;;I"untyped;T;I"	bool;To;;I"1Returns `true` if `int` is an even number.

;T;0;;;I"
even?;F;I"Integer;T;[o;;I" ;F;I"	bool;To;;I"+Returns the Float result of dividing `self` by `numeric`:

    4.fdiv(2)      # => 2.0
    4.fdiv(-2)      # => -2.0
    -4.fdiv(2)      # => -2.0
    4.fdiv(2.0)      # => 2.0
    4.fdiv(Rational(3, 4))      # => 5.333333333333333

Raises an exception if `numeric` cannot be converted to a Float.

;T;0;;;I"	fdiv;F;I"Integer;T;[o;;I"::Numeric;T;I"
Float;To;;0;0;;;I"finite?;F;I"Integer;T;[o;;I" ;F;I"	bool;To;;I"µReturns the largest number less than or equal to `self` with a precision of
`ndigits` decimal digits.

When `ndigits` is negative, the returned value has at least `ndigits.abs`
trailing zeros:

    555.floor(-1)  # => 550
    555.floor(-2)  # => 500
    -555.floor(-2) # => -600
    555.floor(-3)  # => 0

Returns `self` when `ndigits` is zero or positive.

    555.floor     # => 555
    555.floor(50) # => 555

Related: Integer#ceil.

;T;0;;;I"
floor;F;I"Integer;T;[o;;I"?::int digits;T;I"Integer;To;;I"Returns the greatest common divisor of the two integers. The result is always
positive. 0.gcd(x) and x.gcd(0) return x.abs.

    36.gcd(60)                  #=> 12
    2.gcd(2)                    #=> 2
    3.gcd(-7)                   #=> 1
    ((1<<31)-1).gcd((1<<61)-1)  #=> 1

;T;0;;;I"gcd;F;I"Integer;T;[o;;I"::Integer;T;I"Integer;To;;I"JReturns an array with the greatest common divisor and the least common
multiple of the two integers, [gcd, lcm].

    36.gcdlcm(60)                  #=> [12, 180]
    2.gcdlcm(2)                    #=> [2, 2]
    3.gcdlcm(-7)                   #=> [1, 21]
    ((1<<31)-1).gcdlcm((1<<61)-1)  #=> [1, 4951760154835678088235319297]

;T;0;;;I"gcdlcm;F;I"Integer;T;[o;;I"::Integer;T;I"[ ::Integer, ::Integer ];To;;0;0;;;I"i;F;I"Integer;T;[o;;I" ;F;I"Complex;To;;0;0;;;I"	imag;F;I"Integer;T;[o;;I" ;F;I"Integer;To;;0;0;;;I"imaginary;F;I"Integer;T;[o;;I" ;F;I"Integer;To;;0;0;;;I"infinite?;F;I"Integer;T;[o;;I" ;F;I"Integer?;To;;I"ESince `int` is already an Integer, this always returns `true`.

;T;0;;;I"integer?;F;I"Integer;T;[o;;I" ;F;I"	true;Fo;;I"1Returns the least common multiple of the two integers. The result is always
positive. 0.lcm(x) and x.lcm(0) return zero.

    36.lcm(60)                  #=> 180
    2.lcm(2)                    #=> 2
    3.lcm(-7)                   #=> 21
    ((1<<31)-1).lcm((1<<61)-1)  #=> 4951760154835678088235319297

;T;0;;;I"lcm;F;I"Integer;T;[o;;I"::Integer;T;I"Integer;To;;I" ;T;0;;;I"magnitude;F;I"Integer;T;[o;;I" ;F;I"Integer;To;;0;0;;;I"negative?;F;I"Integer;T;[o;;I" ;F;I"	bool;To;;I"ÂReturns the successor integer of `self` (equivalent to `self + 1`):

    1.succ  #=> 2
    -1.succ #=> 0

Integer#next is an alias for Integer#succ.

Related: Integer#pred (predecessor value).

;T;0;;;I"	next;F;I"Integer;T;[o;;I" ;F;I"Integer;To;;I"zReturns `true` if no bit that is set (=1) in `mask` is also set in `self`;
returns `false` otherwise.

Example values:

    0b11110000  self
    0b00001111  mask
    0b00000000  self & mask
          true  self.nobits?(mask)

    0b00000001  self
    0b11111111  mask
    0b00000001  self & mask
         false  self.nobits?(mask)

Related: Integer#allbits?, Integer#anybits?.

;T;0;;;I"nobits?;F;I"Integer;T;[o;;I"::int mask;T;I"	bool;To;;0;0;;;I"nonzero?;F;I"Integer;T;[o;;I" ;F;I"
self?;To;;I"Returns self.

;T;0;;;I"numerator;F;I"Integer;T;[o;;I" ;F;I"Integer;To;;I"0Returns `true` if `int` is an odd number.

;T;0;;;I"	odd?;F;I"Integer;T;[o;;I" ;F;I"	bool;To;;I"µReturns the `int` itself.

    97.ord   #=> 97

This method is intended for compatibility to character literals in Ruby 1.9.

For example, `?a.ord` returns 97 both in 1.8 and 1.9.

;T;0;;;I"ord;F;I"Integer;T;[o;;I" ;F;I"Integer;To;;0;0;;;I"
polar;F;I"Integer;T;[o;;I" ;F;I"'[ ::Integer, ::Integer | ::Float ];To;;0;0;;;I"positive?;F;I"Integer;T;[o;;I" ;F;I"	bool;To;;I"“Returns (modular) exponentiation as:

    a.pow(b)     #=> same as a**b
    a.pow(b, m)  #=> same as (a**b) % m, but avoids huge temporary values

;T;0;;;I"pow;F;I"Integer;T;[	o;;I"'::Integer other, ?::Integer modulo;T;I"Integer;To;;I"::Float;T;I"
Float;To;;I"::Rational;T;I"Rational;To;;I"::Complex;T;I"Complex;To;;I"Returns the predecessor of `self` (equivalent to `self - 1`):

    1.pred  #=> 0
    -1.pred #=> -2

Related: Integer#succ (successor value).

;T;0;;;I"	pred;F;I"Integer;T;[o;;I" ;F;I"Integer;To;;0;0;;;I"quo;F;I"Integer;T;[
o;;I"::Integer;T;I"Rational;To;;I"::Float;T;I"
Float;To;;I"::Rational;T;I"Rational;To;;I"::Complex;T;I"Complex;To;;I"::Numeric;T;I"Numeric;To;;I"WReturns the value as a rational.  The optional argument `eps` is always
ignored.

;T;0;;;I"rationalize;F;I"Integer;T;[o;;I"?::Numeric eps;T;I"Rational;To;;0;0;;;I"	real;F;I"Integer;T;[o;;I" ;F;I"	self;To;;0;0;;;I"
real?;F;I"Integer;T;[o;;I" ;F;I"	true;Fo;;0;0;;;I"	rect;F;I"Integer;T;[o;;I" ;F;I"[ ::Integer, ::Numeric ];To;;I"ßReturns the remainder after dividing `self` by `other`.

Examples:

    11.remainder(4)              # => 3
    11.remainder(-4)             # => 3
    -11.remainder(4)             # => -3
    -11.remainder(-4)            # => -3

    12.remainder(4)              # => 0
    12.remainder(-4)             # => 0
    -12.remainder(4)             # => 0
    -12.remainder(-4)            # => 0

    13.remainder(4.0)            # => 1.0
    13.remainder(Rational(4, 1)) # => (1/1)

;T;0;;;I"remainder;F;I"Integer;T;[	o;;I"::Integer;T;I"Integer;To;;I"::Float;T;I"
Float;To;;I"::Rational;T;I"Rational;To;;I"::Numeric;T;I"Numeric;To;;I"¡Returns `self` rounded to the nearest value with a precision of `ndigits`
decimal digits.

When `ndigits` is negative, the returned value has at least `ndigits.abs`
trailing zeros:

    555.round(-1)      # => 560
    555.round(-2)      # => 600
    555.round(-3)      # => 1000
    -555.round(-2)     # => -600
    555.round(-4)      # => 0

Returns `self` when `ndigits` is zero or positive.

    555.round     # => 555
    555.round(1)  # => 555
    555.round(50) # => 555

If keyword argument `half` is given, and `self` is equidistant from the two
candidate  values, the rounding is according to the given `half` value:

*   `:up` or `nil`: round away from zero:

        25.round(-1, half: :up)      # => 30
        (-25).round(-1, half: :up)   # => -30

*   `:down`: round toward zero:

        25.round(-1, half: :down)    # => 20
        (-25).round(-1, half: :down) # => -20

*   `:even`: round toward the candidate whose last nonzero digit is even:

        25.round(-1, half: :even)    # => 20
        15.round(-1, half: :even)    # => 20
        (-25).round(-1, half: :even) # => -20


Raises and exception if the value for `half` is invalid.

Related: Integer#truncate.

;T;0;;;I"
round;F;I"Integer;T;[o;;I"?half: :up | :down | :even;T;I"Integer;To;;I"-::int digits, ?half: :up | :down | :even;T;I"Integer | ::Float;To;;I"6Document-method: Integer#size

Returns the number of bytes in the machine representation of `int` (machine
dependent).

    1.size               #=> 8
    -1.size              #=> 8
    2147483647.size      #=> 8
    (256**10 - 1).size   #=> 10
    (256**20 - 1).size   #=> 20
    (256**40 - 1).size   #=> 40

;T;0;;;I"	size;F;I"Integer;T;[o;;I" ;F;I"Integer;To;;0;0;;;I"	step;F;I"Integer;T;[o;;I" ;F;I"	void;To;;I"%::Numeric limit, ?::Integer step;T;I"	void;To;;I"%::Numeric limit, ?::Numeric step;T;I"	void;To;;I""to: ::Numeric, ?by: ::Integer;T;I"	void;To;;I""by: ::Numeric, ?to: ::Numeric;T;I"	void;To;;I" ;F;I"Enumerator[::Integer, bot];To;;I"%::Numeric limit, ?::Integer step;T;I" Enumerator[::Integer, void];To;;I"%::Numeric limit, ?::Numeric step;T;I" Enumerator[::Numeric, void];To;;I""to: ::Numeric, ?by: ::Integer;T;I" Enumerator[::Integer, void];To;;I""by: ::Numeric, ?to: ::Numeric;T;I" Enumerator[::Numeric, void];To;;I"ÂReturns the successor integer of `self` (equivalent to `self + 1`):

    1.succ  #=> 2
    -1.succ #=> 0

Integer#next is an alias for Integer#succ.

Related: Integer#pred (predecessor value).

;T;0;;;I"	succ;F;I"Integer;T;[o;;I" ;F;I"Integer;To;;I"×Calls the given block `self` times with each integer in `(0..self-1)`:

    a = []
    5.times {|i| a.push(i) } # => 5
    a                        # => [0, 1, 2, 3, 4]

With no block given, returns an Enumerator.

;T;0;;;I"
times;F;I"Integer;T;[o;;I" ;F;I"	self;To;;I" ;F;I" Enumerator[::Integer, self];To;;0;0;;;I"	to_c;F;I"Integer;T;[o;;I" ;F;I"Complex;To;;I"ØConverts `self` to a Float:

    1.to_f  # => 1.0
    -1.to_f # => -1.0

If the value of `self` does not fit in a Float, the result is infinity:

    (10**400).to_f  # => Infinity
    (-10**400).to_f # => -Infinity

;T;0;;;I"	to_f;F;I"Integer;T;[o;;I" ;F;I"
Float;To;;I"YSince `int` is already an Integer, returns `self`.

#to_int is an alias for #to_i.

;T;0;;;I"	to_i;F;I"Integer;T;[o;;I" ;F;I"Integer;To;;I"sReturns the value as a rational.

    1.to_r        #=> (1/1)
    (1<<64).to_r  #=> (18446744073709551616/1)

;T;0;;;I"	to_r;F;I"Integer;T;[o;;I" ;F;I"Rational;To;;I"òReturns a string containing the place-value representation of `self` in radix
`base` (in 2..36).

    12345.to_s               # => "12345"
    12345.to_s(2)            # => "11000000111001"
    12345.to_s(8)            # => "30071"
    12345.to_s(10)           # => "12345"
    12345.to_s(16)           # => "3039"
    12345.to_s(36)           # => "9ix"
    78546939656932.to_s(36)  # => "rubyrules"

Raises an exception if `base` is out of range.

Integer#inspect is an alias for Integer#to_s.

;T;0;;;I"	to_s;F;I"Integer;T;[*o;;I" ;F;I"String;To;;I"2;T;I"String;To;;I"3;T;I"String;To;;I"4;T;I"String;To;;I"5;T;I"String;To;;I"6;T;I"String;To;;I"7;T;I"String;To;;I"8;T;I"String;To;;I"9;T;I"String;To;;I"10;T;I"String;To;;I"11;T;I"String;To;;I"12;T;I"String;To;;I"13;T;I"String;To;;I"14;T;I"String;To;;I"15;T;I"String;To;;I"16;T;I"String;To;;I"17;T;I"String;To;;I"18;T;I"String;To;;I"19;T;I"String;To;;I"20;T;I"String;To;;I"21;T;I"String;To;;I"22;T;I"String;To;;I"23;T;I"String;To;;I"24;T;I"String;To;;I"25;T;I"String;To;;I"26;T;I"String;To;;I"27;T;I"String;To;;I"28;T;I"String;To;;I"29;T;I"String;To;;I"30;T;I"String;To;;I"31;T;I"String;To;;I"32;T;I"String;To;;I"33;T;I"String;To;;I"34;T;I"String;To;;I"35;T;I"String;To;;I"36;T;I"String;To;;I"::int base;T;I"String;To;;I"˜Returns `self` truncated (toward zero) to a precision of `ndigits` decimal
digits.

When `ndigits` is negative, the returned value has at least `ndigits.abs`
trailing zeros:

    555.truncate(-1)  # => 550
    555.truncate(-2)  # => 500
    -555.truncate(-2) # => -500

Returns `self` when `ndigits` is zero or positive.

    555.truncate     # => 555
    555.truncate(50) # => 555

Related: Integer#round.

;T;0;;;I"truncate;F;I"Integer;T;[o;;I" ;F;I"Integer;To;;I"::int ndigits;T;I"Integer;To;;I"¼Calls the given block with each integer value from `self` up to `limit`;
returns `self`:

    a = []
    5.upto(10) {|i| a << i }              # => 5
    a                                     # => [5, 6, 7, 8, 9, 10]
    a = []
    -5.upto(0) {|i| a << i }              # => -5
    a                                     # => [-5, -4, -3, -2, -1, 0]
    5.upto(4) {|i| fail 'Cannot happen' } # => 5

With no block given, returns an Enumerator.

;T;0;;;I"	upto;F;I"Integer;T;[o;;I"::Numeric limit;T;I"Integer;To;;I"::Numeric limit;T;I" Enumerator[::Integer, self];To;;I"0Returns `true` if `int` has a zero value.

;T;0;;;I"
zero?;F;I"Integer;T;[o;;I" ;F;I"	bool;To;;I"Bitwise OR; each bit in the result is 1 if either corresponding bit in `self`
or `other` is 1, 0 otherwise:

    "%04b" % (0b0101 | 0b0110) # => "0111"

Raises an exception if `other` is not an Integer.

Related: Integer#& (bitwise AND), Integer#^ (bitwise EXCLUSIVE OR).

;T;0;;;I"|;F;I"Integer;T;[o;;I"::Integer;T;I"Integer;To;;I"gOne's complement: returns a number where each bit is flipped.

Inverts the bits in an Integer. As integers are conceptually of infinite
length, the result acts as if it had an infinite number of one bits to the
left. In hex representations, this is displayed as two periods to the left of
the digits.

    sprintf("%X", ~0x1122334455)    #=> "..FEEDDCCBBAA"

;T;0;;;I"~;F;I"Integer;T;[o;;I" ;F;I"Integer;To; ;0;0;	I"Integer;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"›Returns the value of `int` as a BigDecimal.

    require 'bigdecimal'
    require 'bigdecimal/util'

    42.to_d   # => 0.42e2

See also BigDecimal::new.

;T;0;;;I"	to_d;F;I"Integer;T;[o;;I" ;F;I"BigDecimal;To; ;0;0;	I"Integer;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"DReturns a JSON string representation for this Integer number.

;T;0;;;I"to_json;F;I"Integer;T;[o;;I"?::JSON::State state;T;I"String;To; ;0;0;	I"Integer;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"[Iterates the given block over all prime numbers.

See `Prime`#each for more details.

;T;0;;;I"each_prime;F;I"Integer;T;[o;;I"::Integer;T;I"	void;To;;I"vRe-composes a prime factorization and returns the product.

See Prime#int_from_prime_division for more details.

;T;0;;;I"from_prime_division;F;I"Integer;T;[o;;I"::Array[[ ::String ]];T;I"Integer;To;;I"WReturns the factorization of `self`.

See Prime#prime_division for more details.

;T;0;;;I"prime_division;F;I"Integer;T;[o;;I"#?::Prime::PseudoPrimeGenerator;T;I"$Array[[ ::Integer, ::Integer ]];To;;I"vReturns true if `self` is a prime number, else returns false. Not recommended
for very big integers (> 10**23).

;T;0;;;I"prime?;F;I"Integer;T;[o;;I" ;F;I"	bool;To; ;0;0;	I"IO;T;
[ ;[ ;0;[ ;[ ;0;0o; ;0;0;	I"IO;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"kReturns number of bytes that can be read without blocking. Returns zero if no
information available.

;T;0;;;I"
nread;F;I"IO;T;[o;;I" ;F;I"Integer;To;;I"FReturns `true` if input available without blocking, or `false`.

;T;0;;;I"ready?;F;I"IO;T;[o;;I" ;F;I"boolish;To;;I"dWaits until the IO becomes ready for the specified events and returns the
subset of events that become ready, or `false` when times out.

The events can be a bit mask of `IO::READABLE`, `IO::WRITABLE` or
`IO::PRIORITY`.

Returns `true` immediately when buffered data is available.

Optional parameter `mode` is one of `:read`, `:write`, or `:read_write`.

;T;0;;;I"	wait;F;I"IO;T;[o;;I")::Integer events, ?::Numeric timeout;T;I"self | bool | nil;To;;I"/?::Numeric? timeout, *::IO::wait_mode mode;T;I"self | bool | nil;To;;I"‡Waits until IO is readable and returns `true`, or `false` when times out.
Returns `true` immediately when buffered data is available.

;T;0;;;I"wait_readable;F;I"IO;T;[o;;I"?::Numeric? timeout;T;I"(self | bool | nil)?;To;;I"OWaits until IO is writable and returns `true` or `false` when times out.

;T;0;;;I"wait_writable;F;I"IO;T;[o;;I"?::Numeric? timeout;T;I"boolish;To; ;I"ÐHThe IO class is the basis for all input and output in Ruby. An I/O stream may
be *duplexed* (that is, bidirectional), and so may use more than one native
operating system stream.

Many of the examples in this section use the File class, the only standard
subclass of IO. The two classes are closely associated.  Like the File class,
the Socket library subclasses from IO (such as TCPSocket or UDPSocket).

The Kernel#open method can create an IO (or File) object for these types of
arguments:

*   A plain string represents a filename suitable for the underlying operating
    system.

*   A string starting with `"|"` indicates a subprocess. The remainder of the
    string following the `"|"` is invoked as a process with appropriate
    input/output channels connected to it.

*   A string equal to `"|-"` will create another Ruby instance as a
    subprocess.


The IO may be opened with different file modes (read-only, write-only) and
encodings for proper conversion.  See IO.new for these options.  See
Kernel#open for details of the various command formats described above.

IO.popen, the Open3 library, or  Process#spawn may also be used to communicate
with subprocesses through an IO.

Ruby will convert pathnames between different operating system conventions if
possible.  For instance, on a Windows system the filename
`"/gumby/ruby/test.rb"` will be opened as `"\gumby\ruby\test.rb"`.  When
specifying a Windows-style filename in a Ruby string, remember to escape the
backslashes:

    "C:\\gumby\\ruby\\test.rb"

Our examples here will use the Unix-style forward slashes; File::ALT_SEPARATOR
can be used to get the platform-specific separator character.

The global constant ARGF (also accessible as `$<`) provides an IO-like stream
which allows access to all files mentioned on the command line (or STDIN if no
files are mentioned). ARGF#path and its alias ARGF#filename are provided to
access the name of the file currently being read.

## io/console

The io/console extension provides methods for interacting with the console.
The console can be accessed from IO.console or the standard input/output/error
IO objects.

Requiring io/console adds the following methods:

*   IO::console
*   IO#raw
*   IO#raw!
*   IO#cooked
*   IO#cooked!
*   IO#getch
*   IO#echo=
*   IO#echo?
*   IO#noecho
*   IO#winsize
*   IO#winsize=
*   IO#iflush
*   IO#ioflush
*   IO#oflush


Example:

    require 'io/console'
    rows, columns = $stdout.winsize
    puts "Your screen is #{columns} wide and #{rows} tall"

## Example Files

Many examples here use these filenames and their corresponding files:

*   `t.txt`: A text-only file that is assumed to exist via:

        text = <<~EOT
          This is line one.
          This is the second line.
          This is the third line.
        EOT
        File.write('t.txt', text)

*   `t.dat`: A data file that is assumed to exist via:

        data = "\u9990\u9991\u9992\u9993\u9994"
        f = File.open('t.dat', 'wb:UTF-16')
        f.write(data)
        f.close

*   `t.rus`: A Russian-language text file that is assumed to exist via:

        File.write('t.rus', "\u{442 435 441 442}")

*   `t.tmp`: A file that is assumed *not* to exist.


## Modes

A number of IO method calls must or may specify a *mode* for the stream; the
mode determines how stream is to be accessible, including:

*   Whether the stream is to be read-only, write-only, or read-write.
*   Whether the stream is positioned at its beginning or its end.
*   Whether the stream treats data as text-only or binary.
*   The external and internal encodings.


### Mode Specified as an Integer

When `mode` is an integer it must be one or more (combined by bitwise OR (`|`)
of the modes defined in File::Constants:

*   `File::RDONLY`: Open for reading only.
*   `File::WRONLY`: Open for writing only.
*   `File::RDWR`: Open for reading and writing.
*   `File::APPEND`: Open for appending only.
*   `File::CREAT`: Create file if it does not exist.
*   `File::EXCL`: Raise an exception if `File::CREAT` is given and the file
    exists.


Examples:

    File.new('t.txt', File::RDONLY)
    File.new('t.tmp', File::RDWR | File::CREAT | File::EXCL)

Note: Method IO#set_encoding does not allow the mode to be specified as an
integer.

### Mode Specified As a String

When `mode` is a string it must begin with one of the following:

*   `'r'`: Read-only stream, positioned at the beginning; the stream cannot be
    changed to writable.
*   `'w'`: Write-only stream, positioned at the beginning; the stream cannot
    be changed to readable.
*   `'a'`: Write-only stream, positioned at the end; every write appends to
    the end; the stream cannot be changed to readable.
*   `'r+'`: Read-write stream, positioned at the beginning.
*   `'w+'`: Read-write stream, positioned at the end.
*   `'a+'`: Read-write stream, positioned at the end.


For a writable file stream (that is, any except read-only), the file is
truncated to zero if it exists, and is created if it does not exist.

Examples:

    File.open('t.txt', 'r')
    File.open('t.tmp', 'w')

Either of the following may be suffixed to any of the above:

*   `'t'`: Text data; sets the default external encoding to `Encoding::UTF_8`;
    on Windows, enables conversion between EOL and CRLF.
*   `'b'`: Binary data; sets the default external encoding to
    `Encoding::ASCII_8BIT`; on Windows, suppresses conversion between EOL and
    CRLF.


If neither is given, the stream defaults to text data.

Examples:

    File.open('t.txt', 'rt')
    File.open('t.dat', 'rb')

The following may be suffixed to any writable mode above:

*   `'x'`: Creates the file if it does not exist; raises an exception if the
    file exists.


Example:

    File.open('t.tmp', 'wx')

Finally, the mode string may specify encodings -- either external encoding
only or both external and internal encodings -- by appending one or both
encoding names, separated by colons:

    f = File.new('t.dat', 'rb')
    f.external_encoding # => #<Encoding:ASCII-8BIT>
    f.internal_encoding # => nil
    f = File.new('t.dat', 'rb:UTF-16')
    f.external_encoding # => #<Encoding:UTF-16 (dummy)>
    f.internal_encoding # => nil
    f = File.new('t.dat', 'rb:UTF-16:UTF-16')
    f.external_encoding # => #<Encoding:UTF-16 (dummy)>
    f.internal_encoding # => #<Encoding:UTF-16>

The numerous encoding names are available in array Encoding.name_list:

    Encoding.name_list.size    # => 175
    Encoding.name_list.take(3) # => ["ASCII-8BIT", "UTF-8", "US-ASCII"]

## Encodings

When the external encoding is set, strings read are tagged by that encoding
when reading, and strings written are converted to that encoding when writing.

When both external and internal encodings are set, strings read are converted
from external to internal encoding, and strings written are converted from
internal to external encoding. For further details about transcoding input and
output, see Encoding.

If the external encoding is `'BOM|UTF-8'`, `'BOM|UTF-16LE'` or
`'BOM|UTF16-BE'`, Ruby checks for a Unicode BOM in the input document to help
determine the encoding.  For UTF-16 encodings the file open mode must be
binary. If the BOM is found, it is stripped and the external encoding from the
BOM is used.

Note that the BOM-style encoding option is case insensitive, so 'bom|utf-8' is
also valid.)

## Open Options

A number of IO methods accept an optional parameter `opts`, which determines
how a new stream is to be opened:

*   `:mode`: Stream mode.
*   `:flags`: Integer file open flags; If `mode` is also given, the two are
    bitwise-ORed.
*   `:external_encoding`: External encoding for the stream.
*   `:internal_encoding`: Internal encoding for the stream. `'-'` is a synonym
    for the default internal encoding. If the value is `nil` no conversion
    occurs.
*   `:encoding`: Specifies external and internal encodings as
    `'extern:intern'`.
*   `:textmode`: If a truthy value, specifies the mode as text-only, binary
    otherwise.
*   `:binmode`: If a truthy value, specifies the mode as binary, text-only
    otherwise.
*   `:autoclose`: If a truthy value, specifies that the `fd` will close when
    the stream closes; otherwise it remains open.


Also available are the options offered in String#encode, which may control
conversion between external internal encoding.

## Getline Options

A number of IO methods accept optional keyword arguments that determine how a
stream is to be treated:

*   `:chomp`: If `true`, line separators are omitted; default is  `false`.


## Position

An IO stream has a *position*, which is the non-negative integer offset (in
bytes) in the stream where the next read or write will occur.

Note that a text stream may have multi-byte characters, so a text stream whose
position is `n` (*bytes*) may not have `n` *characters* preceding the current
position -- there may be fewer.

A new stream is initially positioned:

*   At the beginning (position `0`) if its mode is `'r'`, `'w'`, or `'r+'`.
*   At the end (position `self.size`) if its mode is `'a'`, `'w+'`, or `'a+'`.


Methods to query the position:

*   IO#tell and its alias IO#pos return the position for an open stream.
*   IO#eof? and its alias IO#eof return whether the position is at the end of
    a readable stream.


Reading from a stream usually changes its position:

    f = File.open('t.txt')
    f.tell     # => 0
    f.readline # => "This is line one.\n"
    f.tell     # => 19
    f.readline # => "This is the second line.\n"
    f.tell     # => 45
    f.eof?     # => false
    f.readline # => "Here's the third line.\n"
    f.eof?     # => true

Writing to a stream usually changes its position:

    f = File.open('t.tmp', 'w')
    f.tell         # => 0
    f.write('foo') # => 3
    f.tell         # => 3
    f.write('bar') # => 3
    f.tell         # => 6

Iterating over a stream usually changes its position:

    f = File.open('t.txt')
    f.each do |line|
      p "position=#{f.pos} eof?=#{f.eof?} line=#{line}"
    end

Output:

    "position=19 eof?=false line=This is line one.\n"
    "position=45 eof?=false line=This is the second line.\n"
    "position=70 eof?=true line=This is the third line.\n"

The position may also be changed by certain other methods:

*   IO#pos= and IO#seek change the position to a specified offset.
*   IO#rewind changes the position to the beginning.


## Line Number

A readable IO stream has a *line* *number*, which is the non-negative integer
line number in the stream where the next read will occur.

A new stream is initially has line number `0`.

Method IO#lineno returns the line number.

Reading lines from a stream usually changes its line number:

    f = File.open('t.txt', 'r')
    f.lineno   # => 0
    f.readline # => "This is line one.\n"
    f.lineno   # => 1
    f.readline # => "This is the second line.\n"
    f.lineno   # => 2
    f.readline # => "Here's the third line.\n"
    f.lineno   # => 3
    f.eof?     # => true

Iterating over lines in a stream usually changes its line number:

    f = File.open('t.txt')
    f.each_line do |line|
      p "position=#{f.pos} eof?=#{f.eof?} line=#{line}"
    end

Output:

    "position=19 eof?=false line=This is line one.\n"
    "position=45 eof?=false line=This is the second line.\n"
    "position=70 eof?=true line=This is the third line.\n"

## What's Here

First, what's elsewhere. Class IO:

*   Inherits from [class
    Object](Object.html#class-Object-label-What-27s+Here).
*   Includes [module
    Enumerable](Enumerable.html#module-Enumerable-label-What-27s+Here), which
    provides dozens of additional methods.


Here, class IO provides methods that are useful for:

*   [Creating](#class-IO-label-Creating)
*   [Reading](#class-IO-label-Reading)
*   [Writing](#class-IO-label-Writing)
*   [Positioning](#class-IO-label-Positioning)
*   [Iterating](#class-IO-label-Iterating)
*   [Settings](#class-IO-label-Settings)
*   [Querying](#class-IO-label-Querying)
*   [Buffering](#class-IO-label-Buffering)
*   [Low-Level Access](#class-IO-label-Low-Level+Access)
*   [Other](#class-IO-label-Other)


### Creating

    ::new (aliased as ::for_fd)
:       Creates and returns a new IO object for the given integer file
        descriptor.

    ::open
:       Creates a new IO object.

    ::pipe
:       Creates a connected pair of reader and writer IO objects.

    ::popen
:       Creates an IO object to interact with a subprocess.

    ::select
:       Selects which given IO instances are ready for reading,

    writing, or have pending exceptions.


### Reading

    ::binread
:       Returns a binary string with all or a subset of bytes from the given
        file.

    ::read
:       Returns a string with all or a subset of bytes from the given file.

    ::readlines
:       Returns an array of strings, which are the lines from the given file.

    #getbyte
:       Returns the next 8-bit byte read from `self` as an integer.

    #getc
:       Returns the next character read from `self` as a string.

    #gets
:       Returns the line read from `self`.

    #pread
:       Returns all or the next *n* bytes read from `self`, not updating the
        receiver's offset.

    #read
:       Returns all remaining or the next *n* bytes read from `self` for a
        given *n*.

    #read_nonblock
:       the next *n* bytes read from `self` for a given *n*, in non-block
        mode.

    #readbyte
:       Returns the next byte read from `self`; same as #getbyte, but raises
        an exception on end-of-file.

    #readchar
:       Returns the next character read from `self`; same as #getc, but raises
        an exception on end-of-file.

    #readline
:       Returns the next line read from `self`; same as #getline, but raises
        an exception of end-of-file.

    #readlines
:       Returns an array of all lines read read from `self`.

    #readpartial
:       Returns up to the given number of bytes from `self`.



### Writing

    ::binwrite
:       Writes the given string to the file at the given filepath, in binary
        mode.

    ::write
:       Writes the given string to `self`.

    [:<<](#method-i-3C-3C)
:       Appends the given string to `self`.

    #print
:       Prints last read line or given objects to `self`.

    #printf
:       Writes to `self` based on the given format string and objects.

    #putc
:       Writes a character to `self`.

    #puts
:       Writes lines to `self`, making sure line ends with a newline.

    #pwrite
:       Writes the given string at the given offset, not updating the
        receiver's offset.

    #write
:       Writes one or more given strings to `self`.

    #write_nonblock
:       Writes one or more given strings to `self` in non-blocking mode.



### Positioning

    #lineno
:       Returns the current line number in `self`.

    #lineno=
:       Sets the line number is `self`.

    #pos (aliased as #tell)
:       Returns the current byte offset in `self`.

    #pos=
:       Sets the byte offset in `self`.

    #reopen
:       Reassociates `self` with a new or existing IO stream.

    #rewind
:       Positions `self` to the beginning of input.

    #seek
:       Sets the offset for `self` relative to given position.



### Iterating

    ::foreach
:       Yields each line of given file to the block.

    #each (aliased as #each_line)
:       Calls the given block with each successive line in `self`.

    #each_byte
:       Calls the given block with each successive byte in `self` as an
        integer.

    #each_char
:       Calls the given block with each successive character in `self` as a
        string.

    #each_codepoint
:       Calls the given block with each successive codepoint in `self` as an
        integer.



### Settings

    #autoclose=
:       Sets whether `self` auto-closes.

    #binmode
:       Sets `self` to binary mode.

    #close
:       Closes `self`.

    #close_on_exec=
:       Sets the close-on-exec flag.

    #close_read
:       Closes `self` for reading.

    #close_write
:       Closes `self` for writing.

    #set_encoding
:       Sets the encoding for `self`.

    #set_encoding_by_bom
:       Sets the encoding for `self`, based on its Unicode byte-order-mark.

    #sync=
:       Sets the sync-mode to the given value.



### Querying

    #autoclose?
:       Returns whether `self` auto-closes.

    #binmode?
:       Returns whether `self` is in binary mode.

    #close_on_exec?
:       Returns the close-on-exec flag for `self`.

    #closed?
:       Returns whether `self` is closed.

    #eof? (aliased as #eof)
:       Returns whether `self` is at end-of-file.

    #external_encoding
:       Returns the external encoding object for `self`.

    #fileno (aliased as #to_i)
:       Returns the integer file descriptor for `self`

    #internal_encoding
:       Returns the internal encoding object for `self`.

    #pid
:       Returns the process ID of a child process associated with `self`, if
        `self` was created by ::popen.

    #stat
:       Returns the File::Stat object containing status information for
        `self`.

    #sync
:       Returns whether `self` is in sync-mode.

    #tty (aliased as #isatty)
:       Returns whether `self` is a terminal.



### Buffering

    #fdatasync
:       Immediately writes all buffered data in `self` to disk.

    #flush
:       Flushes any buffered data within `self` to the underlying operating
        system.

    #fsync
:       Immediately writes all buffered data and attributes in `self` to disk.

    #ungetbyte
:       Prepends buffer for `self` with given integer byte or string.

    #ungetc
:       Prepends buffer for `self` with given string.



### Low-Level Access

    ::sysopen
:       Opens the file given by its path, returning the integer file
        descriptor.

    #advise
:       Announces the intention to access data from `self` in a specific way.

    #fcntl
:       Passes a low-level command to the file specified by the given file
        descriptor.

    #ioctl
:       Passes a low-level command to the device specified by the given file
        descriptor.

    #sysread
:       Returns up to the next *n* bytes read from self using a low-level
        read.

    #sysseek
:       Sets the offset for `self`.

    #syswrite
:       Writes the given string to `self` using a low-level write.



### Other

    ::copy_stream
:       Copies data from a source to a destination, each of which is a
        filepath or an IO-like object.

    ::try_convert
:       Returns a new IO object resulting from converting the given object.

    #inspect
:       Returns the string representation of `self`.

;T;0;	I"IO;T;
[ ;[I"File::Constants;TI"Enumerable;T;0;[ ;[ ;0;I"Object;To;;I"CWrites the given `object` to `self`, which must be opened for writing (see
[Modes](#class-IO-label-Modes)); returns `self`; if `object` is not a string,
it is converted via method `to_s`:

    $stdout << 'Hello' << ', ' << 'World!' << "\n"
    $stdout << 'foo' << :bar << 2 << "\n"

Output:

    Hello, World!
    foobar2

;T;0;;;I"<<;F;I"IO;T;[o;;I"::_ToS obj;T;I"	self;To;;I"/Announce an intention to access data from the current file in a specific
pattern. On platforms that do not support the *posix_fadvise(2)* system call,
this method is a no-op.

*advice* is one of the following symbols:

:normal
:   No advice to give; the default assumption for an open file.
:sequential
:   The data will be accessed sequentially with lower offsets read before
    higher ones.
:random
:   The data will be accessed in random order.
:willneed
:   The data will be accessed in the near future.
:dontneed
:   The data will not be accessed in the near future.
:noreuse
:   The data will only be accessed once.


The semantics of a piece of advice are platform-dependent. See *man 2
posix_fadvise* for details.

"data" means the region of the current file that begins at *offset* and
extends for *len* bytes. If *len* is 0, the region ends at the last byte of
the file. By default, both *offset* and *len* are 0, meaning that the advice
applies to the entire file.

If an error occurs, one of the following exceptions will be raised:

IOError
:   The IO stream is closed.
Errno::EBADF
:   The file descriptor of the current file is invalid.
Errno::EINVAL
:   An invalid value for *advice* was given.
Errno::ESPIPE
:   The file descriptor of the current file refers to a FIFO or pipe. (Linux
    raises Errno::EINVAL in this case).
TypeError
:   Either *advice* was not a Symbol, or one of the other arguments was not an
    Integer.
RangeError
:   One of the arguments given was too big/small.

This list is not exhaustive; other Errno
:   exceptions are also possible.

;T;0;;;I"advise;F;I"IO;T;[o;;I"q:normal | :sequential | :random | :willneed | :dontneed | :noreuse advise, ?::Integer offset, ?::Integer len;T;I"nil;To;;I"íSets auto-close flag.

    f = open("/dev/null")
    IO.for_fd(f.fileno)
    # ...
    f.gets # may cause Errno::EBADF

    f = open("/dev/null")
    IO.for_fd(f.fileno).autoclose = false
    # ...
    f.gets # won't cause Errno::EBADF

;T;0;;;I"autoclose=;F;I"IO;T;[o;;I"::boolish;T;I"untyped;To;;I"€Returns `true` if the underlying file descriptor of *ios* will be closed
automatically at its finalization, otherwise `false`.

;T;0;;;I"autoclose?;F;I"IO;T;[o;;I" ;F;I"	bool;To;;I"ÌPuts *ios* into binary mode. Once a stream is in binary mode, it cannot be
reset to nonbinary mode.

*   newline conversion disabled
*   encoding conversion disabled
*   content is treated as ASCII-8BIT

;T;0;;;I"binmode;F;I"IO;T;[o;;I" ;F;I"	self;To;;I"*Returns `true` if *ios* is binmode.

;T;0;;;I"binmode?;F;I"IO;T;[o;;I" ;F;I"	bool;To;;I"ƒCloses *ios* and flushes any pending writes to the operating system. The
stream is unavailable for any further data operations; an IOError is raised if
such an attempt is made. I/O streams are automatically closed when they are
claimed by the garbage collector.

If *ios* is opened by IO.popen, #close sets `$?`.

Calling this method on closed IO object is just ignored since Ruby 2.3.

;T;0;;;I"
close;F;I"IO;T;[o;;I" ;F;I"NilClass;To;;I"LSets a close-on-exec flag.

    f = open("/dev/null")
    f.close_on_exec = true
    system("cat", "/proc/self/fd/#{f.fileno}") # cat: /proc/self/fd/3: No such file or directory
    f.closed?                #=> false

Ruby sets close-on-exec flags of all file descriptors by default since Ruby
2.0.0. So you don't need to set by yourself. Also, unsetting a close-on-exec
flag can cause file descriptor leak if another thread use fork() and exec()
(via system() method for example). If you really needs file descriptor
inheritance to child process, use spawn()'s argument such as fd=>fd.

;T;0;;;I"close_on_exec=;F;I"IO;T;[o;;I"::boolish;T;I"untyped;To;;I"Returns `true` if *ios* will be closed on exec.

    f = open("/dev/null")
    f.close_on_exec?                 #=> false
    f.close_on_exec = true
    f.close_on_exec?                 #=> true
    f.close_on_exec = false
    f.close_on_exec?                 #=> false

;T;0;;;I"close_on_exec?;F;I"IO;T;[o;;I" ;F;I"	bool;To;;I"˜Closes the read end of a duplex I/O stream (i.e., one that contains both a
read and a write stream, such as a pipe). Will raise an IOError if the stream
is not duplexed.

    f = IO.popen("/bin/sh","r+")
    f.close_read
    f.readlines

*produces:*

    prog.rb:3:in `readlines': not opened for reading (IOError)
     from prog.rb:3

Calling this method on closed IO object is just ignored since Ruby 2.3.

;T;0;;;I"close_read;F;I"IO;T;[o;;I" ;F;I"NilClass;To;;I"»Closes the write end of a duplex I/O stream (i.e., one that contains both a
read and a write stream, such as a pipe). Will raise an IOError if the stream
is not duplexed.

    f = IO.popen("/bin/sh","r+")
    f.close_write
    f.print "nowhere"

*produces:*

    prog.rb:3:in `write': not opened for writing (IOError)
     from prog.rb:3:in `print'
     from prog.rb:3

Calling this method on closed IO object is just ignored since Ruby 2.3.

;T;0;;;I"close_write;F;I"IO;T;[o;;I" ;F;I"NilClass;To;;I"ZReturns `true` if *ios* is completely closed (for duplex streams, both reader
and writer), `false` otherwise.

    f = File.new("testfile")
    f.close         #=> nil
    f.closed?       #=> true
    f = IO.popen("/bin/sh","r+")
    f.close_write   #=> nil
    f.closed?       #=> false
    f.close_read    #=> nil
    f.closed?       #=> true

;T;0;;;I"closed?;F;I"IO;T;[o;;I" ;F;I"	bool;To;;I"·Executes the block for every line in *ios*, where lines are separated by
*sep*. *ios* must be opened for reading or an IOError will be raised.

If no block is given, an enumerator is returned instead.

    f = File.new("testfile")
    f.each {|line| puts "#{f.lineno}: #{line}" }

*produces:*

    1: This is line one
    2: This is line two
    3: This is line three
    4: And so on...

See IO.readlines for details about getline_args.

;T;0;;;I"	each;F;I"IO;T;[o;;I"$?::String sep, ?::Integer limit;T;I"	self;To;;I"$?::String sep, ?::Integer limit;T;I"Enumerator[::String, self];To;;I"uCalls the given block once for each byte (0..255) in *ios*, passing the byte
as an argument. The stream must be opened for reading or an IOError will be
raised.

If no block is given, an enumerator is returned instead.

    f = File.new("testfile")
    checksum = 0
    f.each_byte {|x| checksum ^= x }   #=> #<File:testfile>
    checksum                           #=> 12

;T;0;;;I"each_byte;F;I"IO;T;[o;;I" ;F;I"	self;To;;I" ;F;I" Enumerator[::Integer, self];To;;I"6Calls the given block once for each character in *ios*, passing the character
as an argument. The stream must be opened for reading or an IOError will be
raised.

If no block is given, an enumerator is returned instead.

    f = File.new("testfile")
    f.each_char {|c| print c, ' ' }   #=> #<File:testfile>

;T;0;;;I"each_char;F;I"IO;T;[o;;I" ;F;I"	self;To;;I" ;F;I"Enumerator[::String, self];To;;I"ÜPasses the Integer ordinal of each character in *ios*, passing the codepoint
as an argument. The stream must be opened for reading or an IOError will be
raised.

If no block is given, an enumerator is returned instead.

;T;0;;;I"each_codepoint;F;I"IO;T;[o;;I" ;F;I"	self;To;;I" ;F;I" Enumerator[::Integer, self];To;;I"œReturns `true` if the stream is positioned at its end, `false` otherwise; see
[Position](#class-IO-label-Position):

    f = File.open('t.txt')
    f.eof           # => false
    f.seek(0, :END) # => 0
    f.eof           # => true

Raises an exception unless the stream is opened for reading; see
[Mode](#class-IO-label-Mode).

If `self` is a stream such as pipe or socket, this method blocks until the
other end sends some data or closes it:

    r, w = IO.pipe
    Thread.new { sleep 1; w.close }
    r.eof? # => true # After 1-second wait.

    r, w = IO.pipe
    Thread.new { sleep 1; w.puts "a" }
    r.eof?  # => false # After 1-second wait.

    r, w = IO.pipe
    r.eof?  # blocks forever

Note that this method reads data to the input byte buffer.  So IO#sysread may
not behave as you intend with IO#eof?, unless you call IO#rewind first (which
is not available for some streams).

I#eof? is an alias for IO#eof.

;T;0;;;I"eof;F;I"IO;T;[o;;I" ;F;I"	bool;To;;I"”Provides a mechanism for issuing low-level commands to control or query
file-oriented I/O streams. Arguments and results are platform dependent. If
*arg* is a number, its value is passed directly. If it is a string, it is
interpreted as a binary sequence of bytes (Array#pack might be a useful way to
build this string). On Unix platforms, see `fcntl(2)` for details.  Not
implemented on all platforms.

;T;0;;;I"
fcntl;F;I"IO;T;[o;;I"4::Integer integer_cmd, ::String | ::Integer arg;T;I"Integer;To;;I"¾Immediately writes to disk all data buffered in the stream, via the operating
system's: `fdatasync(2)`, if supported, otherwise via `fsync(2)`, if
supported; otherwise raises an exception.

;T;0;;;I"fdatasync;F;I"IO;T;[o;;I" ;F;I"Integer?;To;;I"ïReturns the integer file descriptor for the stream:

    $stdin.fileno             # => 0
    $stdout.fileno            # => 1
    $stderr.fileno            # => 2
    File.open('t.txt').fileno # => 10

IO#to_i is an alias for IO#fileno.

;T;0;;;I"fileno;F;I"IO;T;[o;;I" ;F;I"Integer;To;;I"æFlushes data buffered in `self` to the operating system (but does not
necessarily flush data buffered in the operating system):

    $stdout.print 'no newline' # Not necessarily flushed.
    $stdout.flush              # Flushed.

;T;0;;;I"
flush;F;I"IO;T;[o;;I" ;F;I"	self;To;;I"ÞImmediately writes to disk all data buffered in the stream, via the operating
system's `fsync(2)`.

Note this difference:

*   IO#sync=: Ensures that data is flushed from the stream's internal buffers,
    but does not guarantee that the operating system actually writes the data
    to disk.
*   IO#fsync: Ensures both that data is flushed from internal buffers, and
    that data is written to disk.


Raises an exception if the operating system does not support `fsync(2)`.

;T;0;;;I"
fsync;F;I"IO;T;[o;;I" ;F;I"Integer?;To;;I"¤Gets the next 8-bit byte (0..255) from *ios*. Returns `nil` if called at end
of file.

    f = File.new("testfile")
    f.getbyte   #=> 84
    f.getbyte   #=> 104

;T;0;;;I"getbyte;F;I"IO;T;[o;;I" ;F;I"Integer?;To;;I"šReads a one-character string from *ios*. Returns `nil` if called at end of
file.

    f = File.new("testfile")
    f.getc   #=> "h"
    f.getc   #=> "e"

;T;0;;;I"	getc;F;I"IO;T;[o;;I" ;F;I"String?;To;;I"?	Reads and returns data from the stream; assigns the return value to `$_`.

With no arguments given, returns the next line as determined by line separator
`$/`, or `nil` if none:

    f = File.open('t.txt')
    f.gets # => "This is line one.\n"
    $_     # => "This is line one.\n"
    f.gets # => "This is the second line.\n"
    f.gets # => "This is the third line.\n"
    f.gets # => nil

With string argument `sep` given, but not argument `limit`, returns the next
line as determined by line separator `sep`, or `nil` if none:

    f = File.open('t.txt')
    f.gets(' is') # => "This is"
    f.gets(' is') # => " line one.\nThis is"
    f.gets(' is') # => " the second line.\nThis is"
    f.gets(' is') # => " the third line.\n"
    f.gets(' is') # => nil

Note two special values for `sep`:

*   `nil`: The entire stream is read and returned.
*   `''` (empty string): The next "paragraph" is read and returned, the
    paragraph separator being two successive line separators.


With integer argument `limit` given, returns up to `limit+1` bytes:

    # Text with 1-byte characters.
    File.open('t.txt') {|f| f.gets(1) } # => "T"
    File.open('t.txt') {|f| f.gets(2) } # => "Th"
    File.open('t.txt') {|f| f.gets(3) } # => "Thi"
    File.open('t.txt') {|f| f.gets(4) } # => "This"
    # No more than one line.
    File.open('t.txt') {|f| f.gets(17) } # => "This is line one."
    File.open('t.txt') {|f| f.gets(18) } # => "This is line one.\n"
    File.open('t.txt') {|f| f.gets(19) } # => "This is line one.\n"

    # Text with 2-byte characters, which will not be split.
    File.open('t.rus') {|f| f.gets(1).size } # => 1
    File.open('t.rus') {|f| f.gets(2).size } # => 1
    File.open('t.rus') {|f| f.gets(3).size } # => 2
    File.open('t.rus') {|f| f.gets(4).size } # => 2

With arguments `sep` and `limit`, combines the two behaviors above:

*   Returns the next line as determined by line separator `sep`, or `nil` if
    none.
*   But returns no more than `limit+1` bytes.


For all forms above, trailing optional keyword arguments may be given; see
[Getline Options](#class-IO-label-Getline+Options):

    f = File.open('t.txt')
    # Chomp the lines.
    f.gets(chomp: true) # => "This is line one."
    f.gets(chomp: true) # => "This is the second line."
    f.gets(chomp: true) # => "This is the third line."
    f.gets(chomp: true) # => nil

;T;0;;;I"	gets;F;I"IO;T;[o;;I"$?::String sep, ?::Integer limit;T;I"String?;To;;I"MReturns a new IO object (a stream) for the given integer file descriptor `fd`
and `mode` string.  `opt` may be used to specify parts of `mode` in a more
readable fashion.  See also IO.sysopen and IO.for_fd.

IO.new is called by various File and IO opening methods such as IO::open,
Kernel#open, and File::open.

### Open Mode

When `mode` is an integer it must be combination of the modes defined in
File::Constants (`File::RDONLY`, `File::WRONLY|File::CREAT`). See the open(2)
man page for more information.

When `mode` is a string it must be in one of the following forms:

    fmode
    fmode ":" ext_enc
    fmode ":" ext_enc ":" int_enc
    fmode ":" "BOM|UTF-*"

`fmode` is an IO open mode string, `ext_enc` is the external encoding for the
IO and `int_enc` is the internal encoding.

#### IO Open Mode

Ruby allows the following open modes:

    "r"  Read-only, starts at beginning of file  (default mode).

    "r+" Read-write, starts at beginning of file.

    "w"  Write-only, truncates existing file
         to zero length or creates a new file for writing.

    "w+" Read-write, truncates existing file to zero length
         or creates a new file for reading and writing.

    "a"  Write-only, each write call appends data at end of file.
         Creates a new file for writing if file does not exist.

    "a+" Read-write, each write call appends data at end of file.
         Creates a new file for reading and writing if file does
         not exist.

The following modes must be used separately, and along with one or more of the
modes seen above.

    "b"  Binary file mode
         Suppresses EOL <-> CRLF conversion on Windows. And
         sets external encoding to ASCII-8BIT unless explicitly
         specified.

    "t"  Text file mode

The exclusive access mode ("x") can be used together with "w" to ensure the
file is created. Errno::EEXIST is raised when it already exists. It may not be
supported with all kinds of streams (e.g. pipes).

When the open mode of original IO is read only, the mode cannot be changed to
be writable.  Similarly, the open mode cannot be changed from write only to
readable.

When such a change is attempted the error is raised in different locations
according to the platform.

### IO Encoding

When `ext_enc` is specified, strings read will be tagged by the encoding when
reading, and strings output will be converted to the specified encoding when
writing.

When `ext_enc` and `int_enc` are specified read strings will be converted from
`ext_enc` to `int_enc` upon input, and written strings will be converted from
`int_enc` to `ext_enc` upon output.  See Encoding for further details of
transcoding on input and output.

If "BOM|UTF-8", "BOM|UTF-16LE" or "BOM|UTF16-BE" are used, Ruby checks for a
Unicode BOM in the input document to help determine the encoding.  For UTF-16
encodings the file open mode must be binary.  When present, the BOM is
stripped and the external encoding from the BOM is used.  When the BOM is
missing the given Unicode encoding is used as `ext_enc`.  (The BOM-set
encoding option is case insensitive, so "bom|utf-8" is also valid.)

### Options

`opt` can be used instead of `mode` for improved readability.  The following
keys are supported:

:mode
:   Same as `mode` parameter

:flags
:   Specifies file open flags as integer. If `mode` parameter is given, this
    parameter will be bitwise-ORed.

:external_encoding
:   External encoding for the IO.

:internal_encoding
:   Internal encoding for the IO.  "-" is a synonym for the default internal
    encoding.

    If the value is `nil` no conversion occurs.

:encoding
:   Specifies external and internal encodings as "extern:intern".

:textmode
:   If the value is truth value, same as "t" in argument `mode`.

:binmode
:   If the value is truth value, same as "b" in argument `mode`.

:autoclose
:   If the value is `false`, the `fd` will be kept open after this IO instance
    gets finalized.


Also, `opt` can have same keys in String#encode for controlling conversion
between the external encoding and the internal encoding.

### Example 1

    fd = IO.sysopen("/dev/tty", "w")
    a = IO.new(fd,"w")
    $stderr.puts "Hello"
    a.puts "World"

Produces:

    Hello
    World

### Example 2

    require 'fcntl'

    fd = STDERR.fcntl(Fcntl::F_DUPFD)
    io = IO.new(fd, mode: 'w:UTF-16LE', cr_newline: true)
    io.puts "Hello, World!"

    fd = STDERR.fcntl(Fcntl::F_DUPFD)
    io = IO.new(fd, mode: 'w', cr_newline: true,
                external_encoding: Encoding::UTF_16LE)
    io.puts "Hello, World!"

Both of above print "Hello, World!" in UTF-16LE to standard error output with
converting EOL generated by #puts to CR.

;T;0;;;I"initialize;F;I"IO;T;[o;;I"2::Integer fd, ?::Integer mode, ?::Integer opt;T;I"	void;To;;I"pReturns a string representation of `self`:

    f = File.open('t.txt')
    f.inspect # => "#<File:t.txt>"

;T;0;;;I"inspect;F;I"IO;T;[o;;I" ;F;I"String;To;;I"gReturns the Encoding of the internal string if conversion is specified.
Otherwise returns `nil`.

;T;0;;;I"internal_encoding;F;I"IO;T;[o;;I" ;F;I"Encoding;To;;I"MProvides a mechanism for issuing low-level commands to control or query I/O
devices. Arguments and results are platform dependent. If *arg* is a number,
its value is passed directly. If it is a string, it is interpreted as a binary
sequence of bytes. On Unix platforms, see `ioctl(2)` for details. Not
implemented on all platforms.

;T;0;;;I"
ioctl;F;I"IO;T;[o;;I"4::Integer integer_cmd, ::String | ::Integer arg;T;I"Integer;To;;I"°Returns `true` if *ios* is associated with a terminal device (tty), `false`
otherwise.

    File.new("testfile").isatty   #=> false
    File.new("/dev/tty").isatty   #=> true

;T;0;;;I"isatty;F;I"IO;T;[o;;I" ;F;I"	bool;To;;I")Returns the current line number in *ios*.  The stream must be opened for
reading. #lineno counts the number of times #gets is called rather than the
number of newlines encountered.  The two values will differ if #gets is called
with a separator other than newline.

Methods that use `$/` like #each, #lines and #readline will also increment
#lineno.

See also the `$.` variable.

    f = File.new("testfile")
    f.lineno   #=> 0
    f.gets     #=> "This is line one\n"
    f.lineno   #=> 1
    f.gets     #=> "This is line two\n"
    f.lineno   #=> 2

;T;0;;;I"lineno;F;I"IO;T;[o;;I" ;F;I"Integer;To;;I"×Manually sets the current line number to the given value. `$.` is updated only
on the next read.

    f = File.new("testfile")
    f.gets                     #=> "This is line one\n"
    $.                         #=> 1
    f.lineno = 1000
    f.lineno                   #=> 1000
    $.                         #=> 1         # lineno of last read
    f.gets                     #=> "This is line two\n"
    $.                         #=> 1001      # lineno of last read

;T;0;;;I"lineno=;F;I"IO;T;[o;;I"::Integer arg0;T;I"Integer;To;;I"„Returns the process ID of a child process associated with the stream, which
will have been set by IO#popen, or `nil` if the stream was not created by
IO#popen:

    pipe = IO.popen("-")
    if pipe
      $stderr.puts "In parent, child pid is #{pipe.pid}"
    else
      $stderr.puts "In child, pid is #{$$}"
    end

Output:

    In child, pid is 26209
    In parent, child pid is 26209

;T;0;;;I"pid;F;I"IO;T;[o;;I" ;F;I"Integer;To;;I"Returns the current position (in bytes) in `self` (see
[Position](#class-IO-label-Position)):

    f = File.new('t.txt')
    f.tell     # => 0
    f.readline # => "This is line one.\n"
    f.tell     # => 19

Related: IO#pos=, IO#seek.

IO#pos is an alias for IO#tell.

;T;0;;;I"pos;F;I"IO;T;[o;;I" ;F;I"Integer;To;;I"ÕSeeks to the given `new_position` (in bytes); see
[Position](#class-IO-label-Position):

    f = File.open('t.txt')
    f.tell     # => 0
    f.pos = 20 # => 20
    f.tell     # => 20

Related: IO#seek, IO#tell.

;T;0;;;I"	pos=;F;I"IO;T;[o;;I"::Integer arg0;T;I"Integer;To;;I"ïWrites the given object(s) to *ios*. Returns `nil`.

The stream must be opened for writing. Each given object that isn't a string
will be converted by calling its `to_s` method. When called without arguments,
prints the contents of `$_`.

If the output field separator (`$,`) is not `nil`, it is inserted between
objects. If the output record separator (`$\`) is not `nil`, it is appended to
the output.

    $stdout.print("This is ", 100, " percent.\n")

*produces:*

    This is 100 percent.

;T;0;;;I"
print;F;I"IO;T;[o;;I"*untyped arg0;T;I"NilClass;To;;I"}Formats and writes to *ios*, converting parameters under control of the format
string. See Kernel#sprintf for details.

;T;0;;;I"printf;F;I"IO;T;[o;;I"*::String format_string, *untyped arg0;T;I"NilClass;To;;I"ûIf *obj* is Numeric, write the character whose code is the least-significant
byte of *obj*.  If *obj* is String, write the first character of *obj* to
*ios*.  Otherwise, raise TypeError.

    $stdout.putc "A"
    $stdout.putc 65

*produces:*

    AA

;T;0;;;I"	putc;F;I"IO;T;[o;;I"::Numeric | ::String arg0;T;I"untyped;To;;I"BWrites the given object(s) to *ios*. Writes a newline after any that do not
already end with a newline sequence. Returns `nil`.

The stream must be opened for writing. If called with an array argument,
writes each element on a new line. Each given object that isn't a string or
array will be converted by calling its `to_s` method. If called without
arguments, outputs a single newline.

    $stdout.puts("this", "is", ["a", "test"])

*produces:*

    this
    is
    a
    test

Note that `puts` always uses newlines and is not affected by the output record
separator (`$\`).

;T;0;;;I"	puts;F;I"IO;T;[o;;I"*untyped arg0;T;I"NilClass;To;;I"¬Reads bytes from the stream (in binary mode):

*   If `maxlen` is `nil`, reads all bytes.
*   Otherwise reads `maxlen` bytes, if available.
*   Otherwise reads all bytes.


Returns a string (either a new string or the given `out_string`) containing
the bytes read. The encoding of the string depends on both `maxLen` and
`out_string`:

*   `maxlen` is `nil`: uses internal encoding of `self` (regardless of whether
    `out_string` was given).
*   `maxlen` not `nil`:

    *   `out_string` given: encoding of `out_string` not modified.
    *   `out_string` not given: ASCII-8BIT is used.



**Without Argument `out_string`**

When argument `out_string` is omitted, the returned value is a new string:

    f = File.new('t.txt')
    f.read
    # => "This is line one.\nThis is the second line.\nThis is the third line.\n"
    f.rewind
    f.read(40)      # => "This is line one.\r\nThis is the second li"
    f.read(40)      # => "ne.\r\nThis is the third line.\r\n"
    f.read(40)      # => nil

If `maxlen` is zero, returns an empty string.

** With Argument `out_string`**

When argument `out_string` is given, the returned value is `out_string`, whose
content is replaced:

    f = File.new('t.txt')
    s = 'foo'      # => "foo"
    f.read(nil, s) # => "This is line one.\nThis is the second line.\nThis is the third line.\n"
    s              # => "This is line one.\nThis is the second line.\nThis is the third line.\n"
    f.rewind
    s = 'bar'
    f.read(40, s)  # => "This is line one.\r\nThis is the second li"
    s              # => "This is line one.\r\nThis is the second li"
    s = 'baz'
    f.read(40, s)  # => "ne.\r\nThis is the third line.\r\n"
    s              # => "ne.\r\nThis is the third line.\r\n"
    s = 'bat'
    f.read(40, s)  # => nil
    s              # => ""

Note that this method behaves like the fread() function in C. This means it
retries to invoke read(2) system calls to read data with the specified maxlen
(or until EOF).

This behavior is preserved even if the stream is in non-blocking mode. (This
method is non-blocking-flag insensitive as other methods.)

If you need the behavior like a single read(2) system call, consider
#readpartial, #read_nonblock, and #sysread.

;T;0;;;I"	read;F;I"IO;T;[o;;I"%?::int? length, ?::string outbuf;T;I"String?;To;;I"ÇReads at most *maxlen* bytes from *ios* using the read(2) system call after
O_NONBLOCK is set for the underlying file descriptor.

If the optional *outbuf* argument is present, it must reference a String,
which will receive the data. The *outbuf* will contain only the received data
after the method call even if it is not empty at the beginning.

read_nonblock just calls the read(2) system call. It causes all errors the
read(2) system call causes: Errno::EWOULDBLOCK, Errno::EINTR, etc. The caller
should care such errors.

If the exception is Errno::EWOULDBLOCK or Errno::EAGAIN, it is extended by
IO::WaitReadable. So IO::WaitReadable can be used to rescue the exceptions for
retrying read_nonblock.

read_nonblock causes EOFError on EOF.

On some platforms, such as Windows, non-blocking mode is not supported on IO
objects other than sockets. In such cases, Errno::EBADF will be raised.

If the read byte buffer is not empty, read_nonblock reads from the buffer like
readpartial. In this case, the read(2) system call is not called.

When read_nonblock raises an exception kind of IO::WaitReadable, read_nonblock
should not be called until io is readable for avoiding busy loop. This can be
done as follows.

    # emulates blocking read (readpartial).
    begin
      result = io.read_nonblock(maxlen)
    rescue IO::WaitReadable
      IO.select([io])
      retry
    end

Although IO#read_nonblock doesn't raise IO::WaitWritable.
OpenSSL::Buffering#read_nonblock can raise IO::WaitWritable. If IO and SSL
should be used polymorphically, IO::WaitWritable should be rescued too. See
the document of OpenSSL::Buffering#read_nonblock for sample code.

Note that this method is identical to readpartial except the non-blocking flag
is set.

By specifying a keyword argument *exception* to `false`, you can indicate that
read_nonblock should not raise an IO::WaitReadable exception, but return the
symbol `:wait_readable` instead. At EOF, it will return nil instead of raising
EOFError.

;T;0;;;I"read_nonblock;F;I"IO;T;[o;;I"/::int len, ?::string buf, ?exception: true;T;I"String;To;;I"/::int len, ?::string buf, exception: false;T;I""String | :wait_readable | nil;To;;I"NReads a byte as with IO#getbyte, but raises an EOFError on end of file.

;T;0;;;I"readbyte;F;I"IO;T;[o;;I" ;F;I"Integer;To;;I"Reads a one-character string from *ios*. Raises an EOFError on end of file.

    f = File.new("testfile")
    f.readchar   #=> "h"
    f.readchar   #=> "e"

;T;0;;;I"readchar;F;I"IO;T;[o;;I" ;F;I"String;To;;I"KReads a line as with IO#gets, but raises an EOFError on end of file.

;T;0;;;I"readline;F;I"IO;T;[o;;I"$?::String sep, ?::Integer limit;T;I"String;To;;I"dReads all of the lines in *ios*, and returns them in an array. Lines are
separated by the optional *sep*. If *sep* is `nil`, the rest of the stream is
returned as a single record. If the first argument is an integer, or an
optional second argument is given, the returning string would not be longer
than the given value in bytes. The stream must be opened for reading or an
IOError will be raised.

    f = File.new("testfile")
    f.readlines[0]   #=> "This is line one\n"

    f = File.new("testfile", chomp: true)
    f.readlines[0]   #=> "This is line one"

See IO.readlines for details about getline_args.

;T;0;;;I"readlines;F;I"IO;T;[o;;I"$?::String sep, ?::Integer limit;T;I"Array[::String];To;;I")Reads up to `maxlen` bytes from the stream; returns a string (either a new
string or the given `out_string`). Its encoding is:

*   The unchanged encoding of `out_string`, if `out_string` is given.
*   ASCII-8BIT, otherwise.

*   Contains `maxlen` bytes from the stream, if available.
*   Otherwise contains all available bytes, if any available.
*   Otherwise is an empty string.


With the single non-negative integer argument `maxlen` given, returns a new
string:

    f = File.new('t.txt')
    f.readpartial(30) # => "This is line one.\nThis is the"
    f.readpartial(30) # => " second line.\nThis is the thi"
    f.readpartial(30) # => "rd line.\n"
    f.eof             # => true
    f.readpartial(30) # Raises EOFError.

With both argument `maxlen` and string argument `out_string` given, returns
modified `out_string`:

    f = File.new('t.txt')
    s = 'foo'
    f.readpartial(30, s) # => "This is line one.\nThis is the"
    s = 'bar'
    f.readpartial(0, s)  # => ""

This method is useful for a stream such as a pipe, a socket, or a tty. It
blocks only when no data is immediately available. This means that it blocks
only when *all* of the following are true:

*   The byte buffer in the stream is empty.
*   The content of the stream is empty.
*   The stream is not at EOF.


When blocked, the method waits for either more data or EOF on the stream:

*   If more data is read, the method returns the data.
*   If EOF is reached, the method raises EOFError.


When not blocked, the method responds immediately:

*   Returns data from the buffer if there is any.
*   Otherwise returns data from the stream if there is any.
*   Otherwise raises EOFError if the stream has reached EOF.


Note that this method is similar to sysread. The differences are:

*   If the byte buffer is not empty, read from the byte buffer instead of
    "sysread for buffered IO (IOError)".
*   It doesn't cause Errno::EWOULDBLOCK and Errno::EINTR.  When readpartial
    meets EWOULDBLOCK and EINTR by read system call, readpartial retries the
    system call.


The latter means that readpartial is non-blocking-flag insensitive. It blocks
on the situation IO#sysread causes Errno::EWOULDBLOCK as if the fd is blocking
mode.

Examples:

    #                        # Returned      Buffer Content    Pipe Content
    r, w = IO.pipe           #
    w << 'abc'               #               ""                "abc".
    r.readpartial(4096)      # => "abc"      ""                ""
    r.readpartial(4096)      # (Blocks because buffer and pipe are empty.)

    #                        # Returned      Buffer Content    Pipe Content
    r, w = IO.pipe           #
    w << 'abc'               #               ""                "abc"
    w.close                  #               ""                "abc" EOF
    r.readpartial(4096)      # => "abc"      ""                 EOF
    r.readpartial(4096)      # raises EOFError

    #                        # Returned      Buffer Content    Pipe Content
    r, w = IO.pipe           #
    w << "abc\ndef\n"        #               ""                "abc\ndef\n"
    r.gets                   # => "abc\n"    "def\n"           ""
    w << "ghi\n"             #               "def\n"           "ghi\n"
    r.readpartial(4096)      # => "def\n"    ""                "ghi\n"
    r.readpartial(4096)      # => "ghi\n"    ""                ""

;T;0;;;I"readpartial;F;I"IO;T;[o;;I"#::int maxlen, ?::string outbuf;T;I"String;To;;I"§Reassociates *ios* with the I/O stream given in *other_IO* or to a new stream
opened on *path*. This may dynamically change the actual class of this stream.
The `mode` and `opt` parameters accept the same values as IO.open.

    f1 = File.new("testfile")
    f2 = File.new("testfile")
    f2.readlines[0]   #=> "This is line one\n"
    f2.reopen(f1)     #=> #<File:testfile>
    f2.readlines[0]   #=> "This is line one\n"

;T;0;;;I"reopen;F;I"IO;T;[o;;I"::IO other_IO_or_path;T;I"IO;To;;I"2::String other_IO_or_path, ?::String mode_str;T;I"IO;To;;I"ðRepositions the stream to its beginning, setting both the position and the
line number to zero; see [Position](#class-IO-label-Position) and [Line
Number](#class-IO-label-Line+Number):

    f = File.open('t.txt')
    f.tell     # => 0
    f.lineno   # => 0
    f.readline # => "This is line one.\n"
    f.tell     # => 19
    f.lineno   # => 1
    f.rewind   # => 0
    f.tell     # => 0
    f.lineno   # => 0

Note that this method cannot be used with streams such as pipes, ttys, and
sockets.

;T;0;;;I"rewind;F;I"IO;T;[o;;I" ;F;I"Integer;To;;I"hSeeks to the position given by integer `offset` (see
[Position](#class-IO-label-Position)) and constant `whence`, which is one of:

*   `:CUR` or `IO::SEEK_CUR`: Repositions the stream to its current position
    plus the given `offset`:

        f = File.open('t.txt')
        f.tell            # => 0
        f.seek(20, :CUR)  # => 0
        f.tell            # => 20
        f.seek(-10, :CUR) # => 0
        f.tell            # => 10

*   `:END` or `IO::SEEK_END`: Repositions the stream to its end plus the given
    `offset`:

        f = File.open('t.txt')
        f.tell            # => 0
        f.seek(0, :END)   # => 0  # Repositions to stream end.
        f.tell            # => 70
        f.seek(-20, :END) # => 0
        f.tell            # => 50
        f.seek(-40, :END) # => 0
        f.tell            # => 30

*   `:SET` or `IO:SEEK_SET`: Repositions the stream to the given `offset`:

        f = File.open('t.txt')
        f.tell            # => 0
        f.seek(20, :SET) # => 0
        f.tell           # => 20
        f.seek(40, :SET) # => 0
        f.tell           # => 40


Related: IO#pos=, IO#tell.

;T;0;;;I"	seek;F;I"IO;T;[o;;I"(::Integer amount, ?::Integer whence;T;I"Integer;To;;I"4If single argument is specified, read string from io is tagged with the
encoding specified.  If encoding is a colon separated two encoding names
"A:B", the read string is converted from encoding A (external encoding) to
encoding B (internal encoding), then tagged with B.  If two arguments are
specified, those must be encoding objects or encoding names, and the first one
is the external encoding, and the second one is the internal encoding. If the
external encoding and the internal encoding is specified, optional hash
argument specify the conversion option.

;T;0;;;I"set_encoding;F;I"IO;T;[o;;I".?::String | ::Encoding ext_or_ext_int_enc;T;I"	self;To;;I"N?::String | ::Encoding ext_or_ext_int_enc, ?::String | ::Encoding int_enc;T;I"	self;To;;I"ÜChecks if `ios` starts with a BOM, and then consumes it and sets the external
encoding.  Returns the result encoding if found, or nil.  If `ios` is not
binmode or its encoding has been set already, an exception will be raised.

    File.write("bom.txt", "\u{FEFF}abc")
    ios = File.open("bom.txt", "rb")
    ios.set_encoding_by_bom    #=>  #<Encoding:UTF-8>

    File.write("nobom.txt", "abc")
    ios = File.open("nobom.txt", "rb")
    ios.set_encoding_by_bom    #=>  nil

;T;0;;;I"set_encoding_by_bom;F;I"IO;T;[o;;I" ;F;I"Encoding?;To;;I"çReturns status information for *ios* as an object of type File::Stat.

    f = File.new("testfile")
    s = f.stat
    "%o" % s.mode   #=> "100644"
    s.blksize       #=> 4096
    s.atime         #=> Wed Apr 09 08:53:54 CDT 2003

;T;0;;;I"	stat;F;I"IO;T;[o;;I" ;F;I"File::Stat;To;;I""Returns the current sync mode of the stream. When sync mode is true, all
output is immediately flushed to the underlying operating system and is not
buffered by Ruby internally. See also #fsync.

    f = File.open('t.tmp', 'w')
    f.sync # => false
    f.sync = true
    f.sync # => true

;T;0;;;I"	sync;F;I"IO;T;[o;;I" ;F;I"	bool;To;;I"’Sets the *sync* *mode* for the stream to the given value; returns the given
value.

Values for the sync mode:

*   `true`: All output is immediately flushed to the underlying operating
    system and is not buffered internally.
*   `false`: Output may be buffered internally.


Example;

    f = File.open('t.tmp', 'w')
    f.sync # => false
    f.sync = true
    f.sync # => true

Related: IO#fsync.

;T;0;;;I"
sync=;F;I"IO;T;[o;;I"::boolish;T;I"untyped;To;;I"Reads *maxlen* bytes from *ios* using a low-level read and returns them as a
string.  Do not mix with other methods that read from *ios* or you may get
unpredictable results.

If the optional *outbuf* argument is present, it must reference a String,
which will receive the data. The *outbuf* will contain only the received data
after the method call even if it is not empty at the beginning.

Raises SystemCallError on error and EOFError at end of file.

    f = File.new("testfile")
    f.sysread(16)   #=> "This is line one"

;T;0;;;I"sysread;F;I"IO;T;[o;;I"&::Integer maxlen, ::String outbuf;T;I"String;To;;I"Seeks to a given *offset* in the stream according to the value of *whence*
(see IO#seek for values of *whence*). Returns the new offset into the file.

    f = File.new("testfile")
    f.sysseek(-13, IO::SEEK_END)   #=> 53
    f.sysread(10)                  #=> "And so on."

;T;0;;;I"sysseek;F;I"IO;T;[o;;I"(::Integer amount, ?::Integer whence;T;I"Integer;To;;I"Writes the given string to *ios* using a low-level write. Returns the number
of bytes written. Do not mix with other methods that write to *ios* or you may
get unpredictable results. Raises SystemCallError on error.

    f = File.new("out", "w")
    f.syswrite("ABCDEF")   #=> 6

;T;0;;;I"syswrite;F;I"IO;T;[o;;I"::_ToS arg0;T;I"Integer;To;;I"Returns the current position (in bytes) in `self` (see
[Position](#class-IO-label-Position)):

    f = File.new('t.txt')
    f.tell     # => 0
    f.readline # => "This is line one.\n"
    f.tell     # => 19

Related: IO#pos=, IO#seek.

IO#pos is an alias for IO#tell.

;T;0;;;I"	tell;F;I"IO;T;[o;;I" ;F;I"Integer;To;;I"Returns `self`.

;T;0;;;I"
to_io;F;I"IO;T;[o;;I" ;F;I"	self;To;;I"°Returns `true` if *ios* is associated with a terminal device (tty), `false`
otherwise.

    File.new("testfile").isatty   #=> false
    File.new("/dev/tty").isatty   #=> true

;T;0;;;I"	tty?;F;I"IO;T;[o;;I" ;F;I"	bool;To;;I"\Pushes back bytes (passed as a parameter) onto *ios*, such that a subsequent
buffered read will return it. It is only guaranteed to support a single byte,
and only if ungetbyte or ungetc has not already been called on *ios* since the
previous read of at least a single byte from *ios*. However, it can support
additional bytes if there is space in the internal buffer to allow for it.

    f = File.new("testfile")   #=> #<File:testfile>
    b = f.getbyte              #=> 0x38
    f.ungetbyte(b)             #=> nil
    f.getbyte                  #=> 0x38

If given an integer, only uses the lower 8 bits of the integer as the byte to
push.

    f = File.new("testfile")   #=> #<File:testfile>
    f.ungetbyte(0x102)         #=> nil
    f.getbyte                  #=> 0x2

Calling this method prepends to the existing buffer, even if the method has
already been called previously:

    f = File.new("testfile")   #=> #<File:testfile>
    f.ungetbyte("ab")          #=> nil
    f.ungetbyte("cd")          #=> nil
    f.read(5)                  #=> "cdab8"

Has no effect with unbuffered reads (such as IO#sysread).

;T;0;;;I"ungetbyte;F;I"IO;T;[o;;I"::String | ::Integer arg0;T;I"NilClass;To;;I"íPushes back characters (passed as a parameter) onto *ios*, such that a
subsequent buffered read will return it. It is only guaranteed to support a
single byte, and only if ungetbyte or ungetc has not already been called on
*ios* since the previous read of at least a single byte from *ios*. However,
it can support additional bytes if there is space in the internal buffer to
allow for it.

    f = File.new("testfile")   #=> #<File:testfile>
    c = f.getc                 #=> "8"
    f.ungetc(c)                #=> nil
    f.getc                     #=> "8"

If given an integer, the integer must represent a valid codepoint in the
external encoding of *ios*.

Calling this method prepends to the existing buffer, even if the method has
already been called previously:

    f = File.new("testfile")   #=> #<File:testfile>
    f.ungetc("ab")             #=> nil
    f.ungetc("cd")             #=> nil
    f.read(5)                  #=> "cdab8"

Has no effect with unbuffered reads (such as IO#sysread).

;T;0;;;I"ungetc;F;I"IO;T;[o;;I"::String arg0;T;I"NilClass;To;;I"Writes each of the given `objects` to `self`, which must be opened for writing
(see [Modes](#class-IO-label-Modes)); returns the total number bytes written;
each of `objects` that is not a string is converted via method `to_s`:

    $stdout.write('Hello', ', ', 'World!', "\n") # => 14
    $stdout.write('foo', :bar, 2, "\n")          # => 8

Output:

    Hello, World!
    foobar2

;T;0;;;I"
write;F;I"IO;T;[o;;I"*::_ToS string;T;I"Integer;To;;I"BWrites the given string to *ios* using the write(2) system call after
O_NONBLOCK is set for the underlying file descriptor.

It returns the number of bytes written.

write_nonblock just calls the write(2) system call. It causes all errors the
write(2) system call causes: Errno::EWOULDBLOCK, Errno::EINTR, etc. The result
may also be smaller than string.length (partial write). The caller should care
such errors and partial write.

If the exception is Errno::EWOULDBLOCK or Errno::EAGAIN, it is extended by
IO::WaitWritable. So IO::WaitWritable can be used to rescue the exceptions for
retrying write_nonblock.

    # Creates a pipe.
    r, w = IO.pipe

    # write_nonblock writes only 65536 bytes and return 65536.
    # (The pipe size is 65536 bytes on this environment.)
    s = "a" * 100000
    p w.write_nonblock(s)     #=> 65536

    # write_nonblock cannot write a byte and raise EWOULDBLOCK (EAGAIN).
    p w.write_nonblock("b")   # Resource temporarily unavailable (Errno::EAGAIN)

If the write buffer is not empty, it is flushed at first.

When write_nonblock raises an exception kind of IO::WaitWritable,
write_nonblock should not be called until io is writable for avoiding busy
loop. This can be done as follows.

    begin
      result = io.write_nonblock(string)
    rescue IO::WaitWritable, Errno::EINTR
      IO.select(nil, [io])
      retry
    end

Note that this doesn't guarantee to write all data in string. The length
written is reported as result and it should be checked later.

On some platforms such as Windows, write_nonblock is not supported according
to the kind of the IO object. In such cases, write_nonblock raises
`Errno::EBADF`.

By specifying a keyword argument *exception* to `false`, you can indicate that
write_nonblock should not raise an IO::WaitWritable exception, but return the
symbol `:wait_writable` instead.

;T;0;;;I"write_nonblock;F;I"IO;T;[o;;I"::_ToS s, ?exception: true;T;I"Integer;To;;I"::_ToS s, exception: false;T;I"#Integer | :wait_writable | nil;To;;I"zOpens the file, optionally seeks to the given *offset*, then returns *length*
bytes (defaulting to the rest of the file). #binread ensures the file is
closed before returning.  The open mode would be `"rb:ASCII-8BIT"`.

If `name` starts with a pipe character (`"|"`) and the receiver is the IO
class, a subprocess is created in the same way as Kernel#open, and its output
is returned. Consider to use File.binread to disable the behavior of
subprocess invocation.

    File.binread("testfile")           #=> "This is line one\nThis is line two\nThis is line three\nAnd so on...\n"
    File.binread("testfile", 20)       #=> "This is line one\nThi"
    File.binread("testfile", 20, 10)   #=> "ne one\nThis is line "
    IO.binread("| cat testfile")       #=> "This is line one\nThis is line two\nThis is line three\nAnd so on...\n"

See also IO.read for details about `name` and open_args.

;T;0;;;I"binread;F;I"IO;T;[o;;I"8::String name, ?::Integer length, ?::Integer offset;T;I"String;To;;I"–Same as IO.write except opening the file in binary mode and ASCII-8BIT
encoding (`"wb:ASCII-8BIT"`).

If `name` starts with a pipe character (`"|"`) and the receiver is the IO
class, a subprocess is created in the same way as Kernel#open, and its output
is returned. Consider to use File.binwrite to disable the behavior of
subprocess invocation.

See also IO.read for details about `name` and open_args.

;T;0;;;I"binwrite;F;I"IO;T;[o;;I"J::String name, ::_ToS string, ?::Integer offset, ?mode: ::String mode;T;I"Integer;To;;I" IO.copy_stream copies *src* to *dst*. *src* and *dst* is either a filename or
an IO-like object. IO-like object for *src* should have #readpartial or #read
method.  IO-like object for *dst* should have #write method. (Specialized
mechanisms, such as sendfile system call, may be used on appropriate
situation.)

This method returns the number of bytes copied.

If optional arguments are not given, the start position of the copy is the
beginning of the filename or the current file offset of the IO. The end
position of the copy is the end of file.

If *copy_length* is given, No more than *copy_length* bytes are copied.

If *src_offset* is given, it specifies the start position of the copy.

When *src_offset* is specified and *src* is an IO, IO.copy_stream doesn't move
the current file offset.

;T;0;;;I"copy_stream;F;I"IO;T;[o;;I"y::String | ::_Reader | ::_ReaderPartial src, ::String | ::_Writer dst, ?::Integer copy_length, ?::Integer src_offset;T;I"Integer;To;;I"BRuns the specified command as a subprocess; the subprocess's standard input
and output will be connected to the returned IO object.

The PID of the started process can be obtained by IO#pid method.

*cmd* is a string or an array as follows.

    cmd:
      "-"                                      : fork
      commandline                              : command line string which is passed to a shell
      [env, cmdname, arg1, ..., opts]          : command name and zero or more arguments (no shell)
      [env, [cmdname, argv0], arg1, ..., opts] : command name, argv[0] and zero or more arguments (no shell)
    (env and opts are optional.)

If *cmd* is a `String` ```-`'', then a new instance of Ruby is started as the
subprocess.

If *cmd* is an `Array` of `String`, then it will be used as the subprocess's
`argv` bypassing a shell. The array can contain a hash at first for
environments and a hash at last for options similar to #spawn.

The default mode for the new file object is ``r'', but *mode* may be set to
any of the modes listed in the description for class IO. The last argument
*opt* qualifies *mode*.

    # set IO encoding
    IO.popen("nkf -e filename", :external_encoding=>"EUC-JP") {|nkf_io|
      euc_jp_string = nkf_io.read
    }

    # merge standard output and standard error using
    # spawn option.  See the document of Kernel.spawn.
    IO.popen(["ls", "/", :err=>[:child, :out]]) {|ls_io|
      ls_result_with_error = ls_io.read
    }

    # spawn options can be mixed with IO options
    IO.popen(["ls", "/"], :err=>[:child, :out]) {|ls_io|
      ls_result_with_error = ls_io.read
    }

Raises exceptions which IO.pipe and Kernel.spawn raise.

If a block is given, Ruby will run the command as a child connected to Ruby
with a pipe. Ruby's end of the pipe will be passed as a parameter to the
block. At the end of block, Ruby closes the pipe and sets `$?`. In this case
IO.popen returns the value of the block.

If a block is given with a *cmd* of ```-`'', the block will be run in two
separate processes: once in the parent, and once in a child. The parent
process will be passed the pipe object as a parameter to the block, the child
version of the block will be passed `nil`, and the child's standard in and
standard out will be connected to the parent through the pipe. Not available
on all platforms.

    f = IO.popen("uname")
    p f.readlines
    f.close
    puts "Parent is #{Process.pid}"
    IO.popen("date") {|f| puts f.gets }
    IO.popen("-") {|f| $stderr.puts "#{Process.pid} is here, f is #{f.inspect}"}
    p $?
    IO.popen(%w"sed -e s|^|<foo>| -e s&$&;zot;&", "r+") {|f|
      f.puts "bar"; f.close_write; puts f.gets
    }

*produces:*

    ["Linux\n"]
    Parent is 21346
    Thu Jan 15 22:41:19 JST 2009
    21346 is here, f is #<IO:fd 3>
    21352 is here, f is nil
    #<Process::Status: pid 21352 exit 0>
    <foo>bar;zot;

;T;0;;;I"
popen;F;I"IO;T;[o;;I"*untyped args;T;I"untyped;To;;I"cOpens the file, optionally seeks to the given `offset`, then returns `length`
bytes (defaulting to the rest of the file).  #read ensures the file is closed
before returning.

If `name` starts with a pipe character (`"|"`) and the receiver is the IO
class, a subprocess is created in the same way as Kernel#open, and its output
is returned. Consider to use File.read to disable the behavior of subprocess
invocation.

### Options

The options hash accepts the following keys:

:encoding
:   string or encoding

    Specifies the encoding of the read string.  `:encoding` will be ignored if
    `length` is specified.  See Encoding.aliases for possible encodings.

:mode
:   string or integer

    Specifies the *mode* argument for open().  It must start with an "r",
    otherwise it will cause an error. See IO.new for the list of possible
    modes.

:open_args
:   array

    Specifies arguments for open() as an array.  This key can not be used in
    combination with either `:encoding` or `:mode`.


Examples:

    File.read("testfile")            #=> "This is line one\nThis is line two\nThis is line three\nAnd so on...\n"
    File.read("testfile", 20)        #=> "This is line one\nThi"
    File.read("testfile", 20, 10)    #=> "ne one\nThis is line "
    File.read("binfile", mode: "rb") #=> "\xF7\x00\x00\x0E\x12"
    IO.read("|ls -a")                #=> ".\n..\n"...

;T;0;;;I"	read;F;I"IO;T;[o;;I"::String name, ?::Integer length, ?::Integer offset, ?external_encoding: ::String external_encoding, ?internal_encoding: ::String internal_encoding, ?encoding: ::String encoding, ?textmode: untyped textmode, ?binmode: untyped binmode, ?autoclose: untyped autoclose, ?mode: ::String mode;T;I"String;To;;I"£Reads the entire file specified by *name* as individual lines, and returns
those lines in an array. Lines are separated by *sep*.

If `name` starts with a pipe character (`"|"`) and the receiver is the IO
class, a subprocess is created in the same way as Kernel#open, and its output
is returned. Consider to use File.readlines to disable the behavior of
subprocess invocation.

    a = File.readlines("testfile")
    a[0]   #=> "This is line one\n"

    b = File.readlines("testfile", chomp: true)
    b[0]   #=> "This is line one"

    IO.readlines("|ls -a")     #=> [".\n", "..\n", ...]

If the last argument is a hash, it's the keyword argument to open.

### Options for getline

The options hash accepts the following keys:

:chomp
:   When the optional `chomp` keyword argument has a true value, `\n`, `\r`,
    and `\r\n` will be removed from the end of each line.


See also IO.read for details about `name` and open_args.

;T;0;;;I"readlines;F;I"IO;T;[o;;I",::String name, ?::String sep, ?::Integer limit, ?external_encoding: ::String external_encoding, ?internal_encoding: ::String internal_encoding, ?encoding: ::String encoding, ?textmode: untyped textmode, ?binmode: untyped binmode, ?autoclose: untyped autoclose, ?mode: ::String mode, ?chomp: ::boolish;T;I"Array[::String];To;;I"áCalls select(2) system call. It monitors given arrays of IO objects, waits
until one or more of IO objects are ready for reading, are ready for writing,
and have pending exceptions respectively, and returns an array that contains
arrays of those IO objects.  It will return `nil` if optional *timeout* value
is given and no IO object is ready in *timeout* seconds.

IO.select peeks the buffer of IO objects for testing readability. If the IO
buffer is not empty, IO.select immediately notifies readability.  This "peek"
only happens for IO objects.  It does not happen for IO-like objects such as
OpenSSL::SSL::SSLSocket.

The best way to use IO.select is invoking it after nonblocking methods such as
#read_nonblock, #write_nonblock, etc.  The methods raise an exception which is
extended by IO::WaitReadable or IO::WaitWritable.  The modules notify how the
caller should wait with IO.select.  If IO::WaitReadable is raised, the caller
should wait for reading.  If IO::WaitWritable is raised, the caller should
wait for writing.

So, blocking read (#readpartial) can be emulated using #read_nonblock and
IO.select as follows:

    begin
      result = io_like.read_nonblock(maxlen)
    rescue IO::WaitReadable
      IO.select([io_like])
      retry
    rescue IO::WaitWritable
      IO.select(nil, [io_like])
      retry
    end

Especially, the combination of nonblocking methods and IO.select is preferred
for IO like objects such as OpenSSL::SSL::SSLSocket.  It has #to_io method to
return underlying IO object.  IO.select calls #to_io to obtain the file
descriptor to wait.

This means that readability notified by IO.select doesn't mean readability
from OpenSSL::SSL::SSLSocket object.

The most likely situation is that OpenSSL::SSL::SSLSocket buffers some data.
IO.select doesn't see the buffer.  So IO.select can block when
OpenSSL::SSL::SSLSocket#readpartial doesn't block.

However, several more complicated situations exist.

SSL is a protocol which is sequence of records. The record consists of
multiple bytes. So, the remote side of SSL sends a partial record, IO.select
notifies readability but OpenSSL::SSL::SSLSocket cannot decrypt a byte and
OpenSSL::SSL::SSLSocket#readpartial will block.

Also, the remote side can request SSL renegotiation which forces the local SSL
engine to write some data. This means OpenSSL::SSL::SSLSocket#readpartial may
invoke #write system call and it can block. In such a situation,
OpenSSL::SSL::SSLSocket#read_nonblock raises IO::WaitWritable instead of
blocking. So, the caller should wait for ready for writability as above
example.

The combination of nonblocking methods and IO.select is also useful for
streams such as tty, pipe socket socket when multiple processes read from a
stream.

Finally, Linux kernel developers don't guarantee that readability of select(2)
means readability of following read(2) even for a single process. See
select(2) manual on GNU/Linux system.

Invoking IO.select before IO#readpartial works well as usual. However it is
not the best way to use IO.select.

The writability notified by select(2) doesn't show how many bytes are
writable. IO#write method blocks until given whole string is written. So,
`IO#write(two or more bytes)` can block after writability is notified by
IO.select.  IO#write_nonblock is required to avoid the blocking.

Blocking write (#write) can be emulated using #write_nonblock and IO.select as
follows: IO::WaitReadable should also be rescued for SSL renegotiation in
OpenSSL::SSL::SSLSocket.

    while 0 < string.bytesize
      begin
        written = io_like.write_nonblock(string)
      rescue IO::WaitReadable
        IO.select([io_like])
        retry
      rescue IO::WaitWritable
        IO.select(nil, [io_like])
        retry
      end
      string = string.byteslice(written..-1)
    end

### Parameters
read_array
:   an array of IO objects that wait until ready for read
write_array
:   an array of IO objects that wait until ready for write
error_array
:   an array of IO objects that wait for exceptions
timeout
:   a numeric value in second


### Example

    rp, wp = IO.pipe
    mesg = "ping "
    100.times {
      # IO.select follows IO#read.  Not the best way to use IO.select.
      rs, ws, = IO.select([rp], [wp])
      if r = rs[0]
        ret = r.read(5)
        print ret
        case ret
        when /ping/
          mesg = "pong\n"
        when /pong/
          mesg = "ping "
        end
      end
      if w = ws[0]
        w.write(mesg)
      end
    }

*produces:*

    ping pong
    ping pong
    ping pong
    (snipped)
    ping

;T;0;;;I"select;F;I"IO;T;[o;;I"d::Array[X & ::io]? read_array, ?::Array[Y & ::io]? write_array, ?::Array[Z & ::io]? error_array;T;I"+[ ::Array[X], ::Array[Y], ::Array[Z] ];To;;I"x::Array[X & ::io]? read_array, ?::Array[Y & ::io]? write_array, ?::Array[Z & ::io]? error_array, ::Numeric? timeout;T;I",[ ::Array[X], ::Array[Y], ::Array[Z] ]?;To;;I"wOpens the given path, returning the underlying file descriptor as a Integer.

    IO.sysopen("testfile")   #=> 3

;T;0;;;I"sysopen;F;I"IO;T;[o;;I"2::String path, ?::String mode, ?::String perm;T;I"Integer;To;;I"	Attempts to convert `object` into an IO object via method `to_io`; returns the
new IO object if successful, or `nil` otherwise:

    IO.try_convert(STDOUT)   # => #<IO:<STDOUT>>
    IO.try_convert(ARGF)     # => #<IO:<STDIN>>
    IO.try_convert('STDOUT') # => nil

;T;0;;;I"try_convert;F;I"IO;T;[o;;I"untyped arg0;T;I"IO?;To;;I"Opens the file, optionally seeks to the given *offset*, writes *string*, then
returns the length written.  #write ensures the file is closed before
returning.  If *offset* is not given in write mode, the file is truncated.
Otherwise, it is not truncated.

If `name` starts with a pipe character (`"|"`) and the receiver is the IO
class, a subprocess is created in the same way as Kernel#open, and its output
is returned. Consider to use File.write to disable the behavior of subprocess
invocation.

    File.write("testfile", "0123456789", 20)  #=> 10
    # File could contain:  "This is line one\nThi0123456789two\nThis is line three\nAnd so on...\n"
    File.write("testfile", "0123456789")      #=> 10
    # File would now read: "0123456789"
    IO.write("|tr a-z A-Z", "abc")            #=> 3
    # Prints "ABC" to the standard output

If the last argument is a hash, it specifies options for the internal open().
It accepts the following keys:

:encoding
:   string or encoding

    Specifies the encoding of the read string. See Encoding.aliases for
    possible encodings.

:mode
:   string or integer

    Specifies the *mode* argument for open().  It must start with "w", "a", or
    "r+", otherwise it will cause an error. See IO.new for the list of
    possible modes.

:perm
:   integer

    Specifies the *perm* argument for open().

:open_args
:   array

    Specifies arguments for open() as an array. This key can not be used in
    combination with other keys.


See also IO.read for details about `name` and open_args.

;T;0;;;I"
write;F;I"IO;T;[o;;I"::String name, ::_ToS arg0, ?::Integer offset, ?external_encoding: ::String external_encoding, ?internal_encoding: ::String internal_encoding, ?encoding: ::String encoding, ?textmode: untyped textmode, ?binmode: untyped binmode, ?autoclose: untyped autoclose, ?mode: ::String mode;T;I"Integer;To;;I"Synonym for IO.new.

;T;0;;;I"for_fd;F;I"IO;T;[o;;I"4::int fd, ?::string | ::int mode, **untyped opt;T;I"instance;To;;I"UWith no associated block, IO.open is a synonym for IO.new.  If the optional
code block is given, it will be passed `io` as an argument, and the IO object
will automatically be closed when the block terminates. In this instance,
IO.open returns the value of the block.

See IO.new for a description of the `fd`, `mode` and `opt` parameters.

;T;0;;;I"	open;F;I"IO;T;[o;;I"4::int fd, ?::string | ::int mode, **untyped opt;T;I"A;Fo;;0;0;;;I"
bytes;F;I"IO;T;[o;;I" ;F;I"	self;To;;I" ;F;I" Enumerator[::Integer, self];To;;0;0;;;I"
chars;F;I"IO;T;[o;;I" ;F;I"	self;To;;I" ;F;I"Enumerator[::String, self];To;;0;0;;;I"codepoints;F;I"IO;T;[o;;I" ;F;I"	self;To;;I" ;F;I" Enumerator[::Integer, self];To;;I"·Executes the block for every line in *ios*, where lines are separated by
*sep*. *ios* must be opened for reading or an IOError will be raised.

If no block is given, an enumerator is returned instead.

    f = File.new("testfile")
    f.each {|line| puts "#{f.lineno}: #{line}" }

*produces:*

    1: This is line one
    2: This is line two
    3: This is line three
    4: And so on...

See IO.readlines for details about getline_args.

;T;0;;;I"each_line;F;I"IO;T;[o;;I"$?::String sep, ?::Integer limit;T;I"	self;To;;I"$?::String sep, ?::Integer limit;T;I"Enumerator[::String, self];To;;I"œReturns `true` if the stream is positioned at its end, `false` otherwise; see
[Position](#class-IO-label-Position):

    f = File.open('t.txt')
    f.eof           # => false
    f.seek(0, :END) # => 0
    f.eof           # => true

Raises an exception unless the stream is opened for reading; see
[Mode](#class-IO-label-Mode).

If `self` is a stream such as pipe or socket, this method blocks until the
other end sends some data or closes it:

    r, w = IO.pipe
    Thread.new { sleep 1; w.close }
    r.eof? # => true # After 1-second wait.

    r, w = IO.pipe
    Thread.new { sleep 1; w.puts "a" }
    r.eof?  # => false # After 1-second wait.

    r, w = IO.pipe
    r.eof?  # blocks forever

Note that this method reads data to the input byte buffer.  So IO#sysread may
not behave as you intend with IO#eof?, unless you call IO#rewind first (which
is not available for some streams).

I#eof? is an alias for IO#eof.

;T;0;;;I"	eof?;F;I"IO;T;[o;;I" ;F;I"	bool;To;;0;0;;;I"
lines;F;I"IO;T;[o;;I"$?::String sep, ?::Integer limit;T;I"	self;To;;I"$?::String sep, ?::Integer limit;T;I"Enumerator[::String, self];To;;I"ïReturns the integer file descriptor for the stream:

    $stdin.fileno             # => 0
    $stdout.fileno            # => 1
    $stderr.fileno            # => 2
    File.open('t.txt').fileno # => 10

IO#to_i is an alias for IO#fileno.

;T;0;;;I"	to_i;F;I"IO;T;[o;;I" ;F;I"Integer;To; ;0;0;	I"IO;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"åReturns an File instance opened console.

If `sym` is given, it will be sent to the opened console with `args` and the
result will be returned instead of the console IO itself.

You must require 'io/console' to use this method.

;T;0;;;I"console;F;I"IO;T;[o;;I" ;F;I"
File?;To;;I":close;T;I"nil;To;;I" ::Symbol sym, *untyped args;T;I"untyped;To;;I" ;T;0;;;I"console_size;F;I"IO;T;[o;;I" ;F;I"[ ::Integer, ::Integer ];To;;I"&fallback to console window size

;T;0;;;I"default_console_size;F;I"IO;T;[o;;I" ;F;I"[ ::Integer, ::Integer ];To;;I" ;T;0;;;I"	beep;F;I"IO;T;[o;;I" ;F;I"	self;To;;I" ;T;0;;;I"check_winsize_changed;F;I"IO;T;[o;;I" ;F;I"	self;To;;I" ;T;0;;;I"clear_screen;F;I"IO;T;[o;;I" ;F;I"	self;To;;I"mReturns a data represents the current console mode.

You must require 'io/console' to use this method.

;T;0;;;I"console_mode;F;I"IO;T;[o;;I" ;F;I"IO::ConsoleMode;To;;I"ZSets the console mode to `mode`.

You must require 'io/console' to use this method.

;T;0;;;I"console_mode=;F;I"IO;T;[o;;I"::IO::ConsoleMode mode;T;I"IO::ConsoleMode;To;;I"®Yields `self` within cooked mode.

    STDIN.cooked(&:gets)

will read and return a line with echo back and line editing.

You must require 'io/console' to use this method.

;T;0;;;I"cooked;F;I"IO;T;[o;;I" ;F;I"T;Fo;;I"ˆEnables cooked mode.

If the terminal mode needs to be back, use io.cooked { ... }.

You must require 'io/console' to use this method.

;T;0;;;I"cooked!;F;I"IO;T;[o;;I" ;F;I"	self;To;;I" ;T;0;;;I"cursor;F;I"IO;T;[o;;I" ;F;I"[ ::Integer, ::Integer ];To;;I" ;T;0;;;I"cursor=;F;I"IO;T;[o;;I"[ ::Integer, ::Integer ];T;I"[ ::Integer, ::Integer ];To;;I" ;T;0;;;I"cursor_down;F;I"IO;T;[o;;I"
::int;T;I"	self;To;;I" ;T;0;;;I"cursor_left;F;I"IO;T;[o;;I"
::int;T;I"	self;To;;I" ;T;0;;;I"cursor_right;F;I"IO;T;[o;;I"
::int;T;I"	self;To;;I" ;T;0;;;I"cursor_up;F;I"IO;T;[o;;I"
::int;T;I"	self;To;;I"¨Enables/disables echo back. On some platforms, all combinations of this flags
and raw/cooked mode may not be valid.

You must require 'io/console' to use this method.

;T;0;;;I"
echo=;F;I"IO;T;[o;;I"bool flag;T;I"	bool;To;;I"aReturns `true` if echo back is enabled.

You must require 'io/console' to use this method.

;T;0;;;I"
echo?;F;I"IO;T;[o;;I" ;F;I"	bool;To;;I" ;T;0;;;I"erase_line;F;I"IO;T;[o;;I"0 | 1 | 2 | nil;T;I"	self;To;;I" ;T;0;;;I"erase_screen;F;I"IO;T;[o;;I"0 | 1 | 2 | 3 | nil;T;I"	self;To;;I"ŠReads and returns a character in raw mode.

See IO#raw for details on the parameters.

You must require 'io/console' to use this method.

;T;0;;;I"
getch;F;I"IO;T;[o;;I"+?min: ::int, ?time: ::int, ?intr: bool;T;I"String;To;;I"ñReads and returns a line without echo back. Prints `prompt` unless it is
`nil`.

The newline character that terminates the read line is removed from the
returned string, see String#chomp!.

You must require 'io/console' to use this method.

;T;0;;;I"getpass;F;I"IO;T;[o;;I"?::String;T;I"String;To;;I" ;T;0;;;I"	goto;F;I"IO;T;[o;;I"::int, ::int;T;I"	self;To;;I" ;T;0;;;I"goto_column;F;I"IO;T;[o;;I"
::int;T;I"	self;To;;I"YFlushes input buffer in kernel.

You must require 'io/console' to use this method.

;T;0;;;I"iflush;F;I"IO;T;[o;;I" ;F;I"	self;To;;I"eFlushes input and output buffers in kernel.

You must require 'io/console' to use this method.

;T;0;;;I"ioflush;F;I"IO;T;[o;;I" ;F;I"	self;To;;I"¦Yields `self` with disabling echo back.

    STDIN.noecho(&:gets)

will read and return a line without echo back.

You must require 'io/console' to use this method.

;T;0;;;I"noecho;F;I"IO;T;[o;;I" ;F;I"T;Fo;;I"ZFlushes output buffer in kernel.

You must require 'io/console' to use this method.

;T;0;;;I"oflush;F;I"IO;T;[o;;I" ;F;I"	self;To;;I" ;T;0;;;I"pressed?;F;I"IO;T;[o;;I"$::Integer | ::Symbol | ::String;T;I"	bool;To;;I"^Yields `self` within raw mode, and returns the result of the block.

    STDIN.raw(&:gets)

will read and return a line without echo back and line editing.

The parameter `min` specifies the minimum number of bytes that should be
received when a read operation is performed. (default: 1)

The parameter `time` specifies the timeout in *seconds* with a precision of
1/10 of a second. (default: 0)

If the parameter `intr` is `true`, enables break, interrupt, quit, and suspend
special characters.

Refer to the manual page of termios for further details.

You must require 'io/console' to use this method.

;T;0;;;I"raw;F;I"IO;T;[o;;I"+?min: ::int, ?time: ::int, ?intr: bool;T;I"T;Fo;;I"ÁEnables raw mode, and returns `io`.

If the terminal mode needs to be back, use `io.raw { ... }`.

See IO#raw for details on the parameters.

You must require 'io/console' to use this method.

;T;0;;;I"	raw!;F;I"IO;T;[o;;I"+?min: ::int, ?time: ::int, ?intr: bool;T;I"	self;To;;I" ;T;0;;;I"scroll_backward;F;I"IO;T;[o;;I"
::int;T;I"	self;To;;I" ;T;0;;;I"scroll_forward;F;I"IO;T;[o;;I"
::int;T;I"	self;To;;I"OReturns console size.

You must require 'io/console' to use this method.

;T;0;;;I"winsize;F;I"IO;T;[o;;I" ;F;I"[ ::Integer, ::Integer ];To;;I"Tries to set console size.  The effect depends on the platform and the running
environment.

You must require 'io/console' to use this method.

;T;0;;;I"winsize=;F;I"IO;T;[o;;I"[ ::Integer, ::Integer ];T;I"[ ::Integer, ::Integer ];To;;I"3[ ::Integer, ::Integer, ::Integer, ::Integer ];T;I"3[ ::Integer, ::Integer, ::Integer, ::Integer ];To; ;I"m
IO::Buffer is a low-level efficient buffer for input/output. There are three
ways of using buffer:

*   Create an empty buffer with ::new, fill it with data using #copy or
    #set_value, #set_string, get data with #get_string;
*   Create a buffer mapped to some string with ::for, then it could be used
    both for reading with #get_string or #get_value, and writing (writing will
    change the source string, too);
*   Create a buffer mapped to some file with ::map, then it could be used for
    reading and writing the underlying file.


Interaction with string and file memory is performed by efficient low-level C
mechanisms like `memcpy`.

The class is meant to be an utility for implementing more high-level
mechanisms like Fiber::SchedulerInterface#io_read and
Fiber::SchedulerInterface#io_write.

**Examples of usage:**

Empty buffer:

    buffer = IO::Buffer.new(8)  # create empty 8-byte buffer
    #  =>
    # #<IO::Buffer 0x0000555f5d1a5c50+8 INTERNAL>
    # ...
    buffer
    #  =>
    # <IO::Buffer 0x0000555f5d156ab0+8 INTERNAL>
    # 0x00000000  00 00 00 00 00 00 00 00
    buffer.set_string('test', 2) # put there bytes of the "test" string, starting from offset 2
    # => 4
    buffer.get_string  # get the result
    # => "\x00\x00test\x00\x00"

Buffer from string:

    string = 'data'
    buffer = IO::Buffer.for(str)
    #  =>
    # #<IO::Buffer 0x00007f3f02be9b18+4 SLICE>
    # ...
    buffer
    #  =>
    # #<IO::Buffer 0x00007f3f02be9b18+4 SLICE>
    # 0x00000000  64 61 74 61                                     data

    buffer.get_string(2)  # read content starting from offset 2
    # => "ta"
    buffer.set_string('---', 1) # write content, starting from offset 1
    # => 3
    buffer
    #  =>
    # #<IO::Buffer 0x00007f3f02be9b18+4 SLICE>
    # 0x00000000  64 2d 2d 2d                                     d---
    string  # original string changed, too
    # => "d---"

Buffer from file:

    File.write('test.txt', 'test data')
    # => 9
    buffer = IO::Buffer.map(File.open('test.txt'))
    #  =>
    # #<IO::Buffer 0x00007f3f0768c000+9 MAPPED IMMUTABLE>
    # ...
    buffer.get_string(5, 2) # read 2 bytes, starting from offset 5
    # => "da"
    buffer.set_string('---', 1) # attempt to write
    # in `set_string': Buffer is not writable! (IO::Buffer::AccessError)

    # To create writable file-mapped buffer
    # Open file for read-write, pass size, offset, and flags=0
    buffer = IO::Buffer.map(File.open('test.txt', 'r+'), 9, 0, 0)
    buffer.set_string('---', 1)
    # => 3 -- bytes written
    File.read('test.txt')
    # => "t--- data"

**The class is experimental and the interface is subject to change.**

;T;0;	I"IO::Buffer;T;
[ ;[I"Comparable;T;0;[ ;[ ;0;0o;;I"ƒCreates a IO::Buffer from the given string's memory. The buffer remains
associated with the string, and writing to a buffer will update the string's
contents.

Until #free is invoked on the buffer, either explicitly or via the garbage
collector, the source string will be locked and cannot be modified.

If the string is frozen, it will create a read-only buffer which cannot be
modified.

    string = 'test'
    buffer = IO::Buffer.for(str)
    buffer.external? #=> true

    buffer.get_string(0, 1)
    # => "t"
    string
    # => "best"

    buffer.resize(100)
    # in `resize': Cannot resize external buffer! (IO::Buffer::AccessError)

;T;0;;;I"for;F;I"IO::Buffer;T;[o;;I"::String;T;I"IO::Buffer;To;;I"2Create an IO::Buffer for reading from `file` by memory-mapping the file.
`file_io` should be a `File` instance, opened for reading.

Optional `size` and `offset` of mapping can be specified.

By default, the buffer would be immutable (read only); to create a writable
mapping, you need to open a file in read-write mode, and explicitly pass
`flags` argument without IO::Buffer::IMMUTABLE.

    File.write('test.txt', 'test')

    buffer = IO::Buffer.map(File.open('test.txt'), nil, 0, IO::Buffer::READONLY)
    # => #<IO::Buffer 0x00000001014a0000+4 MAPPED READONLY>

    buffer.readonly?   # => true

    buffer.get_string
    # => "test"

    buffer.set_string('b', 0)
    # `set_string': Buffer is not writable! (IO::Buffer::AccessError)

    # create read/write mapping: length 4 bytes, offset 0, flags 0
    buffer = IO::Buffer.map(File.open('test.txt', 'r+'), 4, 0)
    buffer.set_string('b', 0)
    # => 1

    # Check it
    File.read('test.txt')
    # => "best"

Note that some operating systems may not have cache coherency between mapped
buffers and file reads.

;T;0;;;I"map;F;I"IO::Buffer;T;[o;;I"G::File file, ?::Integer? size, ?::Integer offset, ?::Integer flags;T;I"IO::Buffer;To;;I"iBuffers are compared by size and exact contents of the memory they are
referencing using `memcmp`.

;T;0;;;I"<=>;F;I"IO::Buffer;T;[o;;I"::IO::Buffer;T;I"Integer;To;;I"1Fill buffer with `value`, starting with `offset` and going for `length` bytes.

    buffer = IO::Buffer.for('test')
    # =>
    #   <IO::Buffer 0x00007fca40087c38+4 SLICE>
    #   0x00000000  74 65 73 74         test

    buffer.clear
    # =>
    #   <IO::Buffer 0x00007fca40087c38+4 SLICE>
    #   0x00000000  00 00 00 00         ....

    buf.clear(1) # fill with 1
    # =>
    #   <IO::Buffer 0x00007fca40087c38+4 SLICE>
    #   0x00000000  01 01 01 01         ....

    buffer.clear(2, 1, 2) # fill with 2, starting from offset 1, for 2 bytes
    # =>
    #   <IO::Buffer 0x00007fca40087c38+4 SLICE>
    #   0x00000000  01 02 02 01         ....

    buffer.clear(2, 1) # fill with 2, starting from offset 1
    # =>
    #   <IO::Buffer 0x00007fca40087c38+4 SLICE>
    #   0x00000000  01 02 02 02         ....

;T;0;;;I"
clear;F;I"IO::Buffer;T;[o;;I";?::Integer value, ?::Integer offset, ?::Integer length;T;I"	self;To;;I"‡Efficiently copy data from a source IO::Buffer into the buffer, at `offset`
using `memcpy`. For copying String instances, see #set_string.

    buffer = IO::Buffer.new(32)
    #  =>
    # #<IO::Buffer 0x0000555f5ca22520+32 INTERNAL>
    # 0x00000000  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
    # 0x00000010  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................  *

    buffer.copy(IO::Buffer.for("test"), 8)
    # => 4 -- size of data copied
    buffer
    #  =>
    # #<IO::Buffer 0x0000555f5cf8fe40+32 INTERNAL>
    # 0x00000000  00 00 00 00 00 00 00 00 74 65 73 74 00 00 00 00 ........test....
    # 0x00000010  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ *

#copy can be used to put data into strings associated with buffer:

    string= "data:    "
    # => "data:    "
    buffer = IO::Buffer.for(str)
    buffer.copy(IO::Buffer.for("test"), 5)
    # => 4
    string
    # => "data:test"

Attempt to copy into a read-only buffer will fail:

    File.write('test.txt', 'test')
    buffer = IO::Buffer.map(File.open('test.txt'), nil, 0, IO::Buffer::READONLY)
    buffer.copy(IO::Buffer.for("test"), 8)
    # in `copy': Buffer is not writable! (IO::Buffer::AccessError)

See ::map for details of creation of mutable file mappings, this will work:

    buffer = IO::Buffer.map(File.open('test.txt', 'r+'))
    buffer.copy("boom", 0)
    # => 4
    File.read('test.txt')
    # => "boom"

Attempt to copy the data which will need place outside of buffer's bounds will
fail:

    buffer = IO::Buffer.new(2)
    buffer.copy('test', 0)
    # in `copy': Specified offset+length exceeds source size! (ArgumentError)

;T;0;;;I"	copy;F;I"IO::Buffer;T;[o;;I"X::IO::Buffer source, ?::Integer offset, ?::Integer length, ?::Integer source_offset;T;I"Integer;To;;I"öIf the buffer is _external_, meaning it references from memory which is not
    allocated or mapped by the buffer itself.

    A buffer created using ::for has an external reference to the string's
    memory.

External buffer can't be resized.

;T;0;;;I"empty?;F;I"IO::Buffer;T;[o;;I" ;F;I"	bool;To;;I" ;T;0;;;I"external?;F;I"IO::Buffer;T;[o;;I" ;F;I"	bool;To;;I"ËIf the buffer references memory, release it back to the operating system.
*   for a *mapped* buffer (e.g. from file): unmap.
*   for a buffer created from scratch: free memory.
*   for a buffer created from string: undo the association.


After the buffer is freed, no further operations can't be performed on it.

    buffer = IO::Buffer.for('test')
    buffer.free
    # => #<IO::Buffer 0x0000000000000000+0 NULL>

    buffer.get_value(:U8, 0)
    # in `get_value': The buffer is not allocated! (IO::Buffer::AllocationError)

    buffer.get_string
    # in `get_string': The buffer is not allocated! (IO::Buffer::AllocationError)

    buffer.null?
    # => true

You can resize a freed buffer to re-allocate it.

;T;0;;;I"	free;F;I"IO::Buffer;T;[o;;I" ;F;I"	self;To;;I"!Read a chunk or all of the buffer into a string, in the specified `encoding`.
If no encoding is provided `Encoding::BINARY` is used.

    buffer = IO::Buffer.for('test')
    buffer.get_string
    # => "test"
    buffer.get_string(2)
    # => "st"
    buffer.get_string(2, 1)
    # => "s"

;T;0;;;I"get_string;F;I"IO::Buffer;T;[o;;I"??::Integer offset, ?::Integer length, ?::Encoding encoding;T;I"String;To;;I"Read from buffer a value of `type` at `offset`. `type` should be one of
symbols:

*   `:U8`: unsigned integer, 1 byte
*   `:S8`: signed integer, 1 byte
*   `:u16`: unsigned integer, 2 bytes, little-endian
*   `:U16`: unsigned integer, 2 bytes, big-endian
*   `:s16`: signed integer, 2 bytes, little-endian
*   `:S16`: signed integer, 2 bytes, big-endian
*   `:u32`: unsigned integer, 4 bytes, little-endian
*   `:U32`: unsigned integer, 4 bytes, big-endian
*   `:s32`: signed integer, 4 bytes, little-endian
*   `:S32`: signed integer, 4 bytes, big-endian
*   `:u64`: unsigned integer, 8 bytes, little-endian
*   `:U64`: unsigned integer, 8 bytes, big-endian
*   `:s64`: signed integer, 8 bytes, little-endian
*   `:S64`: signed integer, 8 bytes, big-endian
*   `:f32`: float, 4 bytes, little-endian
*   `:F32`: float, 4 bytes, big-endian
*   `:f64`: double, 8 bytes, little-endian
*   `:F64`: double, 8 bytes, big-endian


Example:

    string = [1.5].pack('f')
    # => "\x00\x00\xC0?"
    IO::Buffer.for(string).get_value(:f32, 0)
    # => 1.5

;T;0;;;I"get_value;F;I"IO::Buffer;T;[o;;I"1::IO::Buffer::int_get_type, ::Integer offset;T;I"Integer;To;;I"3::IO::Buffer::float_get_type, ::Integer offset;T;I"
Float;To;;I" ;T;0;;;I"hexdump;F;I"IO::Buffer;T;[o;;I" ;F;I"String;To;;I" ;T;0;;;I"inspect;F;I"IO::Buffer;T;[o;;I" ;F;I"String;To;;I"ÖIf the buffer is *internal*, meaning it references memory allocated by the
buffer itself.

An internal buffer is not associated with any external memory (e.g. string) or
file mapping.

Internal buffers are created using ::new and is the default when the requested
size is less than the IO::Buffer::PAGE_SIZE and it was not requested to be
mapped on creation.

Internal buffers can be resized, and such an operation will typically
invalidate all slices, but not always.

;T;0;;;I"internal?;F;I"IO::Buffer;T;[o;;I" ;F;I"	bool;To;;I"7Allows to process a buffer in exclusive way, for concurrency-safety. While the
block is performed, the buffer is considered locked, and no other code can
enter the lock. Also, locked buffer can't be changed with #resize or #free.

    buffer = IO::Buffer.new(4)
    buffer.locked? #=> false

    Fiber.schedule do
      buffer.locked do
        buffer.write(io) # theoretical system call interface
      end
    end

    Fiber.schedule do
      # in `locked': Buffer already locked! (IO::Buffer::LockedError)
      buffer.locked do
        buffer.set_string(...)
      end
    end

The following operations acquire a lock: #resize, #free.

Locking is not thread safe. It is designed as a safety net around non-blocking
system calls. You can only share a buffer between threads with appropriate
synchronisation techniques.

;T;0;;;I"locked;F;I"IO::Buffer;T;[o;;I" ;F;I"A;Fo;;I"jIf the buffer is *locked*, meaning it is inside #locked block execution.
Locked buffer can't be resized or freed, and another lock can't be acquired on
it.

Locking is not thread safe, but is a semantic used to ensure buffers don't
move while being used by a system call.

    buffer.locked do
      buffer.write(io) # theoretical system call interface
    end

;T;0;;;I"locked?;F;I"IO::Buffer;T;[o;;I" ;F;I"	bool;To;;I"|If the buffer is *mapped*, meaning it references memory mapped by the buffer.

Mapped buffers are either anonymous, if created by ::new with the
IO::Buffer::MAPPED flag or if the size was at least IO::Buffer::PAGE_SIZE, or
backed by a file if created with ::map.

Mapped buffers can usually be resized, and such an operation will typically
invalidate all slices, but not always.

;T;0;;;I"mapped?;F;I"IO::Buffer;T;[o;;I" ;F;I"	bool;To;;I"TIf the buffer was freed with #free or was never allocated in the first place.

;T;0;;;I"
null?;F;I"IO::Buffer;T;[o;;I" ;F;I"	bool;To;;I" ;T;0;;;I"
pread;F;I"IO::Buffer;T;[o;;I"untyped, untyped, untyped;T;I"untyped;To;;I" ;T;0;;;I"pwrite;F;I"IO::Buffer;T;[o;;I"untyped, untyped, untyped;T;I"untyped;To;;I" ;T;0;;;I"	read;F;I"IO::Buffer;T;[o;;I"untyped, untyped;T;I"untyped;To;;I" ;T;0;;;I"readonly?;F;I"IO::Buffer;T;[o;;I" ;F;I"	bool;To;;I"%Resizes a buffer to a `new_size` bytes, preserving its content. Depending on
the old and new size, the memory area associated with the buffer might be
either extended, or rellocated at different address with content being copied.

    buffer = IO::Buffer.new(4)
    buffer.set_string("test", 0)
    buffer.resize(8) # resize to 8 bytes
    #  =>
    # #<IO::Buffer 0x0000555f5d1a1630+8 INTERNAL>
    # 0x00000000  74 65 73 74 00 00 00 00                         test....

External buffer (created with ::for), and locked buffer can not be resized.

;T;0;;;I"resize;F;I"IO::Buffer;T;[o;;I"::Integer;T;I"	self;To;;I" ;T;0;;;I"set_string;F;I"IO::Buffer;T;[o;;I"*untyped;T;I"untyped;To;;I"Write to a buffer a `value` of `type` at `offset`. `type` should be one of
symbols described in #get_value.

    buffer = IO::Buffer.new(8)
    #  =>
    # #<IO::Buffer 0x0000555f5c9a2d50+8 INTERNAL>
    # 0x00000000  00 00 00 00 00 00 00 00
    buffer.set_value(:U8, 1, 111)
    # => 1
    buffer
    #  =>
    # #<IO::Buffer 0x0000555f5c9a2d50+8 INTERNAL>
    # 0x00000000  00 6f 00 00 00 00 00 00                         .o......

Note that if the `type` is integer and `value` is Float, the implicit
truncation is performed:

    buffer = IO::Buffer.new(8)
    buffer.set_value(:U32, 0, 2.5)
    buffer
    #   =>
    #  #<IO::Buffer 0x0000555f5c9a2d50+8 INTERNAL>
    #  0x00000000  00 00 00 02 00 00 00 00
    #                       ^^ the same as if we'd pass just integer 2

;T;0;;;I"set_value;F;I"IO::Buffer;T;[o;;I"k::IO::Buffer::int_get_type | ::IO::Buffer::float_get_type, ::Integer offset, ::Float | ::Integer value;T;I"Integer;To;;I"•Returns the size of the buffer that was explicitly set (on creation with ::new
or on #resize), or deduced on buffer's creation from string or file.

;T;0;;;I"	size;F;I"IO::Buffer;T;[o;;I" ;F;I"Integer;To;;I"Produce another IO::Buffer which is a slice (or view into) the current one
starting at `offset` bytes and going for `length` bytes.

The slicing happens without copying of memory, and the slice keeps being
associated with the original buffer's source (string, or file), if any.

Raises RuntimeError if the <tt>offset+length<tt> is out of the current
buffer's bounds.

    string = 'test'
    buffer = IO::Buffer.for(string)

    slice = buffer.slice(1, 2)
    # =>
    #  #<IO::Buffer 0x00007fc3d34ebc49+2 SLICE>
    #  0x00000000  65 73                                           es

    # Put "o" into 0s position of the slice
    slice.set_string('o', 0)
    slice
    # =>
    #  #<IO::Buffer 0x00007fc3d34ebc49+2 SLICE>
    #  0x00000000  6f 73                                           os

    # it is also visible at position 1 of the original buffer
    buffer
    # =>
    #  #<IO::Buffer 0x00007fc3d31e2d80+4 SLICE>
    #  0x00000000  74 6f 73 74                                     tost

    # ...and original string
    string
    # => tost

;T;0;;;I"
slice;F;I"IO::Buffer;T;[o;;I"'::Integer offset, ::Integer length;T;I"IO::Buffer;To;;I"ÞShort representation of the buffer. It includes the address, size and symbolic
flags. This format is subject to change.

    puts IO::Buffer.new(4) # uses to_s internally
    # #<IO::Buffer 0x000055769f41b1a0+4 INTERNAL>

;T;0;;;I"	to_s;F;I"IO::Buffer;T;[o;;I" ;F;I"String;To;;I"qTransfers ownership to a new buffer, deallocating the current one.

    buffer = IO::Buffer.new('test')
    other = buffer.transfer
    other
    #  =>
    # #<IO::Buffer 0x00007f136a15f7b0+4 SLICE>
    # 0x00000000  74 65 73 74                                     test
    buffer
    #  =>
    # #<IO::Buffer 0x0000000000000000+0 NULL>
    buffer.null?
    # => true

;T;0;;;I"transfer;F;I"IO::Buffer;T;[o;;I" ;F;I"IO::Buffer;To;;I"ƒReturns whether the buffer data is accessible.

A buffer becomes invalid if it is a slice of another buffer which has been
freed.

;T;0;;;I"valid?;F;I"IO::Buffer;T;[o;;I" ;F;I"	bool;To;;I" ;T;0;;;I"
write;F;I"IO::Buffer;T;[o;;I"untyped, untyped;T;I"untyped;To;;I" Create a new zero-filled IO::Buffer of `size` bytes. By default, the buffer
will be *internal*: directly allocated chunk of the memory. But if the
requested `size` is more than OS-specific IO::Bufer::PAGE_SIZE, the buffer
would be allocated using the virtual memory mechanism (anonymous `mmap` on
Unix, `VirtualAlloc` on Windows). The behavior can be forced by passing
IO::Buffer::MAPPED as a second parameter.

Examples

    buffer = IO::Buffer.new(4)
    # =>
    #  #<IO::Buffer 0x000055b34497ea10+4 INTERNAL>
    #  0x00000000  00 00 00 00                                     ....

    buffer.get_string(0, 1) # => "\x00"

    buffer.set_string("test")
    buffer
    #  =>
    # #<IO::Buffer 0x000055b34497ea10+4 INTERNAL>
    # 0x00000000  74 65 73 74                                     test

;T;0;;;I"initialize;F;I"IO::Buffer;T;[o;;I"&?::Integer size, ?::Integer flags;T;I"	void;To; ;I">exception to wait for reading by EAGAIN. see IO.select.

;T;0;	I"IO::EAGAINWaitReadable;T;
[ ;[I"IO::WaitReadable;T;0;[ ;[ ;0;I"Errno::EAGAIN;To; ;I">exception to wait for writing by EAGAIN. see IO.select.

;T;0;	I"IO::EAGAINWaitWritable;T;
[ ;[I"IO::WaitWritable;T;0;[ ;[ ;0;I"Errno::EAGAIN;To; ;I"Cexception to wait for reading by EINPROGRESS. see IO.select.

;T;0;	I" IO::EINPROGRESSWaitReadable;T;
[ ;[I"IO::WaitReadable;T;0;[ ;[ ;0;I"Errno::EINPROGRESS;To; ;I"Cexception to wait for writing by EINPROGRESS. see IO.select.

;T;0;	I" IO::EINPROGRESSWaitWritable;T;
[ ;[I"IO::WaitWritable;T;0;[ ;[ ;0;I"Errno::EINPROGRESS;To;;I"4exception to wait for reading. see IO.select.

;T;0;	I"IO::WaitReadable;T;
[ ;[ ;0;[ ;[ o;;I"4exception to wait for writing. see IO.select.

;T;0;	I"IO::WaitWritable;T;
[ ;[ ;0;[ ;[ o;;I"YThe Kernel module is included by class Object, so its methods are available in
every Ruby object.

The Kernel instance methods are documented in class Object while the module
methods are documented here.  These methods are called without a receiver and
thus can be called in functional form:

    sprintf "%.1f", 1.234 #=> "1.2"

## What's Here

Module Kernel provides methods that are useful for:

*   [Converting](#module-Kernel-label-Converting)
*   [Querying](#module-Kernel-label-Querying)
*   [Exiting](#module-Kernel-label-Exiting)
*   [Exceptions](#module-Kernel-label-Exceptions)
*   [IO](#module-Kernel-label-IO)
*   [Procs](#module-Kernel-label-Procs)
*   [Tracing](#module-Kernel-label-Tracing)
*   [Subprocesses](#module-Kernel-label-Subprocesses)
*   [Loading](#module-Kernel-label-Loading)
*   [Yielding](#module-Kernel-label-Yielding)
*   [Random Values](#module-Kernel-label-Random+Values)
*   [Other](#module-Kernel-label-Other)


### Converting

    [#Array](#method-i-Array)
:       Returns an Array based on the given argument.

    [#Complex](#method-i-Complex)
:       Returns a Complex based on the given arguments.

    [#Float](#method-i-Float)
:       Returns a Float based on the given arguments.

    [#Hash](#method-i-Hash)
:       Returns a Hash based on the given argument.

    [#Integer](#method-i-Integer)
:       Returns an Integer based on the given arguments.

    [#Rational](#method-i-Rational)
:       Returns a Rational based on the given arguments.

    [#String](#method-i-String)
:       Returns a String based on the given argument.



### Querying

    [#__callee__](#method-i-__callee__)
:       Returns the called name of the current method as a symbol.

    [#__dir__](#method-i-__dir__)
:       Returns the path to the directory from which the current method is
        called.

    [#__method__](#method-i-__method__)
:       Returns the name of the current method as a symbol.

    #autoload?
:       Returns the file to be loaded when the given module is referenced.

    #binding
:       Returns a Binding for the context at the point of call.

    #block_given?
:       Returns `true` if a block was passed to the calling method.

    #caller
:       Returns the current execution stack as an array of strings.

    #caller_locations
:       Returns the current execution stack as an array of
        Thread::Backtrace::Location objects.

    #class
:       Returns the class of `self`.

    #frozen?
:       Returns whether `self` is frozen.

    #global_variables
:       Returns an array of global variables as symbols.

    #local_variables
:       Returns an array of local variables as symbols.

    #test
:       Performs specified tests on the given single file or pair of files.



### Exiting

    #abort
:       Exits the current process after printing the given arguments.

    #at_exit
:       Executes the given block when the process exits.

    #exit
:       Exits the current process after calling any registered `at_exit`
        handlers.

    #exit!
:       Exits the current process without calling any registered `at_exit`
        handlers.



### Exceptions

    #catch
:       Executes the given block, possibly catching a thrown object.

    #raise (aliased as #fail)
:       Raises an exception based on the given arguments.

    #throw
:       Returns from the active catch block waiting for the given tag.



### IO

    #gets
:       Returns and assigns to `$_` the next line from the current input.

    #open
:       Creates an IO object connected to the given stream, file, or
        subprocess.

    #p
:       Prints the given objects' inspect output to the standard output.

    #pp
:       Prints the given objects in pretty form.

    #print
:       Prints the given objects to standard output without a newline.

    #printf
:       Prints the string resulting from applying the given format string to
        any additional arguments.

    #putc
:       Equivalent to <tt.$stdout.putc(object)</tt> for the given object.

    #puts
:       Equivalent to `$stdout.puts(*objects)` for the given objects.

    #readline
:       Similar to #gets, but raises an exception at the end of file.

    #readlines
:       Returns an array of the remaining lines from the current input.

    #select
:       Same as IO.select.



### Procs

    #lambda
:       Returns a lambda proc for the given block.

    #proc
:       Returns a new Proc; equivalent to Proc.new.



### Tracing

    #set_trace_func
:       Sets the given proc as the handler for tracing, or disables tracing if
        given `nil`.

    #trace_var
:       Starts tracing assignments to the given global variable.

    #untrace_var
:       Disables tracing of assignments to the given global variable.



### Subprocesses

    #`cmd`
:       Returns the standard output of running `cmd` in a subshell.

    #exec
:       Replaces current process with a new process.

    #fork
:       Forks the current process into two processes.

    #spawn
:       Executes the given command and returns its pid without waiting for
        completion.

    #system
:       Executes the given command in a subshell.



### Loading

    #autoload
:       Registers the given file to be loaded when the given constant is first
        referenced.

    #load
:       Loads the given Ruby file.

    #require
:       Loads the given Ruby file unless it has already been loaded.

    #require_relative
:       Loads the Ruby file path relative to the calling file, unless it has
        already been loaded.



### Yielding

    #tap
:       Yields `self` to the given block; returns `self`.

    #then (aliased as #yield_self)
:       Yields `self` to the block and returns the result of the block.



### Random Values

    #rand
:       Returns a pseudo-random floating point number strictly between 0.0 and
        1.0.

    #srand
:       Seeds the pseudo-random number generator with the given number.



### Other

    #eval
:       Evaluates the given string as Ruby code.

    #loop
:       Repeatedly executes the given block.

    #sleep
:       Suspends the current thread for the given number of seconds.

    #sprintf (aliased as #format)
:       Returns the string resulting from applying the given format string to
        any additional arguments.

    #syscall
:       Runs an operating system call.

    #trap
:       Specifies the handling of system signals.

    #warn
:       Issue a warning based on the given messages and options.

;T;0;	I"Kernel;T;
[ ;[ ;0;[ ;[ o;;I"±Returns the current execution stack---an array containing strings in the form
`file:line` or `file:line: in `method'`.

The optional *start* parameter determines the number of initial stack entries
to omit from the top of the stack.

A second optional `length` parameter can be used to limit how many entries are
returned from the stack.

Returns `nil` if *start* is greater than the size of current execution stack.

Optionally you can pass a range, which will return an array containing the
entries within the specified range.

    def a(skip)
      caller(skip)
    end
    def b(skip)
      a(skip)
    end
    def c(skip)
      b(skip)
    end
    c(0)   #=> ["prog:2:in `a'", "prog:5:in `b'", "prog:8:in `c'", "prog:10:in `<main>'"]
    c(1)   #=> ["prog:5:in `b'", "prog:8:in `c'", "prog:11:in `<main>'"]
    c(2)   #=> ["prog:8:in `c'", "prog:12:in `<main>'"]
    c(3)   #=> ["prog:13:in `<main>'"]
    c(4)   #=> []
    c(5)   #=> nil

;T;0;;;I"caller;F;I"Kernel;T;[o;;I"0::Integer start_or_range, ?::Integer length;T;I"Array[::String]?;To;;I"&::Range[::Integer] start_or_range;T;I"Array[::String]?;To;;I" ;F;I"Array[::String];To;;I"(Returns the current execution stack---an array containing backtrace location
objects.

See Thread::Backtrace::Location for more information.

The optional *start* parameter determines the number of initial stack entries
to omit from the top of the stack.

A second optional `length` parameter can be used to limit how many entries are
returned from the stack.

Returns `nil` if *start* is greater than the size of current execution stack.

Optionally you can pass a range, which will return an array containing the
entries within the specified range.

;T;0;;;I"caller_locations;F;I"Kernel;T;[o;;I"1?::Integer start_or_range, ?::Integer length;T;I"*Array[::Thread::Backtrace::Location]?;To;;I"'?::Range[::Integer] start_or_range;T;I"*Array[::Thread::Backtrace::Location]?;To;;I"â`catch` executes its block. If `throw` is not called, the block executes
normally, and `catch` returns the value of the last expression evaluated.

    catch(1) { 123 }            # => 123

If `throw(tag2, val)` is called, Ruby searches up its stack for a `catch`
block whose `tag` has the same `object_id` as *tag2*. When found, the block
stops executing and returns *val* (or `nil` if no second argument was given to
`throw`).

    catch(1) { throw(1, 456) }  # => 456
    catch(1) { throw(1) }       # => nil

When `tag` is passed as the first argument, `catch` yields it as the parameter
of the block.

    catch(1) {|x| x + 2 }       # => 3

When no `tag` is given, `catch` yields a new unique object (as from
`Object.new`) as the block parameter. This object can then be used as the
argument to `throw`, and will match the correct `catch` block.

    catch do |obj_A|
      catch do |obj_B|
        throw(obj_B, 123)
        puts "This puts is not reached"
      end

      puts "This puts is displayed"
      456
    end

    # => 456

    catch do |obj_A|
      catch do |obj_B|
        throw(obj_A, 123)
        puts "This puts is still not reached"
      end

      puts "Now this puts is also not reached"
      456
    end

    # => 123

;T;0;;;I"
catch;F;I"Kernel;T;[o;;I"
T tag;T;I"untyped;To;;I" ;F;I"untyped;To;;I"¿Returns the class of *obj*. This method must always be called with an explicit
receiver, as #class is also a reserved word in Ruby.

    1.class      #=> Integer
    self.class   #=> Object

;T;0;;;I"
class;F;I"Kernel;T;[o;;I" ;F;I"untyped;To;;I"ÇEvaluates the Ruby expression(s) in *string*. If *binding* is given, which
must be a Binding object, the evaluation is performed in its context. If the
optional *filename* and *lineno* parameters are present, they will be used
when reporting syntax errors.

    def get_binding(str)
      return binding
    end
    str = "hello"
    eval "str + ' Fred'"                      #=> "hello Fred"
    eval "str + ' Fred'", get_binding("bye")  #=> "bye Fred"

;T;0;;;I"	eval;F;I"Kernel;T;[o;;I"J::String arg0, ?::Binding arg1, ?::String filename, ?::Integer lineno;T;I"untyped;To;;I"GReturns `true` if `yield` would execute a block in the current context. The
`iterator?` form is mildly deprecated.

    def try
      if block_given?
        yield
      else
        "no block"
      end
    end
    try                  #=> "no block"
    try { "hello" }      #=> "hello"
    try do "hello" end   #=> "hello"

;T;0;;;I"block_given?;F;I"Kernel;T;[o;;I" ;F;I"	bool;To;;I"Returns the names of the current local variables.

    fred = 1
    for i in 1..10
       # ...
    end
    local_variables   #=> [:fred, :i]

;T;0;;;I"local_variables;F;I"Kernel;T;[o;;I" ;F;I"Array[::Symbol];To;;I"tSeeds the system pseudo-random number generator, with `number`. The previous
seed value is returned.

If `number` is omitted, seeds the generator using a source of entropy provided
by the operating system, if available (/dev/urandom on Unix systems or the RSA
cryptographic provider on Windows), which is then combined with the time, the
process id, and a sequence number.

srand may be used to ensure repeatable sequences of pseudo-random numbers
between different runs of the program. By setting the seed to a known value,
programs can be made deterministic during testing.

    srand 1234               # => 268519324636777531569100071560086917274
    [ rand, rand ]           # => [0.1915194503788923, 0.6221087710398319]
    [ rand(10), rand(1000) ] # => [4, 664]
    srand 1234               # => 1234
    [ rand, rand ]           # => [0.1915194503788923, 0.6221087710398319]

;T;0;;;I"
srand;F;I"Kernel;T;[o;;I"?::Numeric number;T;I"Numeric;To;;I"€Creates a subprocess. If a block is specified, that block is run in the
subprocess, and the subprocess terminates with a status of zero. Otherwise,
the `fork` call returns twice, once in the parent, returning the process ID of
the child, and once in the child, returning *nil*. The child process can exit
using Kernel.exit! to avoid running any `at_exit` functions. The parent
process should use Process.wait to collect the termination statuses of its
children or use Process.detach to register disinterest in their status;
otherwise, the operating system may accumulate zombie processes.

The thread calling fork is the only thread in the created child process. fork
doesn't copy other threads.

If fork is not usable, Process.respond_to?(:fork) returns false.

Note that fork(2) is not available on some platforms like Windows and NetBSD
4. Therefore you should use spawn() instead of fork().

;T;0;;;I"	fork;F;I"Kernel;T;[o;;I" ;F;I"Integer?;To;;I" ;F;I"Integer?;To;;0;0;;;I"initialize_copy;F;I"Kernel;T;[o;;I"self object;T;I"	self;To;;I"¾Returns `arg` as an Array.

First tries to call `to_ary` on `arg`, then `to_a`. If `arg` does not respond
to `to_ary` or `to_a`, returns an Array of length 1 containing `arg`.

If `to_ary` or `to_a` returns something other than an Array, raises a
TypeError.

    Array(["a", "b"])  #=> ["a", "b"]
    Array(1..5)        #=> [1, 2, 3, 4, 5]
    Array(key: :value) #=> [[:key, :value]]
    Array(nil)         #=> []
    Array(1)           #=> [1]

;T;0;;;I"
Array;F;I"Kernel;T;[o;;I"::NilClass x;T;I"[ ];To;;I"::Array[T] x;T;I"Array[T];To;;I"::Range[T] x;T;I"Array[T];To;;I"::_Each[T] x;T;I"Array[T];To;;I"::Hash[K, V] x;T;I"Array[[ K, V ]];To;;I"T x;T;I"Array[T];To;;I"nReturns x+i*y;

    Complex(1, 2)    #=> (1+2i)
    Complex('1+2i')  #=> (1+2i)
    Complex(nil)     #=> TypeError
    Complex(1, nil)  #=> TypeError

    Complex(1, nil, exception: false)  #=> nil
    Complex('1+2', exception: false)   #=> nil

Syntax of string form:

    string form = extra spaces , complex , extra spaces ;
    complex = real part | [ sign ] , imaginary part
            | real part , sign , imaginary part
            | rational , "@" , rational ;
    real part = rational ;
    imaginary part = imaginary unit | unsigned rational , imaginary unit ;
    rational = [ sign ] , unsigned rational ;
    unsigned rational = numerator | numerator , "/" , denominator ;
    numerator = integer part | fractional part | integer part , fractional part ;
    denominator = digits ;
    integer part = digits ;
    fractional part = "." , digits , [ ( "e" | "E" ) , [ sign ] , digits ] ;
    imaginary unit = "i" | "I" | "j" | "J" ;
    sign = "-" | "+" ;
    digits = digit , { digit | "_" , digit };
    digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;
    extra spaces = ? \s* ? ;

See String#to_c.

;T;0;;;I"Complex;F;I"Kernel;T;[o;;I"P::Numeric | ::String x, ?::Numeric | ::String y, ?exception: bool exception;T;I"Complex;To;;I"{Returns *arg* converted to a float. Numeric types are converted directly, and
with exception to String and `nil` the rest are converted using *arg*`.to_f`.
Converting a String with invalid characters will result in a ArgumentError.
Converting `nil` generates a TypeError.  Exceptions can be suppressed by
passing `exception: false`.

    Float(1)                 #=> 1.0
    Float("123.456")         #=> 123.456
    Float("123.0_badstring") #=> ArgumentError: invalid value for Float(): "123.0_badstring"
    Float(nil)               #=> TypeError: can't convert nil into Float
    Float("123.0_badstring", exception: false)  #=> nil

;T;0;;;I"
Float;F;I"Kernel;T;[o;;I"7::Numeric | ::String x, ?exception: bool exception;T;I"
Float;To;;I"óConverts *arg* to a Hash by calling *arg*`.to_hash`. Returns an empty Hash
when *arg* is `nil` or `[]`.

    Hash([])          #=> {}
    Hash(nil)         #=> {}
    Hash(key: :value) #=> {:key => :value}
    Hash([1, 2, 3])   #=> TypeError

;T;0;;;I"	Hash;F;I"Kernel;T;[o;;I"::Object x;T;I"Hash[K, V];To;;I"ÜConverts *arg* to an Integer. Numeric types are converted directly (with
floating point numbers being truncated).  *base* (0, or between 2 and 36) is a
base for integer string representation.  If *arg* is a String, when *base* is
omitted or equals zero, radix indicators (`0`, `0b`, and `0x`) are honored. In
any case, strings should consist only of one or more digits, except for that a
sign, one underscore between two digits, and leading/trailing spaces are
optional.  This behavior is different from that of String#to_i.  Non string
values will be converted by first trying `to_int`, then `to_i`.

Passing `nil` raises a TypeError, while passing a String that does not conform
with numeric representation raises an ArgumentError. This behavior can be
altered by passing `exception: false`, in this case a not convertible value
will return `nil`.

    Integer(123.999)    #=> 123
    Integer("0x1a")     #=> 26
    Integer(Time.new)   #=> 1204973019
    Integer("0930", 10) #=> 930
    Integer("111", 2)   #=> 7
    Integer(" +1_0 ")   #=> 10
    Integer(nil)        #=> TypeError: can't convert nil into Integer
    Integer("x")        #=> ArgumentError: invalid value for Integer(): "x"

    Integer("x", exception: false)        #=> nil

;T;0;;;I"Integer;F;I"Kernel;T;[o;;I"9::Numeric | ::String arg, ?exception: bool exception;T;I"Integer;To;;I">::String arg, ?::Integer base, ?exception: bool exception;T;I"Integer;To;;I"Returns `x/y` or `arg` as a Rational.

    Rational(2, 3)   #=> (2/3)
    Rational(5)      #=> (5/1)
    Rational(0.5)    #=> (1/2)
    Rational(0.3)    #=> (5404319552844595/18014398509481984)

    Rational("2/3")  #=> (2/3)
    Rational("0.3")  #=> (3/10)

    Rational("10 cents")  #=> ArgumentError
    Rational(nil)         #=> TypeError
    Rational(1, nil)      #=> TypeError

    Rational("10 cents", exception: false)  #=> nil

Syntax of the string form:

    string form = extra spaces , rational , extra spaces ;
    rational = [ sign ] , unsigned rational ;
    unsigned rational = numerator | numerator , "/" , denominator ;
    numerator = integer part | fractional part | integer part , fractional part ;
    denominator = digits ;
    integer part = digits ;
    fractional part = "." , digits , [ ( "e" | "E" ) , [ sign ] , digits ] ;
    sign = "-" | "+" ;
    digits = digit , { digit | "_" , digit } ;
    digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;
    extra spaces = ? \s* ? ;

See also String#to_r.

;T;0;;;I"Rational;F;I"Kernel;T;[o;;I"[::Numeric | ::String | ::Object x, ?::Numeric | ::String y, ?exception: bool exception;T;I"Rational;To;;I"ÌReturns *arg* as a String.

First tries to call its `to_str` method, then its `to_s` method.

    String(self)        #=> "main"
    String(self.class)  #=> "Object"
    String(123456)      #=> "123456"

;T;0;;;I"String;F;I"Kernel;T;[o;;I"::_ToStr | ::_ToS x;T;I"String;To;;I"rReturns the called name of the current method as a Symbol. If called outside
of a method, it returns `nil`.

;T;0;;;I"__callee__;F;I"Kernel;T;[o;;I" ;F;I"Symbol?;To;;I"Returns the canonicalized absolute path of the directory of the file from
which this method is called. It means symlinks in the path is resolved. If
`__FILE__` is `nil`, it returns `nil`. The return value equals to
`File.dirname(File.realpath(__FILE__))`.

;T;0;;;I"__dir__;F;I"Kernel;T;[o;;I" ;F;I"String?;To;;I"}Returns the name at the definition of the current method as a Symbol. If
called outside of a method, it returns `nil`.

;T;0;;;I"__method__;F;I"Kernel;T;[o;;I" ;F;I"Symbol?;To;;I"JReturns the standard output of running *cmd* in a subshell. The built-in
syntax `%x{...}` uses this method. Sets `$?` to the process status.

    `date`                   #=> "Wed Apr  9 08:56:30 CDT 2003\n"
    `ls testdir`.split[1]    #=> "main.rb"
    `echo oops && exit 99`   #=> "oops\n"
    $?.exitstatus            #=> 99

;T;0;;;I"`;F;I"Kernel;T;[o;;I"::String arg0;T;I"String;To;;I"Terminate execution immediately, effectively by calling `Kernel.exit(false)`.
If *msg* is given, it is written to STDERR prior to terminating.

;T;0;;;I"
abort;F;I"Kernel;T;[o;;I"?::String msg;T;I"bot;To;;I"Converts *block* to a `Proc` object (and therefore binds it at the point of
call) and registers it for execution when the program exits. If multiple
handlers are registered, they are executed in reverse order of registration.

    def do_at_exit(str1)
      at_exit { print str1 }
    end
    at_exit { puts "cruel world" }
    do_at_exit("goodbye ")
    exit

*produces:*

    goodbye cruel world

;T;0;;;I"at_exit;F;I"Kernel;T;[o;;I" ;F;I"	Proc;To;;I"ÉRegisters *filename* to be loaded (using Kernel::require) the first time that
*module* (which may be a String or a symbol) is accessed.

    autoload(:MyModule, "/usr/local/lib/modules/my_module.rb")

;T;0;;;I"autoload;F;I"Kernel;T;[o;;I"3::String | ::Symbol _module, ::String filename;T;I"NilClass;To;;I"„Returns *filename* to be loaded if *name* is registered as `autoload`.

    autoload(:B, "b")
    autoload?(:B)            #=> "b"

;T;0;;;I"autoload?;F;I"Kernel;T;[o;;I"::Symbol | ::String name;T;I"String?;To;;I"`Returns a `Binding` object, describing the variable and method bindings at the
point of call. This object can be used when calling `eval` to execute the
evaluated command in this environment. See also the description of class
`Binding`.

    def get_binding(param)
      binding
    end
    b = get_binding("hello")
    eval("param", b)   #=> "hello"

;T;0;;;I"binding;F;I"Kernel;T;[o;;I" ;F;I"Binding;To;;I"zInitiates the termination of the Ruby script by raising the SystemExit
exception. This exception may be caught. The optional parameter is used to
return a status code to the invoking environment. `true` and `FALSE` of
*status* means success and failure respectively.  The interpretation of other
integer values are system dependent.

    begin
      exit
      puts "never get here"
    rescue SystemExit
      puts "rescued a SystemExit exception"
    end
    puts "after begin block"

*produces:*

    rescued a SystemExit exception
    after begin block

Just prior to termination, Ruby executes any `at_exit` functions (see
Kernel::at_exit) and runs any object finalizers (see
ObjectSpace::define_finalizer).

    at_exit { puts "at_exit function" }
    ObjectSpace.define_finalizer("string",  proc { puts "in finalizer" })
    exit

*produces:*

    at_exit function
    in finalizer

;T;0;;;I"	exit;F;I"Kernel;T;[o;;I" ;F;I"bot;To;;I"3?::Integer | ::TrueClass | ::FalseClass status;T;I"bot;To;;I"•Exits the process immediately. No exit handlers are run. *status* is returned
to the underlying system as the exit status.

    Process.exit!(true)

;T;0;;;I"
exit!;F;I"Kernel;T;[o;;I"2::Integer | ::TrueClass | ::FalseClass status;T;I"bot;To;;I"­With no arguments, raises the exception in `$!` or raises a RuntimeError if
`$!` is `nil`.  With a single `String` argument, raises a `RuntimeError` with
the string as a message. Otherwise, the first parameter should be an
`Exception` class (or another object that returns an `Exception` object when
sent an `exception` message).  The optional second parameter sets the message
associated with the exception (accessible via Exception#message), and the
third parameter is an array of callback information (accessible via
Exception#backtrace). The `cause` of the generated exception (accessible via
Exception#cause) is automatically set to the "current" exception (`$!`), if
any. An alternative value, either an `Exception` object or `nil`, can be
specified via the `:cause` argument.

Exceptions are caught by the `rescue` clause of `begin...end` blocks.

    raise "Failed to create socket"
    raise ArgumentError, "No parameters", caller

;T;0;;;I"	fail;F;I"Kernel;T;[o;;I" ;F;I"bot;To;;I"+::String message, ?cause: ::Exception?;T;I"bot;To;;I"a::_Exception exception, ?untyped message, ?::Array[::String] backtrace, ?cause: ::Exception?;T;I"bot;To;;I"äsprintf("%20.8s", "string test") #=> "            string t"

Examples:

    sprintf("%d %04x", 123, 123)               #=> "123 007b"
    sprintf("%08b '%4s'", 123, 123)            #=> "01111011 ' 123'"
    sprintf("%1$*2$s %2$d %1$s", "hello", 8)   #=> "   hello 8 hello"
    sprintf("%1$*2$s %2$d", "hello", -8)       #=> "hello    -8"
    sprintf("%+g:% g:%-g", 1.23, 1.23, 1.23)   #=> "+1.23: 1.23:1.23"
    sprintf("%u", -123)                        #=> "-123"

For more complex formatting, Ruby supports a reference by name. %<name>s style
uses format style, but %{name} style doesn't.

Examples:
    sprintf("%<foo>d : %<bar>f", { :foo => 1, :bar => 2 })
      #=> 1 : 2.000000
    sprintf("%{foo}f", { :foo => 1 })
      # => "1f"

;T;0;;;I"format;F;I"Kernel;T;[o;;I"#::String format, *untyped args;T;I"String;To;;I"ÑReturns (and assigns to `$_`) the next line from the list of files in `ARGV`
(or `$*`), or from standard input if no files are present on the command line.
Returns `nil` at end of file. The optional argument specifies the record
separator. The separator is included with the contents of each record. A
separator of `nil` reads the entire contents, and a zero-length separator
reads the input one paragraph at a time, where paragraphs are divided by two
consecutive newlines.  If the first argument is an integer, or optional second
argument is given, the returning string would not be longer than the given
value in bytes.  If multiple filenames are present in `ARGV`, `gets(nil)` will
read the contents one file at a time.

    ARGV << "testfile"
    print while gets

*produces:*

    This is line one
    This is line two
    This is line three
    And so on...

The style of programming using `$_` as an implicit parameter is gradually
losing favor in the Ruby community.

;T;0;;;I"	gets;F;I"Kernel;T;[o;;I"$?::String arg0, ?::Integer arg1;T;I"String?;To;;I"Returns an array of the names of global variables. This includes special
regexp global variables such as `$~` and `$+`, but does not include the
numbered regexp global variables (`$1`, `$2`, etc.).

    global_variables.grep /std/   #=> [:$stdin, :$stdout, :$stderr]

;T;0;;;I"global_variables;F;I"Kernel;T;[o;;I" ;F;I"Array[::Symbol];To;;I"sLoads and executes the Ruby program in the file *filename*.

If the filename is an absolute path (e.g. starts with '/'), the file will be
loaded directly using the absolute path.

If the filename is an explicit relative path (e.g. starts with './' or '../'),
the file will be loaded using the relative path from the current directory.

Otherwise, the file will be searched for in the library directories listed in
`$LOAD_PATH` (`$:`). If the file is found in a directory, it will attempt to
load the file relative to that directory.  If the file is not found in any of
the directories in `$LOAD_PATH`, the file will be loaded using the relative
path from the current directory.

If the file doesn't exist when there is an attempt to load it, a LoadError
will be raised.

If the optional *wrap* parameter is `true`, the loaded script will be executed
under an anonymous module, protecting the calling program's global namespace.
If the optional *wrap* parameter is a module, the loaded script will be
executed under the given module. In no circumstance will any local variables
in the loaded file be propagated to the loading environment.

;T;0;;;I"	load;F;I"Kernel;T;[o;;I"(::String filename, ?::Module | bool;T;I"	bool;To;;I"ÐRepeatedly executes the block.

If no block is given, an enumerator is returned instead.

    loop do
      print "Input: "
      line = gets
      break if !line or line =~ /^qQ/
      # ...
    end

StopIteration raised in the block breaks the loop.  In this case, loop returns
the "result" value stored in the exception.

    enum = Enumerator.new { |y|
      y << "one"
      y << "two"
      :ok
    }

    result = loop {
      puts enum.next
    } #=> :ok

;T;0;;;I"	loop;F;I"Kernel;T;[o;;I" ;F;I"bot;To;;I" ;F;I"Enumerator[nil, bot];To;;I"
Creates an IO object connected to the given stream, file, or subprocess.

If `path` does not start with a pipe character (`|`), treat it as the name of
a file to open using the specified mode (defaulting to "r").

The `mode` is either a string or an integer.  If it is an integer, it must be
bitwise-or of open(2) flags, such as File::RDWR or File::EXCL.  If it is a
string, it is either "fmode", "fmode:ext_enc", or "fmode:ext_enc:int_enc".

See the documentation of IO.new for full documentation of the `mode` string
directives.

If a file is being created, its initial permissions may be set using the
`perm` parameter.  See File.new and the open(2) and chmod(2) man pages for a
description of permissions.

If a block is specified, it will be invoked with the IO object as a parameter,
and the IO will be automatically closed when the block terminates.  The call
returns the value of the block.

If `path` starts with a pipe character (`"|"`), a subprocess is created,
connected to the caller by a pair of pipes.  The returned IO object may be
used to write to the standard input and read from the standard output of this
subprocess.

If the command following the pipe is a single minus sign (`"|-"`), Ruby forks,
and this subprocess is connected to the parent.  If the command is not `"-"`,
the subprocess runs the command.  Note that the command may be processed by
shell if it contains shell metacharacters.

When the subprocess is Ruby (opened via `"|-"`), the `open` call returns
`nil`.  If a block is associated with the open call, that block will run twice
--- once in the parent and once in the child.

The block parameter will be an IO object in the parent and `nil` in the child.
The parent's `IO` object will be connected to the child's $stdin and $stdout.
The subprocess will be terminated at the end of the block.

### Examples

Reading from "testfile":

    open("testfile") do |f|
      print f.gets
    end

Produces:

    This is line one

Open a subprocess and read its output:

    cmd = open("|date")
    print cmd.gets
    cmd.close

Produces:

    Wed Apr  9 08:56:31 CDT 2003

Open a subprocess running the same Ruby program:

    f = open("|-", "w+")
    if f.nil?
      puts "in Child"
      exit
    else
      puts "Got: #{f.gets}"
    end

Produces:

    Got: in Child

Open a subprocess using a block to receive the IO object:

    open "|-" do |f|
      if f then
        # parent process
        puts "Got: #{f.gets}"
      else
        # child process
        puts "in Child"
      end
    end

Produces:

    Got: in Child

;T;0;;;I"	open;F;I"Kernel;T;[o;;I"3::String name, ?::String mode, ?::Integer perm;T;I"IO?;To;;I"3::String name, ?::String mode, ?::Integer perm;T;I"T;Fo;;I"äPrints each object in turn to `$stdout`. If the output field separator (`$,`)
is not `nil`, its contents will appear between each field. If the output
record separator (`$\`) is not `nil`, it will be appended to the output. If no
arguments are given, prints `$_`. Objects that aren't strings will be
converted by calling their `to_s` method.

    print "cat", [1,2,3], 99, "\n"
    $, = ", "
    $\ = "\n"
    print "cat", [1,2,3], 99

*produces:*

    cat12399
    cat, 1, 2, 3, 99

;T;0;;;I"
print;F;I"Kernel;T;[o;;I"*::Kernel args;T;I"nil;To;;I"nEquivalent to:
    io.write(sprintf(string, obj, ...))

or
    $stdout.write(sprintf(string, obj, ...))

;T;0;;;I"printf;F;I"Kernel;T;[o;;I",::IO arg0, ::String arg1, *untyped args;T;I"nil;To;;I"!::String arg1, *untyped args;T;I"nil;To;;I" ;F;I"nil;To;;I"Equivalent to Proc.new.

;T;0;;;I"	proc;F;I"Kernel;T;[o;;I" ;F;I"	Proc;To;;I"sEquivalent to Proc.new, except the resulting Proc objects check the number of
parameters passed when called.

;T;0;;;I"lambda;F;I"Kernel;T;[o;;I" ;F;I"	Proc;To;;I"ŠEquivalent to:

    $stdout.putc(int)

Refer to the documentation for IO#putc for important information regarding
multi-byte characters.

;T;0;;;I"	putc;F;I"Kernel;T;[o;;I"::Integer arg0;T;I"Integer;To;;I"::String arg0;T;I"String;To;;I"0Equivalent to

    $stdout.puts(obj, ...)

;T;0;;;I"	puts;F;I"Kernel;T;[o;;I"*untyped arg0;T;I"NilClass;To;;I"ÜFor each object, directly writes *obj*.`inspect` followed by a newline to the
program's standard output.

    S = Struct.new(:name, :state)
    s = S['dave', 'TX']
    p s

*produces:*

    #<S name="dave", state="TX">

;T;0;;;I"p;F;I"Kernel;T;[o;;I"T arg0;T;I"T;Fo;;I"*untyped arg0;T;I"Array[untyped];To;;I"@prints arguments in pretty form.

pp returns argument(s).

;T;0;;;I"pp;F;I"Kernel;T;[o;;I"T arg0;T;I"T;Fo;;I"*untyped arg0;T;I"Array[untyped];To;;I"5If called without an argument, or if `max.to_i.abs == 0`, rand returns a
pseudo-random floating point number between 0.0 and 1.0, including 0.0 and
excluding 1.0.

    rand        #=> 0.2725926052826416

When `max.abs` is greater than or equal to 1, `rand` returns a pseudo-random
integer greater than or equal to 0 and less than `max.to_i.abs`.

    rand(100)   #=> 12

When `max` is a Range, `rand` returns a random number where
range.member?(number) == true.

Negative or floating point values for `max` are allowed, but may give
surprising results.

    rand(-100) # => 87
    rand(-0.5) # => 0.8130921818028143
    rand(1.9)  # equivalent to rand(1), which is always 0

Kernel.srand may be used to ensure that sequences of random numbers are
reproducible between different runs of a program.

See also Random.rand.

;T;0;;;I"	rand;F;I"Kernel;T;[	o;;I" ;F;I"
Float;To;;I"::Integer arg0;T;I"Integer;To;;I"::Range[::Integer] arg0;T;I"Integer;To;;I"::Range[::Float] arg0;T;I"
Float;To;;I"VEquivalent to Kernel::gets, except `readline` raises `EOFError` at end of
file.

;T;0;;;I"readline;F;I"Kernel;T;[o;;I"$?::String arg0, ?::Integer arg1;T;I"String;To;;I"lReturns an array containing the lines returned by calling `Kernel.gets(*sep*)`
until the end of file.

;T;0;;;I"readlines;F;I"Kernel;T;[o;;I"$?::String arg0, ?::Integer arg1;T;I"Array[::String];To;;I"gLoads the given `name`, returning `true` if successful and `false` if the
feature is already loaded.

If the filename neither resolves to an absolute path nor starts with './' or
'../', the file will be searched for in the library directories listed in
`$LOAD_PATH` (`$:`). If the filename starts with './' or '../', resolution is
based on Dir.pwd.

If the filename has the extension ".rb", it is loaded as a source file; if the
extension is ".so", ".o", or ".dll", or the default shared library extension
on the current platform, Ruby loads the shared library as a Ruby extension.
Otherwise, Ruby tries adding ".rb", ".so", and so on to the name until found.
If the file named cannot be found, a LoadError will be raised.

For Ruby extensions the filename given may use any shared library extension.
For example, on Linux the socket extension is "socket.so" and `require
'socket.dll'` will load the socket extension.

The absolute path of the loaded file is added to `$LOADED_FEATURES` (`$"`).  A
file will not be loaded again if its path already appears in `$"`.  For
example, `require 'a'; require './a'` will not load `a.rb` again.

    require "my-library.rb"
    require "db-driver"

Any constants or globals within the loaded source file will be available in
the calling program's global namespace. However, local variables will not be
propagated to the loading environment.

;T;0;;;I"require;F;I"Kernel;T;[o;;I"::String path;T;I"	bool;To;;I"ÒRuby tries to load the library named *string* relative to the requiring file's
path.  If the file's path cannot be determined a LoadError is raised. If a
file is loaded `true` is returned and false otherwise.

;T;0;;;I"require_relative;F;I"Kernel;T;[o;;I"::String feature;T;I"	bool;To;;I"áCalls select(2) system call. It monitors given arrays of IO objects, waits
until one or more of IO objects are ready for reading, are ready for writing,
and have pending exceptions respectively, and returns an array that contains
arrays of those IO objects.  It will return `nil` if optional *timeout* value
is given and no IO object is ready in *timeout* seconds.

IO.select peeks the buffer of IO objects for testing readability. If the IO
buffer is not empty, IO.select immediately notifies readability.  This "peek"
only happens for IO objects.  It does not happen for IO-like objects such as
OpenSSL::SSL::SSLSocket.

The best way to use IO.select is invoking it after nonblocking methods such as
#read_nonblock, #write_nonblock, etc.  The methods raise an exception which is
extended by IO::WaitReadable or IO::WaitWritable.  The modules notify how the
caller should wait with IO.select.  If IO::WaitReadable is raised, the caller
should wait for reading.  If IO::WaitWritable is raised, the caller should
wait for writing.

So, blocking read (#readpartial) can be emulated using #read_nonblock and
IO.select as follows:

    begin
      result = io_like.read_nonblock(maxlen)
    rescue IO::WaitReadable
      IO.select([io_like])
      retry
    rescue IO::WaitWritable
      IO.select(nil, [io_like])
      retry
    end

Especially, the combination of nonblocking methods and IO.select is preferred
for IO like objects such as OpenSSL::SSL::SSLSocket.  It has #to_io method to
return underlying IO object.  IO.select calls #to_io to obtain the file
descriptor to wait.

This means that readability notified by IO.select doesn't mean readability
from OpenSSL::SSL::SSLSocket object.

The most likely situation is that OpenSSL::SSL::SSLSocket buffers some data.
IO.select doesn't see the buffer.  So IO.select can block when
OpenSSL::SSL::SSLSocket#readpartial doesn't block.

However, several more complicated situations exist.

SSL is a protocol which is sequence of records. The record consists of
multiple bytes. So, the remote side of SSL sends a partial record, IO.select
notifies readability but OpenSSL::SSL::SSLSocket cannot decrypt a byte and
OpenSSL::SSL::SSLSocket#readpartial will block.

Also, the remote side can request SSL renegotiation which forces the local SSL
engine to write some data. This means OpenSSL::SSL::SSLSocket#readpartial may
invoke #write system call and it can block. In such a situation,
OpenSSL::SSL::SSLSocket#read_nonblock raises IO::WaitWritable instead of
blocking. So, the caller should wait for ready for writability as above
example.

The combination of nonblocking methods and IO.select is also useful for
streams such as tty, pipe socket socket when multiple processes read from a
stream.

Finally, Linux kernel developers don't guarantee that readability of select(2)
means readability of following read(2) even for a single process. See
select(2) manual on GNU/Linux system.

Invoking IO.select before IO#readpartial works well as usual. However it is
not the best way to use IO.select.

The writability notified by select(2) doesn't show how many bytes are
writable. IO#write method blocks until given whole string is written. So,
`IO#write(two or more bytes)` can block after writability is notified by
IO.select.  IO#write_nonblock is required to avoid the blocking.

Blocking write (#write) can be emulated using #write_nonblock and IO.select as
follows: IO::WaitReadable should also be rescued for SSL renegotiation in
OpenSSL::SSL::SSLSocket.

    while 0 < string.bytesize
      begin
        written = io_like.write_nonblock(string)
      rescue IO::WaitReadable
        IO.select([io_like])
        retry
      rescue IO::WaitWritable
        IO.select(nil, [io_like])
        retry
      end
      string = string.byteslice(written..-1)
    end

### Parameters
read_array
:   an array of IO objects that wait until ready for read
write_array
:   an array of IO objects that wait until ready for write
error_array
:   an array of IO objects that wait for exceptions
timeout
:   a numeric value in second


### Example

    rp, wp = IO.pipe
    mesg = "ping "
    100.times {
      # IO.select follows IO#read.  Not the best way to use IO.select.
      rs, ws, = IO.select([rp], [wp])
      if r = rs[0]
        ret = r.read(5)
        print ret
        case ret
        when /ping/
          mesg = "pong\n"
        when /pong/
          mesg = "ping "
        end
      end
      if w = ws[0]
        w.write(mesg)
      end
    }

*produces:*

    ping pong
    ping pong
    ping pong
    (snipped)
    ping

;T;0;;;I"select;F;I"Kernel;T;[o;;I"W::Array[::IO] read, ?::Array[::IO] write, ?::Array[::IO] error, ?::Integer timeout;T;I"Array[::String];To;;I"ëSuspends the current thread for *duration* seconds (which may be any number,
including a `Float` with fractional seconds). Returns the actual number of
seconds slept (rounded), which may be less than that asked for if another
thread calls Thread#run. Called without an argument, sleep() will sleep
forever.

    Time.new    #=> 2008-03-08 19:56:19 +0900
    sleep 1.2   #=> 1
    Time.new    #=> 2008-03-08 19:56:20 +0900
    sleep 1.9   #=> 2
    Time.new    #=> 2008-03-08 19:56:22 +0900

;T;0;;;I"
sleep;F;I"Kernel;T;[o;;I" ;F;I"bot;To;;I"5::Integer | ::Float | ::Kernel::_Divmod duration;T;I"Integer;To;;I"ÀCalls the operating system function identified by *num* and returns the result
of the function or raises SystemCallError if it failed.

Arguments for the function can follow *num*. They must be either `String`
objects or `Integer` objects. A `String` object is passed as a pointer to the
byte sequence. An `Integer` object is passed as an integer whose bit size is
the same as a pointer. Up to nine parameters may be passed.

The function identified by *num* is system dependent. On some Unix systems,
the numbers may be obtained from a header file called `syscall.h`.

    syscall 4, 1, "hello\n", 6   # '4' is write(2) on our box

*produces:*

    hello

Calling `syscall` on a platform which does not have any way to an arbitrary
system function just fails with NotImplementedError.

**Note:** `syscall` is essentially unsafe and unportable. Feel free to shoot
your foot. The DL (Fiddle) library is preferred for safer and a bit more
portable programming.

;T;0;;;I"syscall;F;I"Kernel;T;[o;;I"!::Integer num, *untyped args;T;I"untyped;To;;I"ä	Uses the character `cmd` to perform various tests on `file1` (first table
below) or on `file1` and `file2` (second table).

File tests on a single file:

    Cmd    Returns   Meaning
    "A"  | Time    | Last access time for file1
    "b"  | boolean | True if file1 is a block device
    "c"  | boolean | True if file1 is a character device
    "C"  | Time    | Last change time for file1
    "d"  | boolean | True if file1 exists and is a directory
    "e"  | boolean | True if file1 exists
    "f"  | boolean | True if file1 exists and is a regular file
    "g"  | boolean | True if file1 has the \CF{setgid} bit
         |         | set (false under NT)
    "G"  | boolean | True if file1 exists and has a group
         |         | ownership equal to the caller's group
    "k"  | boolean | True if file1 exists and has the sticky bit set
    "l"  | boolean | True if file1 exists and is a symbolic link
    "M"  | Time    | Last modification time for file1
    "o"  | boolean | True if file1 exists and is owned by
         |         | the caller's effective uid
    "O"  | boolean | True if file1 exists and is owned by
         |         | the caller's real uid
    "p"  | boolean | True if file1 exists and is a fifo
    "r"  | boolean | True if file1 is readable by the effective
         |         | uid/gid of the caller
    "R"  | boolean | True if file is readable by the real
         |         | uid/gid of the caller
    "s"  | int/nil | If file1 has nonzero size, return the size,
         |         | otherwise return nil
    "S"  | boolean | True if file1 exists and is a socket
    "u"  | boolean | True if file1 has the setuid bit set
    "w"  | boolean | True if file1 exists and is writable by
         |         | the effective uid/gid
    "W"  | boolean | True if file1 exists and is writable by
         |         | the real uid/gid
    "x"  | boolean | True if file1 exists and is executable by
         |         | the effective uid/gid
    "X"  | boolean | True if file1 exists and is executable by
         |         | the real uid/gid
    "z"  | boolean | True if file1 exists and has a zero length

Tests that take two files:

    "-"  | boolean | True if file1 and file2 are identical
    "="  | boolean | True if the modification times of file1
         |         | and file2 are equal
    "<"  | boolean | True if the modification time of file1
         |         | is prior to that of file2
    ">"  | boolean | True if the modification time of file1
         |         | is after that of file2

;T;0;;;I"	test;F;I"Kernel;T;[o;;I"L::String | ::Integer cmd, ::String | ::IO file1, ?::String | ::IO file2;T;I"8TrueClass | ::FalseClass | ::Time | nil | ::Integer;To;;I"&Transfers control to the end of the active `catch` block waiting for *tag*.
Raises `UncaughtThrowError` if there is no `catch` block for the *tag*. The
optional second parameter supplies a return value for the `catch` block, which
otherwise defaults to `nil`. For examples, see Kernel::catch.

;T;0;;;I"
throw;F;I"Kernel;T;[o;;I"::Object tag, ?untyped obj;T;I"bot;To;;I")If warnings have been disabled (for example with the `-W0` flag), does
nothing.  Otherwise, converts each of the messages to strings, appends a
newline character to the string if the string does not end in a newline, and
calls Warning.warn with the string.

      warn("warning 1", "warning 2")

    <em>produces:</em>

      warning 1
      warning 2

If the `uplevel` keyword argument is given, the string will be prepended with
information for the given caller frame in the same format used by the
`rb_warn` C function.

      # In baz.rb
      def foo
        warn("invalid call to foo", uplevel: 1)
      end

      def bar
        foo
      end

      bar

    <em>produces:</em>

      baz.rb:6: warning: invalid call to foo

If `category` keyword argument is given, passes the category to
`Warning.warn`.  The category given must be be one of the following
categories:

:deprecated
:   Used for warning for deprecated functionality that may be removed in the
    future.
:experimental
:   Used for experimental features that may change in future releases.

;T;0;;;I"	warn;F;I"Kernel;T;[o;;I",*untyped msg, ?uplevel: ::Integer | nil;T;I"NilClass;To;;I"&
Replaces the current process by running the given external *command*, which
can take one of the following forms:

`exec(commandline)`
:   command line string which is passed to the standard shell
`exec(cmdname, arg1, ...)`
:   command name and one or more arguments (no shell)
`exec([cmdname, argv0], arg1, ...)`
:   command name, [argv](0) and zero or more arguments (no shell)


In the first form, the string is taken as a command line that is subject to
shell expansion before being executed.

The standard shell always means `"/bin/sh"` on Unix-like systems, otherwise,
`ENV["RUBYSHELL"]` or `ENV["COMSPEC"]` on Windows and similar.  The command is
passed as an argument to the `"-c"` switch to the shell, except in the case of
`COMSPEC`.

If the string from the first form (`exec("command")`) follows these simple
rules:

*   no meta characters
*   not starting with shell reserved word or special built-in
*   Ruby invokes the command directly without shell


You can force shell invocation by adding ";" to the string (because ";" is a
meta character).

Note that this behavior is observable by pid obtained (return value of spawn()
and IO#pid for IO.popen) is the pid of the invoked command, not shell.

In the second form (`exec("command1", "arg1", ...)`), the first is taken as a
command name and the rest are passed as parameters to command with no shell
expansion.

In the third form (`exec(["command", "argv0"], "arg1", ...)`), starting a
two-element array at the beginning of the command, the first element is the
command to be executed, and the second argument is used as the `argv[0]`
value, which may show up in process listings.

In order to execute the command, one of the `exec(2)` system calls are used,
so the running command may inherit some of the environment of the original
program (including open file descriptors).

This behavior is modified by the given `env` and `options` parameters. See
::spawn for details.

If the command fails to execute (typically Errno::ENOENT when it was not
found) a SystemCallError exception is raised.

This method modifies process attributes according to given `options` before
`exec(2)` system call. See ::spawn for more details about the given `options`.

The modified attributes may be retained when `exec(2)` system call fails.

For example, hard resource limits are not restorable.

Consider to create a child process using ::spawn or Kernel#system if this is
not acceptable.

    exec "echo *"       # echoes list of files in current directory
    # never get here

    exec "echo", "*"    # echoes an asterisk
    # never get here

;T;0;;;I"	exec;F;I"Kernel;T;[o;;I"*::String args;T;I"bot;To;;I"V*spawn executes specified command and return its pid.

    pid = spawn("tar xf ruby-2.0.0-p195.tar.bz2")
    Process.wait pid

    pid = spawn(RbConfig.ruby, "-eputs'Hello, world!'")
    Process.wait pid

This method is similar to Kernel#system but it doesn't wait for the command to
finish.

The parent process should use Process.wait to collect the termination status
of its child or use Process.detach to register disinterest in their status;
otherwise, the operating system may accumulate zombie processes.

spawn has bunch of options to specify process attributes:

    env: hash
      name => val : set the environment variable
      name => nil : unset the environment variable

      the keys and the values except for +nil+ must be strings.
    command...:
      commandline                 : command line string which is passed to the standard shell
      cmdname, arg1, ...          : command name and one or more arguments (This form does not use the shell. See below for caveats.)
      [cmdname, argv0], arg1, ... : command name, argv[0] and zero or more arguments (no shell)
    options: hash
      clearing environment variables:
        :unsetenv_others => true   : clear environment variables except specified by env
        :unsetenv_others => false  : don't clear (default)
      process group:
        :pgroup => true or 0 : make a new process group
        :pgroup => pgid      : join the specified process group
        :pgroup => nil       : don't change the process group (default)
      create new process group: Windows only
        :new_pgroup => true  : the new process is the root process of a new process group
        :new_pgroup => false : don't create a new process group (default)
      resource limit: resourcename is core, cpu, data, etc.  See Process.setrlimit.
        :rlimit_resourcename => limit
        :rlimit_resourcename => [cur_limit, max_limit]
      umask:
        :umask => int
      redirection:
        key:
          FD              : single file descriptor in child process
          [FD, FD, ...]   : multiple file descriptor in child process
        value:
          FD                        : redirect to the file descriptor in parent process
          string                    : redirect to file with open(string, "r" or "w")
          [string]                  : redirect to file with open(string, File::RDONLY)
          [string, open_mode]       : redirect to file with open(string, open_mode, 0644)
          [string, open_mode, perm] : redirect to file with open(string, open_mode, perm)
          [:child, FD]              : redirect to the redirected file descriptor
          :close                    : close the file descriptor in child process
        FD is one of follows
          :in     : the file descriptor 0 which is the standard input
          :out    : the file descriptor 1 which is the standard output
          :err    : the file descriptor 2 which is the standard error
          integer : the file descriptor of specified the integer
          io      : the file descriptor specified as io.fileno
      file descriptor inheritance: close non-redirected non-standard fds (3, 4, 5, ...) or not
        :close_others => false  : inherit
      current directory:
        :chdir => str

The `cmdname, arg1, ...` form does not use the shell. However, on different
OSes, different things are provided as built-in commands. An example of this
is +'echo'+, which is a built-in on Windows, but is a normal program on Linux
and Mac OS X. This means that `Process.spawn 'echo', '%Path%'` will display
the contents of the `%Path%` environment variable on Windows, but
`Process.spawn 'echo', '$PATH'` prints the literal `$PATH`.

If a hash is given as `env`, the environment is updated by `env` before
`exec(2)` in the child process. If a pair in `env` has nil as the value, the
variable is deleted.

    # set FOO as BAR and unset BAZ.
    pid = spawn({"FOO"=>"BAR", "BAZ"=>nil}, command)

If a hash is given as `options`, it specifies process group, create new
process group, resource limit, current directory, umask and redirects for the
child process. Also, it can be specified to clear environment variables.

The `:unsetenv_others` key in `options` specifies to clear environment
variables, other than specified by `env`.

    pid = spawn(command, :unsetenv_others=>true) # no environment variable
    pid = spawn({"FOO"=>"BAR"}, command, :unsetenv_others=>true) # FOO only

The `:pgroup` key in `options` specifies a process group. The corresponding
value should be true, zero, a positive integer, or nil. true and zero cause
the process to be a process leader of a new process group. A non-zero positive
integer causes the process to join the provided process group. The default
value, nil, causes the process to remain in the same process group.

    pid = spawn(command, :pgroup=>true) # process leader
    pid = spawn(command, :pgroup=>10) # belongs to the process group 10

The `:new_pgroup` key in `options` specifies to pass
`CREATE_NEW_PROCESS_GROUP` flag to `CreateProcessW()` that is Windows API.
This option is only for Windows. true means the new process is the root
process of the new process group. The new process has CTRL+C disabled. This
flag is necessary for `Process.kill(:SIGINT, pid)` on the subprocess.
:new_pgroup is false by default.

    pid = spawn(command, :new_pgroup=>true)  # new process group
    pid = spawn(command, :new_pgroup=>false) # same process group

The `:rlimit_`*foo* key specifies a resource limit. *foo* should be one of
resource types such as `core`. The corresponding value should be an integer or
an array which have one or two integers: same as cur_limit and max_limit
arguments for Process.setrlimit.

    cur, max = Process.getrlimit(:CORE)
    pid = spawn(command, :rlimit_core=>[0,max]) # disable core temporary.
    pid = spawn(command, :rlimit_core=>max) # enable core dump
    pid = spawn(command, :rlimit_core=>0) # never dump core.

The `:umask` key in `options` specifies the umask.

    pid = spawn(command, :umask=>077)

The :in, :out, :err, an integer, an IO and an array key specifies a
redirection. The redirection maps a file descriptor in the child process.

For example, stderr can be merged into stdout as follows:

    pid = spawn(command, :err=>:out)
    pid = spawn(command, 2=>1)
    pid = spawn(command, STDERR=>:out)
    pid = spawn(command, STDERR=>STDOUT)

The hash keys specifies a file descriptor in the child process started by
#spawn. :err, 2 and STDERR specifies the standard error stream (stderr).

The hash values specifies a file descriptor in the parent process which
invokes #spawn. :out, 1 and STDOUT specifies the standard output stream
(stdout).

In the above example, the standard output in the child process is not
specified. So it is inherited from the parent process.

The standard input stream (stdin) can be specified by :in, 0 and STDIN.

A filename can be specified as a hash value.

    pid = spawn(command, :in=>"/dev/null") # read mode
    pid = spawn(command, :out=>"/dev/null") # write mode
    pid = spawn(command, :err=>"log") # write mode
    pid = spawn(command, [:out, :err]=>"/dev/null") # write mode
    pid = spawn(command, 3=>"/dev/null") # read mode

For stdout and stderr (and combination of them), it is opened in write mode.
Otherwise read mode is used.

For specifying flags and permission of file creation explicitly, an array is
used instead.

    pid = spawn(command, :in=>["file"]) # read mode is assumed
    pid = spawn(command, :in=>["file", "r"])
    pid = spawn(command, :out=>["log", "w"]) # 0644 assumed
    pid = spawn(command, :out=>["log", "w", 0600])
    pid = spawn(command, :out=>["log", File::WRONLY|File::EXCL|File::CREAT, 0600])

The array specifies a filename, flags and permission. The flags can be a
string or an integer. If the flags is omitted or nil, File::RDONLY is assumed.
The permission should be an integer. If the permission is omitted or nil, 0644
is assumed.

If an array of IOs and integers are specified as a hash key, all the elements
are redirected.

    # stdout and stderr is redirected to log file.
    # The file "log" is opened just once.
    pid = spawn(command, [:out, :err]=>["log", "w"])

Another way to merge multiple file descriptors is [:child, fd]. [:child, fd]
means the file descriptor in the child process. This is different from fd. For
example, :err=>:out means redirecting child stderr to parent stdout. But
:err=>[:child, :out] means redirecting child stderr to child stdout. They
differ if stdout is redirected in the child process as follows.

    # stdout and stderr is redirected to log file.
    # The file "log" is opened just once.
    pid = spawn(command, :out=>["log", "w"], :err=>[:child, :out])

[:child, :out] can be used to merge stderr into stdout in IO.popen. In this
case, IO.popen redirects stdout to a pipe in the child process and [:child,
:out] refers the redirected stdout.

    io = IO.popen(["sh", "-c", "echo out; echo err >&2", :err=>[:child, :out]])
    p io.read #=> "out\nerr\n"

The `:chdir` key in `options` specifies the current directory.

    pid = spawn(command, :chdir=>"/var/tmp")

spawn closes all non-standard unspecified descriptors by default. The
"standard" descriptors are 0, 1 and 2. This behavior is specified by
:close_others option. :close_others doesn't affect the standard descriptors
which are closed only if :close is specified explicitly.

    pid = spawn(command, :close_others=>true)  # close 3,4,5,... (default)
    pid = spawn(command, :close_others=>false) # don't close 3,4,5,...

:close_others is false by default for spawn and IO.popen.

Note that fds which close-on-exec flag is already set are closed regardless of
:close_others option.

So IO.pipe and spawn can be used as IO.popen.

    # similar to r = IO.popen(command)
    r, w = IO.pipe
    pid = spawn(command, :out=>w)   # r, w is closed in the child process.
    w.close

:close is specified as a hash value to close a fd individually.

    f = open(foo)
    system(command, f=>:close)        # don't inherit f.

If a file descriptor need to be inherited, io=>io can be used.

    # valgrind has --log-fd option for log destination.
    # log_w=>log_w indicates log_w.fileno inherits to child process.
    log_r, log_w = IO.pipe
    pid = spawn("valgrind", "--log-fd=#{log_w.fileno}", "echo", "a", log_w=>log_w)
    log_w.close
    p log_r.read

It is also possible to exchange file descriptors.

    pid = spawn(command, :out=>:err, :err=>:out)

The hash keys specify file descriptors in the child process. The hash values
specifies file descriptors in the parent process. So the above specifies
exchanging stdout and stderr. Internally, `spawn` uses an extra file
descriptor to resolve such cyclic file descriptor mapping.

See Kernel.exec for the standard shell.

;T;0;;;I"
spawn;F;I"Kernel;T;[o;;I"í::String command, *::String args, ?unsetenv_others: ::boolish, ?pgroup: true | ::Integer, ?umask: ::Integer, ?in: ::Kernel::redirect_fd, ?out: ::Kernel::redirect_fd, ?err: ::Kernel::redirect_fd, ?close_others: ::boolish, ?chdir: ::String;T;I"Integer;To;;I"::Hash[::string, ::string?] env, ::String command, *::String args, ?unsetenv_others: ::boolish, ?pgroup: true | ::Integer, ?umask: ::Integer, ?in: ::Kernel::redirect_fd, ?out: ::Kernel::redirect_fd, ?err: ::Kernel::redirect_fd, ?close_others: ::boolish, ?chdir: ::String;T;I"Integer;To;;I"ÖExecutes *command...* in a subshell. *command...* is one of following forms.

`commandline`
:   command line string which is passed to the standard shell
`cmdname, arg1, ...`
:   command name and one or more arguments (no shell)
`[cmdname, argv0], arg1, ...`
:   command name, `argv[0]` and zero or more arguments (no shell)


system returns `true` if the command gives zero exit status, `false` for non
zero exit status. Returns `nil` if command execution fails. An error status is
available in `$?`.

If the `exception: true` argument is passed, the method raises an exception
instead of returning `false` or `nil`.

The arguments are processed in the same way as for Kernel#spawn.

The hash arguments, env and options, are same as #exec and #spawn. See
Kernel#spawn for details.

    system("echo *")
    system("echo", "*")

*produces:*

    config.h main.rb
    *

Error handling:

    system("cat nonexistent.txt")
    # => false
    system("catt nonexistent.txt")
    # => nil

    system("cat nonexistent.txt", exception: true)
    # RuntimeError (Command failed with exit 1: cat)
    system("catt nonexistent.txt", exception: true)
    # Errno::ENOENT (No such file or directory - catt)

See Kernel#exec for the standard shell.

;T;0;;;I"system;F;I"Kernel;T;[o;;I"í::String command, *::String args, ?unsetenv_others: ::boolish, ?pgroup: true | ::Integer, ?umask: ::Integer, ?in: ::Kernel::redirect_fd, ?out: ::Kernel::redirect_fd, ?err: ::Kernel::redirect_fd, ?close_others: ::boolish, ?chdir: ::String;T;I"*NilClass | ::FalseClass | ::TrueClass;To;;I"::Hash[::string, ::string?] env, ::String command, *::String args, ?unsetenv_others: ::boolish, ?pgroup: true | ::Integer, ?umask: ::Integer, ?in: ::Kernel::redirect_fd, ?out: ::Kernel::redirect_fd, ?err: ::Kernel::redirect_fd, ?close_others: ::boolish, ?chdir: ::String;T;I"*NilClass | ::FalseClass | ::TrueClass;To;;0;0;	I"Kernel;T;
[ ;[ ;0;[ ;[ o;;I"6Returns the \BigDecimal converted from +value+
    with a precision of +ndigits+ decimal digits.

    When +ndigits+ is less than the number of significant digits
    in the value, the result is rounded to that number of digits,
    according to the current rounding mode; see BigDecimal.mode.

Returns `value` converted to a BigDecimal, depending on the type of `value`:

*   Integer, Float, Rational, Complex, or BigDecimal: converted directly:

        # Integer, Complex, or BigDecimal value does not require ndigits; ignored if given.
        BigDecimal(2)                     # => 0.2e1
        BigDecimal(Complex(2, 0))         # => 0.2e1
        BigDecimal(BigDecimal(2))         # => 0.2e1
        # Float or Rational value requires ndigits.
        BigDecimal(2.0, 0)                # => 0.2e1
        BigDecimal(Rational(2, 1), 0)     # => 0.2e1

*   String: converted by parsing if it contains an integer or floating-point
    literal; leading and trailing whitespace is ignored:

        # String does not require ndigits; ignored if given.
        BigDecimal('2')     # => 0.2e1
        BigDecimal('2.0')   # => 0.2e1
        BigDecimal('0.2e1') # => 0.2e1
        BigDecimal(' 2.0 ') # => 0.2e1

*   Other type that responds to method `:to_str`: first converted to a string,
    then converted to a BigDecimal, as above.

*   Other type:

    *   Raises an exception if keyword argument `exception` is `true`.
    *   Returns `nil` if keyword argument `exception` is `true`.



Raises an exception if `value` evaluates to a Float and `digits` is larger
than Float::DIG + 1.

;T;0;;;I"BigDecimal;F;I"Kernel;T;[o;;I"N::real | ::string | ::BigDecimal initial, ?::int digits, ?exception: bool;T;I"BigDecimal;To;;0;0;	I"Kernel;T;
[ ;[ ;0;[ ;[ o;;I"´Describe a series of expectations for a given target `desc`.

Defines a test class subclassing from either Minitest::Spec or from the
surrounding describe's class. The surrounding class may subclass
Minitest::Spec manually in order to easily share code:

    class MySpec < Minitest::Spec
      # ... shared code ...
    end

    class TestStuff < MySpec
      it "does stuff" do
        # shared code available here
      end
      describe "inner stuff" do
        it "still does stuff" do
          # ...and here
        end
      end
    end

For more information on getting started with writing specs, see:

http://www.rubyinside.com/a-minitestspec-tutorial-elegant-spec-style-testing-t
hat-comes-with-ruby-5354.html

For some suggestions on how to improve your specs, try:

http://betterspecs.org

but do note that several items there are debatable or specific to rspec.

For more information about expectations, see Minitest::Expectations.

;T;0;;;I"describe;F;I"Kernel;T;[o;;I"+untyped desc, *untyped additional_desc;T;I"untyped;To;;0;0;	I"Kernel;T;
[ ;[ ;0;[ ;[ o;;I">Creates a new Pathname object from the given string, `path`, and returns
pathname object.

In order to use this constructor, you must first require the Pathname standard
library extension.

    require 'pathname'
    Pathname("/home/zzak")
    #=> #<Pathname:/home/zzak>

See also Pathname::new for more information.

;T;0;;;I"Pathname;F;I"Kernel;T;[o;;I"::String | ::Pathname;T;I"Pathname;To;;0;0;	I"Kernel;T;
[ ;[ ;0;[ ;[ o;;I"0Returns `uri` converted to an URI object.

;T;0;;;I"URI;F;I"Kernel;T;[o;;I""::URI::Generic | ::String uri;T;I"URI::Generic;To;;I"»The marshaling library converts collections of Ruby objects into a byte
stream, allowing them to be stored outside the currently active script. This
data may subsequently be read and the original objects reconstituted.

Marshaled data has major and minor version numbers stored along with the
object information. In normal use, marshaling can only load data written with
the same major version number and an equal or lower minor version number. If
Ruby's ``verbose'' flag is set (normally using -d, -v, -w, or --verbose) the
major and minor numbers must match exactly. Marshal versioning is independent
of Ruby's version numbers. You can extract the version by reading the first
two bytes of marshaled data.

    str = Marshal.dump("thing")
    RUBY_VERSION   #=> "1.9.0"
    str[0].ord     #=> 4
    str[1].ord     #=> 8

Some objects cannot be dumped: if the objects to be dumped include bindings,
procedure or method objects, instances of class IO, or singleton objects, a
TypeError will be raised.

If your class has special serialization needs (for example, if you want to
serialize in some specific format), or if it contains objects that would
otherwise not be serializable, you can implement your own serialization
strategy.

There are two methods of doing this, your object can define either
marshal_dump and marshal_load or _dump and _load.  marshal_dump will take
precedence over _dump if both are defined.  marshal_dump may result in smaller
Marshal strings.

## Security considerations

By design, Marshal.load can deserialize almost any class loaded into the Ruby
process. In many cases this can lead to remote code execution if the Marshal
data is loaded from an untrusted source.

As a result, Marshal.load is not suitable as a general purpose serialization
format and you should never unmarshal user supplied input or other untrusted
data.

If you need to deserialize untrusted data, use JSON or another serialization
format that is only able to load simple, 'primitive' types such as String,
Array, Hash, etc. Never allow user input to specify arbitrary types to
deserialize into.

## marshal_dump and marshal_load

When dumping an object the method marshal_dump will be called. marshal_dump
must return a result containing the information necessary for marshal_load to
reconstitute the object.  The result can be any object.

When loading an object dumped using marshal_dump the object is first allocated
then marshal_load is called with the result from marshal_dump. marshal_load
must recreate the object from the information in the result.

Example:

    class MyObj
      def initialize name, version, data
        @name    = name
        @version = version
        @data    = data
      end

      def marshal_dump
        [@name, @version]
      end

      def marshal_load array
        @name, @version = array
      end
    end

## _dump and _load

Use _dump and _load when you need to allocate the object you're restoring
yourself.

When dumping an object the instance method _dump is called with an Integer
which indicates the maximum depth of objects to dump (a value of -1 implies
that you should disable depth checking).  _dump must return a String
containing the information necessary to reconstitute the object.

The class method _load should take a String and use it to return an object of
the same class.

Example:

    class MyObj
      def initialize name, version, data
        @name    = name
        @version = version
        @data    = data
      end

      def _dump level
        [@name, @version].join ':'
      end

      def self._load args
        new(*args.split(':'))
      end
    end

Since Marshal.dump outputs a string you can have _dump return a Marshal string
which is Marshal.loaded in _load for complex objects.

;T;0;	I"Marshal;T;
[ ;[ ;0;[ ;[ o;;I"iSerializes obj and all descendant objects. If anIO is specified, the
serialized data will be written to it, otherwise the data will be returned as
a String. If limit is specified, the traversal of subobjects will be limited
to that depth. If limit is negative, no checking of depth will be performed.

    class Klass
      def initialize(str)
        @str = str
      end
      def say_hello
        @str
      end
    end

(produces no output)

    o = Klass.new("hello\n")
    data = Marshal.dump(o)
    obj = Marshal.load(data)
    obj.say_hello  #=> "hello\n"

Marshal can't dump following objects:
*   anonymous Class/Module.
*   objects which are related to system (ex: Dir, File::Stat, IO, File, Socket
    and so on)
*   an instance of MatchData, Data, Method, UnboundMethod, Proc, Thread,
    ThreadGroup, Continuation
*   objects which define singleton methods

;T;0;;;I"	dump;F;I"Marshal;T;[o;;I"0untyped obj, untyped port, ?::Integer limit;T;I"untyped;To;;I""untyped obj, ?::Integer limit;T;I"String;To;;I"~Returns the result of converting the serialized data in source into a Ruby
object (possibly with associated subordinate objects). source may be either an
instance of IO or an object that responds to to_str. If proc is specified,
each object will be passed to the proc, as the object is being deserialized.

Never pass untrusted data (including user supplied input) to this method.
Please see the overview for further details.

If the `freeze: true` argument is passed, deserialized object would be deeply
frozen. Note that it may lead to more efficient memory usage due to frozen
strings deduplication:

    serialized = Marshal.dump(['value1', 'value2', 'value1', 'value2'])

    deserialized = Marshal.load(serialized)
    deserialized.map(&:frozen?)
    # => [false, false, false, false]
    deserialized.map(&:object_id)
    # => [1023900, 1023920, 1023940, 1023960] -- 4 different objects

    deserialized = Marshal.load(serialized, freeze: true)
    deserialized.map(&:frozen?)
    # => [true, true, true, true]
    deserialized.map(&:object_id)
    # => [1039360, 1039380, 1039360, 1039380] -- only 2 different objects, object_ids repeating

;T;0;;;I"	load;F;I"Marshal;T;[o;;I"0::String | untyped port, ?freeze: ::boolish;T;I"untyped;To;;I"A::String | untyped port, ^(untyped) -> A, ?freeze: ::boolish;T;I"A;Fo; ;I"MatchData encapsulates the result of matching a Regexp against string. It is
returned by Regexp#match and String#match, and also stored in a global
variable returned by Regexp.last_match.

Usage:

    url = 'https://docs.ruby-lang.org/en/2.5.0/MatchData.html'
    m = url.match(/(\d\.?)+/)   # => #<MatchData "2.5.0" 1:"0">
    m.string                    # => "https://docs.ruby-lang.org/en/2.5.0/MatchData.html"
    m.regexp                    # => /(\d\.?)+/
    # entire matched substring:
    m[0]                        # => "2.5.0"

    # Working with unnamed captures
    m = url.match(%r{([^/]+)/([^/]+)\.html$})
    m.captures                  # => ["2.5.0", "MatchData"]
    m[1]                        # => "2.5.0"
    m.values_at(1, 2)           # => ["2.5.0", "MatchData"]

    # Working with named captures
    m = url.match(%r{(?<version>[^/]+)/(?<module>[^/]+)\.html$})
    m.captures                  # => ["2.5.0", "MatchData"]
    m.named_captures            # => {"version"=>"2.5.0", "module"=>"MatchData"}
    m[:version]                 # => "2.5.0"
    m.values_at(:version, :module)
                                # => ["2.5.0", "MatchData"]
    # Numerical indexes are working, too
    m[1]                        # => "2.5.0"
    m.values_at(1, 2)           # => ["2.5.0", "MatchData"]

## Global variables equivalence

Parts of last MatchData (returned by Regexp.last_match) are also aliased as
global variables:

*   `$~` is Regexp.last_match;
*   `$&` is Regexp.last_match`[ 0 ]`;
*   `$1`, `$2`, and so on are Regexp.last_match`[ i ]` (captures by number);
*   `$`` is Regexp.last_match`.pre_match`;
*   `$'` is Regexp.last_match`.post_match`;
*   `$+` is Regexp.last_match`[ -1 ]` (the last capture).


See also "Special global variables" section in Regexp documentation.

;T;0;	I"MatchData;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"qEquality---Two matchdata are equal if their target strings, patterns, and
matched positions are identical.

;T;0;;;I"==;F;I"MatchData;T;[o;;I"untyped other;T;I"	bool;To;;I"ÇMatch Reference -- MatchData acts as an array, and may be accessed using the
normal array indexing techniques.  `mtch[0]` is equivalent to the special
variable `$&`, and returns the entire matched string.  `mtch[1]`, `mtch[2]`,
and so on return the values of the matched backreferences (portions of the
pattern between parentheses).

    m = /(.)(.)(\d+)(\d)/.match("THX1138.")
    m          #=> #<MatchData "HX1138" 1:"H" 2:"X" 3:"113" 4:"8">
    m[0]       #=> "HX1138"
    m[1, 2]    #=> ["H", "X"]
    m[1..3]    #=> ["H", "X", "113"]
    m[-3, 2]   #=> ["X", "113"]

    m = /(?<foo>a+)b/.match("ccaaab")
    m          #=> #<MatchData "aaab" foo:"aaa">
    m["foo"]   #=> "aaa"
    m[:foo]    #=> "aaa"

;T;0;;;I"[];F;I"MatchData;T;[	o;;I"::Integer idx;T;I"String?;To;;I"&::Integer start, ::Integer length;T;I"Array[::String?];To;;I"::Range[::Integer] range;T;I"Array[::String?];To;;I"::String | ::Symbol name;T;I"String?;To;;I"\Returns the offset of the start of the *n*th element of the match array in the
string. *n* can be a string or symbol to reference a named capture.

    m = /(.)(.)(\d+)(\d)/.match("THX1138.")
    m.begin(0)       #=> 1
    m.begin(2)       #=> 2

    m = /(?<foo>.)(.)(?<bar>.)/.match("hoge")
    p m.begin(:foo)  #=> 0
    p m.begin(:bar)  #=> 2

;T;0;;;I"
begin;F;I"MatchData;T;[o;;I".::Integer | ::String | ::Symbol n_or_name;T;I"Integer?;To;;I"ÌReturns the array of captures; equivalent to `mtch.to_a[1..-1]`.

    f1,f2,f3,f4 = /(.)(.)(\d+)(\d)/.match("THX1138.").captures
    f1    #=> "H"
    f2    #=> "X"
    f3    #=> "113"
    f4    #=> "8"

;T;0;;;I"captures;F;I"MatchData;T;[o;;I" ;F;I"Array[::String?];To;;I"~Returns the offset of the character immediately following the end of the *n*th
element of the match array in the string. *n* can be a string or symbol to
reference a named capture.

    m = /(.)(.)(\d+)(\d)/.match("THX1138.")
    m.end(0)         #=> 7
    m.end(2)         #=> 3

    m = /(?<foo>.)(.)(?<bar>.)/.match("hoge")
    p m.end(:foo)    #=> 1
    p m.end(:bar)    #=> 3

;T;0;;;I"end;F;I"MatchData;T;[o;;I".::Integer | ::String | ::Symbol n_or_name;T;I"Integer?;To;;I"qEquality---Two matchdata are equal if their target strings, patterns, and
matched positions are identical.

;T;0;;;I"	eql?;F;I"MatchData;T;[o;;I"untyped other;T;I"	bool;To;;I"xProduce a hash based on the target string, regexp and matched positions of
this matchdata.

See also Object#hash.

;T;0;;;I"	hash;F;I"MatchData;T;[o;;I" ;F;I"Integer;To;;I"…Returns a printable version of *mtch*.

    puts /.$/.match("foo").inspect
    #=> #<MatchData "o">

    puts /(.)(.)(.)/.match("foo").inspect
    #=> #<MatchData "foo" 1:"f" 2:"o" 3:"o">

    puts /(.)(.)?(.)/.match("fo").inspect
    #=> #<MatchData "fo" 1:"f" 2:nil 3:"o">

    puts /(?<foo>.)(?<bar>.)(?<baz>.)/.match("hoge").inspect
    #=> #<MatchData "hog" foo:"h" bar:"o" baz:"g">

;T;0;;;I"inspect;F;I"MatchData;T;[o;;I" ;F;I"String;To;;I"‹Returns the number of elements in the match array.

    m = /(.)(.)(\d+)(\d)/.match("THX1138.")
    m.length   #=> 5
    m.size     #=> 5

;T;0;;;I"length;F;I"MatchData;T;[o;;I" ;F;I"Integer;To;;I"ôReturns a Hash using named capture.

A key of the hash is a name of the named captures. A value of the hash is a
string of last successful capture of corresponding group.

    m = /(?<a>.)(?<b>.)/.match("01")
    m.named_captures #=> {"a" => "0", "b" => "1"}

    m = /(?<a>.)(?<b>.)?/.match("0")
    m.named_captures #=> {"a" => "0", "b" => nil}

    m = /(?<a>.)(?<a>.)/.match("01")
    m.named_captures #=> {"a" => "1"}

    m = /(?<a>x)|(?<a>y)/.match("x")
    m.named_captures #=> {"a" => "x"}

;T;0;;;I"named_captures;F;I"MatchData;T;[o;;I" ;F;I"Hash[::String, ::String?];To;;I"4Returns a list of names of captures as an array of strings. This is the same
as mtch.regexp.names.

    /(?<foo>.)(?<bar>.)(?<baz>.)/.match("hoge").names
    #=> ["foo", "bar", "baz"]

    m = /(?<x>.)(?<y>.)?/.match("a") #=> #<MatchData "a" x:"a" y:nil>
    m.names                          #=> ["x", "y"]

;T;0;;;I"
names;F;I"MatchData;T;[o;;I" ;F;I"Array[::String];To;;I"tReturns the captured substring corresponding to the argument. *n* can be a
string or symbol to reference a named capture.

    m = /(.)(.)(\d+)(\d)(\w)?/.match("THX1138.")
    m.match(0)       #=> "HX1138"
    m.match(4)       #=> "8"
    m.match(5)       #=> nil

    m = /(?<foo>.)(.)(?<bar>.+)/.match("hoge")
    m.match(:foo)    #=> "h"
    m.match(:bar)    #=> "ge"

;T;0;;;I"
match;F;I"MatchData;T;[o;;I" ::int | ::String | ::Symbol;T;I"String?;To;;I"—Returns the length of the captured substring corresponding to the argument.
*n* can be a string or symbol to reference a named capture.

    m = /(.)(.)(\d+)(\d)(\w)?/.match("THX1138.")
    m.match_length(0)       #=> 6
    m.match_length(4)       #=> 1
    m.match_length(5)       #=> nil

    m = /(?<foo>.)(.)(?<bar>.+)/.match("hoge")
    m.match_length(:foo)    #=> 1
    m.match_length(:bar)    #=> 2

;T;0;;;I"match_length;F;I"MatchData;T;[o;;I" ::int | ::String | ::Symbol;T;I"Integer?;To;;I"uReturns a two-element array containing the beginning and ending offsets of the
*n*th match. *n* can be a string or symbol to reference a named capture.

    m = /(.)(.)(\d+)(\d)/.match("THX1138.")
    m.offset(0)      #=> [1, 7]
    m.offset(4)      #=> [6, 7]

    m = /(?<foo>.)(.)(?<bar>.)/.match("hoge")
    p m.offset(:foo) #=> [0, 1]
    p m.offset(:bar) #=> [2, 3]

;T;0;;;I"offset;F;I"MatchData;T;[o;;I".::Integer | ::Symbol | ::String n_or_name;T;I",[ ::Integer, ::Integer ] | [ nil, nil ];To;;I"ÊReturns the portion of the original string after the current match. Equivalent
to the special variable `$'`.

    m = /(.)(.)(\d+)(\d)/.match("THX1138: The Movie")
    m.post_match   #=> ": The Movie"

;T;0;;;I"post_match;F;I"MatchData;T;[o;;I" ;F;I"String;To;;I"¶Returns the portion of the original string before the current match.
Equivalent to the special variable `$``.

    m = /(.)(.)(\d+)(\d)/.match("THX1138.")
    m.pre_match   #=> "T"

;T;0;;;I"pre_match;F;I"MatchData;T;[o;;I" ;F;I"String;To;;I"OReturns the regexp.

    m = /a.*b/.match("abc")
    m.regexp #=> /a.*b/

;T;0;;;I"regexp;F;I"MatchData;T;[o;;I" ;F;I"Regexp;To;;I"‹Returns the number of elements in the match array.

    m = /(.)(.)(\d+)(\d)/.match("THX1138.")
    m.length   #=> 5
    m.size     #=> 5

;T;0;;;I"	size;F;I"MatchData;T;[o;;I" ;F;I"Integer;To;;I"†Returns a frozen copy of the string passed in to `match`.

    m = /(.)(.)(\d+)(\d)/.match("THX1138.")
    m.string   #=> "THX1138."

;T;0;;;I"string;F;I"MatchData;T;[o;;I" ;F;I"String;To;;I"çReturns the array of matches.

    m = /(.)(.)(\d+)(\d)/.match("THX1138.")
    m.to_a   #=> ["HX1138", "H", "X", "113", "8"]

Because `to_a` is called when expanding `*`*variable*, there's a useful
assignment shortcut for extracting matched fields. This is slightly slower
than accessing the fields directly (as an intermediate array is generated).

    all,f1,f2,f3 = * /(.)(.)(\d+)(\d)/.match("THX1138.")
    all   #=> "HX1138"
    f1    #=> "H"
    f2    #=> "X"
    f3    #=> "113"

;T;0;;;I"	to_a;F;I"MatchData;T;[o;;I" ;F;I"Array[::String?];To;;I"pReturns the entire matched string.

    m = /(.)(.)(\d+)(\d)/.match("THX1138.")
    m.to_s   #=> "HX1138"

;T;0;;;I"	to_s;F;I"MatchData;T;[o;;I" ;F;I"String;To;;I"æUses each *index* to access the matching values, returning an array of the
corresponding matches.

    m = /(.)(.)(\d+)(\d)/.match("THX1138: The Movie")
    m.to_a               #=> ["HX1138", "H", "X", "113", "8"]
    m.values_at(0, 2, -2)   #=> ["HX1138", "X", "113"]
    m.values_at(1..2, -1)   #=> ["H", "X", "8"]

    m = /(?<a>\d+) *(?<op>[+\-*\/]) *(?<b>\d+)/.match("1 + 2")
    m.to_a               #=> ["1 + 2", "1", "+", "2"]
    m.values_at(:a, :b, :op) #=> ["1", "2", "+"]

;T;0;;;I"values_at;F;I"MatchData;T;[o;;I"/*::Integer | ::Symbol | ::String n_or_name;T;I"Array[::String?];To;;0;0;;;I"initialize_copy;F;I"MatchData;T;[o;;I"self object;T;I"	void;To;;I"ûThe Math module contains module functions for basic trigonometric and
transcendental functions. See class Float for a list of constants that define
Ruby's floating point accuracy.

Domains and codomains are given only for real (not complex) numbers.

;T;0;	I"	Math;T;
[ ;[ ;0;[ ;[ o;;I"~Computes the arc cosine of `x`. Returns 0..PI.

Domain: [-1, 1]

Codomain: [0, PI]

    Math.acos(0) == Math::PI/2  #=> true

;T;0;;;I"	acos;F;I"	Math;T;[o;;I"::Numeric x;T;I"
Float;To;;I"{Computes the inverse hyperbolic cosine of `x`.

Domain: [1, INFINITY)

Codomain: [0, INFINITY)

    Math.acosh(1) #=> 0.0

;T;0;;;I"
acosh;F;I"	Math;T;[o;;I"::Numeric x;T;I"
Float;To;;I"‰Computes the arc sine of `x`. Returns -PI/2..PI/2.

Domain: [-1, -1]

Codomain: [-PI/2, PI/2]

    Math.asin(1) == Math::PI/2  #=> true

;T;0;;;I"	asin;F;I"	Math;T;[o;;I"::Numeric x;T;I"
Float;To;;I"—Computes the inverse hyperbolic sine of `x`.

Domain: (-INFINITY, INFINITY)

Codomain: (-INFINITY, INFINITY)

    Math.asinh(1) #=> 0.881373587019543

;T;0;;;I"
asinh;F;I"	Math;T;[o;;I"::Numeric x;T;I"
Float;To;;I"‰Computes the arc tangent of `x`. Returns -PI/2..PI/2.

Domain: (-INFINITY, INFINITY)

Codomain: (-PI/2, PI/2)

    Math.atan(0) #=> 0.0

;T;0;;;I"	atan;F;I"	Math;T;[o;;I"::Numeric x;T;I"
Float;To;;I"ÚComputes the arc tangent given `y` and `x`. Returns a Float in the range
-PI..PI. Return value is a angle in radians between the positive x-axis of
cartesian plane and the point given by the coordinates (`x`, `y`) on it.

Domain: (-INFINITY, INFINITY)

Codomain: [-PI, PI]

    Math.atan2(-0.0, -1.0) #=> -3.141592653589793
    Math.atan2(-1.0, -1.0) #=> -2.356194490192345
    Math.atan2(-1.0, 0.0)  #=> -1.5707963267948966
    Math.atan2(-1.0, 1.0)  #=> -0.7853981633974483
    Math.atan2(-0.0, 1.0)  #=> -0.0
    Math.atan2(0.0, 1.0)   #=> 0.0
    Math.atan2(1.0, 1.0)   #=> 0.7853981633974483
    Math.atan2(1.0, 0.0)   #=> 1.5707963267948966
    Math.atan2(1.0, -1.0)  #=> 2.356194490192345
    Math.atan2(0.0, -1.0)  #=> 3.141592653589793
    Math.atan2(INFINITY, INFINITY)   #=> 0.7853981633974483
    Math.atan2(INFINITY, -INFINITY)  #=> 2.356194490192345
    Math.atan2(-INFINITY, INFINITY)  #=> -0.7853981633974483
    Math.atan2(-INFINITY, -INFINITY) #=> -2.356194490192345

;T;0;;;I"
atan2;F;I"	Math;T;[o;;I"::Numeric y, ::Numeric x;T;I"
Float;To;;I"ƒComputes the inverse hyperbolic tangent of `x`.

Domain: (-1, 1)

Codomain: (-INFINITY, INFINITY)

    Math.atanh(1) #=> Infinity

;T;0;;;I"
atanh;F;I"	Math;T;[o;;I"::Numeric x;T;I"
Float;To;;I"Returns the cube root of `x`.

Domain: (-INFINITY, INFINITY)

Codomain: (-INFINITY, INFINITY)

    -9.upto(9) {|x|
      p [x, Math.cbrt(x), Math.cbrt(x)**3]
    }
    #=> [-9, -2.0800838230519, -9.0]
    #   [-8, -2.0, -8.0]
    #   [-7, -1.91293118277239, -7.0]
    #   [-6, -1.81712059283214, -6.0]
    #   [-5, -1.7099759466767, -5.0]
    #   [-4, -1.5874010519682, -4.0]
    #   [-3, -1.44224957030741, -3.0]
    #   [-2, -1.25992104989487, -2.0]
    #   [-1, -1.0, -1.0]
    #   [0, 0.0, 0.0]
    #   [1, 1.0, 1.0]
    #   [2, 1.25992104989487, 2.0]
    #   [3, 1.44224957030741, 3.0]
    #   [4, 1.5874010519682, 4.0]
    #   [5, 1.7099759466767, 5.0]
    #   [6, 1.81712059283214, 6.0]
    #   [7, 1.91293118277239, 7.0]
    #   [8, 2.0, 8.0]
    #   [9, 2.0800838230519, 9.0]

;T;0;;;I"	cbrt;F;I"	Math;T;[o;;I"::Numeric x;T;I"
Float;To;;I"¯Computes the cosine of `x` (expressed in radians). Returns a Float in the
range -1.0..1.0.

Domain: (-INFINITY, INFINITY)

Codomain: [-1, 1]

    Math.cos(Math::PI) #=> -1.0

;T;0;;;I"cos;F;I"	Math;T;[o;;I"::Numeric x;T;I"
Float;To;;I"‘Computes the hyperbolic cosine of `x` (expressed in radians).

Domain: (-INFINITY, INFINITY)

Codomain: [1, INFINITY)

    Math.cosh(0) #=> 1.0

;T;0;;;I"	cosh;F;I"	Math;T;[o;;I"::Numeric x;T;I"
Float;To;;I"wCalculates the error function of `x`.

Domain: (-INFINITY, INFINITY)

Codomain: (-1, 1)

    Math.erf(0) #=> 0.0

;T;0;;;I"erf;F;I"	Math;T;[o;;I"::Numeric x;T;I"
Float;To;;I"~Calculates the complementary error function of x.

Domain: (-INFINITY, INFINITY)

Codomain: (0, 2)

    Math.erfc(0) #=> 1.0

;T;0;;;I"	erfc;F;I"	Math;T;[o;;I"::Numeric x;T;I"
Float;To;;I"¿Returns e**x.

Domain: (-INFINITY, INFINITY)

Codomain: (0, INFINITY)

    Math.exp(0)       #=> 1.0
    Math.exp(1)       #=> 2.718281828459045
    Math.exp(1.5)     #=> 4.4816890703380645

;T;0;;;I"exp;F;I"	Math;T;[o;;I"::Numeric x;T;I"
Float;To;;I"çReturns a two-element array containing the normalized fraction (a Float) and
exponent (an Integer) of `x`.

    fraction, exponent = Math.frexp(1234)   #=> [0.6025390625, 11]
    fraction * 2**exponent                  #=> 1234.0

;T;0;;;I"
frexp;F;I"	Math;T;[o;;I"::Numeric x;T;I"[ ::Float, ::Integer ];To;;I"Calculates the gamma function of x.

Note that gamma(n) is the same as fact(n-1) for integer n > 0. However
gamma(n) returns float and can be an approximation.

    def fact(n) (1..n).inject(1) {|r,i| r*i } end
    1.upto(26) {|i| p [i, Math.gamma(i), fact(i-1)] }
    #=> [1, 1.0, 1]
    #   [2, 1.0, 1]
    #   [3, 2.0, 2]
    #   [4, 6.0, 6]
    #   [5, 24.0, 24]
    #   [6, 120.0, 120]
    #   [7, 720.0, 720]
    #   [8, 5040.0, 5040]
    #   [9, 40320.0, 40320]
    #   [10, 362880.0, 362880]
    #   [11, 3628800.0, 3628800]
    #   [12, 39916800.0, 39916800]
    #   [13, 479001600.0, 479001600]
    #   [14, 6227020800.0, 6227020800]
    #   [15, 87178291200.0, 87178291200]
    #   [16, 1307674368000.0, 1307674368000]
    #   [17, 20922789888000.0, 20922789888000]
    #   [18, 355687428096000.0, 355687428096000]
    #   [19, 6.402373705728e+15, 6402373705728000]
    #   [20, 1.21645100408832e+17, 121645100408832000]
    #   [21, 2.43290200817664e+18, 2432902008176640000]
    #   [22, 5.109094217170944e+19, 51090942171709440000]
    #   [23, 1.1240007277776077e+21, 1124000727777607680000]
    #   [24, 2.5852016738885062e+22, 25852016738884976640000]
    #   [25, 6.204484017332391e+23, 620448401733239439360000]
    #   [26, 1.5511210043330954e+25, 15511210043330985984000000]

;T;0;;;I"
gamma;F;I"	Math;T;[o;;I"::Numeric x;T;I"
Float;To;;I"~Returns sqrt(x**2 + y**2), the hypotenuse of a right-angled triangle with
sides `x` and `y`.

    Math.hypot(3, 4)   #=> 5.0

;T;0;;;I"
hypot;F;I"	Math;T;[o;;I"::Numeric x, ::Numeric y;T;I"
Float;To;;I"Returns the value of `fraction`*(2**`exponent`).

    fraction, exponent = Math.frexp(1234)
    Math.ldexp(fraction, exponent)   #=> 1234.0

;T;0;;;I"
ldexp;F;I"	Math;T;[o;;I"+::Numeric fraction, ::Numeric exponent;T;I"
Float;To;;I"ýCalculates the logarithmic gamma of `x` and the sign of gamma of `x`.

Math.lgamma(x) is the same as
    [Math.log(Math.gamma(x).abs), Math.gamma(x) < 0 ? -1 : 1]

but avoids overflow by Math.gamma(x) for large x.

    Math.lgamma(0) #=> [Infinity, 1]

;T;0;;;I"lgamma;F;I"	Math;T;[o;;I"::Numeric x;T;I"[ ::Float, ::Integer ];To;;I"Returns the logarithm of `x`. If additional second argument is given, it will
be the base of logarithm. Otherwise it is `e` (for the natural logarithm).

Domain: (0, INFINITY)

Codomain: (-INFINITY, INFINITY)

    Math.log(0)          #=> -Infinity
    Math.log(1)          #=> 0.0
    Math.log(Math::E)    #=> 1.0
    Math.log(Math::E**3) #=> 3.0
    Math.log(12, 3)      #=> 2.2618595071429146

;T;0;;;I"log;F;I"	Math;T;[o;;I"!::Numeric x, ?::Numeric base;T;I"
Float;To;;I"ÂReturns the base 10 logarithm of `x`.

Domain: (0, INFINITY)

Codomain: (-INFINITY, INFINITY)

    Math.log10(1)       #=> 0.0
    Math.log10(10)      #=> 1.0
    Math.log10(10**100) #=> 100.0

;T;0;;;I"
log10;F;I"	Math;T;[o;;I"::Numeric x;T;I"
Float;To;;I"ÙReturns the base 2 logarithm of `x`.

Domain: (0, INFINITY)

Codomain: (-INFINITY, INFINITY)

    Math.log2(1)      #=> 0.0
    Math.log2(2)      #=> 1.0
    Math.log2(32768)  #=> 15.0
    Math.log2(65536)  #=> 16.0

;T;0;;;I"	log2;F;I"	Math;T;[o;;I"::Numeric x;T;I"
Float;To;;I"®Computes the sine of `x` (expressed in radians). Returns a Float in the range
-1.0..1.0.

Domain: (-INFINITY, INFINITY)

Codomain: [-1, 1]

    Math.sin(Math::PI/2) #=> 1.0

;T;0;;;I"sin;F;I"	Math;T;[o;;I"::Numeric x;T;I"
Float;To;;I"—Computes the hyperbolic sine of `x` (expressed in radians).

Domain: (-INFINITY, INFINITY)

Codomain: (-INFINITY, INFINITY)

    Math.sinh(0) #=> 0.0

;T;0;;;I"	sinh;F;I"	Math;T;[o;;I"::Numeric x;T;I"
Float;To;;I"ºReturns the non-negative square root of `x`.

Domain: [0, INFINITY)

Codomain:[0, INFINITY)

    0.upto(10) {|x|
      p [x, Math.sqrt(x), Math.sqrt(x)**2]
    }
    #=> [0, 0.0, 0.0]
    #   [1, 1.0, 1.0]
    #   [2, 1.4142135623731, 2.0]
    #   [3, 1.73205080756888, 3.0]
    #   [4, 2.0, 4.0]
    #   [5, 2.23606797749979, 5.0]
    #   [6, 2.44948974278318, 6.0]
    #   [7, 2.64575131106459, 7.0]
    #   [8, 2.82842712474619, 8.0]
    #   [9, 3.0, 9.0]
    #   [10, 3.16227766016838, 10.0]

Note that the limited precision of floating point arithmetic might lead to
surprising results:

    Math.sqrt(10**46).to_i  #=> 99999999999999991611392 (!)

See also BigDecimal#sqrt and Integer.sqrt.

;T;0;;;I"	sqrt;F;I"	Math;T;[o;;I"::Numeric x;T;I"
Float;To;;I"ŽComputes the tangent of `x` (expressed in radians).

Domain: (-INFINITY, INFINITY)

Codomain: (-INFINITY, INFINITY)

    Math.tan(0) #=> 0.0

;T;0;;;I"tan;F;I"	Math;T;[o;;I"::Numeric x;T;I"
Float;To;;I"ŒComputes the hyperbolic tangent of `x` (expressed in radians).

Domain: (-INFINITY, INFINITY)

Codomain: (-1, 1)

    Math.tanh(0) #=> 0.0

;T;0;;;I"	tanh;F;I"	Math;T;[o;;I"::Numeric x;T;I"
Float;To; ;I"7Raised when a mathematical function is evaluated outside of its domain of
definition.

For example, since `cos` returns values in the range -1..1, its inverse
function `acos` is only defined on that interval:

    Math.acos(42)

*produces:*

    Math::DomainError: Numerical argument is out of domain - "acos"

;T;0;	I"Math::DomainError;T;
[ ;[ ;0;[ ;[ ;0;I"StandardError;To; ;I"Method objects are created by Object#method, and are associated with a
particular object (not just with a class).  They may be used to invoke the
method within the object, and as a block associated with an iterator.  They
may also be unbound from one object (creating an UnboundMethod) and bound to
another.

    class Thing
      def square(n)
        n*n
      end
    end
    thing = Thing.new
    meth  = thing.method(:square)

    meth.call(9)                 #=> 81
    [ 1, 2, 3 ].collect(&meth)   #=> [1, 4, 9]

    [ 1, 2, 3 ].each(&method(:puts)) #=> prints 1, 2, 3

    require 'date'
    %w[2017-03-01 2017-03-02].collect(&Date.method(:parse))
    #=> [#<Date: 2017-03-01 ((2457814j,0s,0n),+0s,2299161j)>, #<Date: 2017-03-02 ((2457815j,0s,0n),+0s,2299161j)>]

;T;0;	I"Method;T;
[ ;[ ;0;[ ;[ ;0;I"Object;To;;I":Returns a Proc object corresponding to this method.

;T;0;;;I"to_proc;F;I"Method;T;[o;;I" ;F;I"	Proc;To;;I"ŸInvokes the *meth* with the specified arguments, returning the method's return
value.

    m = 12.method("+")
    m.call(3)    #=> 15
    m.call(20)   #=> 32

;T;0;;;I"	call;F;I"Method;T;[o;;I"*untyped args;T;I"untyped;To;;I"1Returns a proc that is the composition of this method and the given *g*. The
returned proc takes a variable number of arguments, calls *g* with them then
calls this method with the result.

    def f(x)
      x * x
    end

    f = self.method(:f)
    g = proc {|x| x + x }
    p (f << g).call(2) #=> 16

;T;0;;;I"<<;F;I"Method;T;[o;;I"::Proc g;T;I"	Proc;To;;I"0Returns a proc that is the composition of this method and the given *g*. The
returned proc takes a variable number of arguments, calls this method with
them then calls *g* with the result.

    def f(x)
      x * x
    end

    f = self.method(:f)
    g = proc {|x| x + x }
    p (f >> g).call(2) #=> 8

;T;0;;;I">>;F;I"Method;T;[o;;I"::Proc g;T;I"	Proc;To;;I"<Returns an indication of the number of arguments accepted by a method. Returns
a nonnegative integer for methods that take a fixed number of arguments. For
Ruby methods that take a variable number of arguments, returns -n-1, where n
is the number of required arguments. Keyword arguments will be considered as a
single additional argument, that argument being mandatory if any keyword
argument is mandatory. For methods written in C, returns -1 if the call takes
a variable number of arguments.

    class C
      def one;    end
      def two(a); end
      def three(*a);  end
      def four(a, b); end
      def five(a, b, *c);    end
      def six(a, b, *c, &d); end
      def seven(a, b, x:0); end
      def eight(x:, y:); end
      def nine(x:, y:, **z); end
      def ten(*a, x:, y:); end
    end
    c = C.new
    c.method(:one).arity     #=> 0
    c.method(:two).arity     #=> 1
    c.method(:three).arity   #=> -1
    c.method(:four).arity    #=> 2
    c.method(:five).arity    #=> -3
    c.method(:six).arity     #=> -3
    c.method(:seven).arity   #=> -3
    c.method(:eight).arity   #=> 1
    c.method(:nine).arity    #=> 1
    c.method(:ten).arity     #=> -2

    "cat".method(:size).arity      #=> 0
    "cat".method(:replace).arity   #=> 1
    "cat".method(:squeeze).arity   #=> -1
    "cat".method(:count).arity     #=> -1

;T;0;;;I"
arity;F;I"Method;T;[o;;I" ;F;I"Integer;To;;I"µReturns a clone of this method.

    class A
      def foo
        return "bar"
      end
    end

    m = A.new.method(:foo)
    m.call # => "bar"
    n = m.clone.call # => "bar"

;T;0;;;I"
clone;F;I"Method;T;[o;;I" ;F;I"Method;To;;I"ZReturns a curried proc based on the method. When the proc is called with a
number of arguments that is lower than the method's arity, then another
curried proc is returned. Only when enough arguments have been supplied to
satisfy the method signature, will the method actually be called.

The optional *arity* argument should be supplied when currying methods with
variable arguments to determine how many arguments are needed before the
method is called.

    def foo(a,b,c)
      [a, b, c]
    end

    proc  = self.method(:foo).curry
    proc2 = proc.call(1, 2)          #=> #<Proc>
    proc2.call(3)                    #=> [1,2,3]

    def vararg(*args)
      args
    end

    proc = self.method(:vararg).curry(4)
    proc2 = proc.call(:x)      #=> #<Proc>
    proc3 = proc2.call(:y, :z) #=> #<Proc>
    proc3.call(:a)             #=> [:x, :y, :z, :a]

;T;0;;;I"
curry;F;I"Method;T;[o;;I"?::Integer arity;T;I"	Proc;To;;I"&Returns the name of the method.

;T;0;;;I"	name;F;I"Method;T;[o;;I" ;F;I"Symbol;To;;I"šReturns the original name of the method.

    class C
      def foo; end
      alias bar foo
    end
    C.instance_method(:bar).original_name # => :foo

;T;0;;;I"original_name;F;I"Method;T;[o;;I" ;F;I"Symbol;To;;I"~Returns the class or module that defines the method. See also Method#receiver.

    (1..3).method(:map).owner #=> Enumerable

;T;0;;;I"
owner;F;I"Method;T;[o;;I" ;F;I"Class | ::Module;To;;I"ÞReturns the parameter information of this method.

    def foo(bar); end
    method(:foo).parameters #=> [[:req, :bar]]

    def foo(bar, baz, bat, &blk); end
    method(:foo).parameters #=> [[:req, :bar], [:req, :baz], [:req, :bat], [:block, :blk]]

    def foo(bar, *args); end
    method(:foo).parameters #=> [[:req, :bar], [:rest, :args]]

    def foo(bar, baz, *args, &blk); end
    method(:foo).parameters #=> [[:req, :bar], [:req, :baz], [:rest, :args], [:block, :blk]]

;T;0;;;I"parameters;F;I"Method;T;[o;;I" ;F;I"iArray[[ :req | :opt | :rest | :keyreq | :key | :keyrest | :block, ::Symbol ] | [ :rest | :keyrest ]];To;;I"-Returns whether the method is private.

;T;0;;;I"private?;F;I"Method;T;[o;;I" ;F;I"	bool;To;;I"/Returns whether the method is protected.

;T;0;;;I"protected?;F;I"Method;T;[o;;I" ;F;I"	bool;To;;I",Returns whether the method is public.

;T;0;;;I"public?;F;I"Method;T;[o;;I" ;F;I"	bool;To;;I"cReturns the bound receiver of the method object.

    (1..3).method(:map).receiver # => 1..3

;T;0;;;I"receiver;F;I"Method;T;[o;;I" ;F;I"untyped;To;;I"†Returns the Ruby source filename and line number containing this method or nil
if this method was not defined in Ruby (i.e. native).

;T;0;;;I"source_location;F;I"Method;T;[o;;I" ;F;I"[ ::String, ::Integer ]?;To;;I"zReturns a Method of superclass which would be called when super is used or nil
if there is no method on superclass.

;T;0;;;I"super_method;F;I"Method;T;[o;;I" ;F;I"Method?;To;;I"œDissociates *meth* from its current receiver. The resulting UnboundMethod can
subsequently be bound to a new object of the same class (see UnboundMethod).

;T;0;;;I"unbind;F;I"Method;T;[o;;I" ;F;I"UnboundMethod;To; ;I"ÔA Module is a collection of methods and constants. The methods in a module may
be instance methods or module methods. Instance methods appear as methods in a
class when the module is included, module methods do not. Conversely, module
methods may be called without creating an encapsulating object, while instance
methods may not. (See Module#module_function.)

In the descriptions that follow, the parameter *sym* refers to a symbol, which
is either a quoted string or a Symbol (such as `:name`).

    module Mod
      include Math
      CONST = 1
      def meth
        #  ...
      end
    end
    Mod.class              #=> Module
    Mod.constants          #=> [:CONST, :PI, :E]
    Mod.instance_methods   #=> [:meth]

;T;0;	I"Module;T;
[ ;[ ;0;[ ;[ ;0;I"Object;To;;I"ÇIn the first form, returns an array of the names of all constants accessible
from the point of call. This list includes the names of all modules and
classes defined in the global scope.

    Module.constants.first(4)
       # => [:ARGF, :ARGV, :ArgumentError, :Array]

    Module.constants.include?(:SEEK_SET)   # => false

    class IO
      Module.constants.include?(:SEEK_SET) # => true
    end

The second form calls the instance method `constants`.

;T;0;;;I"constants;F;I"Module;T;[o;;I" ;F;I"Array[::Integer];To;;I"ÉReturns the list of `Modules` nested at the point of call.

    module M1
      module M2
        $a = Module.nesting
      end
    end
    $a           #=> [M1::M2, M1]
    $a[0].name   #=> "M1::M2"

;T;0;;;I"nesting;F;I"Module;T;[o;;I" ;F;I"Array[::Module];To;;I"5Returns an array of all modules used in the current scope. The ordering of
modules in the resulting array is not defined.

    module A
      refine Object do
      end
    end

    module B
      refine Object do
      end
    end

    using A
    using B
    p Module.used_modules

*produces:*

    [B, A]

;T;0;;;I"used_modules;F;I"Module;T;[o;;I" ;F;I"Array[::Module];To;;I"ÈReturns true if *mod* is a subclass of *other*. Returns `nil` if there's no
relationship between the two. (Think of the relationship in terms of the class
definition: "class A < B" implies "A < B".)

;T;0;;;I"<;F;I"Module;T;[o;;I"::Module other;T;I"
bool?;To;;I"âReturns true if *mod* is a subclass of *other* or is the same as *other*.
Returns `nil` if there's no relationship between the two. (Think of the
relationship in terms of the class definition: "class A < B" implies "A < B".)

;T;0;;;I"<=;F;I"Module;T;[o;;I"::Module other;T;I"
bool?;To;;I"-Comparison---Returns -1, 0, +1 or nil depending on whether `module` includes
`other_module`, they are the same, or if `module` is included by
`other_module`.

Returns `nil` if `module` has no relationship with `other_module`, if
`other_module` is not a module, or if the two values are incomparable.

;T;0;;;I"<=>;F;I"Module;T;[o;;I"untyped other;T;I"Integer?;To;;I"€Equality --- At the Object level, #== returns `true` only if `obj` and `other`
are the same object.  Typically, this method is overridden in descendant
classes to provide class-specific meaning.

Unlike #==, the #equal? method should never be overridden by subclasses as it
is used to determine object identity (that is, `a.equal?(b)` if and only if
`a` is the same object as `b`):

    obj = "a"
    other = obj.dup

    obj == other      #=> true
    obj.equal? other  #=> false
    obj.equal? obj    #=> true

The #eql? method returns `true` if `obj` and `other` refer to the same hash
key.  This is used by Hash to test members for equality.  For any pair of
objects where #eql? returns `true`, the #hash value of both objects must be
equal. So any subclass that overrides #eql? should also override #hash
appropriately.

For objects of class Object, #eql?  is synonymous with #==.  Subclasses
normally continue this tradition by aliasing #eql? to their overridden #==
method, but there are exceptions. Numeric types, for example, perform type
conversion across #==, but not across #eql?, so:

    1 == 1.0     #=> true
    1.eql? 1.0   #=> false

;T;0;;;I"==;F;I"Module;T;[o;;I"untyped other;T;I"	bool;To;;I"ÎCase Equality---Returns `true` if *obj* is an instance of *mod* or an instance
of one of *mod*'s descendants. Of limited use for modules, but can be used in
`case` statements to classify objects by class.

;T;0;;;I"===;F;I"Module;T;[o;;I"untyped other;T;I"	bool;To;;I"ÉReturns true if *mod* is an ancestor of *other*. Returns `nil` if there's no
relationship between the two. (Think of the relationship in terms of the class
definition: "class A < B" implies "B > A".)

;T;0;;;I">;F;I"Module;T;[o;;I"::Module other;T;I"
bool?;To;;I"êReturns true if *mod* is an ancestor of *other*, or the two modules are the
same. Returns `nil` if there's no relationship between the two. (Think of the
relationship in terms of the class definition: "class A < B" implies "B > A".)

;T;0;;;I">=;F;I"Module;T;[o;;I"::Module other;T;I"
bool?;To;;I"kMakes *new_name* a new copy of the method *old_name*. This can be used to
retain access to methods that are overridden.

    module Mod
      alias_method :orig_exit, :exit #=> :orig_exit
      def exit(code=0)
        puts "Exiting with code #{code}"
        orig_exit(code)
      end
    end
    include Mod
    exit(99)

*produces:*

    Exiting with code 99

;T;0;;;I"alias_method;F;I"Module;T;[o;;I"?::Symbol | ::String new_name, ::Symbol | ::String old_name;T;I"Symbol;To;;I">Returns a list of modules included/prepended in *mod* (including *mod*
itself).

    module Mod
      include Math
      include Comparable
      prepend Enumerable
    end

    Mod.ancestors        #=> [Enumerable, Mod, Comparable, Math]
    Math.ancestors       #=> [Math]
    Enumerable.ancestors #=> [Enumerable]

;T;0;;;I"ancestors;F;I"Module;T;[o;;I" ;F;I"Array[::Module];To;;I"RWhen this module is included in another, Ruby calls #append_features in this
module, passing it the receiving module in *mod*. Ruby's default
implementation is to add the constants, methods, and module variables of this
module to *mod* if this module has not already been added to *mod* or one of
its ancestors. See also Module#include.

;T;0;;;I"append_features;F;I"Module;T;[o;;I"::Module arg0;T;I"	self;To;;I"ÙDefines a named attribute for this module, where the name is
*symbol.*`id2name`, creating an instance variable (`@name`) and a
corresponding access method to read it. Also creates a method called `name=`
to set the attribute. String arguments are converted to symbols. Returns an
array of defined method names as symbols.

    module Mod
      attr_accessor(:one, :two) #=> [:one, :one=, :two, :two=]
    end
    Mod.instance_methods.sort   #=> [:one, :one=, :two, :two=]

;T;0;;;I"attr_accessor;F;I"Module;T;[o;;I"*::Symbol | ::String arg0;T;I"NilClass;To;;I"Creates instance variables and corresponding methods that return the value of
each instance variable. Equivalent to calling ```attr`*:name*'' on each name
in turn. String arguments are converted to symbols. Returns an array of
defined method names as symbols.

;T;0;;;I"attr_reader;F;I"Module;T;[o;;I"*::Symbol | ::String arg0;T;I"NilClass;To;;I"µCreates an accessor method to allow assignment to the attribute
*symbol*`.id2name`. String arguments are converted to symbols. Returns an
array of defined method names as symbols.

;T;0;;;I"attr_writer;F;I"Module;T;[o;;I"*::Symbol | ::String arg0;T;I"NilClass;To;;I"úRegisters *filename* to be loaded (using Kernel::require) the first time that
*module* (which may be a String or a symbol) is accessed in the namespace of
*mod*.

    module A
    end
    A.autoload(:B, "b")
    A::B.doit            # autoloads "b"

;T;0;;;I"autoload;F;I"Module;T;[o;;I"(::Symbol _module, ::String filename;T;I"NilClass;To;;I"õReturns *filename* to be loaded if *name* is registered as `autoload` in the
namespace of *mod* or one of its ancestors.

    module A
    end
    A.autoload(:B, "b")
    A.autoload?(:B)            #=> "b"

If `inherit` is false, the lookup only checks the autoloads in the receiver:

    class A
      autoload :CONST, "const.rb"
    end

    class B < A
    end

    B.autoload?(:CONST)          #=> "const.rb", found in A (ancestor)
    B.autoload?(:CONST, false)   #=> nil, not found in B itself

;T;0;;;I"autoload?;F;I"Module;T;[o;;I"&::Symbol name, ?::boolish inherit;T;I"String?;To;;I"rEvaluates the string or block in the context of *mod*, except that when a
block is given, constant/class variable lookup is not affected. This can be
used to add methods to a class. `module_eval` returns the result of evaluating
its argument. The optional *filename* and *lineno* parameters set the text for
error messages.

    class Thing
    end
    a = %q{def hello() "Hello there!" end}
    Thing.module_eval(a)
    puts Thing.new.hello()
    Thing.module_eval("invalid code", "dummy", 123)

*produces:*

    Hello there!
    dummy:123:in `module_eval': undefined local variable
        or method `code' for Thing:Class

;T;0;;;I"class_eval;F;I"Module;T;[o;;I"9::String arg0, ?::String filename, ?::Integer lineno;T;I"untyped;To;;I" ;F;I"U;Fo;;I"’Evaluates the given block in the context of the class/module. The method
defined in the block will belong to the receiver. Any arguments passed to the
method will be passed to the block. This can be used if the block needs to
access instance variables.

    class Thing
    end
    Thing.class_exec{
      def hello() "Hello there!" end
    }
    puts Thing.new.hello()

*produces:*

    Hello there!

;T;0;;;I"class_exec;F;I"Module;T;[o;;I"*untyped args;T;I"U;Fo;;I" Returns `true` if the given class variable is defined in *obj*. String
arguments are converted to symbols.

    class Fred
      @@foo = 99
    end
    Fred.class_variable_defined?(:@@foo)    #=> true
    Fred.class_variable_defined?(:@@bar)    #=> false

;T;0;;;I"class_variable_defined?;F;I"Module;T;[o;;I"::Symbol | ::String arg0;T;I"	bool;To;;I"(Returns the value of the given class variable (or throws a NameError
exception). The `@@` part of the variable name should be included for regular
class variables. String arguments are converted to symbols.

    class Fred
      @@foo = 99
    end
    Fred.class_variable_get(:@@foo)     #=> 99

;T;0;;;I"class_variable_get;F;I"Module;T;[o;;I"::Symbol | ::String arg0;T;I"untyped;To;;I"QSets the class variable named by *symbol* to the given object. If the class
variable name is passed as a string, that string is converted to a symbol.

    class Fred
      @@foo = 99
      def foo
        @@foo
      end
    end
    Fred.class_variable_set(:@@foo, 101)     #=> 101
    Fred.new.foo                             #=> 101

;T;0;;;I"class_variable_set;F;I"Module;T;[o;;I"+::Symbol | ::String arg0, untyped arg1;T;I"untyped;To;;I"Returns an array of the names of class variables in *mod*. This includes the
names of class variables in any included modules, unless the *inherit*
parameter is set to `false`.

    class One
      @@var1 = 1
    end
    class Two < One
      @@var2 = 2
    end
    One.class_variables          #=> [:@@var1]
    Two.class_variables          #=> [:@@var2, :@@var1]
    Two.class_variables(false)   #=> [:@@var2]

;T;0;;;I"class_variables;F;I"Module;T;[o;;I"?::boolish inherit;T;I"Array[::Symbol];To;;I"õSays whether *mod* or its ancestors have a constant with the given name:

    Float.const_defined?(:EPSILON)      #=> true, found in Float itself
    Float.const_defined?("String")      #=> true, found in Object (ancestor)
    BasicObject.const_defined?(:Hash)   #=> false

If *mod* is a `Module`, additionally `Object` and its ancestors are checked:

    Math.const_defined?(:String)   #=> true, found in Object

In each of the checked classes or modules, if the constant is not present but
there is an autoload for it, `true` is returned directly without autoloading:

    module Admin
      autoload :User, 'admin/user'
    end
    Admin.const_defined?(:User)   #=> true

If the constant is not found the callback `const_missing` is **not** called
and the method returns `false`.

If `inherit` is false, the lookup only checks the constants in the receiver:

    IO.const_defined?(:SYNC)          #=> true, found in File::Constants (ancestor)
    IO.const_defined?(:SYNC, false)   #=> false, not found in IO itself

In this case, the same logic for autoloading applies.

If the argument is not a valid constant name a `NameError` is raised with the
message "wrong constant name *name*":

    Hash.const_defined? 'foobar'   #=> NameError: wrong constant name foobar

;T;0;;;I"const_defined?;F;I"Module;T;[o;;I"1::Symbol | ::String name, ?::boolish inherit;T;I"	bool;To;;I"¨Checks for a constant with the given name in *mod*. If `inherit` is set, the
lookup will also search the ancestors (and `Object` if *mod* is a `Module`).

The value of the constant is returned if a definition is found, otherwise a
`NameError` is raised.

    Math.const_get(:PI)   #=> 3.14159265358979

This method will recursively look up constant names if a namespaced class name
is provided.  For example:

    module Foo; class Bar; end end
    Object.const_get 'Foo::Bar'

The `inherit` flag is respected on each lookup.  For example:

    module Foo
      class Bar
        VAL = 10
      end

      class Baz < Bar; end
    end

    Object.const_get 'Foo::Baz::VAL'         # => 10
    Object.const_get 'Foo::Baz::VAL', false  # => NameError

If the argument is not a valid constant name a `NameError` will be raised with
a warning "wrong constant name".

    Object.const_get 'foobar' #=> NameError: wrong constant name foobar

;T;0;;;I"const_get;F;I"Module;T;[o;;I"1::Symbol | ::String name, ?::boolish inherit;T;I"untyped;To;;I"Invoked when a reference is made to an undefined constant in *mod*. It is
passed a symbol for the undefined constant, and returns a value to be used for
that constant. The following code is an example of the same:

    def Foo.const_missing(name)
      name # return the constant name as Symbol
    end

    Foo::UNDEFINED_CONST    #=> :UNDEFINED_CONST: symbol returned

In the next example when a reference is made to an undefined constant, it
attempts to load a file whose name is the lowercase version of the constant
(thus class `Fred` is assumed to be in file `fred.rb`).  If found, it returns
the loaded class. It therefore implements an autoload feature similar to
Kernel#autoload and Module#autoload.

    def Object.const_missing(name)
      @looked_for ||= {}
      str_name = name.to_s
      raise "Class not found: #{name}" if @looked_for[str_name]
      @looked_for[str_name] = 1
      file = str_name.downcase
      require file
      klass = const_get(name)
      return klass if klass
      raise "Class not found: #{name}"
    end

;T;0;;;I"const_missing;F;I"Module;T;[o;;I"::Symbol arg0;T;I"untyped;To;;I"äSets the named constant to the given object, returning that object. Creates a
new constant if no constant with the given name previously existed.

    Math.const_set("HIGH_SCHOOL_PI", 22.0/7.0)   #=> 3.14285714285714
    Math::HIGH_SCHOOL_PI - Math::PI              #=> 0.00126448926734968

If `sym` or `str` is not a valid constant name a `NameError` will be raised
with a warning "wrong constant name".

    Object.const_set('foobar', 42) #=> NameError: wrong constant name foobar

;T;0;;;I"const_set;F;I"Module;T;[o;;I"+::Symbol | ::String arg0, untyped arg1;T;I"untyped;To;;I"±Returns the Ruby source filename and line number containing the definition of
the constant specified. If the named constant is not found, `nil` is returned.
If the constant is found, but its source location can not be extracted
(constant is defined in C code), empty array is returned.

*inherit* specifies whether to lookup in `mod.ancestors` (`true` by default).

    # test.rb:
    class A         # line 1
      C1 = 1
      C2 = 2
    end

    module M        # line 6
      C3 = 3
    end

    class B < A     # line 10
      include M
      C4 = 4
    end

    class A # continuation of A definition
      C2 = 8 # constant redefinition; warned yet allowed
    end

    p B.const_source_location('C4')           # => ["test.rb", 12]
    p B.const_source_location('C3')           # => ["test.rb", 7]
    p B.const_source_location('C1')           # => ["test.rb", 2]

    p B.const_source_location('C3', false)    # => nil  -- don't lookup in ancestors

    p A.const_source_location('C2')           # => ["test.rb", 16] -- actual (last) definition place

    p Object.const_source_location('B')       # => ["test.rb", 10] -- top-level constant could be looked through Object
    p Object.const_source_location('A')       # => ["test.rb", 1] -- class reopening is NOT considered new definition

    p B.const_source_location('A')            # => ["test.rb", 1]  -- because Object is in ancestors
    p M.const_source_location('A')            # => ["test.rb", 1]  -- Object is not ancestor, but additionally checked for modules

    p Object.const_source_location('A::C1')   # => ["test.rb", 2]  -- nesting is supported
    p Object.const_source_location('String')  # => []  -- constant is defined in C code

;T;0;;;I"const_source_location;F;I"Module;T;[o;;I"1::Symbol | ::String name, ?::boolish inherit;T;I"([ ::String, ::Integer ] | [ ] | nil;To;;I"´Returns an array of the names of the constants accessible in *mod*. This
includes the names of constants in any included modules (example at start of
section), unless the *inherit* parameter is set to `false`.

The implementation makes no guarantees about the order in which the constants
are yielded.

    IO.constants.include?(:SYNC)        #=> true
    IO.constants(false).include?(:SYNC) #=> false

Also see Module#const_defined?.

;T;0;;;I"constants;F;I"Module;T;[o;;I"?::boolish inherit;T;I"Array[::Symbol];To;;I"QDefines an instance method in the receiver. The *method* parameter can be a
`Proc`, a `Method` or an `UnboundMethod` object. If a block is specified, it
is used as the method body. If a block or the *method* parameter has
parameters, they're used as method parameters. This block is evaluated using
#instance_eval.

    class A
      def fred
        puts "In Fred"
      end
      def create_method(name, &block)
        self.class.define_method(name, &block)
      end
      define_method(:wilma) { puts "Charge it!" }
      define_method(:flint) {|name| puts "I'm #{name}!"}
    end
    class B < A
      define_method(:barney, instance_method(:fred))
    end
    a = B.new
    a.barney
    a.wilma
    a.flint('Dino')
    a.create_method(:betty) { p self }
    a.betty

*produces:*

    In Fred
    Charge it!
    I'm Dino!
    #<B:0x401b39e8>

;T;0;;;I"define_method;F;I"Module;T;[o;;I"H::Symbol | ::String arg0, ?::Proc | ::Method | ::UnboundMethod arg1;T;I"Symbol;To;;I"::Symbol | ::String arg0;T;I"Symbol;To;;I"UMakes a list of existing constants deprecated. Attempt to refer to them will
produce a warning.

    module HTTP
      NotFound = Exception.new
      NOT_FOUND = NotFound # previous version of the library used this name

      deprecate_constant :NOT_FOUND
    end

    HTTP::NOT_FOUND
    # warning: constant HTTP::NOT_FOUND is deprecated

;T;0;;;I"deprecate_constant;F;I"Module;T;[o;;I"*::Symbol;T;I"	self;To;;0;0;;;I"	eql?;F;I"Module;T;[o;;I"untyped other;T;I"	bool;To;;0;0;;;I"equal?;F;I"Module;T;[o;;I"untyped other;T;I"	bool;To;;I",Extends the specified object by adding this module's constants and methods
(which are added as singleton methods). This is the callback method used by
Object#extend.

    module Picky
      def Picky.extend_object(o)
        if String === o
          puts "Can't add Picky to a String"
        else
          puts "Picky added to #{o.class}"
          super
        end
      end
    end
    (s = Array.new).extend Picky  # Call Object.extend
    (s = "quick brown fox").extend Picky

*produces:*

    Picky added to Array
    Can't add Picky to a String

;T;0;;;I"extend_object;F;I"Module;T;[o;;I"untyped arg0;T;I"untyped;To;;I"ùThe equivalent of `included`, but for extended modules.

    module A
      def self.extended(mod)
        puts "#{self} extended in #{mod}"
      end
    end
    module Enumerable
      extend A
    end
     # => prints "A extended in Enumerable"

;T;0;;;I"extended;F;I"Module;T;[o;;I"::Module othermod;T;I"untyped;To;;I"JPrevents further modifications to *mod*.

This method returns self.

;T;0;;;I"freeze;F;I"Module;T;[o;;I" ;F;I"	self;To;;I"IInvokes Module.append_features on each parameter in reverse order.

;T;0;;;I"include;F;I"Module;T;[o;;I"*::Module arg0;T;I"	self;To;;I"Returns `true` if *module* is included or prepended in *mod* or one of *mod*'s
ancestors.

    module A
    end
    class B
      include A
    end
    class C < B
    end
    B.include?(A)   #=> true
    C.include?(A)   #=> true
    A.include?(A)   #=> false

;T;0;;;I"include?;F;I"Module;T;[o;;I"::Module arg0;T;I"	bool;To;;I"œCallback invoked whenever the receiver is included in another module or class.
This should be used in preference to `Module.append_features` if your code
wants to perform some action when a module is included in another.

    module A
      def A.included(mod)
        puts "#{self} included in #{mod}"
      end
    end
    module Enumerable
      include A
    end
     # => prints "A included in Enumerable"

;T;0;;;I"included;F;I"Module;T;[o;;I"::Module othermod;T;I"untyped;To;;I"!Returns the list of modules included or prepended in *mod* or one of *mod*'s
ancestors.

    module Sub
    end

    module Mixin
      prepend Sub
    end

    module Outer
      include Mixin
    end

    Mixin.included_modules   #=> [Sub]
    Outer.included_modules   #=> [Sub, Mixin]

;T;0;;;I"included_modules;F;I"Module;T;[o;;I" ;F;I"Array[::Module];To;;I"ùCreates a new anonymous module. If a block is given, it is passed the module
object, and the block is evaluated in the context of this module like
#module_eval.

    fred = Module.new do
      def meth1
        "hello"
      end
      def meth2
        "bye"
      end
    end
    a = "my string"
    a.extend(fred)   #=> "my string"
    a.meth1          #=> "hello"
    a.meth2          #=> "bye"

Assign the module to a constant (name starting uppercase) if you want to treat
it like a regular module.

;T;0;;;I"initialize;F;I"Module;T;[o;;I" ;F;I"Object;To;;I" ;F;I"	void;To;;I"ŠReturns an `UnboundMethod` representing the given instance method in *mod*.

    class Interpreter
      def do_a() print "there, "; end
      def do_d() print "Hello ";  end
      def do_e() print "!\n";     end
      def do_v() print "Dave";    end
      Dispatcher = {
        "a" => instance_method(:do_a),
        "d" => instance_method(:do_d),
        "e" => instance_method(:do_e),
        "v" => instance_method(:do_v)
      }
      def interpret(string)
        string.each_char {|b| Dispatcher[b].bind(self).call }
      end
    end

    interpreter = Interpreter.new
    interpreter.interpret('dave')

*produces:*

    Hello there, Dave!

;T;0;;;I"instance_method;F;I"Module;T;[o;;I"::Symbol arg0;T;I"UnboundMethod;To;;I"ýReturns an array containing the names of the public and protected instance
methods in the receiver. For a module, these are the public and protected
methods; for a class, they are the instance (not singleton) methods. If the
optional parameter is `false`, the methods of any ancestors are not included.

    module A
      def method1()  end
    end
    class B
      include A
      def method2()  end
    end
    class C < B
      def method3()  end
    end

    A.instance_methods(false)                   #=> [:method1]
    B.instance_methods(false)                   #=> [:method2]
    B.instance_methods(true).include?(:method1) #=> true
    C.instance_methods(false)                   #=> [:method3]
    C.instance_methods.include?(:method2)       #=> true

;T;0;;;I"instance_methods;F;I"Module;T;[o;;I"?::boolish include_super;T;I"Array[::Symbol];To;;I"CInvoked as a callback whenever an instance method is added to the receiver.

    module Chatty
      def self.method_added(method_name)
        puts "Adding #{method_name.inspect}"
      end
      def self.some_class_method() end
      def some_instance_method() end
    end

*produces:*

    Adding :some_instance_method

;T;0;;;I"method_added;F;I"Module;T;[o;;I"::Symbol meth;T;I"untyped;To;;I"×Returns `true` if the named method is defined by *mod*.  If *inherit* is set,
the lookup will also search *mod*'s ancestors. Public and protected methods
are matched. String arguments are converted to symbols.

    module A
      def method1()  end
      def protected_method1()  end
      protected :protected_method1
    end
    class B
      def method2()  end
      def private_method2()  end
      private :private_method2
    end
    class C < B
      include A
      def method3()  end
    end

    A.method_defined? :method1              #=> true
    C.method_defined? "method1"             #=> true
    C.method_defined? "method2"             #=> true
    C.method_defined? "method2", true       #=> true
    C.method_defined? "method2", false      #=> false
    C.method_defined? "method3"             #=> true
    C.method_defined? "protected_method1"   #=> true
    C.method_defined? "method4"             #=> false
    C.method_defined? "private_method2"     #=> false

;T;0;;;I"method_defined?;F;I"Module;T;[o;;I"1::Symbol | ::String name, ?::boolish inherit;T;I"	bool;To;;I"¾Invoked as a callback whenever an instance method is removed from the
receiver.

    module Chatty
      def self.method_removed(method_name)
        puts "Removing #{method_name.inspect}"
      end
      def self.some_class_method() end
      def some_instance_method() end
      class << self
        remove_method :some_class_method
      end
      remove_method :some_instance_method
    end

*produces:*

    Removing :some_instance_method

;T;0;;;I"method_removed;F;I"Module;T;[o;;I"::Symbol method_name;T;I"untyped;To;;I"rEvaluates the string or block in the context of *mod*, except that when a
block is given, constant/class variable lookup is not affected. This can be
used to add methods to a class. `module_eval` returns the result of evaluating
its argument. The optional *filename* and *lineno* parameters set the text for
error messages.

    class Thing
    end
    a = %q{def hello() "Hello there!" end}
    Thing.module_eval(a)
    puts Thing.new.hello()
    Thing.module_eval("invalid code", "dummy", 123)

*produces:*

    Hello there!
    dummy:123:in `module_eval': undefined local variable
        or method `code' for Thing:Class

;T;0;;;I"module_eval;F;I"Module;T;[o;;I"9::String arg0, ?::String filename, ?::Integer lineno;T;I"untyped;To;;I" ;F;I"U;Fo;;I"’Evaluates the given block in the context of the class/module. The method
defined in the block will belong to the receiver. Any arguments passed to the
method will be passed to the block. This can be used if the block needs to
access instance variables.

    class Thing
    end
    Thing.class_exec{
      def hello() "Hello there!" end
    }
    puts Thing.new.hello()

*produces:*

    Hello there!

;T;0;;;I"module_exec;F;I"Module;T;[o;;I"*untyped args;T;I"U;Fo;;I" Creates module functions for the named methods. These functions may be called
with the module as a receiver, and also become available as instance methods
to classes that mix in the module. Module functions are copies of the
original, and so may be changed independently. The instance-method versions
are made private. If used with no arguments, subsequently defined methods
become module functions. String arguments are converted to symbols. If a
single argument is passed, it is returned. If no argument is passed, nil is
returned. If multiple arguments are passed, the arguments are returned as an
array.

    module Mod
      def one
        "This is one"
      end
      module_function :one
    end
    class Cls
      include Mod
      def call_one
        one
      end
    end
    Mod.one     #=> "This is one"
    c = Cls.new
    c.call_one  #=> "This is one"
    module Mod
      def one
        "This is the new one"
      end
    end
    Mod.one     #=> "This is one"
    c.call_one  #=> "This is the new one"

;T;0;;;I"module_function;F;I"Module;T;[o;;I"*::Symbol | ::String arg0;T;I"	self;To;;I"PReturns the name of the module *mod*.  Returns nil for anonymous modules.

;T;0;;;I"	name;F;I"Module;T;[o;;I" ;F;I"String?;To;;I"JInvokes Module.prepend_features on each parameter in reverse order.

;T;0;;;I"prepend;F;I"Module;T;[o;;I"*::Module arg0;T;I"	self;To;;I"XWhen this module is prepended in another, Ruby calls #prepend_features in this
module, passing it the receiving module in *mod*. Ruby's default
implementation is to overlay the constants, methods, and module variables of
this module to *mod* if this module has not already been added to *mod* or one
of its ancestors. See also Module#prepend.

;T;0;;;I"prepend_features;F;I"Module;T;[o;;I"::Module arg0;T;I"	self;To;;I"þThe equivalent of `included`, but for prepended modules.

    module A
      def self.prepended(mod)
        puts "#{self} prepended to #{mod}"
      end
    end
    module Enumerable
      prepend A
    end
     # => prints "A prepended to Enumerable"

;T;0;;;I"prepended;F;I"Module;T;[o;;I"::Module othermod;T;I"untyped;To;;I"With no arguments, sets the default visibility for subsequently defined
methods to private. With arguments, sets the named methods to have private
visibility. String arguments are converted to symbols. An Array of Symbols
and/or Strings is also accepted. If a single argument is passed, it is
returned. If no argument is passed, nil is returned. If multiple arguments are
passed, the arguments are returned as an array.

    module Mod
      def a()  end
      def b()  end
      private
      def c()  end
      private :a
    end
    Mod.private_instance_methods   #=> [:a, :c]

Note that to show a private method on RDoc, use `:doc:`.

;T;0;;;I"private;F;I"Module;T;[
o;;I" ;F;I"nil;To;;I"::Symbol method_name;T;I"Symbol;To;;I".::Symbol, ::Symbol, *::Symbol method_name;T;I"Array[::Symbol];To;;I"::string method_name;T;I"string;To;;I"O::string | ::Symbol, ::string | ::Symbol, *::string | ::Symbol method_name;T;I"Array[::string | ::Symbol];To;;I"€Makes existing class methods private. Often used to hide the default
constructor `new`.

String arguments are converted to symbols. An Array of Symbols and/or Strings
is also accepted.

    class SimpleSingleton  # Not thread safe
      private_class_method :new
      def SimpleSingleton.create(*args, &block)
        @me = new(*args, &block) if ! @me
        @me
      end
    end

;T;0;;;I"private_class_method;F;I"Module;T;[o;;I"*::Symbol | ::String arg0;T;I"	self;To;;I"2Makes a list of existing constants private.

;T;0;;;I"private_constant;F;I"Module;T;[o;;I"*::Symbol arg0;T;I"	self;To;;I"\Returns a list of the private instance methods defined in *mod*. If the
optional parameter is `false`, the methods of any ancestors are not included.

    module Mod
      def method1()  end
      private :method1
      def method2()  end
    end
    Mod.instance_methods           #=> [:method2]
    Mod.private_instance_methods   #=> [:method1]

;T;0;;;I"private_instance_methods;F;I"Module;T;[o;;I"?::boolish include_super;T;I"Array[::Symbol];To;;I"¼Returns `true` if the named private method is defined by *mod*.  If *inherit*
is set, the lookup will also search *mod*'s ancestors. String arguments are
converted to symbols.

    module A
      def method1()  end
    end
    class B
      private
      def method2()  end
    end
    class C < B
      include A
      def method3()  end
    end

    A.method_defined? :method1                   #=> true
    C.private_method_defined? "method1"          #=> false
    C.private_method_defined? "method2"          #=> true
    C.private_method_defined? "method2", true    #=> true
    C.private_method_defined? "method2", false   #=> false
    C.method_defined? "method2"                  #=> false

;T;0;;;I"private_method_defined?;F;I"Module;T;[o;;I"1::Symbol | ::String name, ?::boolish inherit;T;I"	bool;To;;I"%With no arguments, sets the default visibility for subsequently defined
methods to protected. With arguments, sets the named methods to have protected
visibility. String arguments are converted to symbols. An Array of Symbols
and/or Strings is also accepted. If a single argument is passed, it is
returned. If no argument is passed, nil is returned. If multiple arguments are
passed, the arguments are returned as an array.

If a method has protected visibility, it is callable only where `self` of the
context is the same as the method. (method definition or instance_eval). This
behavior is different from Java's protected method. Usually `private` should
be used.

Note that a protected method is slow because it can't use inline cache.

To show a private method on RDoc, use `:doc:` instead of this.

;T;0;;;I"protected;F;I"Module;T;[o;;I"*::Symbol | ::String arg0;T;I"	self;To;;I"™Returns a list of the protected instance methods defined in *mod*. If the
optional parameter is `false`, the methods of any ancestors are not included.

;T;0;;;I"protected_instance_methods;F;I"Module;T;[o;;I"?::boolish include_super;T;I"Array[::Symbol];To;;I"ÂReturns `true` if the named protected method is defined *mod*.  If *inherit*
is set, the lookup will also search *mod*'s ancestors. String arguments are
converted to symbols.

    module A
      def method1()  end
    end
    class B
      protected
      def method2()  end
    end
    class C < B
      include A
      def method3()  end
    end

    A.method_defined? :method1                    #=> true
    C.protected_method_defined? "method1"         #=> false
    C.protected_method_defined? "method2"         #=> true
    C.protected_method_defined? "method2", true   #=> true
    C.protected_method_defined? "method2", false  #=> false
    C.method_defined? "method2"                   #=> true

;T;0;;;I"protected_method_defined?;F;I"Module;T;[o;;I"1::Symbol | ::String name, ?::boolish inherit;T;I"	bool;To;;I"£With no arguments, sets the default visibility for subsequently defined
methods to public. With arguments, sets the named methods to have public
visibility. String arguments are converted to symbols. An Array of Symbols
and/or Strings is also accepted. If a single argument is passed, it is
returned. If no argument is passed, nil is returned. If multiple arguments are
passed, the arguments are returned as an array.

;T;0;;;I"public;F;I"Module;T;[
o;;I" ;F;I"nil;To;;I"::Symbol method_name;T;I"Symbol;To;;I".::Symbol, ::Symbol, *::Symbol method_name;T;I"Array[::Symbol];To;;I"::string method_name;T;I"string;To;;I"O::string | ::Symbol, ::string | ::Symbol, *::string | ::Symbol method_name;T;I"Array[::string | ::Symbol];To;;I"‘Makes a list of existing class methods public.

String arguments are converted to symbols. An Array of Symbols and/or Strings
is also accepted.

;T;0;;;I"public_class_method;F;I"Module;T;[o;;I"*::Symbol | ::String arg0;T;I"	self;To;;I"1Makes a list of existing constants public.

;T;0;;;I"public_constant;F;I"Module;T;[o;;I"*::Symbol arg0;T;I"	self;To;;I"ASimilar to *instance_method*, searches public method only.

;T;0;;;I"public_instance_method;F;I"Module;T;[o;;I"::Symbol arg0;T;I"UnboundMethod;To;;I"–Returns a list of the public instance methods defined in *mod*. If the
optional parameter is `false`, the methods of any ancestors are not included.

;T;0;;;I"public_instance_methods;F;I"Module;T;[o;;I"?::boolish include_super;T;I"Array[::Symbol];To;;I"¯Returns `true` if the named public method is defined by *mod*.  If *inherit*
is set, the lookup will also search *mod*'s ancestors. String arguments are
converted to symbols.

    module A
      def method1()  end
    end
    class B
      protected
      def method2()  end
    end
    class C < B
      include A
      def method3()  end
    end

    A.method_defined? :method1                 #=> true
    C.public_method_defined? "method1"         #=> true
    C.public_method_defined? "method1", true   #=> true
    C.public_method_defined? "method1", false  #=> true
    C.public_method_defined? "method2"         #=> false
    C.method_defined? "method2"                #=> true

;T;0;;;I"public_method_defined?;F;I"Module;T;[o;;I"1::Symbol | ::String name, ?::boolish inherit;T;I"	bool;To;;I"ZRefine *mod* in the receiver.

Returns a module, where refined methods are defined.

;T;0;;;I"refine;F;I"Module;T;[o;;I"::Class arg0;T;I"	self;To;;I"àRemoves the named class variable from the receiver, returning that variable's
value.

    class Example
      @@var = 99
      puts remove_class_variable(:@@var)
      p(defined? @@var)
    end

*produces:*

    99
    nil

;T;0;;;I"remove_class_variable;F;I"Module;T;[o;;I"::Symbol arg0;T;I"untyped;To;;I"ÄRemoves the definition of the given constant, returning that constant's
previous value.  If that constant referred to a module, this will not change
that module's name and can lead to confusion.

;T;0;;;I"remove_const;F;I"Module;T;[o;;I"::Symbol arg0;T;I"untyped;To;;I"—Removes the method identified by *symbol* from the current class. For an
example, see Module#undef_method. String arguments are converted to symbols.

;T;0;;;I"remove_method;F;I"Module;T;[o;;I"*::Symbol | ::String arg0;T;I"	self;To;;I"×Returns `true` if *mod* is a singleton class or `false` if it is an ordinary
class or module.

    class C
    end
    C.singleton_class?                  #=> false
    C.singleton_class.singleton_class?  #=> true

;T;0;;;I"singleton_class?;F;I"Module;T;[o;;I" ;F;I"	bool;To;;I"²Returns a string representing this module or class. For basic classes and
modules, this is the name. For singletons, we show information on the thing
we're attached to as well.

;T;0;;;I"	to_s;F;I"Module;T;[o;;I" ;F;I"String;To;;I"Prevents the current class from responding to calls to the named method.
Contrast this with `remove_method`, which deletes the method from the
particular class; Ruby will still search superclasses and mixed-in modules for
a possible receiver. String arguments are converted to symbols.

    class Parent
      def hello
        puts "In parent"
      end
    end
    class Child < Parent
      def hello
        puts "In child"
      end
    end

    c = Child.new
    c.hello

    class Child
      remove_method :hello  # remove from child, still in parent
    end
    c.hello

    class Child
      undef_method :hello   # prevent any calls to 'hello'
    end
    c.hello

*produces:*

    In child
    In parent
    prog.rb:23: undefined method `hello' for #<Child:0x401b3bb4> (NoMethodError)

;T;0;;;I"undef_method;F;I"Module;T;[o;;I"*::Symbol | ::String arg0;T;I"	self;To;;I"ZImport class refinements from *module* into the current class or module
definition.

;T;0;;;I"
using;F;I"Module;T;[o;;I"::Module arg0;T;I"	self;To;;I"²Returns a string representing this module or class. For basic classes and
modules, this is the name. For singletons, we show information on the thing
we're attached to as well.

;T;0;;;I"inspect;F;I"Module;T;[o;;I" ;F;I"String;To;;I"îThe first form is equivalent to #attr_reader. The second form is equivalent to
`attr_accessor(name)` but deprecated. The last form is equivalent to
`attr_reader(name)` but deprecated. Returns an array of defined method names
as symbols.

;T;0;;;I"	attr;F;I"Module;T;[o;;I"*::Symbol | ::String arg0;T;I"NilClass;To; ;I"/The class of the singleton object `nil`.

;T;0;	I"NilClass;T;
[ ;[ ;0;[ ;[ ;0;0o;;0;0;;;I"!;F;I"NilClass;T;[o;;I" ;F;I"	true;Fo;;I"ŽAnd---Returns `false`. *obj* is always evaluated as it is the argument to a
method call---there is no short-circuit evaluation in this case.

;T;0;;;I"&;F;I"NilClass;T;[o;;I"untyped obj;T;I"
false;Fo;;I"©Case Equality -- For class Object, effectively the same as calling `#==`, but
typically overridden by descendants to provide meaningful semantics in `case`
statements.

;T;0;;;I"===;F;I"NilClass;T;[o;;I"nil;T;I"	true;Fo;;I"untyped obj;T;I"
false;Fo;;I"4Dummy pattern matching -- always returns nil.

;T;0;;;I"=~;F;I"NilClass;T;[o;;I"untyped obj;T;I"nil;To;;I"_Exclusive Or---If *obj* is `nil` or `false`, returns `false`; otherwise,
returns `true`.

;T;0;;;I"^;F;I"NilClass;T;[o;;I"nil;T;I"
false;Fo;;I"
false;T;I"
false;Fo;;I"untyped obj;T;I"	true;Fo;;I"'Always returns the string "nil".

;T;0;;;I"inspect;F;I"NilClass;T;[o;;I" ;F;I"
"nil";To;;I"7Only the object *nil* responds `true` to `nil?`.

;T;0;;;I"	nil?;F;I"NilClass;T;[o;;I" ;F;I"	true;Fo;;I"RReturns zero as a rational.  The optional argument `eps` is always ignored.

;T;0;;;I"rationalize;F;I"NilClass;T;[o;;I"?untyped eps;T;I"Rational;To;;I"<Always returns an empty array.

    nil.to_a   #=> []

;T;0;;;I"	to_a;F;I"NilClass;T;[o;;I" ;F;I"[ ];To;;I"!Returns zero as a complex.

;T;0;;;I"	to_c;F;I"NilClass;T;[o;;I" ;F;I"Complex;To;;I"3Always returns zero.

    nil.to_f   #=> 0.0

;T;0;;;I"	to_f;F;I"NilClass;T;[o;;I" ;F;I"
Float;To;;I";Always returns an empty hash.

    nil.to_h   #=> {}

;T;0;;;I"	to_h;F;I"NilClass;T;[o;;I" ;F;I"Hash[untyped, untyped];To;;I"1Always returns zero.

    nil.to_i   #=> 0

;T;0;;;I"	to_i;F;I"NilClass;T;[o;;I" ;F;I"0;Fo;;I""Returns zero as a rational.

;T;0;;;I"	to_r;F;I"NilClass;T;[o;;I" ;F;I"Rational;To;;I"'Always returns the empty string.

;T;0;;;I"	to_s;F;I"NilClass;T;[o;;I" ;F;I""";To;;I"KOr---Returns `false` if *obj* is `nil` or `false`; `true` otherwise.

;T;0;;;I"|;F;I"NilClass;T;[o;;I"nil;T;I"
false;Fo;;I"
false;T;I"
false;Fo;;I"untyped obj;T;I"	true;Fo;;0;0;;;I"
clone;F;I"NilClass;T;[o;;I"?freeze: true?;T;I"	self;To; ;0;0;	I"NilClass;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"{Returns nil represented as a BigDecimal.

    require 'bigdecimal'
    require 'bigdecimal/util'

    nil.to_d   # => 0.0

;T;0;;;I"	to_d;F;I"NilClass;T;[o;;I" ;F;I"BigDecimal;To; ;0;0;	I"NilClass;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"-Returns a JSON string for nil: 'null'.

;T;0;;;I"to_json;F;I"NilClass;T;[o;;I"?::JSON::State state;T;I"String;To; ;I"ÛNumeric is the class from which all higher-level numeric classes should
inherit.

Numeric allows instantiation of heap-allocated objects. Other core numeric
classes such as Integer are implemented as immediates, which means that each
Integer is a single immutable object which is always passed by value.

    a = 1
    1.object_id == a.object_id   #=> true

There can only ever be one instance of the integer `1`, for example. Ruby
ensures this by preventing instantiation. If duplication is attempted, the
same instance is returned.

    Integer.new(1)                   #=> NoMethodError: undefined method `new' for Integer:Class
    1.dup                            #=> 1
    1.object_id == 1.dup.object_id   #=> true

For this reason, Numeric should be used when defining other numeric classes.

Classes which inherit from Numeric must implement `coerce`, which returns a
two-member Array containing an object that has been coerced into an instance
of the new class and `self` (see #coerce).

Inheriting classes should also implement arithmetic operator methods (`+`,
`-`, `*` and `/`) and the `<=>` operator (see Comparable). These methods may
rely on `coerce` to ensure interoperability with instances of other numeric
classes.

    class Tally < Numeric
      def initialize(string)
        @string = string
      end

      def to_s
        @string
      end

      def to_i
        @string.size
      end

      def coerce(other)
        [self.class.new('|' * other.to_i), self]
      end

      def <=>(other)
        to_i <=> other.to_i
      end

      def +(other)
        self.class.new('|' * (to_i + other.to_i))
      end

      def -(other)
        self.class.new('|' * (to_i - other.to_i))
      end

      def *(other)
        self.class.new('|' * (to_i * other.to_i))
      end

      def /(other)
        self.class.new('|' * (to_i / other.to_i))
      end
    end

    tally = Tally.new('||')
    puts tally * 2            #=> "||||"
    puts tally > 1            #=> true

## What's Here

First, what's elsewhere. Class Numeric:

*   Inherits from [class
    Object](Object.html#class-Object-label-What-27s+Here).
*   Includes [module
    Comparable](Comparable.html#module-Comparable-label-What-27s+Here).


Here, class Numeric provides methods for:

*   [Querying](#class-Numeric-label-Querying)
*   [Comparing](#class-Numeric-label-Comparing)
*   [Converting](#class-Numeric-label-Converting)
*   [Other](#class-Numeric-label-Other)


### Querying

    #finite?
:       Returns true unless `self` is infinite or not a number.

    #infinite?
:       Returns -1, `nil` or +1, depending on whether `self` is
        `-Infinity<tt>, finite, or <tt>+Infinity`.

    #integer?
:       Returns whether `self` is an integer.

    #negative?
:       Returns whether `self` is negative.

    #nonzero?
:       Returns whether `self` is not zero.

    #positive?
:       Returns whether `self` is positive.

    #real?
:       Returns whether `self` is a real value.

    #zero?
:       Returns whether `self` is zero.



### Comparing

    [<=>](#method-i-3C-3D-3E)
:       Returns:

    *   -1 if  `self` is less than the given value.
    *   0 if `self` is equal to the given value.
    *   1 if `self` is greater than the given value.
    *   `nil` if `self` and the given value are not comparable.

    #eql?
:       Returns whether `self` and the given value have the same value and
        type.



### Converting

    #% (aliased as #modulo)
:       Returns the remainder of `self` divided by the given value.

    #-@
:       Returns the value of `self`, negated.

    #abs (aliased as #magnitude)
:       Returns the absolute value of `self`.

    #abs2
:       Returns the square of `self`.

    #angle (aliased as #arg and #phase)
:       Returns 0 if `self` is positive, Math::PI otherwise.

    #ceil
:       Returns the smallest number greater than or equal to `self`, to a
        given precision.

    #coerce
:       Returns array `[coerced_self, coerced_other]` for the given other
        value.

    #conj (aliased as #conjugate)
:       Returns the complex conjugate of `self`.

    #denominator
:       Returns the denominator (always positive) of the Rational
        representation of `self`.

    #div
:       Returns the value of `self` divided by the given value and converted
        to an integer.

    #divmod
:       Returns array `[quotient, modulus]` resulting from dividing `self` the
        given divisor.

    #fdiv
:       Returns the Float result of dividing `self` by the given divisor.

    #floor
:       Returns the largest number less than or equal to `self`, to a given
        precision.

    #i
:       Returns the Complex object `Complex(0, self)`. the given value.

    #imaginary (aliased as #imag)
:       Returns the imaginary part of the `self`.

    #numerator
:       Returns the numerator of the Rational representation of `self`; has
        the same sign as `self`.

    #polar
:       Returns the array `[self.abs, self.arg]`.

    #quo
:       Returns the value of `self` divided by the given value.

    #real
:       Returns the real part of `self`.

    #rect (aliased as #rectangular)
:       Returns the array `[self, 0]`.

    #remainder
:       Returns `self-arg*(self/arg).truncate` for the given `arg`.

    #round
:       Returns the value of `self` rounded to the nearest value for the given
        a precision.

    #to_c
:       Returns the Complex representation of `self`.

    #to_int
:       Returns the Integer representation of `self`, truncating if necessary.

    #truncate
:       Returns `self` truncated (toward zero) to a given precision.



### Other

    #clone
:       Returns `self`; does not allow freezing.

    #dup (aliased as #+@)
:       Returns `self`.

    #step
:       Invokes the given block with the sequence of specified numbers.

;T;0;	I"Numeric;T;
[ ;[I"Comparable;T;0;[ ;[ ;0;0o;;I"õReturns `self` modulo `other` as a real number.

Of the Core and Standard Library classes, only Rational uses this
implementation.

For Rational `r` and real number `n`, these expressions are equivalent:

    c % n
    c-n*(c/n).floor
    c.divmod(n)[1]

See Numeric#divmod.

Examples:

    r = Rational(1, 2)    # => (1/2)
    r2 = Rational(2, 3)   # => (2/3)
    r % r2                # => (1/2)
    r % 2                 # => (1/2)
    r % 2.0               # => 0.5

    r = Rational(301,100) # => (301/100)
    r2 = Rational(7,5)    # => (7/5)
    r % r2                # => (21/100)
    r % -r2               # => (-119/100)
    (-r) % r2             # => (119/100)
    (-r) %-r2             # => (-21/100)

Numeric#modulo is an alias for Numeric#%.

;T;0;;;I"%;F;I"Numeric;T;[o;;I"::Numeric;T;I"Numeric;To;;I"^Performs addition: the class of the resulting object depends on the class of
`numeric`.

;T;0;;;I"+;F;I"Numeric;T;[o;;I"::Numeric;T;I"Numeric;To;;I"Returns `self`.

;T;0;;;I"+@;F;I"Numeric;T;[o;;I" ;F;I"Numeric;To;;I"aPerforms subtraction: the class of the resulting object depends on the class
of `numeric`.

;T;0;;;I"-;F;I"Numeric;T;[o;;I"::Numeric;T;I"Numeric;To;;I"3Unary Minus---Returns the receiver, negated.

;T;0;;;I"-@;F;I"Numeric;T;[o;;I" ;F;I"Numeric;To;;I"Returns zero if `self` is the same as `other`, `nil` otherwise.

No subclass in the Ruby Core or Standard Library uses this implementation.

;T;0;;;I"<=>;F;I"Numeric;T;[o;;I"::Numeric other;T;I"Integer;To;;I"©Returns the absolute value of `self`.

    12.abs        #=> 12
    (-34.56).abs  #=> 34.56
    -34.56.abs    #=> 34.56

Numeric#magnitude is an alias for Numeric#abs.

;T;0;;;I"abs;F;I"Numeric;T;[o;;I" ;F;I"Numeric;To;;I"Returns square of self.

;T;0;;;I"	abs2;F;I"Numeric;T;[o;;I" ;F;I"Numeric;To;;I"8Returns 0 if the value is positive, pi otherwise.

;T;0;;;I"
angle;F;I"Numeric;T;[o;;I" ;F;I"Numeric;To;;I"ÄReturns the smallest number that is greater than or equal to `self` with a
precision of `digits` decimal digits.

Numeric implements this by converting `self` to a Float and invoking
Float#ceil.

;T;0;;;I"	ceil;F;I"Numeric;T;[o;;I" ;F;I"Integer;To;;I"::Integer digits;T;I"Integer | ::Numeric;To;;I"ðReturns a 2-element array containing two numeric elements, formed from the two
operands `self` and `other`, of a common compatible type.

Of the Core and Standard Library classes, Integer, Rational, and Complex use
this implementation.

Examples:

    i = 2                    # => 2
    i.coerce(3)              # => [3, 2]
    i.coerce(3.0)            # => [3.0, 2.0]
    i.coerce(Rational(1, 2)) # => [0.5, 2.0]
    i.coerce(Complex(3, 4))  # Raises RangeError.

    r = Rational(5, 2)       # => (5/2)
    r.coerce(2)              # => [(2/1), (5/2)]
    r.coerce(2.0)            # => [2.0, 2.5]
    r.coerce(Rational(2, 3)) # => [(2/3), (5/2)]
    r.coerce(Complex(3, 4))  # => [(3+4i), ((5/2)+0i)]

    c = Complex(2, 3)        # => (2+3i)
    c.coerce(2)              # => [(2+0i), (2+3i)]
    c.coerce(2.0)            # => [(2.0+0i), (2+3i)]
    c.coerce(Rational(1, 2)) # => [((1/2)+0i), (2+3i)]
    c.coerce(Complex(3, 4))  # => [(3+4i), (2+3i)]

Raises an exception if any type conversion fails.

;T;0;;;I"coerce;F;I"Numeric;T;[o;;I"::Numeric;T;I"[ ::Numeric, ::Numeric ];To;;I"Returns self.

;T;0;;;I"	conj;F;I"Numeric;T;[o;;I" ;F;I"Numeric;To;;I"Returns self.

;T;0;;;I"conjugate;F;I"Numeric;T;[o;;I" ;F;I"Numeric;To;;I"1Returns the denominator (always positive).

;T;0;;;I"denominator;F;I"Numeric;T;[o;;I" ;F;I"Integer;To;;I"ÿReturns the quotient `self/other` as an integer (via `floor`), using method
`/` in the derived class of `self`. (Numeric itself does not define method
`/`.)

Of the Core and Standard Library classes, Float, Rational, and Complex use
this implementation.

;T;0;;;I"div;F;I"Numeric;T;[o;;I"::Numeric;T;I"Integer;To;;I"ZReturns a 2-element array `[q, r]`, where

    q = (self/other).floor                  # Quotient
    r = self % other                        # Remainder

Of the Core and Standard Library classes, only Rational uses this
implementation.

Examples:

    Rational(11, 1).divmod(4)               # => [2, (3/1)]
    Rational(11, 1).divmod(-4)              # => [-3, (-1/1)]
    Rational(-11, 1).divmod(4)              # => [-3, (1/1)]
    Rational(-11, 1).divmod(-4)             # => [2, (-3/1)]

    Rational(12, 1).divmod(4)               # => [3, (0/1)]
    Rational(12, 1).divmod(-4)              # => [-3, (0/1)]
    Rational(-12, 1).divmod(4)              # => [-3, (0/1)]
    Rational(-12, 1).divmod(-4)             # => [3, (0/1)]

    Rational(13, 1).divmod(4.0)             # => [3, 1.0]
    Rational(13, 1).divmod(Rational(4, 11)) # => [35, (3/11)]

;T;0;;;I"divmod;F;I"Numeric;T;[o;;I"::Numeric;T;I"[ ::Numeric, ::Numeric ];To;;I"½Returns `true` if `self` and `other` are the same type and have equal values.

Of the Core and Standard Library classes, only Integer, Rational, and Complex
use this implementation.

Examples:

    1.eql?(1)              # => true
    1.eql?(1.0)            # => false
    1.eql?(Rational(1, 1)) # => false
    1.eql?(Complex(1, 0))  # => false

Method `eql?` is different from +==+ in that `eql?` requires matching types,
while +==+ does not.

;T;0;;;I"	eql?;F;I"Numeric;T;[o;;I"untyped;T;I"	bool;To;;I"âReturns the quotient `self/other` as a float, using method `/` in the derived
class of `self`. (Numeric itself does not define method `/`.)

Of the Core and Standard Library classes, only BigDecimal uses this
implementation.

;T;0;;;I"	fdiv;F;I"Numeric;T;[o;;I"::Numeric;T;I"Numeric;To;;I"MReturns `true` if `num` is a finite number, otherwise returns `false`.

;T;0;;;I"finite?;F;I"Numeric;T;[o;;I" ;F;I"	bool;To;;I"ÁReturns the largest number that is less than or equal to `self` with a
precision of `digits` decimal digits.

Numeric implements this by converting `self` to a Float and invoking
Float#floor.

;T;0;;;I"
floor;F;I"Numeric;T;[o;;I" ;F;I"Integer;To;;I"::Integer digits;T;I"Numeric;To;;I"ÖReturns `Complex(0, self)`:

    2.i              # => (0+2i)
    -2.i             # => (0-2i)
    2.0.i            # => (0+2.0i)
    Rational(1, 2).i # => (0+(1/2)*i)
    Complex(3, 4).i  # Raises NoMethodError.

;T;0;;;I"i;F;I"Numeric;T;[o;;I" ;F;I"Complex;To;;I"Returns zero.

;T;0;;;I"	imag;F;I"Numeric;T;[o;;I" ;F;I"Numeric;To;;I"Returns zero.

;T;0;;;I"imaginary;F;I"Numeric;T;[o;;I" ;F;I"Numeric;To;;I"eReturns `nil`, -1, or 1 depending on whether the value is finite, `-Infinity`,
or `+Infinity`.

;T;0;;;I"infinite?;F;I"Numeric;T;[o;;I" ;F;I"Integer?;To;;I"gReturns `true` if `num` is an Integer.

    1.0.integer?   #=> false
    1.integer?     #=> true

;T;0;;;I"integer?;F;I"Numeric;T;[o;;I" ;F;I"	bool;To;;I"õReturns `self` modulo `other` as a real number.

Of the Core and Standard Library classes, only Rational uses this
implementation.

For Rational `r` and real number `n`, these expressions are equivalent:

    c % n
    c-n*(c/n).floor
    c.divmod(n)[1]

See Numeric#divmod.

Examples:

    r = Rational(1, 2)    # => (1/2)
    r2 = Rational(2, 3)   # => (2/3)
    r % r2                # => (1/2)
    r % 2                 # => (1/2)
    r % 2.0               # => 0.5

    r = Rational(301,100) # => (301/100)
    r2 = Rational(7,5)    # => (7/5)
    r % r2                # => (21/100)
    r % -r2               # => (-119/100)
    (-r) % r2             # => (119/100)
    (-r) %-r2             # => (-21/100)

Numeric#modulo is an alias for Numeric#%.

;T;0;;;I"modulo;F;I"Numeric;T;[o;;I"::Numeric;T;I"Numeric;To;;I"BReturns `true` if `self` is less than 0, `false` otherwise.

;T;0;;;I"negative?;F;I"Numeric;T;[o;;I" ;F;I"	bool;To;;I"¸Returns `self` if `self` is not a zero value, `nil` otherwise; uses method
`zero?` for the evaluation.

The returned `self` allows the method to be chained:

    a = %w[z Bb bB bb BB a aA Aa AA A]
    a.sort {|a, b| (a.downcase <=> b.downcase).nonzero? || a <=> b }
    # => ["A", "a", "AA", "Aa", "aA", "BB", "Bb", "bB", "bb", "z"]

Of the Core and Standard Library classes, Integer, Float, Rational, and
Complex use this implementation.

;T;0;;;I"nonzero?;F;I"Numeric;T;[o;;I" ;F;I"
self?;To;;I"Returns the numerator.

;T;0;;;I"numerator;F;I"Numeric;T;[o;;I" ;F;I"Numeric;To;;I",Returns an array; [num.abs, num.arg].

;T;0;;;I"
polar;F;I"Numeric;T;[o;;I" ;F;I"[ ::Numeric, ::Numeric ];To;;I"EReturns `true` if `self` is greater than 0, `false` otherwise.

;T;0;;;I"positive?;F;I"Numeric;T;[o;;I" ;F;I"	bool;To;;I"QReturns the most exact division (rational for integers, float for floats).

;T;0;;;I"quo;F;I"Numeric;T;[o;;I"::Numeric;T;I"Numeric;To;;I"Returns self.

;T;0;;;I"	real;F;I"Numeric;T;[o;;I" ;F;I"Numeric;To;;I"CReturns `true` if `num` is a real number (i.e. not Complex).

;T;0;;;I"
real?;F;I"Numeric;T;[o;;I" ;F;I"	bool;To;;I""Returns an array; [num, 0].

;T;0;;;I"	rect;F;I"Numeric;T;[o;;I" ;F;I"[ ::Numeric, ::Numeric ];To;;I"Returns the remainder after dividing `self` by `other`.

Of the Core and Standard Library classes, only Float and Rational use this
implementation.

Examples:

    11.0.remainder(4)              # => 3.0
    11.0.remainder(-4)             # => 3.0
    -11.0.remainder(4)             # => -3.0
    -11.0.remainder(-4)            # => -3.0

    12.0.remainder(4)              # => 0.0
    12.0.remainder(-4)             # => 0.0
    -12.0.remainder(4)             # => -0.0
    -12.0.remainder(-4)            # => -0.0

    13.0.remainder(4.0)            # => 1.0
    13.0.remainder(Rational(4, 1)) # => 1.0

    Rational(13, 1).remainder(4)   # => (1/1)
    Rational(13, 1).remainder(-4)  # => (1/1)
    Rational(-13, 1).remainder(4)  # => (-1/1)
    Rational(-13, 1).remainder(-4) # => (-1/1)

;T;0;;;I"remainder;F;I"Numeric;T;[o;;I"::Numeric;T;I"Numeric;To;;I"­Returns `self` rounded to the nearest value with a precision of `digits`
decimal digits.

Numeric implements this by converting `self` to a Float and invoking
Float#round.

;T;0;;;I"
round;F;I"Numeric;T;[o;;I" ;F;I"Integer;To;;I"::Integer digits;T;I"Numeric;To;;I"|Generates a sequence of numbers; with a block given, traverses the sequence.

    Of the Core and Standard Library classes,
    Integer, Float, and Rational use this implementation.

    A quick example:

      squares = []
      1.step(by: 2, to: 10) {|i| squares.push(i*i) }
      squares # => [1, 9, 25, 49, 81]

    The generated sequence:

    - Begins with +self+.
    - Continues at intervals of +step+ (which may not be zero).
    - Ends with the last number that is within or equal to +limit+;
      that is, less than or equal to +limit+ if +step+ is positive,
      greater than or equal to +limit+ if +step+ is negative.
      If +limit+ is not given, the sequence is of infinite length.

    If a block is given, calls the block with each number in the sequence;
    returns +self+.  If no block is given, returns an Enumerator::ArithmeticSequence.

    <b>Keyword Arguments</b>

    With keyword arguments +by+ and +to+,
    their values (or defaults) determine the step and limit:

      # Both keywords given.
      squares = []
      4.step(by: 2, to: 10) {|i| squares.push(i*i) }    # => 4
      squares # => [16, 36, 64, 100]
      cubes = []
      3.step(by: -1.5, to: -3) {|i| cubes.push(i*i*i) } # => 3
      cubes   # => [27.0, 3.375, 0.0, -3.375, -27.0]
      squares = []
      1.2.step(by: 0.2, to: 2.0) {|f| squares.push(f*f) }
      squares # => [1.44, 1.9599999999999997, 2.5600000000000005, 3.24, 4.0]

      squares = []
      Rational(6/5).step(by: 0.2, to: 2.0) {|r| squares.push(r*r) }
      squares # => [1.0, 1.44, 1.9599999999999997, 2.5600000000000005, 3.24, 4.0]

      # Only keyword to given.
      squares = []
      4.step(to: 10) {|i| squares.push(i*i) }           # => 4
      squares # => [16, 25, 36, 49, 64, 81, 100]
      # Only by given.

      # Only keyword by given
      squares = []
      4.step(by:2) {|i| squares.push(i*i); break if i > 10 }
      squares # => [16, 36, 64, 100, 144]

      # No block given.
      e = 3.step(by: -1.5, to: -3) # => (3.step(by: -1.5, to: -3))
      e.class                      # => Enumerator::ArithmeticSequence

    <b>Positional Arguments</b>

    With optional positional arguments +limit+ and +step+,
    their values (or defaults) determine the step and limit:

      squares = []
      4.step(10, 2) {|i| squares.push(i*i) }    # => 4
      squares # => [16, 36, 64, 100]
      squares = []
      4.step(10) {|i| squares.push(i*i) }
      squares # => [16, 25, 36, 49, 64, 81, 100]
      squares = []
      4.step {|i| squares.push(i*i); break if i > 10 }  # => nil
      squares # => [16, 25, 36, 49, 64, 81, 100, 121]

**Implementation Notes**

    If all the arguments are integers, the loop operates using an integer
    counter.

    If any of the arguments are floating point numbers, all are converted
    to floats, and the loop is executed
    <i>floor(n + n*Float::EPSILON) + 1</i> times,
    where <i>n = (limit - self)/step</i>.

;T;0;;;I"	step;F;I"Numeric;T;[	o;;I"&?::Numeric limit, ?::Numeric step;T;I"	self;To;;I"&?::Numeric limit, ?::Numeric step;T;I" Enumerator[::Numeric, self];To;;I"#?by: ::Numeric, ?to: ::Numeric;T;I"	self;To;;I"#?by: ::Numeric, ?to: ::Numeric;T;I" Enumerator[::Numeric, self];To;;I"&Returns the value as a complex.

;T;0;;;I"	to_c;F;I"Numeric;T;[o;;I" ;F;I"Complex;To;;I"gReturns `self` as an integer; converts using method `to_i` in the derived
class.

Of the Core and Standard Library classes, only Rational and Complex use this
implementation.

Examples:

    Rational(1, 2).to_int # => 0
    Rational(2, 1).to_int # => 2
    Complex(2, 0).to_int  # => 2
    Complex(2, 1)         # Raises RangeError (non-zero imaginary part)

;T;0;;;I"to_int;F;I"Numeric;T;[o;;I" ;F;I"Integer;To;;I"©Returns `self` truncated (toward zero) to a precision of `digits` decimal
digits.

Numeric implements this by converting `self` to a Float and invoking
Float#truncate.

;T;0;;;I"truncate;F;I"Numeric;T;[o;;I" ;F;I"Integer;To;;I"::Integer ndigits;T;I"Integer | ::Numeric;To;;I"Returns `true` if `zero` has a zero value, `false` otherwise.

Of the Core and Standard Library classes, only Rational and Complex use this
implementation.

;T;0;;;I"
zero?;F;I"Numeric;T;[o;;I" ;F;I"	bool;To;;I"yReturns `self`.

Raises an exception if the value for `freeze` is neither `true` nor `nil`.

Related: Numeric#dup.

;T;0;;;I"
clone;F;I"Numeric;T;[o;;I"?freeze: true?;T;I"	self;To; ;I"ðObject is the default root of all Ruby objects.  Object inherits from
BasicObject which allows creating alternate object hierarchies.  Methods on
Object are available to all classes unless explicitly overridden.

Object mixes in the Kernel module, making the built-in kernel functions
globally accessible.  Although the instance methods of Object are defined by
the Kernel module, we have chosen to document them here for clarity.

When referencing constants in classes inheriting from Object you do not need
to use the full namespace.  For example, referencing `File` inside `YourClass`
will find the top-level File class.

In the descriptions of Object's methods, the parameter *symbol* refers to a
symbol, which is either a quoted string or a Symbol (such as `:name`).

## What's Here

First, what's elsewhere. Class Object:

*   Inherits from [class
    BasicObject](BasicObject.html#class-BasicObject-label-What-27s+Here).
*   Includes [module Kernel](Kernel.html#module-Kernel-label-What-27s+Here).


Here, class Object provides methods for:

*   [Querying](#class-Object-label-Querying)
*   [Instance Variables](#class-Object-label-Instance+Variables)
*   [Other](#class-Object-label-Other)


### Querying

    [!~](#method-i-21~)
:       Returns `true` if `self` does not match the given object, otherwise
        `false`.

    [<=>](#method-i-3C-3D-3E)
:       Returns 0 if `self` and the given object `object` are the same object,
        or if `self == object`; otherwise returns `nil`.

    #===
:       Implements case equality, effectively the same as calling #==.

    #eql?
:       Implements hash equality, effectively the same as calling #==.

    #kind_of? (aliased as #is_a?)
:       Returns whether given argument is an ancestor of the singleton class
        of `self`.

    #instance_of?
:       Returns whether `self` is an instance of the given class.

    #instance_variable_defined?
:       Returns whether the given instance variable is defined in `self`.

    #method
:       Returns the Method object for the given method in `self`.

    #methods
:       Returns an array of symbol names of public and protected methods in
        `self`.

    #nil?
:       Returns `false`. (Only `nil` responds `true` to method `nil?`.)

    #object_id
:       Returns an integer corresponding to `self` that is unique for the
        current process

    #private_methods
:       Returns an array of the symbol names of the private methods in `self`.

    #protected_methods
:       Returns an array of the symbol names of the protected methods in
        `self`.

    #public_method
:       Returns the Method object for the given public method in `self`.

    #public_methods
:       Returns an array of the symbol names of the public methods in `self`.

    #respond_to?
:       Returns whether `self` responds to the given method.

    #singleton_class
:       Returns the singleton class of `self`.

    #singleton_method
:       Returns the Method object for the given singleton method in `self`.

    #singleton_methods
:       Returns an array of the symbol names of the singleton methods in
        `self`.


    #define_singleton_method
:       Defines a singleton method in `self` for the given symbol method-name
        and block or proc.

    #extend
:       Includes the given modules in the singleton class of `self`.

    #public_send
:       Calls the given public method in `self` with the given argument.

    #send
:       Calls the given method in `self` with the given argument.



### Instance Variables

    #instance_variable_get
:       Returns the value of the given instance variable in `self`, or `nil`
        if the instance variable is not set.

    #instance_variable_set
:       Sets the value of the given instance variable in `self` to the given
        object.

    #instance_variables
:       Returns an array of the symbol names of the instance variables in
        `self`.

    #remove_instance_variable
:       Removes the named instance variable from `self`.



### Other

    #clone
:       Returns a shallow copy of `self`, including singleton class and frozen
        state.

    #define_singleton_method
:       Defines a singleton method in `self` for the given symbol method-name
        and block or proc.

    #display
:       Prints `self` to the given IO stream or `$stdout`.

    #dup
:       Returns a shallow unfrozen copy of `self`.

    #enum_for (aliased as #to_enum)
:       Returns an Enumerator for `self` using the using the given method,
        arguments, and block.

    #extend
:       Includes the given modules in the singleton class of `self`.

    #freeze
:       Prevents further modifications to `self`.

    #hash
:       Returns the integer hash value for `self`.

    #inspect
:       Returns a human-readable  string representation of `self`.

    #itself
:       Returns `self`.

    #public_send
:       Calls the given public method in `self` with the given argument.

    #send
:       Calls the given method in `self` with the given argument.

    #to_s
:       Returns a string representation of `self`.

;T;0;	I"Object;T;
[ ;[I"Kernel;T;0;[ ;[ ;0;I"BasicObject;To;;I"YReturns true if two objects do not match (using the *=~* method), otherwise
false.

;T;0;;;I"!~;F;I"Object;T;[o;;I"untyped;T;I"	bool;To;;I"Returns 0 if `obj` and `other` are the same object or `obj == other`,
otherwise nil.

The #<=> is used by various methods to compare objects, for example
Enumerable#sort, Enumerable#max etc.

Your implementation of #<=> should return one of the following values: -1, 0,
1 or nil. -1 means self is smaller than other. 0 means self is equal to other.
1 means self is bigger than other. Nil means the two values could not be
compared.

When you define #<=>, you can include Comparable to gain the methods #<=, #<,
#==, #>=, #> and #between?.

;T;0;;;I"<=>;F;I"Object;T;[o;;I"untyped;T;I"Integer?;To;;I"©Case Equality -- For class Object, effectively the same as calling `#==`, but
typically overridden by descendants to provide meaningful semantics in `case`
statements.

;T;0;;;I"===;F;I"Object;T;[o;;I"untyped;T;I"	bool;To;;I"rThis method is deprecated.

This is not only useless but also troublesome because it may hide a type
error.

;T;0;;;I"=~;F;I"Object;T;[o;;I"untyped;T;I"	bool;To;;I"ÀReturns the class of *obj*. This method must always be called with an explicit
receiver, as `class` is also a reserved word in Ruby.

    1.class      #=> Integer
    self.class   #=> Object

;T;0;;;I"
class;F;I"Object;T;[o;;I" ;F;I"untyped;To;;I"þProduces a shallow copy of *obj*---the instance variables of *obj* are copied,
but not the objects they reference. `clone` copies the frozen (unless :freeze
keyword argument is given with a false value) and tainted state of *obj*. See
also the discussion under `Object#dup`.

    class Klass
       attr_accessor :str
    end
    s1 = Klass.new      #=> #<Klass:0x401b3a38>
    s1.str = "Hello"    #=> "Hello"
    s2 = s1.clone       #=> #<Klass:0x401b3998 @str="Hello">
    s2.str[1,4] = "i"   #=> "i"
    s1.inspect          #=> "#<Klass:0x401b3a38 @str=\"Hi\">"
    s2.inspect          #=> "#<Klass:0x401b3998 @str=\"Hi\">"

This method may have class-specific behavior.  If so, that behavior will be
documented under the #`initialize_copy` method of the class.

;T;0;;;I"
clone;F;I"Object;T;[o;;I"?freeze: bool?;T;I"	self;To;;I"çDefines a singleton method in the receiver. The *method* parameter can be a
`Proc`, a `Method` or an `UnboundMethod` object. If a block is specified, it
is used as the method body. If a block or a method has parameters, they're
used as method parameters.

    class A
      class << self
        def class_name
          to_s
        end
      end
    end
    A.define_singleton_method(:who_am_i) do
      "I am: #{class_name}"
    end
    A.who_am_i   # ==> "I am: A"

    guy = "Bob"
    guy.define_singleton_method(:hello) { "#{self}: Hello there!" }
    guy.hello    #=>  "Bob: Hello there!"

    chris = "Chris"
    chris.define_singleton_method(:greet) {|greeting| "#{greeting}, I'm Chris!" }
    chris.greet("Hi") #=> "Hi, I'm Chris!"

;T;0;;;I"define_singleton_method;F;I"Object;T;[o;;I")::Symbol, ::Method | ::UnboundMethod;T;I"Symbol;To;;I"::Symbol;T;I"Symbol;To;;I"ñPrints *obj* on the given port (default `$>`). Equivalent to:

    def display(port=$>)
      port.write self
      nil
    end

For example:

    1.display
    "cat".display
    [ 4, 5, 6 ].display
    puts

*produces:*

    1cat[4, 5, 6]

;T;0;;;I"display;F;I"Object;T;[o;;I"?::_Writeable port;T;I"	void;To;;I"áProduces a shallow copy of *obj*---the instance variables of *obj* are copied,
but not the objects they reference.

This method may have class-specific behavior.  If so, that behavior will be
documented under the #`initialize_copy` method of the class.

### on dup vs clone

In general, #clone and #dup may have different semantics in descendant
classes. While #clone is used to duplicate an object, including its internal
state, #dup typically uses the class of the descendant object to create the
new instance.

When using #dup, any modules that the object has been extended with will not
be copied.

    class Klass
      attr_accessor :str
    end

    module Foo
      def foo; 'foo'; end
    end

    s1 = Klass.new #=> #<Klass:0x401b3a38>
    s1.extend(Foo) #=> #<Klass:0x401b3a38>
    s1.foo #=> "foo"

    s2 = s1.clone #=> #<Klass:0x401be280>
    s2.foo #=> "foo"

    s3 = s1.dup #=> #<Klass:0x401c1084>
    s3.foo #=> NoMethodError: undefined method `foo' for #<Klass:0x401c1084>

;T;0;;;I"dup;F;I"Object;T;[o;;I" ;F;I"	self;To;;I"ÁCreates a new Enumerator which will enumerate by calling `method` on `obj`,
passing `args` if any. What was *yielded* by method becomes values of
enumerator.

If a block is given, it will be used to calculate the size of the enumerator
without the need to iterate it (see Enumerator#size).

### Examples

    str = "xyz"

    enum = str.enum_for(:each_byte)
    enum.each { |b| puts b }
    # => 120
    # => 121
    # => 122

    # protect an array from being modified by some_method
    a = [1, 2, 3]
    some_method(a.to_enum)

    # String#split in block form is more memory-effective:
    very_large_string.split("|") { |chunk| return chunk if chunk.include?('DATE') }
    # This could be rewritten more idiomatically with to_enum:
    very_large_string.to_enum(:split, "|").lazy.grep(/DATE/).first

It is typical to call to_enum when defining methods for a generic Enumerable,
in case no block is passed.

Here is such an example, with parameter passing and a sizing block:

    module Enumerable
      # a generic method to repeat the values of any enumerable
      def repeat(n)
        raise ArgumentError, "#{n} is negative!" if n < 0
        unless block_given?
          return to_enum(__method__, n) do # __method__ is :repeat here
            sz = size     # Call size and multiply by n...
            sz * n if sz  # but return nil if size itself is nil
          end
        end
        each do |*val|
          n.times { yield *val }
        end
      end
    end

    %i[hello world].repeat(2) { |w| puts w }
      # => Prints 'hello', 'hello', 'world', 'world'
    enum = (1..14).repeat(3)
      # => returns an Enumerator when called without a block
    enum.first(4) # => [1, 1, 1, 2]
    enum.size # => 42

;T;0;;;I"enum_for;F;I"Object;T;[o;;I"#::Symbol method, *untyped args;T;I"!Enumerator[untyped, untyped];To;;I" ;F;I"Enumerator[untyped, self];To;;I"€Equality --- At the Object level, #== returns `true` only if `obj` and `other`
are the same object.  Typically, this method is overridden in descendant
classes to provide class-specific meaning.

Unlike #==, the #equal? method should never be overridden by subclasses as it
is used to determine object identity (that is, `a.equal?(b)` if and only if
`a` is the same object as `b`):

    obj = "a"
    other = obj.dup

    obj == other      #=> true
    obj.equal? other  #=> false
    obj.equal? obj    #=> true

The #eql? method returns `true` if `obj` and `other` refer to the same hash
key.  This is used by Hash to test members for equality.  For any pair of
objects where #eql? returns `true`, the #hash value of both objects must be
equal. So any subclass that overrides #eql? should also override #hash
appropriately.

For objects of class Object, #eql?  is synonymous with #==.  Subclasses
normally continue this tradition by aliasing #eql? to their overridden #==
method, but there are exceptions. Numeric types, for example, perform type
conversion across #==, but not across #eql?, so:

    1 == 1.0     #=> true
    1.eql? 1.0   #=> false

;T;0;;;I"	eql?;F;I"Object;T;[o;;I"untyped;T;I"	bool;To;;I"ƒAdds to *obj* the instance methods from each module given as a parameter.

    module Mod
      def hello
        "Hello from Mod.\n"
      end
    end

    class Klass
      def hello
        "Hello from Klass.\n"
      end
    end

    k = Klass.new
    k.hello         #=> "Hello from Klass.\n"
    k.extend(Mod)   #=> #<Klass:0x401b3bc8>
    k.hello         #=> "Hello from Mod.\n"

;T;0;;;I"extend;F;I"Object;T;[o;;I"*::Module;T;I"	self;To;;I"©Prevents further modifications to *obj*. A FrozenError will be raised if
modification is attempted. There is no way to unfreeze a frozen object. See
also Object#frozen?.

This method returns self.

    a = [ "a", "b", "c" ]
    a.freeze
    a << "z"

*produces:*

    prog.rb:3:in `<<': can't modify frozen Array (FrozenError)
     from prog.rb:3

Objects of the following classes are always frozen: Integer, Float, Symbol.

;T;0;;;I"freeze;F;I"Object;T;[o;;I" ;F;I"	self;To;;I"}Returns the freeze status of *obj*.

    a = [ "a", "b", "c" ]
    a.freeze    #=> ["a", "b", "c"]
    a.frozen?   #=> true

;T;0;;;I"frozen?;F;I"Object;T;[o;;I" ;F;I"	bool;To;;I"¸Generates an Integer hash value for this object.  This function must have the
property that `a.eql?(b)` implies `a.hash == b.hash`.

The hash value is used along with #eql? by the Hash class to determine if two
objects reference the same hash key.  Any hash value that exceeds the capacity
of an Integer will be truncated before being used.

The hash value for an object may not be identical across invocations or
implementations of Ruby.  If you need a stable identifier across Ruby
invocations and implementations you will need to generate one with a custom
method.

Certain core classes such as Integer use built-in hash calculations and do not
call the #hash method when used as a hash key.

;T;0;;;I"	hash;F;I"Object;T;[o;;I" ;F;I"Integer;To;;I":Returns a string containing a human-readable representation of *obj*. The
default #inspect shows the object's class name, an encoding of its memory
address, and a list of the instance variables and their values (by calling
#inspect on each of them).  User defined classes should override this method
to provide a better representation of *obj*.  When overriding this method, it
should return a string whose encoding is compatible with the default external
encoding.

    [ 1, 2, 3..4, 'five' ].inspect   #=> "[1, 2, 3..4, \"five\"]"
    Time.new.inspect                 #=> "2008-03-08 19:43:39 +0900"

    class Foo
    end
    Foo.new.inspect                  #=> "#<Foo:0x0300c868>"

    class Bar
      def initialize
        @bar = 1
      end
    end
    Bar.new.inspect                  #=> "#<Bar:0x0300c868 @bar=1>"

;T;0;;;I"inspect;F;I"Object;T;[o;;I" ;F;I"String;To;;I"Returns `true` if *obj* is an instance of the given class. See also
Object#kind_of?.

    class A;     end
    class B < A; end
    class C < B; end

    b = B.new
    b.instance_of? A   #=> false
    b.instance_of? B   #=> true
    b.instance_of? C   #=> false

;T;0;;;I"instance_of?;F;I"Object;T;[o;;I"::Module;T;I"	bool;To;;I"…Returns `true` if the given instance variable is defined in *obj*. String
arguments are converted to symbols.

    class Fred
      def initialize(p1, p2)
        @a, @b = p1, p2
      end
    end
    fred = Fred.new('cat', 99)
    fred.instance_variable_defined?(:@a)    #=> true
    fred.instance_variable_defined?("@b")   #=> true
    fred.instance_variable_defined?("@c")   #=> false

;T;0;;;I"instance_variable_defined?;F;I"Object;T;[o;;I"::String | ::Symbol var;T;I"	bool;To;;I"Returns the value of the given instance variable, or nil if the instance
variable is not set. The `@` part of the variable name should be included for
regular instance variables. Throws a NameError exception if the supplied
symbol is not valid as an instance variable name. String arguments are
converted to symbols.

    class Fred
      def initialize(p1, p2)
        @a, @b = p1, p2
      end
    end
    fred = Fred.new('cat', 99)
    fred.instance_variable_get(:@a)    #=> "cat"
    fred.instance_variable_get("@b")   #=> 99

;T;0;;;I"instance_variable_get;F;I"Object;T;[o;;I"::String | ::Symbol var;T;I"untyped;To;;I"‰Sets the instance variable named by *symbol* to the given object. This may
circumvent the encapsulation intended by the author of the class, so it should
be used with care. The variable does not have to exist prior to this call. If
the instance variable name is passed as a string, that string is converted to
a symbol.

    class Fred
      def initialize(p1, p2)
        @a, @b = p1, p2
      end
    end
    fred = Fred.new('cat', 99)
    fred.instance_variable_set(:@a, 'dog')   #=> "dog"
    fred.instance_variable_set(:@c, 'cat')   #=> "cat"
    fred.inspect                             #=> "#<Fred:0x401b3da8 @a=\"dog\", @b=99, @c=\"cat\">"

;T;0;;;I"instance_variable_set;F;I"Object;T;[o;;I"%::String | ::Symbol var, X value;T;I"X;Fo;;I"&Returns an array of instance variable names for the receiver. Note that simply
defining an accessor does not create the corresponding instance variable.

    class Fred
      attr_accessor :a1
      def initialize
        @iv = 3
      end
    end
    Fred.new.instance_variables   #=> [:@iv]

;T;0;;;I"instance_variables;F;I"Object;T;[o;;I" ;F;I"Array[::Symbol];To;;I"øReturns `true` if *class* is the class of *obj*, or if *class* is one of the
superclasses of *obj* or modules included in *obj*.

    module M;    end
    class A
      include M
    end
    class B < A; end
    class C < B; end

    b = B.new
    b.is_a? A          #=> true
    b.is_a? B          #=> true
    b.is_a? C          #=> false
    b.is_a? M          #=> true

    b.kind_of? A       #=> true
    b.kind_of? B       #=> true
    b.kind_of? C       #=> false
    b.kind_of? M       #=> true

;T;0;;;I"
is_a?;F;I"Object;T;[o;;I"::Module;T;I"	bool;To;;I"qReturns the receiver.

    string = "my string"
    string.itself.object_id == string.object_id   #=> true

;T;0;;;I"itself;F;I"Object;T;[o;;I" ;F;I"	self;To;;I"àLooks up the named method as a receiver in *obj*, returning a Method object
(or raising NameError). The Method object acts as a closure in *obj*'s object
instance, so instance variables and the value of `self` remain available.

    class Demo
      def initialize(n)
        @iv = n
      end
      def hello()
        "Hello, @iv = #{@iv}"
      end
    end

    k = Demo.new(99)
    m = k.method(:hello)
    m.call   #=> "Hello, @iv = 99"

    l = Demo.new('Fred')
    m = l.method("hello")
    m.call   #=> "Hello, @iv = Fred"

Note that Method implements `to_proc` method, which means it can be used with
iterators.

    [ 1, 2, 3 ].each(&method(:puts)) # => prints 3 lines to stdout

    out = File.open('test.txt', 'w')
    [ 1, 2, 3 ].each(&out.method(:puts)) # => prints 3 lines to file

    require 'date'
    %w[2017-03-01 2017-03-02].collect(&Date.method(:parse))
    #=> [#<Date: 2017-03-01 ((2457814j,0s,0n),+0s,2299161j)>, #<Date: 2017-03-02 ((2457815j,0s,0n),+0s,2299161j)>]

;T;0;;;I"method;F;I"Object;T;[o;;I"::String | ::Symbol name;T;I"Method;To;;I"Returns a list of the names of public and protected methods of *obj*. This
will include all the methods accessible in *obj*'s ancestors. If the optional
parameter is `false`, it returns an array of *obj*'s public and protected
singleton methods, the array will not include methods in modules included in
*obj*.

    class Klass
      def klass_method()
      end
    end
    k = Klass.new
    k.methods[0..9]    #=> [:klass_method, :nil?, :===,
                       #    :==~, :!, :eql?
                       #    :hash, :<=>, :class, :singleton_class]
    k.methods.length   #=> 56

    k.methods(false)   #=> []
    def k.singleton_method; end
    k.methods(false)   #=> [:singleton_method]

    module M123; def m123; end end
    k.extend M123
    k.methods(false)   #=> [:singleton_method]

;T;0;;;I"methods;F;I"Object;T;[o;;I" ;F;I"Array[::Symbol];To;;I"wOnly the object *nil* responds `true` to `nil?`.

    Object.new.nil?   #=> false
    nil.nil?          #=> true

;T;0;;;I"	nil?;F;I"Object;T;[o;;I" ;F;I"	bool;To;;I"íReturns an integer identifier for `obj`.

The same number will be returned on all calls to `object_id` for a given
object, and no two active objects will share an id.

Note: that some objects of builtin classes are reused for optimization. This
is the case for immediate values and frozen string literals.

BasicObject implements +__id__+, Kernel implements `object_id`.

Immediate values are not passed by reference but are passed by value: `nil`,
`true`, `false`, Fixnums, Symbols, and some Floats.

    Object.new.object_id  == Object.new.object_id  # => false
    (21 * 2).object_id    == (21 * 2).object_id    # => true
    "hello".object_id     == "hello".object_id     # => false
    "hi".freeze.object_id == "hi".freeze.object_id # => true

;T;0;;;I"object_id;F;I"Object;T;[o;;I" ;F;I"Integer;To;;I"—Returns the list of private methods accessible to *obj*. If the *all*
parameter is set to `false`, only those methods in the receiver will be
listed.

;T;0;;;I"private_methods;F;I"Object;T;[o;;I" ;F;I"Array[::Symbol];To;;I"™Returns the list of protected methods accessible to *obj*. If the *all*
parameter is set to `false`, only those methods in the receiver will be
listed.

;T;0;;;I"protected_methods;F;I"Object;T;[o;;I" ;F;I"Array[::Symbol];To;;I"8Similar to *method*, searches public method only.

;T;0;;;I"public_method;F;I"Object;T;[o;;I"::Object::name name;T;I"Method;To;;I"–Returns the list of public methods accessible to *obj*. If the *all* parameter
is set to `false`, only those methods in the receiver will be listed.

;T;0;;;I"public_methods;F;I"Object;T;[o;;I"?::boolish all;T;I"Array[::Symbol];To;;I"Invokes the method identified by *symbol*, passing it any arguments specified.
Unlike send, public_send calls public methods only. When the method is
identified by a string, the string is converted to a symbol.

    1.public_send(:puts, "hello")  # causes NoMethodError

;T;0;;;I"public_send;F;I"Object;T;[o;;I"'::Object::name name, *untyped args;T;I"untyped;To;;I"vRemoves the named instance variable from *obj*, returning that variable's
value. String arguments are converted to symbols.

    class Dummy
      attr_reader :var
      def initialize
        @var = 99
      end
      def remove
        remove_instance_variable(:@var)
      end
    end
    d = Dummy.new
    d.var      #=> 99
    d.remove   #=> 99
    d.var      #=> nil

;T;0;;;I"remove_instance_variable;F;I"Object;T;[o;;I"::Object::name name;T;I"untyped;To;;I"ÛReturns `true` if *obj* responds to the given method.  Private and protected
methods are included in the search only if the optional second parameter
evaluates to `true`.

If the method is not implemented, as Process.fork on Windows, File.lchmod on
GNU/Linux, etc., false is returned.

If the method is not defined, `respond_to_missing?` method is called and the
result is returned.

When the method name parameter is given as a string, the string is converted
to a symbol.

;T;0;;;I"respond_to?;F;I"Object;T;[o;;I"0::Object::name name, ?::boolish include_all;T;I"	bool;To;;I"ûInvokes the method identified by *symbol*, passing it any arguments specified.
When the method is identified by a string, the string is converted to a
symbol.

BasicObject implements +__send__+, Kernel implements `send`. `__send__` is
safer than `send` when *obj* has the same method name like `Socket`. See also
`public_send`.

    class Klass
      def hello(*args)
        "Hello " + args.join(' ')
      end
    end
    k = Klass.new
    k.send :hello, "gentle", "readers"   #=> "Hello gentle readers"

;T;0;;;I"	send;F;I"Object;T;[o;;I"'::Object::name name, *untyped args;T;I"untyped;To;;I"»Returns the singleton class of *obj*.  This method creates a new singleton
class if *obj* does not have one.

If *obj* is `nil`, `true`, or `false`, it returns NilClass, TrueClass, or
FalseClass, respectively. If *obj* is an Integer, a Float or a Symbol, it
raises a TypeError.

    Object.new.singleton_class  #=> #<Class:#<Object:0xb7ce1e24>>
    String.singleton_class      #=> #<Class:String>
    nil.singleton_class         #=> NilClass

;T;0;;;I"singleton_class;F;I"Object;T;[o;;I" ;F;I"
Class;To;;I"oSimilar to *method*, searches singleton method only.

    class Demo
      def initialize(n)
        @iv = n
      end
      def hello()
        "Hello, @iv = #{@iv}"
      end
    end

    k = Demo.new(99)
    def k.hi
      "Hi, @iv = #{@iv}"
    end
    m = k.singleton_method(:hi)
    m.call   #=> "Hi, @iv = 99"
    m = k.singleton_method(:hello) #=> NameError

;T;0;;;I"singleton_method;F;I"Object;T;[o;;I"::Object::name name;T;I"Method;To;;I"NReturns an array of the names of singleton methods for *obj*. If the optional
*all* parameter is true, the list will include methods in modules included in
*obj*. Only public and protected singleton methods are returned.

    module Other
      def three() end
    end

    class Single
      def Single.four() end
    end

    a = Single.new

    def a.one()
    end

    class << a
      include Other
      def two()
      end
    end

    Single.singleton_methods    #=> [:four]
    a.singleton_methods(false)  #=> [:two, :one]
    a.singleton_methods         #=> [:two, :one, :three]

;T;0;;;I"singleton_methods;F;I"Object;T;[o;;I" ;F;I"Array[::Symbol];To;;I"QReturns object. This method is deprecated and will be removed in Ruby 3.2.

;T;0;;;I"
taint;F;I"Object;T;[o;;I" ;F;I"	self;To;;I"QReturns false.  This method is deprecated and will be removed in Ruby 3.2.

;T;0;;;I"tainted?;F;I"Object;T;[o;;I" ;F;I"	bool;To;;I"¼Yields self to the block, and then returns self. The primary purpose of this
method is to "tap into" a method chain, in order to perform operations on
intermediate results within the chain.

    (1..10)                  .tap {|x| puts "original: #{x}" }
      .to_a                  .tap {|x| puts "array:    #{x}" }
      .select {|x| x.even? } .tap {|x| puts "evens:    #{x}" }
      .map {|x| x*x }        .tap {|x| puts "squares:  #{x}" }

;T;0;;;I"tap;F;I"Object;T;[o;;I" ;F;I"	self;To;;I"ÈYields self to the block and returns the result of the block.

    3.next.then {|x| x**x }.to_s             #=> "256"
    "my string".yield_self {|s| s.upcase }   #=> "MY STRING"

Good usage for `yield_self` is value piping in method chains:

    require 'open-uri'
    require 'json'

    construct_url(arguments).
      yield_self {|url| open(url).read }.
      yield_self {|response| JSON.parse(response) }

When called without block, the method returns `Enumerator`, which can be used,
for example, for conditional circuit-breaking:

    # meets condition, no-op
    1.yield_self.detect(&:odd?)            # => 1
    # does not meet condition, drop value
    2.yield_self.detect(&:odd?)            # => nil

;T;0;;;I"yield_self;F;I"Object;T;[o;;I" ;F;I"X;Fo;;I" ;F;I"Enumerator[self, untyped];To;;I"åReturns a string representing *obj*. The default #to_s prints the object's
class and an encoding of the object id. As a special case, the top-level
object that is the initial execution context of Ruby programs returns
``main''.

;T;0;;;I"	to_s;F;I"Object;T;[o;;I" ;F;I"String;To;;I"QReturns object. This method is deprecated and will be removed in Ruby 3.2.

;T;0;;;I"untaint;F;I"Object;T;[o;;I" ;F;I"	self;To; ;0;0;	I"Object;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"-Returns a Digest subclass by `name` in a thread-safe manner even when
on-demand loading is involved.

    require 'digest'

    Digest("MD5")
    # => Digest::MD5

    Digest(:SHA256)
    # => Digest::SHA256

    Digest(:Foo)
    # => LoadError: library not found for class Digest::Foo -- digest/foo

;T;0;;;I"Digest;F;I"Object;T;[o;;I"::String | ::Symbol name;T;I"singleton(::Digest::Base);To; ;0;0;	I"Object;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"¸Converts this object to a string (calling #to_s), converts
it to a JSON string, and returns the result. This is a fallback, if no
special method #to_json was defined for some object.

;T;0;;;I"to_json;F;I"Object;T;[o;;I"?::JSON::State state;T;I"String;To;;I"ÚThe ObjectSpace module contains a number of routines that interact with the
garbage collection facility and allow you to traverse all living objects with
an iterator.

ObjectSpace also provides support for object finalizers, procs that will be
called when a specific object is about to be destroyed by garbage collection.
See the documentation for `ObjectSpace.define_finalizer` for important
information on how to use this method correctly.

    a = "A"
    b = "B"

    ObjectSpace.define_finalizer(a, proc {|id| puts "Finalizer one on #{id}" })
    ObjectSpace.define_finalizer(b, proc {|id| puts "Finalizer two on #{id}" })

    a = nil
    b = nil

*produces:*

    Finalizer two on 537763470
    Finalizer one on 537763480

;T;0;	I"ObjectSpace;T;
[ ;[ ;0;[ ;[ o;;I" ;T;0;;;I"_id2ref;F;I"ObjectSpace;T;[o;;I"::Integer id;T;I"untyped;To;;I"ïCounts all objects grouped by type.

It returns a hash, such as:
    {
      :TOTAL=>10000,
      :FREE=>3011,
      :T_OBJECT=>6,
      :T_CLASS=>404,
      # ...
    }

The contents of the returned hash are implementation specific. It may be
changed in future.

The keys starting with `:T_` means live objects. For example, `:T_ARRAY` is
the number of arrays. `:FREE` means object slots which is not used now.
`:TOTAL` means sum of above.

If the optional argument `result_hash` is given, it is overwritten and
returned. This is intended to avoid probe effect.

    h = {}
    ObjectSpace.count_objects(h)
    puts h
    # => { :TOTAL=>10000, :T_CLASS=>158280, :T_MODULE=>20672, :T_STRING=>527249 }

This method is only expected to work on C Ruby.

;T;0;;;I"count_objects;F;I"ObjectSpace;T;[o;;I"-?::Hash[::Symbol, ::Integer] result_hash;T;I"Hash[::Symbol, ::Integer];To;;I")Adds *aProc* as a finalizer, to be called after *obj* was destroyed. The
object ID of the *obj* will be passed as an argument to *aProc*. If *aProc* is
a lambda or method, make sure it can be called with a single argument.

The return value is an array `[0, aProc]`.

The two recommended patterns are to either create the finaliser proc in a
non-instance method where it can safely capture the needed state, or to use a
custom callable object that stores the needed state explicitly as instance
variables.

    class Foo
      def initialize(data_needed_for_finalization)
        ObjectSpace.define_finalizer(self, self.class.create_finalizer(data_needed_for_finalization))
      end

      def self.create_finalizer(data_needed_for_finalization)
        proc {
          puts "finalizing #{data_needed_for_finalization}"
        }
      end
    end

    class Bar
     class Remover
        def initialize(data_needed_for_finalization)
          @data_needed_for_finalization = data_needed_for_finalization
        end

        def call(id)
          puts "finalizing #{@data_needed_for_finalization}"
        end
      end

      def initialize(data_needed_for_finalization)
        ObjectSpace.define_finalizer(self, Remover.new(data_needed_for_finalization))
      end
    end

Note that if your finalizer references the object to be finalized it will
never be run on GC, although it will still be run at exit. You will get a
warning if you capture the object to be finalized as the receiver of the
finalizer.

    class CapturesSelf
      def initialize(name)
        ObjectSpace.define_finalizer(self, proc {
          # this finalizer will only be run on exit
          puts "finalizing #{name}"
        })
      end
    end

Also note that finalization can be unpredictable and is never guaranteed to be
run except on exit.

;T;0;;;I"define_finalizer;F;I"ObjectSpace;T;[o;;I"/untyped obj, ^(::Integer id) -> void aProc;T;I"[ ::Integer, ::Proc ];To;;I"untyped obj;T;I"[ ::Integer, ::Proc ];To;;I"YCalls the block once for each living, nonimmediate object in this Ruby
process. If *module* is specified, calls the block for only those classes or
modules that match (or are a subclass of) *module*. Returns the number of
objects found. Immediate objects (`Fixnum`s, `Symbol`s `true`, `false`, and
`nil`) are never returned. In the example below, #each_object returns both the
numbers we defined and several constants defined in the Math module.

If no block is given, an enumerator is returned instead.

    a = 102.7
    b = 95       # Won't be returned
    c = 12345678987654321
    count = ObjectSpace.each_object(Numeric) {|x| p x }
    puts "Total count: #{count}"

*produces:*

    12345678987654321
    102.7
    2.71828182845905
    3.14159265358979
    2.22044604925031e-16
    1.7976931348623157e+308
    2.2250738585072e-308
    Total count: 7

;T;0;;;I"each_object;F;I"ObjectSpace;T;[o;;I"?::Module `module`;T;I"#Enumerator[untyped, ::Integer];To;;I"?::Module `module`;T;I"Integer;To;;I" ;T;0;;;I"garbage_collect;F;I"ObjectSpace;T;[o;;I"D?full_mark: bool, ?immediate_mark: bool, ?immediate_sweep: bool;T;I"	void;To;;I"(Removes all finalizers for *obj*.

;T;0;;;I"undefine_finalizer;F;I"ObjectSpace;T;[o;;I"
X obj;T;I"X;Fo;;I" ;T;0;;;I"garbage_collect;F;I"ObjectSpace;T;[o;;I"D?full_mark: bool, ?immediate_mark: bool, ?immediate_sweep: bool;T;I"	void;To;;I"©The objspace library extends the ObjectSpace module and adds several methods
to get internal statistic information about object/memory management.

You need to `require 'objspace'` to use this extension module.

Generally, you *SHOULD NOT* use this library if you do not know about the MRI
implementation.  Mainly, this library is for (memory) profiler developers and
MRI developers who need to know about MRI memory usage.

;T;0;	I"ObjectSpace;T;
[ ;[ ;0;[ ;[ o;;I"GReturns the class for the given `object`.

    class A
      def foo
        ObjectSpace::trace_object_allocations do
          obj = Object.new
          p "#{ObjectSpace::allocation_class_path(obj)}"
        end
      end
    end

    A.new.foo #=> "Class"

See ::trace_object_allocations for more information and examples.

;T;0;;;I"allocation_class_path;F;I"ObjectSpace;T;[o;;I"untyped;T;I"String;To;;I"sReturns garbage collector generation for the given `object`.

    class B
      include ObjectSpace

      def foo
        trace_object_allocations do
          obj = Object.new
          p "Generation is #{allocation_generation(obj)}"
        end
      end
    end

    B.new.foo #=> "Generation is 3"

See ::trace_object_allocations for more information and examples.

;T;0;;;I"allocation_generation;F;I"ObjectSpace;T;[o;;I"untyped;T;I"Integer | nil;To;;I"uReturns the method identifier for the given `object`.

    class A
      include ObjectSpace

      def foo
        trace_object_allocations do
          obj = Object.new
          p "#{allocation_class_path(obj)}##{allocation_method_id(obj)}"
        end
      end
    end

    A.new.foo #=> "Class#new"

See ::trace_object_allocations for more information and examples.

;T;0;;;I"allocation_method_id;F;I"ObjectSpace;T;[o;;I"untyped;T;I"Symbol;To;;I"|Returns the source file origin from the given `object`.

See ::trace_object_allocations for more information and examples.

;T;0;;;I"allocation_sourcefile;F;I"ObjectSpace;T;[o;;I"untyped;T;I"String;To;;I"‡Returns the original line from source for from the given `object`.

See ::trace_object_allocations for more information and examples.

;T;0;;;I"allocation_sourceline;F;I"ObjectSpace;T;[o;;I"untyped;T;I"Integer;To;;I"LCounts objects for each `T_IMEMO` type.

This method is only for MRI developers interested in performance and memory
usage of Ruby programs.

It returns a hash as:

    {:imemo_ifunc=>8,
     :imemo_svar=>7,
     :imemo_cref=>509,
     :imemo_memo=>1,
     :imemo_throw_data=>1}

If the optional argument, result_hash, is given, it is overwritten and
returned. This is intended to avoid probe effect.

The contents of the returned hash is implementation specific and may change in
the future.

In this version, keys are symbol objects.

This method is only expected to work with C Ruby.

;T;0;;;I"count_imemo_objects;F;I"ObjectSpace;T;[o;;I"-?::Hash[::Symbol, ::Integer] result_hash;T;I"Hash[::Symbol, ::Integer];To;;I"ñCounts nodes for each node type.

This method is only for MRI developers interested in performance and memory
usage of Ruby programs.

It returns a hash as:

    {:NODE_METHOD=>2027, :NODE_FBODY=>1927, :NODE_CFUNC=>1798, ...}

If the optional argument, result_hash, is given, it is overwritten and
returned. This is intended to avoid probe effect.

Note: The contents of the returned hash is implementation defined. It may be
changed in future.

This method is only expected to work with C Ruby.

;T;0;;;I"count_nodes;F;I"ObjectSpace;T;[o;;I"-?::Hash[::Symbol, ::Integer] result_hash;T;I"Hash[::Symbol, ::Integer];To;;I"7Counts objects size (in bytes) for each type.

Note that this information is incomplete.  You need to deal with this
information as only a **HINT**.  Especially, total size of T_DATA may be
wrong.

It returns a hash as:
    {:TOTAL=>1461154, :T_CLASS=>158280, :T_MODULE=>20672, :T_STRING=>527249, ...}

If the optional argument, result_hash, is given, it is overwritten and
returned. This is intended to avoid probe effect.

The contents of the returned hash is implementation defined. It may be changed
in future.

This method is only expected to work with C Ruby.

;T;0;;;I"count_objects_size;F;I"ObjectSpace;T;[o;;I"-?::Hash[::Symbol, ::Integer] result_hash;T;I"Hash[::Symbol, ::Integer];To;;I"5Counts symbols for each Symbol type.

This method is only for MRI developers interested in performance and memory
usage of Ruby programs.

If the optional argument, result_hash, is given, it is overwritten and
returned. This is intended to avoid probe effect.

Note: The contents of the returned hash is implementation defined. It may be
changed in future.

This method is only expected to work with C Ruby.

On this version of MRI, they have 3 types of Symbols (and 1 total counts).

    * mortal_dynamic_symbol: GC target symbols (collected by GC)
    * immortal_dynamic_symbol: Immortal symbols promoted from dynamic symbols (do not collected by GC)
    * immortal_static_symbol: Immortal symbols (do not collected by GC)
    * immortal_symbol: total immortal symbols (immortal_dynamic_symbol+immortal_static_symbol)

;T;0;;;I"count_symbols;F;I"ObjectSpace;T;[o;;I"-?::Hash[::Symbol, ::Integer] result_hash;T;I"Hash[::Symbol, ::Integer];To;;I"ÚCounts objects for each `T_DATA` type.

This method is only for MRI developers interested in performance and memory
usage of Ruby programs.

It returns a hash as:

    {RubyVM::InstructionSequence=>504, :parser=>5, :barrier=>6,
     :mutex=>6, Proc=>60, RubyVM::Env=>57, Mutex=>1, Encoding=>99,
     ThreadGroup=>1, Binding=>1, Thread=>1, RubyVM=>1, :iseq=>1,
     Random=>1, ARGF.class=>1, Data=>1, :autoload=>3, Time=>2}
    # T_DATA objects existing at startup on r32276.

If the optional argument, result_hash, is given, it is overwritten and
returned. This is intended to avoid probe effect.

The contents of the returned hash is implementation specific and may change in
the future.

In this version, keys are Class object or Symbol object.

If object is kind of normal (accessible) object, the key is Class object. If
object is not a kind of normal (internal) object, the key is symbol name,
registered by rb_data_type_struct.

This method is only expected to work with C Ruby.

;T;0;;;I"count_tdata_objects;F;I"ObjectSpace;T;[o;;I",?::Hash[untyped, ::Integer] result_hash;T;I"Hash[untyped, ::Integer];To;;I"Dump the contents of a ruby object as JSON.

This method is only expected to work with C Ruby. This is an experimental
method and is subject to change. In particular, the function signature and
output format are not guaranteed to be compatible in future versions of ruby.

;T;0;;;I"	dump;F;I"ObjectSpace;T;[o;;I"#untyped obj, ?output: ::Symbol;T;I"String | ::File | nil;To;;I"²Dump the contents of the ruby heap as JSON.

*since* must be a non-negative integer or `nil`.

If *since* is a positive integer, only objects of that generation and newer
generations are dumped. The current generation can be accessed using
GC::count.

Objects that were allocated without object allocation tracing enabled are
ignored. See ::trace_object_allocations for more information and examples.

If *since* is omitted or is `nil`, all objects are dumped.

This method is only expected to work with C Ruby. This is an experimental
method and is subject to change. In particular, the function signature and
output format are not guaranteed to be compatible in future versions of ruby.

;T;0;;;I"dump_all;F;I"ObjectSpace;T;[o;;I"A?since: ::Integer | nil, ?full: ::boolish, ?output: ::Symbol;T;I"String | ::File | nil;To;;I"©MRI specific feature
:   Return internal class of obj.

obj can be an instance of InternalObjectWrapper.

Note that you should not use this method in your application.

;T;0;;;I"internal_class_of;F;I"ObjectSpace;T;[o;;I"untyped;T;I"
Class;To;;I"ÁMRI specific feature
:   Return internal super class of cls (Class or Module).

obj can be an instance of InternalObjectWrapper.

Note that you should not use this method in your application.

;T;0;;;I"internal_super_of;F;I"ObjectSpace;T;[o;;I"untyped;T;I"untyped;To;;I"LReturn consuming memory size of obj in bytes.

Note that the return size is incomplete.  You need to deal with this
information as only a **HINT**. Especially, the size of `T_DATA` may not be
correct.

This method is only expected to work with C Ruby.

From Ruby 2.2, memsize_of(obj) returns a memory size includes sizeof(RVALUE).

;T;0;;;I"memsize_of;F;I"ObjectSpace;T;[o;;I"untyped;T;I"Integer;To;;I"ÀReturn consuming memory size of all living objects in bytes.

If `klass` (should be Class object) is given, return the total memory size of
instances of the given class.

Note that the returned size is incomplete. You need to deal with this
information as only a **HINT**. Especially, the size of `T_DATA` may not be
correct.

Note that this method does **NOT** return total malloc'ed memory size.

This method can be defined by the following Ruby code:

    def memsize_of_all klass = false
      total = 0
      ObjectSpace.each_object{|e|
        total += ObjectSpace.memsize_of(e) if klass == false || e.kind_of?(klass)
      }
      total
    end

This method is only expected to work with C Ruby.

;T;0;;;I"memsize_of_all;F;I"ObjectSpace;T;[o;;I"?::Class;T;I"Integer;To;;I"
MRI specific feature
:   Return all reachable objects from `obj'.


This method returns all reachable objects from `obj'.

If `obj' has two or more references to the same object `x', then returned
array only includes one `x' object.

If `obj' is a non-markable (non-heap management) object such as true, false,
nil, symbols and Fixnums (and Flonum) then it simply returns nil.

If `obj' has references to an internal object, then it returns instances of
ObjectSpace::InternalObjectWrapper class. This object contains a reference to
an internal object and you can check the type of internal object with `type'
method.

If `obj' is instance of ObjectSpace::InternalObjectWrapper class, then this
method returns all reachable object from an internal object, which is pointed
by `obj'.

With this method, you can find memory leaks.

This method is only expected to work except with C Ruby.

Example:
    ObjectSpace.reachable_objects_from(['a', 'b', 'c'])
    #=> [Array, 'a', 'b', 'c']

    ObjectSpace.reachable_objects_from(['a', 'a', 'a'])
    #=> [Array, 'a', 'a', 'a'] # all 'a' strings have different object id

    ObjectSpace.reachable_objects_from([v = 'a', v, v])
    #=> [Array, 'a']

    ObjectSpace.reachable_objects_from(1)
    #=> nil # 1 is not markable (heap managed) object

;T;0;;;I"reachable_objects_from;F;I"ObjectSpace;T;[o;;I"untyped;T;I"[ untyped ] | nil;To;;I"GMRI specific feature
:   Return all reachable objects from root.

;T;0;;;I" reachable_objects_from_root;F;I"ObjectSpace;T;[o;;I" ;F;I"Hash[::String, untyped];To;;I"eStarts tracing object allocations from the ObjectSpace extension module.

For example:

    require 'objspace'

    class C
      include ObjectSpace

      def foo
        trace_object_allocations do
          obj = Object.new
          p "#{allocation_sourcefile(obj)}:#{allocation_sourceline(obj)}"
        end
      end
    end

    C.new.foo #=> "objtrace.rb:8"

This example has included the ObjectSpace module to make it easier to read,
but you can also use the ::trace_object_allocations notation (recommended).

Note that this feature introduces a huge performance decrease and huge memory
consumption.

;T;0;;;I"trace_object_allocations;F;I"ObjectSpace;T;[o;;I" ;F;I"untyped;To;;I"*Clear recorded tracing information.

;T;0;;;I"#trace_object_allocations_clear;F;I"ObjectSpace;T;[o;;I" ;F;I"	void;To;;I" ;T;0;;;I")trace_object_allocations_debug_start;F;I"ObjectSpace;T;[o;;I" ;F;I"	void;To;;I")Starts tracing object allocations.

;T;0;;;I"#trace_object_allocations_start;F;I"ObjectSpace;T;[o;;I" ;F;I"	void;To;;I"²Stop tracing object allocations.

Note that if ::trace_object_allocations_start is called n-times, then tracing
will stop after calling ::trace_object_allocations_stop n-times.

;T;0;;;I""trace_object_allocations_stop;F;I"ObjectSpace;T;[o;;I" ;F;I"	void;To; ;I"(A `Proc` object is an encapsulation of a block of code, which can be stored in
a local variable, passed to a method or another Proc, and can be called. Proc
is an essential concept in Ruby and a core of its functional programming
features.

    square = Proc.new {|x| x**2 }

    square.call(3)  #=> 9
    # shorthands:
    square.(3)      #=> 9
    square[3]       #=> 9

Proc objects are *closures*, meaning they remember and can use the entire
context in which they were created.

    def gen_times(factor)
      Proc.new {|n| n*factor } # remembers the value of factor at the moment of creation
    end

    times3 = gen_times(3)
    times5 = gen_times(5)

    times3.call(12)               #=> 36
    times5.call(5)                #=> 25
    times3.call(times5.call(4))   #=> 60

## Creation

There are several methods to create a Proc

*   Use the Proc class constructor:

        proc1 = Proc.new {|x| x**2 }

*   Use the Kernel#proc method as a shorthand of Proc.new:

        proc2 = proc {|x| x**2 }

*   Receiving a block of code into proc argument (note the `&`):

        def make_proc(&block)
          block
        end

        proc3 = make_proc {|x| x**2 }

*   Construct a proc with lambda semantics using the Kernel#lambda method (see
    below for explanations about lambdas):

        lambda1 = lambda {|x| x**2 }

*   Use the [Lambda proc
    literal](doc/syntax/literals_rdoc.html#label-Lambda+Proc+Literals) syntax
    (also constructs a proc with lambda semantics):

        lambda2 = ->(x) { x**2 }


## Lambda and non-lambda semantics

Procs are coming in two flavors: lambda and non-lambda (regular procs).
Differences are:

*   In lambdas, `return` and `break` means exit from this lambda;
*   In non-lambda procs, `return` means exit from embracing method (and will
    throw `LocalJumpError` if invoked outside the method);
*   In non-lambda procs, `break` means exit from the method which the block
    given for. (and will throw `LocalJumpError` if invoked after the method
    returns);
*   In lambdas, arguments are treated in the same way as in methods: strict,
    with `ArgumentError` for mismatching argument number, and no additional
    argument processing;
*   Regular procs accept arguments more generously: missing arguments are
    filled with `nil`, single Array arguments are deconstructed if the proc
    has multiple arguments, and there is no error raised on extra arguments.


Examples:

    # +return+ in non-lambda proc, +b+, exits +m2+.
    # (The block +{ return }+ is given for +m1+ and embraced by +m2+.)
    $a = []; def m1(&b) b.call; $a << :m1 end; def m2() m1 { return }; $a << :m2 end; m2; p $a
    #=> []

    # +break+ in non-lambda proc, +b+, exits +m1+.
    # (The block +{ break }+ is given for +m1+ and embraced by +m2+.)
    $a = []; def m1(&b) b.call; $a << :m1 end; def m2() m1 { break }; $a << :m2 end; m2; p $a
    #=> [:m2]

    # +next+ in non-lambda proc, +b+, exits the block.
    # (The block +{ next }+ is given for +m1+ and embraced by +m2+.)
    $a = []; def m1(&b) b.call; $a << :m1 end; def m2() m1 { next }; $a << :m2 end; m2; p $a
    #=> [:m1, :m2]

    # Using +proc+ method changes the behavior as follows because
    # The block is given for +proc+ method and embraced by +m2+.
    $a = []; def m1(&b) b.call; $a << :m1 end; def m2() m1(&proc { return }); $a << :m2 end; m2; p $a
    #=> []
    $a = []; def m1(&b) b.call; $a << :m1 end; def m2() m1(&proc { break }); $a << :m2 end; m2; p $a
    # break from proc-closure (LocalJumpError)
    $a = []; def m1(&b) b.call; $a << :m1 end; def m2() m1(&proc { next }); $a << :m2 end; m2; p $a
    #=> [:m1, :m2]

    # +return+, +break+ and +next+ in the stubby lambda exits the block.
    # (+lambda+ method behaves same.)
    # (The block is given for stubby lambda syntax and embraced by +m2+.)
    $a = []; def m1(&b) b.call; $a << :m1 end; def m2() m1(&-> { return }); $a << :m2 end; m2; p $a
    #=> [:m1, :m2]
    $a = []; def m1(&b) b.call; $a << :m1 end; def m2() m1(&-> { break }); $a << :m2 end; m2; p $a
    #=> [:m1, :m2]
    $a = []; def m1(&b) b.call; $a << :m1 end; def m2() m1(&-> { next }); $a << :m2 end; m2; p $a
    #=> [:m1, :m2]

    p = proc {|x, y| "x=#{x}, y=#{y}" }
    p.call(1, 2)      #=> "x=1, y=2"
    p.call([1, 2])    #=> "x=1, y=2", array deconstructed
    p.call(1, 2, 8)   #=> "x=1, y=2", extra argument discarded
    p.call(1)         #=> "x=1, y=", nil substituted instead of error

    l = lambda {|x, y| "x=#{x}, y=#{y}" }
    l.call(1, 2)      #=> "x=1, y=2"
    l.call([1, 2])    # ArgumentError: wrong number of arguments (given 1, expected 2)
    l.call(1, 2, 8)   # ArgumentError: wrong number of arguments (given 3, expected 2)
    l.call(1)         # ArgumentError: wrong number of arguments (given 1, expected 2)

    def test_return
      -> { return 3 }.call      # just returns from lambda into method body
      proc { return 4 }.call    # returns from method
      return 5
    end

    test_return # => 4, return from proc

Lambdas are useful as self-sufficient functions, in particular useful as
arguments to higher-order functions, behaving exactly like Ruby methods.

Procs are useful for implementing iterators:

    def test
      [[1, 2], [3, 4], [5, 6]].map {|a, b| return a if a + b > 10 }
                                #  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    end

Inside `map`, the block of code is treated as a regular (non-lambda) proc,
which means that the internal arrays will be deconstructed to pairs of
arguments, and `return` will exit from the method `test`. That would not be
possible with a stricter lambda.

You can tell a lambda from a regular proc by using the #lambda? instance
method.

Lambda semantics is typically preserved during the proc lifetime, including
`&`-deconstruction to a block of code:

    p = proc {|x, y| x }
    l = lambda {|x, y| x }
    [[1, 2], [3, 4]].map(&p) #=> [1, 3]
    [[1, 2], [3, 4]].map(&l) # ArgumentError: wrong number of arguments (given 1, expected 2)

The only exception is dynamic method definition: even if defined by passing a
non-lambda proc, methods still have normal semantics of argument checking.

    class C
      define_method(:e, &proc {})
    end
    C.new.e(1,2)       #=> ArgumentError
    C.new.method(:e).to_proc.lambda?   #=> true

This exception ensures that methods never have unusual argument passing
conventions, and makes it easy to have wrappers defining methods that behave
as usual.

    class C
      def self.def2(name, &body)
        define_method(name, &body)
      end

      def2(:f) {}
    end
    C.new.f(1,2)       #=> ArgumentError

The wrapper `def2` receives *body* as a non-lambda proc, yet defines a method
which has normal semantics.

## Conversion of other objects to procs

Any object that implements the `to_proc` method can be converted into a proc
by the `&` operator, and therefore can be consumed by iterators.

    class Greeter
      def initialize(greeting)
        @greeting = greeting
      end

      def to_proc
        proc {|name| "#{@greeting}, #{name}!" }
      end
    end

    hi = Greeter.new("Hi")
    hey = Greeter.new("Hey")
    ["Bob", "Jane"].map(&hi)    #=> ["Hi, Bob!", "Hi, Jane!"]
    ["Bob", "Jane"].map(&hey)   #=> ["Hey, Bob!", "Hey, Jane!"]

Of the Ruby core classes, this method is implemented by Symbol, Method, and
Hash.

    :to_s.to_proc.call(1)           #=> "1"
    [1, 2].map(&:to_s)              #=> ["1", "2"]

    method(:puts).to_proc.call(1)   # prints 1
    [1, 2].each(&method(:puts))     # prints 1, 2

    {test: 1}.to_proc.call(:test)       #=> 1
    %i[test many keys].map(&{test: 1})  #=> [1, nil, nil]

## Orphaned Proc

`return` and `break` in a block exit a method. If a Proc object is generated
from the block and the Proc object survives until the method is returned,
`return` and `break` cannot work. In such case, `return` and `break` raises
LocalJumpError. A Proc object in such situation is called as orphaned Proc
object.

Note that the method to exit is different for `return` and `break`. There is a
situation that orphaned for `break` but not orphaned for `return`.

    def m1(&b) b.call end; def m2(); m1 { return } end; m2 # ok
    def m1(&b) b.call end; def m2(); m1 { break } end; m2 # ok

    def m1(&b) b end; def m2(); m1 { return }.call end; m2 # ok
    def m1(&b) b end; def m2(); m1 { break }.call end; m2 # LocalJumpError

    def m1(&b) b end; def m2(); m1 { return } end; m2.call # LocalJumpError
    def m1(&b) b end; def m2(); m1 { break } end; m2.call # LocalJumpError

Since `return` and `break` exits the block itself in lambdas, lambdas cannot
be orphaned.

## Numbered parameters

Numbered parameters are implicitly defined block parameters intended to
simplify writing short blocks:

    # Explicit parameter:
    %w[test me please].each { |str| puts str.upcase } # prints TEST, ME, PLEASE
    (1..5).map { |i| i**2 } # => [1, 4, 9, 16, 25]

    # Implicit parameter:
    %w[test me please].each { puts _1.upcase } # prints TEST, ME, PLEASE
    (1..5).map { _1**2 } # => [1, 4, 9, 16, 25]

Parameter names from `_1` to `_9` are supported:

    [10, 20, 30].zip([40, 50, 60], [70, 80, 90]).map { _1 + _2 + _3 }
    # => [120, 150, 180]

Though, it is advised to resort to them wisely, probably limiting yourself to
`_1` and `_2`, and to one-line blocks.

Numbered parameters can't be used together with explicitly named ones:

    [10, 20, 30].map { |x| _1**2 }
    # SyntaxError (ordinary parameter is defined)

To avoid conflicts, naming local variables or method arguments `_1`, `_2` and
so on, causes a warning.

    _1 = 'test'
    # warning: `_1' is reserved as numbered parameter

Using implicit numbered parameters affects block's arity:

    p = proc { _1 + _2 }
    l = lambda { _1 + _2 }
    p.parameters     # => [[:opt, :_1], [:opt, :_2]]
    p.arity          # => 2
    l.parameters     # => [[:req, :_1], [:req, :_2]]
    l.arity          # => 2

Blocks with numbered parameters can't be nested:

    %w[test me].each { _1.each_char { p _1 } }
    # SyntaxError (numbered parameter is already used in outer block here)
    # %w[test me].each { _1.each_char { p _1 } }
    #                    ^~

Numbered parameters were introduced in Ruby 2.7.

;T;0;	I"	Proc;T;
[ ;[ ;0;[ ;[ ;0;I"Object;To;;0;0;;;I"
clone;F;I"	Proc;T;[o;;I" ;F;I"	self;To;;I"Returns the number of mandatory arguments. If the block is declared to take no
arguments, returns 0. If the block is known to take exactly n arguments,
returns n. If the block has optional arguments, returns -n-1, where n is the
number of mandatory arguments, with the exception for blocks that are not
lambdas and have only a finite number of optional arguments; in this latter
case, returns n. Keyword arguments will be considered as a single additional
argument, that argument being mandatory if any keyword argument is mandatory.
A #proc with no argument declarations is the same as a block declaring `||` as
its arguments.

    proc {}.arity                  #=>  0
    proc { || }.arity              #=>  0
    proc { |a| }.arity             #=>  1
    proc { |a, b| }.arity          #=>  2
    proc { |a, b, c| }.arity       #=>  3
    proc { |*a| }.arity            #=> -1
    proc { |a, *b| }.arity         #=> -2
    proc { |a, *b, c| }.arity      #=> -3
    proc { |x:, y:, z:0| }.arity   #=>  1
    proc { |*a, x:, y:0| }.arity   #=> -2

    proc   { |a=0| }.arity         #=>  0
    lambda { |a=0| }.arity         #=> -1
    proc   { |a=0, b| }.arity      #=>  1
    lambda { |a=0, b| }.arity      #=> -2
    proc   { |a=0, b=0| }.arity    #=>  0
    lambda { |a=0, b=0| }.arity    #=> -1
    proc   { |a, b=0| }.arity      #=>  1
    lambda { |a, b=0| }.arity      #=> -2
    proc   { |(a, b), c=0| }.arity #=>  1
    lambda { |(a, b), c=0| }.arity #=> -2
    proc   { |a, x:0, y:0| }.arity #=>  1
    lambda { |a, x:0, y:0| }.arity #=> -2

;T;0;;;I"
arity;F;I"	Proc;T;[o;;I" ;F;I"Integer;To;;I"Returns the binding associated with *prc*.

    def fred(param)
      proc {}
    end

    b = fred(99)
    eval("param", b.binding)   #=> 99

;T;0;;;I"binding;F;I"	Proc;T;[o;;I" ;F;I"Binding;To;;I"
Invokes the block, setting the block's parameters to the values in *params*
using something close to method calling semantics. Returns the value of the
last expression evaluated in the block.

    a_proc = Proc.new {|scalar, *values| values.map {|value| value*scalar } }
    a_proc.call(9, 1, 2, 3)    #=> [9, 18, 27]
    a_proc[9, 1, 2, 3]         #=> [9, 18, 27]
    a_proc.(9, 1, 2, 3)        #=> [9, 18, 27]
    a_proc.yield(9, 1, 2, 3)   #=> [9, 18, 27]

Note that `prc.()` invokes `prc.call()` with the parameters given.  It's
syntactic sugar to hide "call".

For procs created using #lambda or `->()` an error is generated if the wrong
number of parameters are passed to the proc.  For procs created using Proc.new
or Kernel.proc, extra parameters are silently discarded and missing parameters
are set to `nil`.

    a_proc = proc {|a,b| [a,b] }
    a_proc.call(1)   #=> [1, nil]

    a_proc = lambda {|a,b| [a,b] }
    a_proc.call(1)   # ArgumentError: wrong number of arguments (given 1, expected 2)

See also Proc#lambda?.

;T;0;;;I"	call;F;I"	Proc;T;[o;;I"*untyped arg0;T;I"untyped;To;;I"
Invokes the block, setting the block's parameters to the values in *params*
using something close to method calling semantics. Returns the value of the
last expression evaluated in the block.

    a_proc = Proc.new {|scalar, *values| values.map {|value| value*scalar } }
    a_proc.call(9, 1, 2, 3)    #=> [9, 18, 27]
    a_proc[9, 1, 2, 3]         #=> [9, 18, 27]
    a_proc.(9, 1, 2, 3)        #=> [9, 18, 27]
    a_proc.yield(9, 1, 2, 3)   #=> [9, 18, 27]

Note that `prc.()` invokes `prc.call()` with the parameters given.  It's
syntactic sugar to hide "call".

For procs created using #lambda or `->()` an error is generated if the wrong
number of parameters are passed to the proc.  For procs created using Proc.new
or Kernel.proc, extra parameters are silently discarded and missing parameters
are set to `nil`.

    a_proc = proc {|a,b| [a,b] }
    a_proc.call(1)   #=> [1, nil]

    a_proc = lambda {|a,b| [a,b] }
    a_proc.call(1)   # ArgumentError: wrong number of arguments (given 1, expected 2)

See also Proc#lambda?.

;T;0;;;I"[];F;I"	Proc;T;[o;;I"*untyped arg0;T;I"untyped;To;;I"CReturns a curried proc. If the optional *arity* argument is given, it
determines the number of arguments. A curried proc receives some arguments. If
a sufficient number of arguments are supplied, it passes the supplied
arguments to the original proc and returns the result. Otherwise, returns
another curried proc that takes the rest of arguments.

    b = proc {|x, y, z| (x||0) + (y||0) + (z||0) }
    p b.curry[1][2][3]           #=> 6
    p b.curry[1, 2][3, 4]        #=> 6
    p b.curry(5)[1][2][3][4][5]  #=> 6
    p b.curry(5)[1, 2][3, 4][5]  #=> 6
    p b.curry(1)[1]              #=> 1

    b = proc {|x, y, z, *w| (x||0) + (y||0) + (z||0) + w.inject(0, &:+) }
    p b.curry[1][2][3]           #=> 6
    p b.curry[1, 2][3, 4]        #=> 10
    p b.curry(5)[1][2][3][4][5]  #=> 15
    p b.curry(5)[1, 2][3, 4][5]  #=> 15
    p b.curry(1)[1]              #=> 1

    b = lambda {|x, y, z| (x||0) + (y||0) + (z||0) }
    p b.curry[1][2][3]           #=> 6
    p b.curry[1, 2][3, 4]        #=> wrong number of arguments (given 4, expected 3)
    p b.curry(5)                 #=> wrong number of arguments (given 5, expected 3)
    p b.curry(1)                 #=> wrong number of arguments (given 1, expected 3)

    b = lambda {|x, y, z, *w| (x||0) + (y||0) + (z||0) + w.inject(0, &:+) }
    p b.curry[1][2][3]           #=> 6
    p b.curry[1, 2][3, 4]        #=> 10
    p b.curry(5)[1][2][3][4][5]  #=> 15
    p b.curry(5)[1, 2][3, 4][5]  #=> 15
    p b.curry(1)                 #=> wrong number of arguments (given 1, expected 3)

    b = proc { :foo }
    p b.curry[]                  #=> :foo

;T;0;;;I"
curry;F;I"	Proc;T;[o;;I"?::_ToInt arity;T;I"	Proc;To;;I"NReturns a hash value corresponding to proc body.

See also Object#hash.

;T;0;;;I"	hash;F;I"	Proc;T;[o;;I" ;F;I"Integer;To;;I"ËCreates a new Proc object, bound to the current context.

    proc = Proc.new { "hello" }
    proc.call   #=> "hello"

Raises ArgumentError if called without a block.

    Proc.new    #=> ArgumentError

;T;0;;;I"initialize;F;I"	Proc;T;[o;;I" ;F;I"	void;To;;I"
Returns `true` if a Proc object is lambda. `false` if non-lambda.

The lambda-ness affects argument handling and the behavior of `return` and
`break`.

A Proc object generated by `proc` ignores extra arguments.

    proc {|a,b| [a,b] }.call(1,2,3)    #=> [1,2]

It provides `nil` for missing arguments.

    proc {|a,b| [a,b] }.call(1)        #=> [1,nil]

It expands a single array argument.

    proc {|a,b| [a,b] }.call([1,2])    #=> [1,2]

A Proc object generated by `lambda` doesn't have such tricks.

    lambda {|a,b| [a,b] }.call(1,2,3)  #=> ArgumentError
    lambda {|a,b| [a,b] }.call(1)      #=> ArgumentError
    lambda {|a,b| [a,b] }.call([1,2])  #=> ArgumentError

Proc#lambda? is a predicate for the tricks. It returns `true` if no tricks
apply.

    lambda {}.lambda?            #=> true
    proc {}.lambda?              #=> false

Proc.new is the same as `proc`.

    Proc.new {}.lambda?          #=> false

`lambda`, `proc` and Proc.new preserve the tricks of a Proc object given by
`&` argument.

    lambda(&lambda {}).lambda?   #=> true
    proc(&lambda {}).lambda?     #=> true
    Proc.new(&lambda {}).lambda? #=> true

    lambda(&proc {}).lambda?     #=> false
    proc(&proc {}).lambda?       #=> false
    Proc.new(&proc {}).lambda?   #=> false

A Proc object generated by `&` argument has the tricks

    def n(&b) b.lambda? end
    n {}                         #=> false

The `&` argument preserves the tricks if a Proc object is given by `&`
argument.

    n(&lambda {})                #=> true
    n(&proc {})                  #=> false
    n(&Proc.new {})              #=> false

A Proc object converted from a method has no tricks.

    def m() end
    method(:m).to_proc.lambda?   #=> true

    n(&method(:m))               #=> true
    n(&method(:m).to_proc)       #=> true

`define_method` is treated the same as method definition. The defined method
has no tricks.

    class C
      define_method(:d) {}
    end
    C.new.d(1,2)       #=> ArgumentError
    C.new.method(:d).to_proc.lambda?   #=> true

`define_method` always defines a method without the tricks, even if a
non-lambda Proc object is given. This is the only exception for which the
tricks are not preserved.

    class C
      define_method(:e, &proc {})
    end
    C.new.e(1,2)       #=> ArgumentError
    C.new.method(:e).to_proc.lambda?   #=> true

This exception ensures that methods never have tricks and makes it easy to
have wrappers to define methods that behave as usual.

    class C
      def self.def2(name, &body)
        define_method(name, &body)
      end

      def2(:f) {}
    end
    C.new.f(1,2)       #=> ArgumentError

The wrapper *def2* defines a method which has no tricks.

;T;0;;;I"lambda?;F;I"	Proc;T;[o;;I" ;F;I"	bool;To;;I"˜Returns the parameter information of this proc.

    prc = lambda{|x, y=42, *other|}
    prc.parameters  #=> [[:req, :x], [:opt, :y], [:rest, :other]]

;T;0;;;I"parameters;F;I"	Proc;T;[o;;I" ;F;I""Array[[ ::Symbol, ::Symbol ]];To;;I"„Returns the Ruby source filename and line number containing this proc or `nil`
if this proc was not defined in Ruby (i.e. native).

;T;0;;;I"source_location;F;I"	Proc;T;[o;;I" ;F;I"[ ::String, ::Integer ];To;;I"uPart of the protocol for converting objects to Proc objects. Instances of
class Proc simply return themselves.

;T;0;;;I"to_proc;F;I"	Proc;T;[o;;I" ;F;I"	self;To;;I"kReturns the unique identifier for this proc, along with an indication of where
the proc was defined.

;T;0;;;I"	to_s;F;I"	Proc;T;[o;;I" ;F;I"String;To;;I"kReturns the unique identifier for this proc, along with an indication of where
the proc was defined.

;T;0;;;I"inspect;F;I"	Proc;T;[o;;I" ;F;I"String;To;;I"The module contains several groups of functionality for handling OS processes:

*   Low-level property introspection and management of the current process,
    like Process.argv0, Process.pid;
*   Low-level introspection of other processes, like Process.getpgid,
    Process.getpriority;
*   Management of the current process: Process.abort, Process.exit,
    Process.daemon, etc. (for convenience, most of those are also available as
    global functions and module functions of Kernel);
*   Creation and management of child processes: Process.fork, Process.spawn,
    and related methods;
*   Management of low-level system clock: Process.times and
    Process.clock_gettime, which could be important for proper benchmarking
    and other elapsed time measurement tasks.

;T;0;	I"Process;T;
[ ;[ ;0;[ ;[ o;;I"-An internal API for fork. Do not call this method directly. Currently, this is
called via Kernel#fork, Process.fork, and IO.popen with `"-"`.

This method is not for casual code but for application monitoring libraries.
You can add custom code before and after fork events by overriding this
method.

;T;0;;;I"
_fork;F;I"Process;T;[o;;I" ;F;I"Integer;To;;I"ÔReturns the name of the script being executed.  The value is not affected by
assigning a new value to $0.

This method first appeared in Ruby 2.1 to serve as a global variable free
means to get the script name.

;T;0;;;I"
argv0;F;I"Process;T;[o;;I" ;F;I"String;To;;I"ÉReturns an estimate of the resolution of a `clock_id` using the POSIX
`clock_getres()` function.

Note the reported resolution is often inaccurate on most platforms due to
underlying bugs for this function and therefore the reported resolution often
differs from the actual resolution of the clock in practice. Inaccurate
reported resolutions have been observed for various clocks including
CLOCK_MONOTONIC and CLOCK_MONOTONIC_RAW when using Linux, macOS, BSD or AIX
platforms, when using ARM processors, or when using virtualization.

`clock_id` specifies a kind of clock. See the document of
`Process.clock_gettime` for details. `clock_id` can be a symbol as for
`Process.clock_gettime`.

If the given `clock_id` is not supported, Errno::EINVAL is raised.

`unit` specifies the type of the return value. `Process.clock_getres` accepts
`unit` as `Process.clock_gettime`. The default value, `:float_second`, is also
the same as `Process.clock_gettime`.

`Process.clock_getres` also accepts `:hertz` as `unit`. `:hertz` means the
reciprocal of `:float_second`.

`:hertz` can be used to obtain the exact value of the clock ticks per second
for the times() function and CLOCKS_PER_SEC for the clock() function.

`Process.clock_getres(:TIMES_BASED_CLOCK_PROCESS_CPUTIME_ID, :hertz)` returns
the clock ticks per second.

`Process.clock_getres(:CLOCK_BASED_CLOCK_PROCESS_CPUTIME_ID, :hertz)` returns
CLOCKS_PER_SEC.

    p Process.clock_getres(Process::CLOCK_MONOTONIC)
    #=> 1.0e-09

;T;0;;;I"clock_getres;F;I"Process;T;[o;;I"2::Symbol | ::Integer clock_id, ?::Symbol unit;T;I"Float | ::Integer;To;;I"Returns a time returned by POSIX clock_gettime() function.

    p Process.clock_gettime(Process::CLOCK_MONOTONIC)
    #=> 896053.968060096

`clock_id` specifies a kind of clock. It is specified as a constant which
begins with `Process::CLOCK_` such as Process::CLOCK_REALTIME and
Process::CLOCK_MONOTONIC.

The supported constants depends on OS and version. Ruby provides following
types of `clock_id` if available.

CLOCK_REALTIME
:   SUSv2 to 4, Linux 2.5.63, FreeBSD 3.0, NetBSD 2.0, OpenBSD 2.1, macOS
    10.12, Windows-8/Server-2012
CLOCK_MONOTONIC
:   SUSv3 to 4, Linux 2.5.63, FreeBSD 3.0, NetBSD 2.0, OpenBSD 3.4, macOS
    10.12, Windows-2000
CLOCK_PROCESS_CPUTIME_ID
:   SUSv3 to 4, Linux 2.5.63, FreeBSD 9.3, OpenBSD 5.4, macOS 10.12
CLOCK_THREAD_CPUTIME_ID
:   SUSv3 to 4, Linux 2.5.63, FreeBSD 7.1, OpenBSD 5.4, macOS 10.12
CLOCK_VIRTUAL
:   FreeBSD 3.0, OpenBSD 2.1
CLOCK_PROF
:   FreeBSD 3.0, OpenBSD 2.1
CLOCK_REALTIME_FAST
:   FreeBSD 8.1
CLOCK_REALTIME_PRECISE
:   FreeBSD 8.1
CLOCK_REALTIME_COARSE
:   Linux 2.6.32
CLOCK_REALTIME_ALARM
:   Linux 3.0
CLOCK_MONOTONIC_FAST
:   FreeBSD 8.1
CLOCK_MONOTONIC_PRECISE
:   FreeBSD 8.1
CLOCK_MONOTONIC_COARSE
:   Linux 2.6.32
CLOCK_MONOTONIC_RAW
:   Linux 2.6.28, macOS 10.12
CLOCK_MONOTONIC_RAW_APPROX
:   macOS 10.12
CLOCK_BOOTTIME
:   Linux 2.6.39
CLOCK_BOOTTIME_ALARM
:   Linux 3.0
CLOCK_UPTIME
:   FreeBSD 7.0, OpenBSD 5.5
CLOCK_UPTIME_FAST
:   FreeBSD 8.1
CLOCK_UPTIME_RAW
:   macOS 10.12
CLOCK_UPTIME_RAW_APPROX
:   macOS 10.12
CLOCK_UPTIME_PRECISE
:   FreeBSD 8.1
CLOCK_SECOND
:   FreeBSD 8.1
CLOCK_TAI
:   Linux 3.10


Note that SUS stands for Single Unix Specification. SUS contains POSIX and
clock_gettime is defined in the POSIX part. SUS defines CLOCK_REALTIME
mandatory but CLOCK_MONOTONIC, CLOCK_PROCESS_CPUTIME_ID and
CLOCK_THREAD_CPUTIME_ID are optional.

Also, several symbols are accepted as `clock_id`. There are emulations for
clock_gettime().

For example, Process::CLOCK_REALTIME is defined as
`:GETTIMEOFDAY_BASED_CLOCK_REALTIME` when clock_gettime() is not available.

Emulations for `CLOCK_REALTIME`:
:GETTIMEOFDAY_BASED_CLOCK_REALTIME
:   Use gettimeofday() defined by SUS. (SUSv4 obsoleted it, though.) The
    resolution is 1 microsecond.
:TIME_BASED_CLOCK_REALTIME
:   Use time() defined by ISO C. The resolution is 1 second.


Emulations for `CLOCK_MONOTONIC`:
:MACH_ABSOLUTE_TIME_BASED_CLOCK_MONOTONIC
:   Use mach_absolute_time(), available on Darwin. The resolution is CPU
    dependent.
:TIMES_BASED_CLOCK_MONOTONIC
:   Use the result value of times() defined by POSIX. POSIX defines it as
    "times() shall return the elapsed real time, in clock ticks, since an
    arbitrary point in the past (for example, system start-up time)". For
    example, GNU/Linux returns a value based on jiffies and it is monotonic.
    However, 4.4BSD uses gettimeofday() and it is not monotonic. (FreeBSD uses
    clock_gettime(CLOCK_MONOTONIC) instead, though.) The resolution is the
    clock tick. "getconf CLK_TCK" command shows the clock ticks per second.
    (The clock ticks per second is defined by HZ macro in older systems.) If
    it is 100 and clock_t is 32 bits integer type, the resolution is 10
    millisecond and cannot represent over 497 days.


Emulations for `CLOCK_PROCESS_CPUTIME_ID`:
:GETRUSAGE_BASED_CLOCK_PROCESS_CPUTIME_ID
:   Use getrusage() defined by SUS. getrusage() is used with RUSAGE_SELF to
    obtain the time only for the calling process (excluding the time for child
    processes). The result is addition of user time (ru_utime) and system time
    (ru_stime). The resolution is 1 microsecond.
:TIMES_BASED_CLOCK_PROCESS_CPUTIME_ID
:   Use times() defined by POSIX. The result is addition of user time
    (tms_utime) and system time (tms_stime). tms_cutime and tms_cstime are
    ignored to exclude the time for child processes. The resolution is the
    clock tick. "getconf CLK_TCK" command shows the clock ticks per second.
    (The clock ticks per second is defined by HZ macro in older systems.) If
    it is 100, the resolution is 10 millisecond.
:CLOCK_BASED_CLOCK_PROCESS_CPUTIME_ID
:   Use clock() defined by ISO C. The resolution is 1/CLOCKS_PER_SEC.
    CLOCKS_PER_SEC is the C-level macro defined by time.h. SUS defines
    CLOCKS_PER_SEC is 1000000. Non-Unix systems may define it a different
    value, though. If CLOCKS_PER_SEC is 1000000 as SUS, the resolution is 1
    microsecond. If CLOCKS_PER_SEC is 1000000 and clock_t is 32 bits integer
    type, it cannot represent over 72 minutes.


If the given `clock_id` is not supported, Errno::EINVAL is raised.

`unit` specifies a type of the return value.

:float_second
:   number of seconds as a float (default)
:float_millisecond
:   number of milliseconds as a float
:float_microsecond
:   number of microseconds as a float
:second
:   number of seconds as an integer
:millisecond
:   number of milliseconds as an integer
:microsecond
:   number of microseconds as an integer
:nanosecond
:   number of nanoseconds as an integer


The underlying function, clock_gettime(), returns a number of nanoseconds.
Float object (IEEE 754 double) is not enough to represent the return value for
CLOCK_REALTIME. If the exact nanoseconds value is required, use `:nanoseconds`
as the `unit`.

The origin (zero) of the returned value varies. For example, system start up
time, process start up time, the Epoch, etc.

The origin in CLOCK_REALTIME is defined as the Epoch (1970-01-01 00:00:00
UTC). But some systems count leap seconds and others doesn't. So the result
can be interpreted differently across systems. Time.now is recommended over
CLOCK_REALTIME.

;T;0;;;I"clock_gettime;F;I"Process;T;[o;;I""::Symbol | ::Integer clock_id;T;I"
Float;To;;I"`::Symbol | ::Integer clock_id, :float_second | :float_millisecond | :float_microsecond unit;T;I"
Float;To;;I"\::Symbol | ::Integer clock_id, :second | :millisecond | :microsecond | :nanosecond unit;T;I"Integer;To;;I"|Detach the process from controlling terminal and run in the background as
system daemon.  Unless the argument nochdir is true (i.e. non false), it
changes the current working directory to the root ("/"). Unless the argument
noclose is true, daemon() will redirect standard input, standard output and
standard error to /dev/null. Return zero on success, or raise one of Errno::*.

;T;0;;;I"daemon;F;I"Process;T;[o;;I"'?untyped nochdir, ?untyped noclose;T;I"Integer;To;;I"Some operating systems retain the status of terminated child processes until
the parent collects that status (normally using some variant of `wait()`). If
the parent never collects this status, the child stays around as a *zombie*
process. Process::detach prevents this by setting up a separate Ruby thread
whose sole job is to reap the status of the process *pid* when it terminates.
Use #detach only when you do not intend to explicitly wait for the child to
terminate.

The waiting thread returns the exit status of the detached process when it
terminates, so you can use Thread#join to know the result.  If specified *pid*
is not a valid child process ID, the thread returns `nil` immediately.

The waiting thread has #pid method which returns the pid.

In this first example, we don't reap the first child process, so it appears as
a zombie in the process status display.

    p1 = fork { sleep 0.1 }
    p2 = fork { sleep 0.2 }
    Process.waitpid(p2)
    sleep 2
    system("ps -ho pid,state -p #{p1}")

*produces:*

    27389 Z

In the next example, Process::detach is used to reap the child automatically.

    p1 = fork { sleep 0.1 }
    p2 = fork { sleep 0.2 }
    Process.detach(p1)
    Process.waitpid(p2)
    sleep 2
    system("ps -ho pid,state -p #{p1}")

*(produces no output)*

;T;0;;;I"detach;F;I"Process;T;[o;;I"::Integer pid;T;I"Thread;To;;I"sReturns the effective group ID for this process. Not available on all
platforms.

    Process.egid   #=> 500

;T;0;;;I"	egid;F;I"Process;T;[o;;I" ;F;I"Integer;To;;I"TSets the effective group ID for this process. Not available on all platforms.

;T;0;;;I"
egid=;F;I"Process;T;[o;;I"::Integer arg0;T;I"Integer;To;;I"RReturns the effective user ID for this process.

    Process.euid   #=> 501

;T;0;;;I"	euid;F;I"Process;T;[o;;I" ;F;I"Integer;To;;I"SSets the effective user ID for this process. Not available on all platforms.

;T;0;;;I"
euid=;F;I"Process;T;[o;;I"::Integer arg0;T;I"Integer;To;;I"‰Returns the process group ID for the given process id. Not available on all
platforms.

    Process.getpgid(Process.ppid())   #=> 25527

;T;0;;;I"getpgid;F;I"Process;T;[o;;I"::Integer pid;T;I"Integer;To;;I"—Returns the process group ID for this process. Not available on all platforms.

    Process.getpgid(0)   #=> 25527
    Process.getpgrp      #=> 25527

;T;0;;;I"getpgrp;F;I"Process;T;[o;;I" ;F;I"Integer;To;;I"ùGets the scheduling priority for specified process, process group, or user.
*kind* indicates the kind of entity to find: one of Process::PRIO_PGRP,
Process::PRIO_USER, or Process::PRIO_PROCESS. *integer* is an id indicating
the particular process, process group, or user (an id of 0 means *current*).
Lower priorities are more favorable for scheduling. Not available on all
platforms.

    Process.getpriority(Process::PRIO_USER, 0)      #=> 19
    Process.getpriority(Process::PRIO_PROCESS, 0)   #=> 19

;T;0;;;I"getpriority;F;I"Process;T;[o;;I"#::Integer kind, ::Integer arg0;T;I"Integer;To;;I"ýGets the resource limit of the process. *cur_limit* means current (soft) limit
and *max_limit* means maximum (hard) limit.

*resource* indicates the kind of resource to limit. It is specified as a
symbol such as `:CORE`, a string such as `"CORE"` or a constant such as
Process::RLIMIT_CORE. See Process.setrlimit for details.

*cur_limit* and *max_limit* may be Process::RLIM_INFINITY,
Process::RLIM_SAVED_MAX or Process::RLIM_SAVED_CUR. See Process.setrlimit and
the system getrlimit(2) manual for details.

;T;0;;;I"getrlimit;F;I"Process;T;[o;;I"-::Symbol | ::String | ::Integer resource;T;I"[ ::Integer, ::Integer ];To;;I"Returns the session ID for the given process id. If not given, return current
process sid. Not available on all platforms.

    Process.getsid()                #=> 27422
    Process.getsid(0)               #=> 27422
    Process.getsid(Process.pid())   #=> 27422

;T;0;;;I"getsid;F;I"Process;T;[o;;I"?::Integer pid;T;I"Integer;To;;I"OReturns the (real) group ID for this process.

    Process.gid   #=> 500

;T;0;;;I"gid;F;I"Process;T;[o;;I" ;F;I"Integer;To;;I"*Sets the group ID for this process.

;T;0;;;I"	gid=;F;I"Process;T;[o;;I"::Integer arg0;T;I"Integer;To;;I"Get an Array of the group IDs in the supplemental group access list for this
process.

    Process.groups   #=> [27, 6, 10, 11]

Note that this method is just a wrapper of getgroups(2). This means that the
following characteristics of the result completely depend on your system:

*   the result is sorted
*   the result includes effective GIDs
*   the result does not include duplicated GIDs


You can make sure to get a sorted unique GID list of the current process by
this expression:

    Process.groups.uniq.sort

;T;0;;;I"groups;F;I"Process;T;[o;;I" ;F;I"Array[::Integer];To;;I"îSet the supplemental group access list to the given Array of group IDs.

    Process.groups   #=> [0, 1, 2, 3, 4, 6, 10, 11, 20, 26, 27]
    Process.groups = [27, 6, 10, 11]   #=> [27, 6, 10, 11]
    Process.groups   #=> [27, 6, 10, 11]

;T;0;;;I"groups=;F;I"Process;T;[o;;I"::Array[::Integer] arg0;T;I"Array[::Integer];To;;I"øInitializes the supplemental group access list by reading the system group
database and using all groups of which the given user is a member. The group
with the specified *gid* is also added to the list. Returns the resulting
Array of the gids of all the groups in the supplementary group access list.
Not available on all platforms.

    Process.groups   #=> [0, 1, 2, 3, 4, 6, 10, 11, 20, 26, 27]
    Process.initgroups( "mgranger", 30 )   #=> [30, 6, 10, 11]
    Process.groups   #=> [30, 6, 10, 11]

;T;0;;;I"initgroups;F;I"Process;T;[o;;I"%::String username, ::Integer gid;T;I"Array[::Integer];To;;I"‹Sends the given signal to the specified process id(s) if *pid* is positive. If
*pid* is zero, *signal* is sent to all processes whose group ID is equal to
the group ID of the process. If *pid* is negative, results are dependent on
the operating system. *signal* may be an integer signal number or a POSIX
signal name (either with or without a `SIG` prefix). If *signal* is negative
(or starts with a minus sign), kills process groups instead of processes. Not
all signals are available on all platforms. The keys and values of Signal.list
are known signal names and numbers, respectively.

    pid = fork do
       Signal.trap("HUP") { puts "Ouch!"; exit }
       # ... do some work ...
    end
    # ...
    Process.kill("HUP", pid)
    Process.wait

*produces:*

    Ouch!

If *signal* is an integer but wrong for signal, Errno::EINVAL or RangeError
will be raised.  Otherwise unless *signal* is a String or a Symbol, and a
known signal name, ArgumentError will be raised.

Also, Errno::ESRCH or RangeError for invalid *pid*, Errno::EPERM when failed
because of no privilege, will be raised.  In these cases, signals may have
been sent to preceding processes.

;T;0;;;I"	kill;F;I"Process;T;[o;;I"<::Integer | ::Symbol | ::String signal, *::Integer pids;T;I"Integer;To;;I"xReturns the maximum number of gids allowed in the supplemental group access
list.

    Process.maxgroups   #=> 32

;T;0;;;I"maxgroups;F;I"Process;T;[o;;I" ;F;I"Integer;To;;I"USets the maximum number of gids allowed in the supplemental group access list.

;T;0;;;I"maxgroups=;F;I"Process;T;[o;;I"::Integer arg0;T;I"Integer;To;;I"kReturns the process id of this process. Not available on all platforms.

    Process.pid   #=> 27415

;T;0;;;I"pid;F;I"Process;T;[o;;I" ;F;I"Integer;To;;I"Returns the process id of the parent of this process. Returns untrustworthy
value on Win32/64. Not available on all platforms.

    puts "I am #{Process.pid}"
    Process.fork { puts "Dad is #{Process.ppid}" }

*produces:*

    I am 27417
    Dad is 27417

;T;0;;;I"	ppid;F;I"Process;T;[o;;I" ;F;I"Integer;To;;I"rSets the process group ID of *pid* (0 indicates this process) to *integer*.
Not available on all platforms.

;T;0;;;I"setpgid;F;I"Process;T;[o;;I""::Integer pid, ::Integer arg0;T;I"Integer;To;;I"See Process.getpriority.

    Process.setpriority(Process::PRIO_USER, 0, 19)      #=> 0
    Process.setpriority(Process::PRIO_PROCESS, 0, 19)   #=> 0
    Process.getpriority(Process::PRIO_USER, 0)          #=> 19
    Process.getpriority(Process::PRIO_PROCESS, 0)       #=> 19

;T;0;;;I"setpriority;F;I"Process;T;[o;;I"7::Integer kind, ::Integer arg0, ::Integer priority;T;I"Integer;To;;I"ØSets the process title that appears on the ps(1) command.  Not necessarily
effective on all platforms.  No exception will be raised regardless of the
result, nor will NotImplementedError be raised even if the platform does not
support the feature.

Calling this method does not affect the value of $0.

    Process.setproctitle('myapp: worker #%d' % worker_id)

This method first appeared in Ruby 2.1 to serve as a global variable free
means to change the process title.

;T;0;;;I"setproctitle;F;I"Process;T;[o;;I"::String arg0;T;I"String;To;;I"òSets the resource limit of the process. *cur_limit* means current (soft) limit
and *max_limit* means maximum (hard) limit.

If *max_limit* is not given, *cur_limit* is used.

*resource* indicates the kind of resource to limit. It should be a symbol such
as `:CORE`, a string such as `"CORE"` or a constant such as
Process::RLIMIT_CORE. The available resources are OS dependent. Ruby may
support following resources.

AS
:   total available memory (bytes) (SUSv3, NetBSD, FreeBSD, OpenBSD but
    4.4BSD-Lite)
CORE
:   core size (bytes) (SUSv3)
CPU
:   CPU time (seconds) (SUSv3)
DATA
:   data segment (bytes) (SUSv3)
FSIZE
:   file size (bytes) (SUSv3)
MEMLOCK
:   total size for mlock(2) (bytes) (4.4BSD, GNU/Linux)
MSGQUEUE
:   allocation for POSIX message queues (bytes) (GNU/Linux)
NICE
:   ceiling on process's nice(2) value (number) (GNU/Linux)
NOFILE
:   file descriptors (number) (SUSv3)
NPROC
:   number of processes for the user (number) (4.4BSD, GNU/Linux)
RSS
:   resident memory size (bytes) (4.2BSD, GNU/Linux)
RTPRIO
:   ceiling on the process's real-time priority (number) (GNU/Linux)
RTTIME
:   CPU time for real-time process (us) (GNU/Linux)
SBSIZE
:   all socket buffers (bytes) (NetBSD, FreeBSD)
SIGPENDING
:   number of queued signals allowed (signals) (GNU/Linux)
STACK
:   stack size (bytes) (SUSv3)


*cur_limit* and *max_limit* may be `:INFINITY`, `"INFINITY"` or
Process::RLIM_INFINITY, which means that the resource is not limited. They may
be Process::RLIM_SAVED_MAX, Process::RLIM_SAVED_CUR and corresponding symbols
and strings too. See system setrlimit(2) manual for details.

The following example raises the soft limit of core size to the hard limit to
try to make core dump possible.

    Process.setrlimit(:CORE, Process.getrlimit(:CORE)[1])

;T;0;;;I"setrlimit;F;I"Process;T;[o;;I"X::Symbol | ::String | ::Integer resource, ::Integer cur_limit, ?::Integer max_limit;T;I"nil;To;;I"¶Establishes this process as a new session and process group leader, with no
controlling tty. Returns the session id. Not available on all platforms.

    Process.setsid   #=> 27422

;T;0;;;I"setsid;F;I"Process;T;[o;;I" ;F;I"Integer;To;;I"ëReturns a `Tms` structure (see Process::Tms) that contains user and system CPU
times for this process, and also for children processes.

    t = Process.times
    [ t.utime, t.stime, t.cutime, t.cstime ]   #=> [0.0, 0.02, 0.00, 0.00]

;T;0;;;I"
times;F;I"Process;T;[o;;I" ;F;I"Process::Tms;To;;I"MReturns the (real) user ID of this process.

    Process.uid   #=> 501

;T;0;;;I"uid;F;I"Process;T;[o;;I" ;F;I"Integer;To;;I"PSets the (user) user ID for this process. Not available on all platforms.

;T;0;;;I"	uid=;F;I"Process;T;[o;;I"::Integer user;T;I"Integer;To;;I"†Waits for a child process to exit, returns its process id, and sets `$?` to a
Process::Status object containing information on that process. Which child it
waits on depends on the value of *pid*:

> 0
:   Waits for the child whose process ID equals *pid*.

0
:   Waits for any child whose process group ID equals that of the calling
    process.

-1
:   Waits for any child process (the default if no *pid* is given).

< -1
:   Waits for any child whose process group ID equals the absolute value of
    *pid*.


The *flags* argument may be a logical or of the flag values Process::WNOHANG
(do not block if no child available) or Process::WUNTRACED (return stopped
children that haven't been reported). Not all flags are available on all
platforms, but a flag value of zero will work on all platforms.

Calling this method raises a SystemCallError if there are no child processes.
Not available on all platforms.

    include Process
    fork { exit 99 }                 #=> 27429
    wait                             #=> 27429
    $?.exitstatus                    #=> 99

    pid = fork { sleep 3 }           #=> 27440
    Time.now                         #=> 2008-03-08 19:56:16 +0900
    waitpid(pid, Process::WNOHANG)   #=> nil
    Time.now                         #=> 2008-03-08 19:56:16 +0900
    waitpid(pid, 0)                  #=> 27440
    Time.now                         #=> 2008-03-08 19:56:19 +0900

;T;0;;;I"	wait;F;I"Process;T;[o;;I"%?::Integer pid, ?::Integer flags;T;I"Integer;To;;I"ŽWaits for a child process to exit (see Process::waitpid for exact semantics)
and returns an array containing the process id and the exit status (a
Process::Status object) of that child. Raises a SystemCallError if there are
no child processes.

    Process.fork { exit 99 }   #=> 27437
    pid, status = Process.wait2
    pid                        #=> 27437
    status.exitstatus          #=> 99

;T;0;;;I"
wait2;F;I"Process;T;[o;;I"%?::Integer pid, ?::Integer flags;T;I"%[ ::Integer, ::Process::Status ];To;;I"´Waits for all children, returning an array of *pid*/*status* pairs (where
*status* is a Process::Status object).

    fork { sleep 0.2; exit 2 }   #=> 27432
    fork { sleep 0.1; exit 1 }   #=> 27433
    fork {            exit 0 }   #=> 27434
    p Process.waitall

*produces*:

    [[30982, #<Process::Status: pid 30982 exit 0>],
     [30979, #<Process::Status: pid 30979 exit 1>],
     [30976, #<Process::Status: pid 30976 exit 2>]]

;T;0;;;I"waitall;F;I"Process;T;[o;;I" ;F;I",Array[[ ::Integer, ::Process::Status ]];To;;I"†Waits for a child process to exit, returns its process id, and sets `$?` to a
Process::Status object containing information on that process. Which child it
waits on depends on the value of *pid*:

> 0
:   Waits for the child whose process ID equals *pid*.

0
:   Waits for any child whose process group ID equals that of the calling
    process.

-1
:   Waits for any child process (the default if no *pid* is given).

< -1
:   Waits for any child whose process group ID equals the absolute value of
    *pid*.


The *flags* argument may be a logical or of the flag values Process::WNOHANG
(do not block if no child available) or Process::WUNTRACED (return stopped
children that haven't been reported). Not all flags are available on all
platforms, but a flag value of zero will work on all platforms.

Calling this method raises a SystemCallError if there are no child processes.
Not available on all platforms.

    include Process
    fork { exit 99 }                 #=> 27429
    wait                             #=> 27429
    $?.exitstatus                    #=> 99

    pid = fork { sleep 3 }           #=> 27440
    Time.now                         #=> 2008-03-08 19:56:16 +0900
    waitpid(pid, Process::WNOHANG)   #=> nil
    Time.now                         #=> 2008-03-08 19:56:16 +0900
    waitpid(pid, 0)                  #=> 27440
    Time.now                         #=> 2008-03-08 19:56:19 +0900

;T;0;;;I"waitpid;F;I"Process;T;[o;;I"%?::Integer pid, ?::Integer flags;T;I"Integer;To;;I"ŽWaits for a child process to exit (see Process::waitpid for exact semantics)
and returns an array containing the process id and the exit status (a
Process::Status object) of that child. Raises a SystemCallError if there are
no child processes.

    Process.fork { exit 99 }   #=> 27437
    pid, status = Process.wait2
    pid                        #=> 27437
    status.exitstatus          #=> 99

;T;0;;;I"waitpid2;F;I"Process;T;[o;;I"%?::Integer pid, ?::Integer flags;T;I"%[ ::Integer, ::Process::Status ];To;;I"²The Process::GID module contains a collection of module functions which can be
used to portably get, set, and switch the current process's real, effective,
and saved group IDs.

;T;0;	I"Process::GID;T;
[ ;[ ;0;[ ;[ o;;I"-Change the current process's real and effective group ID to that specified by
*group*. Returns the new group ID. Not available on all platforms.

    [Process.gid, Process.egid]          #=> [0, 0]
    Process::GID.change_privilege(33)    #=> 33
    [Process.gid, Process.egid]          #=> [33, 33]

;T;0;;;I"change_privilege;F;I"Process::GID;T;[o;;I"::Integer group;T;I"Integer;To;;I"sReturns the effective group ID for this process. Not available on all
platforms.

    Process.egid   #=> 500

;T;0;;;I"eid;F;I"Process::GID;T;[o;;I" ;F;I"Integer;To;;I"æGet the group ID by the *name*. If the group is not found, `ArgumentError`
will be raised.

    Process::GID.from_name("wheel") #=> 0
    Process::GID.from_name("nosuchgroup") #=> can't find group for nosuchgroup (ArgumentError)

;T;0;;;I"from_name;F;I"Process::GID;T;[o;;I"::String name;T;I"Integer;To;;I"DSet the effective group ID, and if possible, the saved group ID of the process
to the given *group*. Returns the new effective group ID. Not available on all
platforms.

    [Process.gid, Process.egid]          #=> [0, 0]
    Process::GID.grant_privilege(31)     #=> 33
    [Process.gid, Process.egid]          #=> [0, 33]

;T;0;;;I"grant_privilege;F;I"Process::GID;T;[o;;I"::Integer group;T;I"Integer;To;;I"óExchange real and effective group IDs and return the new effective group ID.
Not available on all platforms.

    [Process.gid, Process.egid]   #=> [0, 33]
    Process::GID.re_exchange      #=> 0
    [Process.gid, Process.egid]   #=> [33, 0]

;T;0;;;I"re_exchange;F;I"Process::GID;T;[o;;I" ;F;I"Integer;To;;I"pReturns `true` if the real and effective group IDs of a process may be
exchanged on the current platform.

;T;0;;;I"re_exchangeable?;F;I"Process::GID;T;[o;;I" ;F;I"	bool;To;;I"OReturns the (real) group ID for this process.

    Process.gid   #=> 500

;T;0;;;I"rid;F;I"Process::GID;T;[o;;I" ;F;I"Integer;To;;I"OReturns `true` if the current platform has saved group ID functionality.

;T;0;;;I"sid_available?;F;I"Process::GID;T;[o;;I" ;F;I"	bool;To;;I"
Switch the effective and real group IDs of the current process. If a *block*
is given, the group IDs will be switched back after the block is executed.
Returns the new effective group ID if called without a block, and the return
value of the block if one is given.

;T;0;;;I"switch;F;I"Process::GID;T;[o;;I" ;F;I"Integer;To;;I" ;F;I"T;Fo;;0;0;;;I"	eid=;F;I"Process::GID;T;[o;;I"::Integer group;T;I"Integer;To; ;I"Process::Status encapsulates the information on the status of a running or
terminated system process. The built-in variable `$?` is either `nil` or a
Process::Status object.

    fork { exit 99 }   #=> 26557
    Process.wait       #=> 26557
    $?.class           #=> Process::Status
    $?.to_i            #=> 25344
    $? >> 8            #=> 99
    $?.stopped?        #=> false
    $?.exited?         #=> true
    $?.exitstatus      #=> 99

Posix systems record information on processes using a 16-bit integer.  The
lower bits record the process status (stopped, exited, signaled) and the upper
bits possibly contain additional information (for example the program's return
code in the case of exited processes). Pre Ruby 1.8, these bits were exposed
directly to the Ruby program. Ruby now encapsulates these in a Process::Status
object. To maximize compatibility, however, these objects retain a
bit-oriented interface. In the descriptions that follow, when we talk about
the integer value of *stat*, we're referring to this 16 bit value.

;T;0;	I"Process::Status;T;
[ ;[ ;0;[ ;[ ;0;I"Object;To;;I"´Logical AND of the bits in *stat* with *num*.

    fork { exit 0x37 }
    Process.wait
    sprintf('%04x', $?.to_i)       #=> "3700"
    sprintf('%04x', $? & 0x1e00)   #=> "1600"

;T;0;;;I"&;F;I"Process::Status;T;[o;;I"::Integer num;T;I"Integer;To;;I"DReturns `true` if the integer value of *stat* equals *other*.

;T;0;;;I"==;F;I"Process::Status;T;[o;;I"untyped other;T;I"	bool;To;;I"°Shift the bits in *stat* right *num* places.

    fork { exit 99 }   #=> 26563
    Process.wait       #=> 26563
    $?.to_i            #=> 25344
    $? >> 8            #=> 99

;T;0;;;I">>;F;I"Process::Status;T;[o;;I"::Integer num;T;I"Integer;To;;I"hReturns `true` if *stat* generated a coredump when it terminated. Not
available on all platforms.

;T;0;;;I"coredump?;F;I"Process::Status;T;[o;;I" ;F;I"	bool;To;;I"nReturns `true` if *stat* exited normally (for example using an `exit()` call
or finishing the program).

;T;0;;;I"exited?;F;I"Process::Status;T;[o;;I" ;F;I"	bool;To;;I"oReturns the least significant eight bits of the return code of *stat*. Only
available if #exited? is `true`.

    fork { }           #=> 26572
    Process.wait       #=> 26572
    $?.exited?         #=> true
    $?.exitstatus      #=> 0

    fork { exit 99 }   #=> 26573
    Process.wait       #=> 26573
    $?.exited?         #=> true
    $?.exitstatus      #=> 99

;T;0;;;I"exitstatus;F;I"Process::Status;T;[o;;I" ;F;I"Integer?;To;;I"wOverride the inspection method.

    system("false")
    p $?.inspect #=> "#<Process::Status: pid 12861 exit 1>"

;T;0;;;I"inspect;F;I"Process::Status;T;[o;;I" ;F;I"String;To;;I"—Returns the process ID that this status object represents.

    fork { exit }   #=> 26569
    Process.wait    #=> 26569
    $?.pid          #=> 26569

;T;0;;;I"pid;F;I"Process::Status;T;[o;;I" ;F;I"Integer;To;;I"IReturns `true` if *stat* terminated because of an uncaught signal.

;T;0;;;I"signaled?;F;I"Process::Status;T;[o;;I" ;F;I"	bool;To;;I"‡Returns `true` if this process is stopped. This is only returned if the
corresponding #wait call had the Process::WUNTRACED flag set.

;T;0;;;I"stopped?;F;I"Process::Status;T;[o;;I" ;F;I"	bool;To;;I"eReturns the number of the signal that caused *stat* to stop (or `nil` if self
is not stopped).

;T;0;;;I"stopsig;F;I"Process::Status;T;[o;;I" ;F;I"Integer?;To;;I"gReturns `true` if *stat* is successful, `false` if not. Returns `nil` if
#exited? is not `true`.

;T;0;;;I"success?;F;I"Process::Status;T;[o;;I" ;F;I"	bool;To;;I"Returns the number of the signal that caused *stat* to terminate (or `nil` if
self was not terminated by an uncaught signal).

;T;0;;;I"termsig;F;I"Process::Status;T;[o;;I" ;F;I"Integer?;To;;I"ÛReturns the bits in *stat* as an Integer. Poking around in these bits is
platform dependent.

    fork { exit 0xab }         #=> 26566
    Process.wait               #=> 26566
    sprintf('%04x', $?.to_i)   #=> "ab00"

;T;0;;;I"	to_i;F;I"Process::Status;T;[o;;I" ;F;I"Integer;To;;I"nShow pid and exit status as a string.

    system("false")
    p $?.to_s         #=> "pid 12766 exit 1"

;T;0;;;I"	to_s;F;I"Process::Status;T;[o;;I" ;F;I"String;To;;I"úThe Process::Sys module contains UID and GID functions which provide direct
bindings to the system calls of the same names instead of the more-portable
versions of the same functionality found in the Process, Process::UID, and
Process::GID modules.

;T;0;	I"Process::Sys;T;
[ ;[ ;0;[ ;[ o;;I"RReturns the effective user ID for this process.

    Process.euid   #=> 501

;T;0;;;I"geteuid;F;I"Process::Sys;T;[o;;I" ;F;I"Integer;To;;I"OReturns the (real) group ID for this process.

    Process.gid   #=> 500

;T;0;;;I"getgid;F;I"Process::Sys;T;[o;;I" ;F;I"Integer;To;;I"MReturns the (real) user ID of this process.

    Process.uid   #=> 501

;T;0;;;I"getuid;F;I"Process::Sys;T;[o;;I" ;F;I"Integer;To;;I"Returns `true` if the process was created as a result of an execve(2) system
call which had either of the setuid or setgid bits set (and extra privileges
were given as a result) or if it has changed any of its real, effective or
saved user or group IDs since it began execution.

;T;0;;;I"issetugid;F;I"Process::Sys;T;[o;;I" ;F;I"	bool;To;;I"eSet the effective group ID of the calling process to *group*.  Not available
on all platforms.

;T;0;;;I"setegid;F;I"Process::Sys;T;[o;;I"::Integer group;T;I"nil;To;;I"cSet the effective user ID of the calling process to *user*.  Not available on
all platforms.

;T;0;;;I"seteuid;F;I"Process::Sys;T;[o;;I"::Integer user;T;I"nil;To;;I"ZSet the group ID of the current process to *group*. Not available on all
platforms.

;T;0;;;I"setgid;F;I"Process::Sys;T;[o;;I"::Integer group;T;I"nil;To;;I"ÈSets the (group) real and/or effective group IDs of the current process to
*rid* and *eid*, respectively. A value of `-1` for either means to leave that
ID unchanged. Not available on all platforms.

;T;0;;;I"setregid;F;I"Process::Sys;T;[o;;I"!::Integer rid, ::Integer eid;T;I"nil;To;;I"ÖSets the (group) real, effective, and saved user IDs of the current process to
*rid*, *eid*, and *sid* respectively. A value of `-1` for any value means to
leave that ID unchanged. Not available on all platforms.

;T;0;;;I"setresgid;F;I"Process::Sys;T;[o;;I"0::Integer rid, ::Integer eid, ::Integer sid;T;I"nil;To;;I"ÕSets the (user) real, effective, and saved user IDs of the current process to
*rid*, *eid*, and *sid* respectively. A value of `-1` for any value means to
leave that ID unchanged. Not available on all platforms.

;T;0;;;I"setresuid;F;I"Process::Sys;T;[o;;I"0::Integer rid, ::Integer eid, ::Integer sid;T;I"nil;To;;I"ÆSets the (user) real and/or effective user IDs of the current process to *rid*
and *eid*, respectively. A value of `-1` for either means to leave that ID
unchanged. Not available on all platforms.

;T;0;;;I"setreuid;F;I"Process::Sys;T;[o;;I"!::Integer rid, ::Integer eid;T;I"nil;To;;I"_Set the real group ID of the calling process to *group*. Not available on all
platforms.

;T;0;;;I"setrgid;F;I"Process::Sys;T;[o;;I"::Integer group;T;I"nil;To;;I"]Set the real user ID of the calling process to *user*. Not available on all
platforms.

;T;0;;;I"setruid;F;I"Process::Sys;T;[o;;I"::Integer user;T;I"nil;To;;I"XSet the user ID of the current process to *user*. Not available on all
platforms.

;T;0;;;I"setuid;F;I"Process::Sys;T;[o;;I"::Integer user;T;I"nil;To;;I"±The Process::UID module contains a collection of module functions which can be
used to portably get, set, and switch the current process's real, effective,
and saved user IDs.

;T;0;	I"Process::UID;T;
[ ;[ ;0;[ ;[ o;;I"*Change the current process's real and effective user ID to that specified by
*user*. Returns the new user ID. Not available on all platforms.

    [Process.uid, Process.euid]          #=> [0, 0]
    Process::UID.change_privilege(31)    #=> 31
    [Process.uid, Process.euid]          #=> [31, 31]

;T;0;;;I"change_privilege;F;I"Process::UID;T;[o;;I"::Integer user;T;I"Integer;To;;I"RReturns the effective user ID for this process.

    Process.euid   #=> 501

;T;0;;;I"eid;F;I"Process::UID;T;[o;;I" ;F;I"Integer;To;;I"àGet the user ID by the *name*. If the user is not found, `ArgumentError` will
be raised.

    Process::UID.from_name("root") #=> 0
    Process::UID.from_name("nosuchuser") #=> can't find user for nosuchuser (ArgumentError)

;T;0;;;I"from_name;F;I"Process::UID;T;[o;;I"::String name;T;I"Integer;To;;I"@Set the effective user ID, and if possible, the saved user ID of the process
to the given *user*. Returns the new effective user ID. Not available on all
platforms.

    [Process.uid, Process.euid]          #=> [0, 0]
    Process::UID.grant_privilege(31)     #=> 31
    [Process.uid, Process.euid]          #=> [0, 31]

;T;0;;;I"grant_privilege;F;I"Process::UID;T;[o;;I"::Integer user;T;I"Integer;To;;I"ñExchange real and effective user IDs and return the new effective user ID. Not
available on all platforms.

    [Process.uid, Process.euid]   #=> [0, 31]
    Process::UID.re_exchange      #=> 0
    [Process.uid, Process.euid]   #=> [31, 0]

;T;0;;;I"re_exchange;F;I"Process::UID;T;[o;;I" ;F;I"Integer;To;;I"oReturns `true` if the real and effective user IDs of a process may be
exchanged on the current platform.

;T;0;;;I"re_exchangeable?;F;I"Process::UID;T;[o;;I" ;F;I"	bool;To;;I"MReturns the (real) user ID of this process.

    Process.uid   #=> 501

;T;0;;;I"rid;F;I"Process::UID;T;[o;;I" ;F;I"Integer;To;;I"NReturns `true` if the current platform has saved user ID functionality.

;T;0;;;I"sid_available?;F;I"Process::UID;T;[o;;I" ;F;I"	bool;To;;I"Switch the effective and real user IDs of the current process. If a *block* is
given, the user IDs will be switched back after the block is executed. Returns
the new effective user ID if called without a block, and the return value of
the block if one is given.

;T;0;;;I"switch;F;I"Process::UID;T;[o;;I" ;F;I"Integer;To;;I" ;F;I"T;Fo;;0;0;;;I"	eid=;F;I"Process::UID;T;[o;;I"::Integer user;T;I"Integer;To; ;0;0;	I"Process::Tms;T;
[ ;[ ;0;[ ;[ ;0;I"Struct;To; ;0;0;	I"Process::Waiter;T;
[ ;[ ;0;[ ;[ ;0;I"Thread;To;;0;0;;;I"pid;F;I"Process::Waiter;T;[o;;I" ;F;I"Integer;To; ;I"m!Ractor is a Actor-model abstraction for Ruby that provides thread-safe
parallel execution.

Ractor.new can make a new Ractor, and it will run in parallel.

    # The simplest ractor
    r = Ractor.new {puts "I am in Ractor!"}
    r.take # wait for it to finish
    # here "I am in Ractor!" would be printed

Ractors do not share usual objects, so the same kinds of thread-safety
concerns such as data-race, race-conditions are not available on multi-ractor
programming.

To achieve this, ractors severely limit object sharing between different
ractors. For example, unlike threads, ractors can't access each other's
objects, nor any objects through variables of the outer scope.

    a = 1
    r = Ractor.new {puts "I am in Ractor! a=#{a}"}
    # fails immediately with
    # ArgumentError (can not isolate a Proc because it accesses outer variables (a).)

On CRuby (the default implementation), Global Virtual Machine Lock (GVL) is
held per ractor, so ractors are performed in parallel without locking each
other.

Instead of accessing the shared state, the objects should be passed to and
from ractors via sending and receiving objects as messages.

    a = 1
    r = Ractor.new do
      a_in_ractor = receive # receive blocks till somebody will pass message
      puts "I am in Ractor! a=#{a_in_ractor}"
    end
    r.send(a)  # pass it
    r.take
    # here "I am in Ractor! a=1" would be printed

There are two pairs of methods for sending/receiving messages:

*   Ractor#send and Ractor.receive for when the *sender* knows the receiver
    (push);
*   Ractor.yield and Ractor#take for when the *receiver* knows the sender
    (pull);


In addition to that, an argument to Ractor.new would be passed to block and
available there as if received by Ractor.receive, and the last block value
would be sent outside of the ractor as if sent by Ractor.yield.

A little demonstration on a classic ping-pong:

    server = Ractor.new do
      puts "Server starts: #{self.inspect}"
      puts "Server sends: ping"
      Ractor.yield 'ping'                       # The server doesn't know the receiver and sends to whoever interested
      received = Ractor.receive                 # The server doesn't know the sender and receives from whoever sent
      puts "Server received: #{received}"
    end

    client = Ractor.new(server) do |srv|        # The server is sent inside client, and available as srv
      puts "Client starts: #{self.inspect}"
      received = srv.take                       # The Client takes a message specifically from the server
      puts "Client received from " \
           "#{srv.inspect}: #{received}"
      puts "Client sends to " \
           "#{srv.inspect}: pong"
      srv.send 'pong'                           # The client sends a message specifically to the server
    end

    [client, server].each(&:take)               # Wait till they both finish

This will output:

    Server starts: #<Ractor:#2 test.rb:1 running>
    Server sends: ping
    Client starts: #<Ractor:#3 test.rb:8 running>
    Client received from #<Ractor:#2 rac.rb:1 blocking>: ping
    Client sends to #<Ractor:#2 rac.rb:1 blocking>: pong
    Server received: pong

It is said that Ractor receives messages via the *incoming port*, and sends
them to the *outgoing port*. Either one can be disabled with
Ractor#close_incoming and Ractor#close_outgoing respectively. If a ractor
terminated, its ports will be closed automatically.

## Shareable and unshareable objects

When the object is sent to and from the ractor, it is important to understand
whether the object is shareable or unshareable. Most of objects are
unshareable objects.

Shareable objects are basically those which can be used by several threads
without compromising thread-safety; e.g. immutable ones. Ractor.shareable?
allows to check this, and Ractor.make_shareable tries to make object shareable
if it is not.

    Ractor.shareable?(1)            #=> true -- numbers and other immutable basic values are
    Ractor.shareable?('foo')        #=> false, unless the string is frozen due to # freeze_string_literals: true
    Ractor.shareable?('foo'.freeze) #=> true

    ary = ['hello', 'world']
    ary.frozen?                 #=> false
    ary[0].frozen?              #=> false
    Ractor.make_shareable(ary)
    ary.frozen?                 #=> true
    ary[0].frozen?              #=> true
    ary[1].frozen?              #=> true

When a shareable object is sent (via #send or Ractor.yield), no additional
processing happens, and it just becomes usable by both ractors. When an
unshareable object is sent, it can be either *copied* or *moved*. The first is
the default, and it makes the object's full copy by deep cloning of
non-shareable parts of its structure.

    data = ['foo', 'bar'.freeze]
    r = Ractor.new do
      data2 = Ractor.receive
      puts "In ractor: #{data2.object_id}, #{data2[0].object_id}, #{data2[1].object_id}"
    end
    r.send(data)
    r.take
    puts "Outside  : #{data.object_id}, #{data[0].object_id}, #{data[1].object_id}"

This will output:

    In ractor: 340, 360, 320
    Outside  : 380, 400, 320

(Note that object id of both array and non-frozen string inside array have
changed inside the ractor, showing it is different objects. But the second
array's element, which is a shareable frozen string, has the same object_id.)

Deep cloning of the objects may be slow, and sometimes impossible.
Alternatively, `move: true` may be used on sending. This will *move* the
object to the receiving ractor, making it inaccessible for a sending ractor.

    data = ['foo', 'bar']
    r = Ractor.new do
      data_in_ractor = Ractor.receive
      puts "In ractor: #{data_in_ractor.object_id}, #{data_in_ractor[0].object_id}"
    end
    r.send(data, move: true)
    r.take
    puts "Outside: moved? #{Ractor::MovedObject === data}"
    puts "Outside: #{data.inspect}"

This will output:

    In ractor: 100, 120
    Outside: moved? true
    test.rb:9:in `method_missing': can not send any methods to a moved object (Ractor::MovedError)

Notice that even `inspect` (and more basic methods like `__id__`) is
inaccessible on a moved object.

Besides frozen objects, there are shareable objects. Class and Module objects
are shareable so the Class/Module definitions are shared between ractors.
Ractor objects are also shareable objects. All operations for the shareable
mutable objects are thread-safe, so the thread-safety property will be kept.
We can not define mutable shareable objects in Ruby, but C extensions can
introduce them.

It is prohibited to access instance variables of mutable shareable objects
(especially Modules and classes) from ractors other than main:

    class C
      class << self
        attr_accessor :tricky
      end
    end

    C.tricky = 'test'

    r = Ractor.new(C) do |cls|
      puts "I see #{cls}"
      puts "I can't see #{cls.tricky}"
    end
    r.take
    # I see C
    # can not access instance variables of classes/modules from non-main Ractors (RuntimeError)

Ractors can access constants if they are shareable. The main Ractor is the
only one that can access non-shareable constants.

    GOOD = 'good'.freeze
    BAD = 'bad'

    r = Ractor.new do
      puts "GOOD=#{GOOD}"
      puts "BAD=#{BAD}"
    end
    r.take
    # GOOD=good
    # can not access non-shareable objects in constant Object::BAD by non-main Ractor. (NameError)

    # Consider the same C class from above

    r = Ractor.new do
      puts "I see #{C}"
      puts "I can't see #{C.tricky}"
    end
    r.take
    # I see C
    # can not access instance variables of classes/modules from non-main Ractors (RuntimeError)

See also the description of `# shareable_constant_value` pragma in [Comments
syntax](rdoc-ref:syntax/comments.rdoc) explanation.

## Ractors vs threads

Each ractor creates its own thread. New threads can be created from inside
ractor (and, on CRuby, sharing GVL with other threads of this ractor).

    r = Ractor.new do
      a = 1
      Thread.new {puts "Thread in ractor: a=#{a}"}.join
    end
    r.take
    # Here "Thread in ractor: a=1" will be printed

## Note on code examples

In examples below, sometimes we use the following method to wait till ractors
that are not currently blocked will finish (or process till next blocking)
method.

    def wait
      sleep(0.1)
    end

It is **only for demonstration purposes** and shouldn't be used in a real
code. Most of the times, just #take is used to wait till ractor will finish.

## Reference

See [Ractor design doc](rdoc-ref:ractor.md) for more details.

;T;0;	I"Ractor;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"zReturns total count of Ractors currently running.

    Ractor.count                   #=> 1
    r = Ractor.new(name: 'example') { Ractor.yield(1) }
    Ractor.count                   #=> 2 (main + example ractor)
    r.take                         # wait for Ractor.yield(1)
    r.take                         # wait till r will finish
    Ractor.count                   #=> 1

;T;0;;;I"
count;F;I"Ractor;T;[o;;I" ;F;I"Integer;To;;I"[Returns the currently executing Ractor.

    Ractor.current #=> #<Ractor:#1 running>

;T;0;;;I"current;F;I"Ractor;T;[o;;I" ;F;I"untyped;To;;I"returns main ractor

;T;0;;;I"	main;F;I"Ractor;T;[o;;I" ;F;I"untyped;To;;I"zMake `obj` shareable between ractors.

`obj` and all the objects it refers to will be frozen, unless they are already
shareable.

If `copy` keyword is `true`, the method will copy objects before freezing them
This is safer option but it can take be slower.

Note that the specification and implementation of this method are not mature
and may be changed in the future.

    obj = ['test']
    Ractor.shareable?(obj)     #=> false
    Ractor.make_shareable(obj) #=> ["test"]
    Ractor.shareable?(obj)     #=> true
    obj.frozen?                #=> true
    obj[0].frozen?             #=> true

    # Copy vs non-copy versions:
    obj1 = ['test']
    obj1s = Ractor.make_shareable(obj1)
    obj1.frozen?                        #=> true
    obj1s.object_id == obj1.object_id   #=> true
    obj2 = ['test']
    obj2s = Ractor.make_shareable(obj2, copy: true)
    obj2.frozen?                        #=> false
    obj2s.frozen?                       #=> true
    obj2s.object_id == obj2.object_id   #=> false
    obj2s[0].object_id == obj2[0].object_id #=> false

See also the "Shareable and unshareable objects" section in the Ractor class
docs.

;T;0;;;I"make_shareable;F;I"Ractor;T;[o;;I"T obj, ?copy: ::boolish;T;I"T;Fo;;I"´Create a new Ractor with args and a block.

A block (Proc) will be isolated (can't access to outer variables). `self`
inside the block will refer to the current Ractor.

    r = Ractor.new { puts "Hi, I am #{self.inspect}" }
    r.take
    # Prints "Hi, I am #<Ractor:#2 test.rb:1 running>"

`args` passed to the method would be propagated to block args by the same
rules as objects passed through #send/Ractor.receive: if `args` are not
shareable, they will be copied (via deep cloning, which might be inefficient).

    arg = [1, 2, 3]
    puts "Passing: #{arg} (##{arg.object_id})"
    r = Ractor.new(arg) {|received_arg|
      puts "Received: #{received_arg} (##{received_arg.object_id})"
    }
    r.take
    # Prints:
    #   Passing: [1, 2, 3] (#280)
    #   Received: [1, 2, 3] (#300)

Ractor's `name` can be set for debugging purposes:

    r = Ractor.new(name: 'my ractor') {}
    p r
    #=> #<Ractor:#3 my ractor test.rb:1 terminated>

;T;0;;;I"new;F;I"Ractor;T;[o;;I"#*untyped args, ?name: ::string;T;I"Ractor;To;;I"Receive an incoming message from the current Ractor's incoming port's queue,
which was sent there by #send.

    r = Ractor.new do
      v1 = Ractor.receive
      puts "Received: #{v1}"
    end
    r.send('message1')
    r.take
    # Here will be printed: "Received: message1"

Alternatively, private instance method `receive` may be used:

    r = Ractor.new do
      v1 = receive
      puts "Received: #{v1}"
    end
    r.send('message1')
    r.take
    # Here will be printed: "Received: message1"

The method blocks if the queue is empty.

    r = Ractor.new do
      puts "Before first receive"
      v1 = Ractor.receive
      puts "Received: #{v1}"
      v2 = Ractor.receive
      puts "Received: #{v2}"
    end
    wait
    puts "Still not received"
    r.send('message1')
    wait
    puts "Still received only one"
    r.send('message2')
    r.take

Output:

    Before first receive
    Still not received
    Received: message1
    Still received only one
    Received: message2

If close_incoming was called on the ractor, the method raises
Ractor::ClosedError if there are no more messages in incoming queue:

    Ractor.new do
      close_incoming
      receive
    end
    wait
    # in `receive': The incoming port is already closed => #<Ractor:#2 test.rb:1 running> (Ractor::ClosedError)

;T;0;;;I"receive;F;I"Ractor;T;[o;;I" ;F;I"untyped;To;;I")Receive only a specific message.

Instead of Ractor.receive, Ractor.receive_if can provide a pattern by a block
and you can choose the receiving message.

    r = Ractor.new do
      p Ractor.receive_if{|msg| msg.match?(/foo/)} #=> "foo3"
      p Ractor.receive_if{|msg| msg.match?(/bar/)} #=> "bar1"
      p Ractor.receive_if{|msg| msg.match?(/baz/)} #=> "baz2"
    end
    r << "bar1"
    r << "baz2"
    r << "foo3"
    r.take

This will output:

    foo3
    bar1
    baz2

If the block returns a truthy value, the message will be removed from the
incoming queue and returned. Otherwise, the message remains in the incoming
queue and the following received messages are checked by the given block.

If there are no messages left in the incoming queue, the method will block
until new messages arrive.

If the block is escaped by break/return/exception/throw, the message is
removed from the incoming queue as if a truthy value had been returned.

    r = Ractor.new do
      val = Ractor.receive_if{|msg| msg.is_a?(Array)}
      puts "Received successfully: #{val}"
    end

    r.send(1)
    r.send('test')
    wait
    puts "2 non-matching sent, nothing received"
    r.send([1, 2, 3])
    wait

Prints:

    2 non-matching sent, nothing received
    Received successfully: [1, 2, 3]

Note that you can not call receive/receive_if in the given block recursively.
It means that you should not do any tasks in the block.

    Ractor.current << true
    Ractor.receive_if{|msg| Ractor.receive}
    #=> `receive': can not call receive/receive_if recursively (Ractor::Error)

;T;0;;;I"receive_if;F;I"Ractor;T;[o;;I" ;F;I"untyped;To;;I"¤Waits for the first ractor to have something in its outgoing port, reads from
this ractor, and returns that ractor and the object received.

    r1 = Ractor.new {Ractor.yield 'from 1'}
    r2 = Ractor.new {Ractor.yield 'from 2'}

    r, obj = Ractor.select(r1, r2)

    puts "received #{obj.inspect} from #{r.inspect}"
    # Prints: received "from 1" from #<Ractor:#2 test.rb:1 running>

If one of the given ractors is the current ractor, and it would be selected,
`r` will contain `:receive` symbol instead of the ractor object.

    r1 = Ractor.new(Ractor.current) do |main|
      main.send 'to main'
      Ractor.yield 'from 1'
    end
    r2 = Ractor.new do
      Ractor.yield 'from 2'
    end

    r, obj = Ractor.select(r1, r2, Ractor.current)
    puts "received #{obj.inspect} from #{r.inspect}"
    # Prints: received "to main" from :receive

If `yield_value` is provided, that value may be yielded if another Ractor is
calling #take. In this case, the pair `[:yield, nil]` would be returned:

    r1 = Ractor.new(Ractor.current) do |main|
      puts "Received from main: #{main.take}"
    end

    puts "Trying to select"
    r, obj = Ractor.select(r1, Ractor.current, yield_value: 123)
    wait
    puts "Received #{obj.inspect} from #{r.inspect}"

This will print:

    Trying to select
    Received from main: 123
    Received nil from :yield

`move` boolean flag defines whether yielded value should be copied (default)
or moved.

;T;0;;;I"select;F;I"Ractor;T;[o;;I"?*::Ractor ractors, ?move: ::boolish, ?yield_value: untyped;T;I"%[ ::Ractor | ::Symbol, untyped ];To;;I"†Checks if the object is shareable by ractors.

    Ractor.shareable?(1)            #=> true -- numbers and other immutable basic values are frozen
    Ractor.shareable?('foo')        #=> false, unless the string is frozen due to # freeze_string_literals: true
    Ractor.shareable?('foo'.freeze) #=> true

See also the "Shareable and unshareable objects" section in the Ractor class
docs.

;T;0;;;I"shareable?;F;I"Ractor;T;[o;;I"untyped obj;T;I"	bool;To;;I"4Send a message to the current ractor's outgoing port to be consumed by #take.

    r = Ractor.new {Ractor.yield 'Hello from ractor'}
    puts r.take
    # Prints: "Hello from ractor"

The method is blocking, and will return only when somebody consumes the sent
message.

    r = Ractor.new do
      Ractor.yield 'Hello from ractor'
      puts "Ractor: after yield"
    end
    wait
    puts "Still not taken"
    puts r.take

This will print:

    Still not taken
    Hello from ractor
    Ractor: after yield

If the outgoing port was closed with #close_outgoing, the method will raise:

    r = Ractor.new do
      close_outgoing
      Ractor.yield 'Hello from ractor'
    end
    wait
    # `yield': The outgoing-port is already closed (Ractor::ClosedError)

The meaning of `move` argument is the same as for #send.

;T;0;;;I"
yield;F;I"Ractor;T;[o;;I""untyped obj, ?move: ::boolish;T;I"untyped;To;;I",get a value from ractor-local storage

;T;0;;;I"[];F;I"Ractor;T;[o;;I"::Symbol | ::String sym;T;I"untyped;To;;I"*set a value in ractor-local storage

;T;0;;;I"[]=;F;I"Ractor;T;[o;;I"#::Symbol | ::String sym, T val;T;I"T;Fo;;I"_Closes the incoming port and returns its previous state. All further attempts
to Ractor.receive in the ractor, and #send to the ractor will fail with
Ractor::ClosedError.

    r = Ractor.new {sleep(500)}
    r.close_incoming  #=> false
    r.close_incoming  #=> true
    r.send('test')
    # Ractor::ClosedError (The incoming-port is already closed)

;T;0;;;I"close_incoming;F;I"Ractor;T;[o;;I" ;F;I"	bool;To;;I"WCloses the outgoing port and returns its previous state. All further attempts
to Ractor.yield in the ractor, and #take from the ractor will fail with
Ractor::ClosedError.

    r = Ractor.new {sleep(500)}
    r.close_outgoing  #=> false
    r.close_outgoing  #=> true
    r.take
    # Ractor::ClosedError (The outgoing-port is already closed)

;T;0;;;I"close_outgoing;F;I"Ractor;T;[o;;I" ;F;I"	bool;To;;I" ;T;0;;;I"inspect;F;I"Ractor;T;[o;;I" ;F;I"String;To;;I",The name set in Ractor.new, or `nil`.

;T;0;;;I"	name;F;I"Ractor;T;[o;;I" ;F;I"String?;To;;I"æSend a message to a Ractor's incoming queue to be consumed by Ractor.receive.

    r = Ractor.new do
      value = Ractor.receive
      puts "Received #{value}"
    end
    r.send 'message'
    # Prints: "Received: message"

The method is non-blocking (will return immediately even if the ractor is not
ready to receive anything):

    r = Ractor.new {sleep(5)}
    r.send('test')
    puts "Sent successfully"
    # Prints: "Sent successfully" immediately

Attempt to send to ractor which already finished its execution will raise
Ractor::ClosedError.

    r = Ractor.new {}
    r.take
    p r
    # "#<Ractor:#6 (irb):23 terminated>"
    r.send('test')
    # Ractor::ClosedError (The incoming-port is already closed)

If close_incoming was called on the ractor, the method also raises
Ractor::ClosedError.

    r =  Ractor.new do
      sleep(500)
      receive
    end
    r.close_incoming
    r.send('test')
    # Ractor::ClosedError (The incoming-port is already closed)
    # The error would be raised immediately, not when ractor will try to receive

If the `obj` is unshareable, by default it would be copied into ractor by deep
cloning. If the `move: true` is passed, object is *moved* into ractor and
becomes inaccessible to sender.

    r = Ractor.new {puts "Received: #{receive}"}
    msg = 'message'
    r.send(msg, move: true)
    r.take
    p msg

This prints:

    Received: message
    in `p': undefined method `inspect' for #<Ractor::MovedObject:0x000055c99b9b69b8>

All references to the object and its parts will become invalid in sender.

    r = Ractor.new {puts "Received: #{receive}"}
    s = 'message'
    ary = [s]
    copy = ary.dup
    r.send(ary, move: true)

    s.inspect
    # Ractor::MovedError (can not send any methods to a moved object)
    ary.class
    # Ractor::MovedError (can not send any methods to a moved object)
    copy.class
    # => Array, it is different object
    copy[0].inspect
    # Ractor::MovedError (can not send any methods to a moved object)
    # ...but its item was still a reference to `s`, which was moved

If the object was shareable, `move: true` has no effect on it:

    r = Ractor.new {puts "Received: #{receive}"}
    s = 'message'.freeze
    r.send(s, move: true)
    s.inspect #=> "message", still available

;T;0;;;I"	send;F;I"Ractor;T;[o;;I""untyped obj, ?move: ::boolish;T;I"Ractor;To;;I"üTake a message from ractor's outgoing port, which was put there by
Ractor.yield or at ractor's finalization.

    r = Ractor.new do
      Ractor.yield 'explicit yield'
      'last value'
    end
    puts r.take #=> 'explicit yield'
    puts r.take #=> 'last value'
    puts r.take # Ractor::ClosedError (The outgoing-port is already closed)

The fact that the last value is also put to outgoing port means that `take`
can be used as some analog of Thread#join ("just wait till ractor finishes"),
but don't forget it will raise if somebody had already consumed everything
ractor have produced.

If the outgoing port was closed with #close_outgoing, the method will raise
Ractor::ClosedError.

    r = Ractor.new do
      sleep(500)
      Ractor.yield 'Hello from ractor'
    end
    r.close_outgoing
    r.take
    # Ractor::ClosedError (The outgoing-port is already closed)
    # The error would be raised immediately, not when ractor will try to receive

If an uncaught exception is raised in the Ractor, it is propagated on take as
a Ractor::RemoteError.

    r = Ractor.new {raise "Something weird happened"}

    begin
      r.take
    rescue => e
      p e              #  => #<Ractor::RemoteError: thrown by remote Ractor.>
      p e.ractor == r  # => true
      p e.cause        # => #<RuntimeError: Something weird happened>
    end

Ractor::ClosedError is a descendant of StopIteration, so the closing of the
ractor will break the loops without propagating the error:

    r = Ractor.new do
      3.times {|i| Ractor.yield "message #{i}"}
      "finishing"
    end

    loop {puts "Received: " + r.take}
    puts "Continue successfully"

This will print:

    Received: message 0
    Received: message 1
    Received: message 2
    Received: finishing
    Continue successfully

;T;0;;;I"	take;F;I"Ractor;T;[o;;I" ;F;I"untyped;To;;I"same as Ractor.receive

;T;0;;;I"receive;F;I"Ractor;T;[o;;I" ;F;I"untyped;To;;I" ;T;0;;;I"receive_if;F;I"Ractor;T;[o;;I" ;F;I"untyped;To; ;I"ERaised when an attempt is made to send a message to a closed port, or to
retrieve a message from a closed and empty port. Ports may be closed
explicitly with Ractor#close_outgoing/close_incoming and are closed implicitly
when a Ractor terminates.

    r = Ractor.new { sleep(500) }
    r.close_outgoing
    r.take # Ractor::ClosedError

ClosedError is a descendant of StopIteration, so the closing of the ractor
will break the loops without propagating the error:

    r = Ractor.new do
      loop do
        msg = receive # raises ClosedError and loop traps it
        puts "Received: #{msg}"
      end
      puts "loop exited"
    end

    3.times{|i| r << i}
    r.close_incoming
    r.take
    puts "Continue successfully"

This will print:

    Received: 0
    Received: 1
    Received: 2
    loop exited
    Continue successfully

;T;0;	I"Ractor::ClosedError;T;
[ ;[ ;0;[ ;[ ;0;I"StopIteration;To; ;0;0;	I"Ractor::Error;T;
[ ;[ ;0;[ ;[ ;0;I"RuntimeError;To; ;0;0;	I"Ractor::IsolationError;T;
[ ;[ ;0;[ ;[ ;0;I"Ractor::Error;To; ;I"ÿRaised on an attempt to access an object which was moved in Ractor#send or
Ractor.yield.

    r = Ractor.new { sleep }

    ary = [1, 2, 3]
    r.send(ary, move: true)
    ary.inspect
    # Ractor::MovedError (can not send any methods to a moved object)

;T;0;	I"Ractor::MovedError;T;
[ ;[ ;0;[ ;[ ;0;I"Ractor::Error;To; ;I"ƒA special object which replaces any value that was moved to another ractor in
Ractor#send or Ractor.yield. Any attempt to access the object results in
Ractor::MovedError.

    r = Ractor.new { receive }

    ary = [1, 2, 3]
    r.send(ary, move: true)
    p Ractor::MovedObject === ary
    # => true
    ary.inspect
    # Ractor::MovedError (can not send any methods to a moved object)

;T;0;	I"Ractor::MovedObject;T;
[ ;[ ;0;[ ;[ ;0;I"BasicObject;To;;I" ;T;0;;;I"!;F;I"Ractor::MovedObject;T;[o;;I"*untyped;T;I"untyped;To;;I" ;T;0;;;I"!=;F;I"Ractor::MovedObject;T;[o;;I"*untyped;T;I"untyped;To;;I" ;T;0;;;I"==;F;I"Ractor::MovedObject;T;[o;;I"*untyped;T;I"untyped;To;;I" ;T;0;;;I"__id__;F;I"Ractor::MovedObject;T;[o;;I"*untyped;T;I"untyped;To;;I" ;T;0;;;I"__send__;F;I"Ractor::MovedObject;T;[o;;I"*untyped;T;I"untyped;To;;I" ;T;0;;;I"equal?;F;I"Ractor::MovedObject;T;[o;;I"*untyped;T;I"untyped;To;;I" ;T;0;;;I"instance_eval;F;I"Ractor::MovedObject;T;[o;;I"*untyped;T;I"untyped;To;;I" ;T;0;;;I"instance_exec;F;I"Ractor::MovedObject;T;[o;;I"*untyped;T;I"untyped;To;;I" ;T;0;;;I"method_missing;F;I"Ractor::MovedObject;T;[o;;I"*untyped;T;I"untyped;To; ;I"ÕRaised on attempt to Ractor#take if there was an uncaught exception in the
Ractor. Its `cause` will contain the original exception, and `ractor` is the
original ractor it was raised in.

    r = Ractor.new { raise "Something weird happened" }

    begin
      r.take
    rescue => e
      p e             # => #<Ractor::RemoteError: thrown by remote Ractor.>
      p e.ractor == r # => true
      p e.cause       # => #<RuntimeError: Something weird happened>
    end

;T;0;	I"Ractor::RemoteError;T;
[ ;[ ;0;[ ;[ ;0;I"Ractor::Error;To;;0;0;;;I"ractor;F;I"Ractor::RemoteError;T;[o;;I" ;F;I"Ractor;To; ;0;0;	I"Ractor::UnsafeError;T;
[ ;[ ;0;[ ;[ ;0;I"Ractor::Error;To; ;I"úRandom provides an interface to Ruby's pseudo-random number generator, or
PRNG.  The PRNG produces a deterministic sequence of bits which approximate
true randomness. The sequence may be represented by integers, floats, or
binary strings.

The generator may be initialized with either a system-generated or
user-supplied seed value by using Random.srand.

The class method Random.rand provides the base functionality of Kernel.rand
along with better handling of floating point values. These are both interfaces
to the Ruby system PRNG.

Random.new will create a new PRNG with a state independent of the Ruby system
PRNG, allowing multiple generators with different seed values or sequence
positions to exist simultaneously. Random objects can be marshaled, allowing
sequences to be saved and resumed.

PRNGs are currently implemented as a modified Mersenne Twister with a period
of 2**19937-1.  As this algorithm is *not* for cryptographical use, you must
use SecureRandom for security purpose, instead of this PRNG.

;T;0;	I"Random;T;
[ ;[ ;0;[ ;[ ;0;I"RBS::Unnamed::Random_Base;To;;I"€Returns true if the two generators have the same internal state, otherwise
false.  Equivalent generators will return the same sequence of pseudo-random
numbers.  Two generators will generally have the same state only if they were
initialized with the same seed

    Random.new == Random.new             # => false
    Random.new(1234) == Random.new(1234) # => true

and have the same invocation history.

    prng1 = Random.new(1234)
    prng2 = Random.new(1234)
    prng1 == prng2 # => true

    prng1.rand     # => 0.1915194503788923
    prng1 == prng2 # => false

    prng2.rand     # => 0.1915194503788923
    prng1 == prng2 # => true

;T;0;;;I"==;F;I"Random;T;[o;;I"untyped arg0;T;I"	bool;To;;I"¯Returns an arbitrary seed value. This is used by Random.new when no seed value
is specified as an argument.

    Random.new_seed  #=> 115032730400174366788466674494640623225

;T;0;;;I"new_seed;F;I"Random;T;[o;;I" ;F;I"Integer;To;;I"QReturns a random number using the Ruby system PRNG.

See also Random#rand.

;T;0;;;I"	rand;F;I"Random;T;[o;;I" ;F;I"
Float;To;;I"'::Integer | ::Range[::Integer] max;T;I"Integer;To;;I"#::Float | ::Range[::Float] max;T;I"
Float;To;;I"tSeeds the system pseudo-random number generator, with `number`. The previous
seed value is returned.

If `number` is omitted, seeds the generator using a source of entropy provided
by the operating system, if available (/dev/urandom on Unix systems or the RSA
cryptographic provider on Windows), which is then combined with the time, the
process id, and a sequence number.

srand may be used to ensure repeatable sequences of pseudo-random numbers
between different runs of the program. By setting the seed to a known value,
programs can be made deterministic during testing.

    srand 1234               # => 268519324636777531569100071560086917274
    [ rand, rand ]           # => [0.1915194503788923, 0.6221087710398319]
    [ rand(10), rand(1000) ] # => [4, 664]
    srand 1234               # => 1234
    [ rand, rand ]           # => [0.1915194503788923, 0.6221087710398319]

;T;0;;;I"
srand;F;I"Random;T;[o;;I"?::Integer number;T;I"Integer;To; ;0;0;	I"Random::Base;T;
[ ;[ ;0;[ ;[ ;0;I"RBS::Unnamed::Random_Base;To;;I"5Generate a random number in the given range as Random does

    prng.random_number       #=> 0.5816771641321361
    prng.random_number(1000) #=> 485
    prng.random_number(1..6) #=> 3
    prng.rand                #=> 0.5816771641321361
    prng.rand(1000)          #=> 485
    prng.rand(1..6)          #=> 3

;T;0;	I"Random::Formatter;T;
[ ;[ ;0;[ ;[ o; ;I"ßA Range object represents a collection of values that are between given begin
and end values.

You can create an Range object explicitly with:

*   A [range literal](doc/syntax/literals_rdoc.html#label-Range+Literals):

        # Ranges that use '..' to include the given end value.
        (1..4).to_a      # => [1, 2, 3, 4]
        ('a'..'d').to_a  # => ["a", "b", "c", "d"]
        # Ranges that use '...' to exclude the given end value.
        (1...4).to_a     # => [1, 2, 3]
        ('a'...'d').to_a # => ["a", "b", "c"]


A range may be created using method Range.new:

    # Ranges that by default include the given end value.
    Range.new(1, 4).to_a     # => [1, 2, 3, 4]
    Range.new('a', 'd').to_a # => ["a", "b", "c", "d"]
    # Ranges that use third argument +exclude_end+ to exclude the given end value.
    Range.new(1, 4, true).to_a     # => [1, 2, 3]
    Range.new('a', 'd', true).to_a # => ["a", "b", "c"]

## Beginless Ranges

A *beginless* *range* has a definite end value, but a `nil` begin value. Such
a range includes all values up to the end value.

    r = (..4)               # => nil..4
    r.begin                 # => nil
    r.include?(-50)         # => true
    r.include?(4)           # => true

    r = (...4)              # => nil...4
    r.include?(4)           # => false

    Range.new(nil, 4)       # => nil..4
    Range.new(nil, 4, true) # => nil...4

A beginless range may be used to slice an array:

    a = [1, 2, 3, 4]
    r = (..2) # => nil...2
    a[r]      # => [1, 2]

Method `each` for a beginless range raises an exception.

## Endless Ranges

An *endless* *range* has a definite begin value, but a `nil` end value. Such a
range includes all values from the begin value.

    r = (1..)         # => 1..
    r.end             # => nil
    r.include?(50)    # => true

    Range.new(1, nil) # => 1..

The literal for  an endless range may be written with either two dots or
three. The range has the same elements, either way. But note that the two are
not equal:

    r0 = (1..)           # => 1..
    r1 = (1...)          # => 1...
    r0.begin == r1.begin # => true
    r0.end == r1.end     # => true
    r0 == r1             # => false

An endless range may be used to slice an array:

    a = [1, 2, 3, 4]
    r = (2..) # => 2..
    a[r]      # => [3, 4]

Method `each` for an endless range calls the given block indefinitely:

    a = []
    r = (1..)
    r.each do |i|
      a.push(i) if i.even?
      break if i > 10
    end
    a # => [2, 4, 6, 8, 10]

## Ranges and Other Classes

An object may be put into a range if its class implements instance method
`<=>`. Ruby core classes that do so include Array, Complex, File::Stat, Float,
Integer, Kernel, Module, Numeric, Rational, String, Symbol, and Time.

Example:

    t0 = Time.now         # => 2021-09-19 09:22:48.4854986 -0500
    t1 = Time.now         # => 2021-09-19 09:22:56.0365079 -0500
    t2 = Time.now         # => 2021-09-19 09:23:08.5263283 -0500
    (t0..t2).include?(t1) # => true
    (t0..t1).include?(t2) # => false

A range can be iterated over only if its elements implement instance method
`succ`. Ruby core classes that do so include Integer, String, and Symbol (but
not the other classes mentioned above).

Iterator methods include:

*   In Range itself: #each, #step, and #%
*   Included from module Enumerable: #each_entry, #each_with_index,
    #each_with_object, #each_slice, #each_cons, and #reverse_each.


Example:

    a = []
    (1..4).each {|i| a.push(i) }
    a # => [1, 2, 3, 4]

## Ranges and User-Defined Classes

A user-defined class that is to be used in a range must implement instance
`<=>`; see [Integer#<=>](Integer.html#label-method-i-3C-3D-3E). To make
iteration available, it must also implement instance method `succ`; see
Integer#succ.

The class below implements both `<=>` and `succ`, and so can be used both to
construct ranges and to iterate over them. Note that the Comparable module is
included so the `==` method is defined in terms of `<=>`.

    # Represent a string of 'X' characters.
    class Xs
      include Comparable
      attr_accessor :length
      def initialize(n)
        @length = n
      end
      def succ
        Xs.new(@length + 1)
      end
      def <=>(other)
        @length <=> other.length
      end
      def to_s
        sprintf "%2d #{inspect}", @length
      end
      def inspect
        'X' * @length
      end
    end

    r = Xs.new(3)..Xs.new(6) #=> XXX..XXXXXX
    r.to_a                   #=> [XXX, XXXX, XXXXX, XXXXXX]
    r.include?(Xs.new(5))    #=> true
    r.include?(Xs.new(7))    #=> false

## What's Here

First, what's elsewhere. Class Range:

*   Inherits from [class
    Object](Object.html#class-Object-label-What-27s+Here).
*   Includes [module
    Enumerable](Enumerable.html#module-Enumerable-label-What-27s+Here), which
    provides dozens of additional methods.


Here, class Range provides methods that are useful for:

*   [Creating a Range](#class-Range-label-Methods+for+Creating+a+Range)
*   [Querying](#class-Range-label-Methods+for+Querying)
*   [Comparing](#class-Range-label-Methods+for+Comparing)
*   [Iterating](#class-Range-label-Methods+for+Iterating)
*   [Converting](#class-Range-label-Methods+for+Converting)


### Methods for Creating a Range

    ::new
:       Returns a new range.



### Methods for Querying

    #begin
:       Returns the begin value given for `self`.

    #bsearch
:       Returns an element from `self` selected by a binary search.

    #count
:       Returns a count of elements in `self`.

    #end
:       Returns the end value given for `self`.

    #exclude_end?
:       Returns whether the end object is excluded.

    #first
:       Returns the first elements of `self`.

    #hash
:       Returns the integer hash code.

    #last
:       Returns the last elements of `self`.

    #max
:       Returns the maximum values in `self`.

    #min
:       Returns the minimum values in `self`.

    #minmax
:       Returns the minimum and maximum values in `self`.

    #size
:       Returns the count of elements in `self`.



### Methods for Comparing

    [#==](#method-i-3D-3D)
:       Returns whether a given object is equal to `self` (uses #==).

    #===
:       Returns whether the given object is between the begin and end values.

    #cover?
:       Returns whether a given object is within `self`.

    #eql?
:       Returns whether a given object is equal to `self` (uses #eql?).

    #include? (aliased as #member?)
:       Returns whether a given object is an element of `self`.



### Methods for Iterating

    #%
:       Requires argument `n`; calls the block with each `n`-th element of
        `self`.

    #each
:       Calls the block with each element of `self`.

    #step
:       Takes optional argument `n` (defaults to 1); calls the block with each
        `n`-th element of `self`.



### Methods for Converting

    #inspect
:       Returns a string representation of `self` (uses #inspect).

    #to_a (aliased as #entries)
:       Returns elements of `self` in an array.

    #to_s
:       Returns a string representation of `self` (uses #to_s).

;T;0;	I"
Range;T;
[ ;[I"Enumerable;T;0;[ ;[ ;0;I"Object;To;;I"›Returns `true` if and only if:

*   `other` is a range.
*   `other.begin == self.begin`.
*   `other.end == self.end`.
*   `other.exclude_end? == self.exclude_end?`.


Otherwise returns `false`.

    r = (1..5)
    r == (1..5)                # => true
    r = Range.new(1, 5)
    r == 'foo'                 # => false
    r == (2..5)                # => false
    r == (1..4)                # => false
    r == (1...5)               # => false
    r == Range.new(1, 5, true) # => false

Note that even with the same argument, the return values of #== and #eql? can
differ:

    (1..2) == (1..2.0)   # => true
    (1..2).eql? (1..2.0) # => false

Related: Range#eql?.

;T;0;;;I"==;F;I"
Range;T;[o;;I"untyped obj;T;I"	bool;To;;I"¨Returns `true` if `object` is between `self.begin` and `self.end`. `false`
otherwise:

    (1..4) === 2       # => true
    (1..4) === 5       # => false
    (1..4) === 'a'     # => false
    (1..4) === 4       # => true
    (1...4) === 4      # => false
    ('a'..'d') === 'c' # => true
    ('a'..'d') === 'e' # => false

A case statement uses method `===`, and so:

    case 79
    when (1..50)
      "low"
    when (51..75)
      "medium"
    when (76..100)
      "high"
    end # => "high"

    case "2.6.5"
    when ..."2.4"
      "EOL"
    when "2.4"..."2.5"
      "maintenance"
    when "2.5"..."3.0"
      "stable"
    when "3.1"..
      "upcoming"
    end # => "stable"

;T;0;;;I"===;F;I"
Range;T;[o;;I"untyped obj;T;I"	bool;To;;I"Returns the object that defines the beginning of `self`.

    (1..4).begin # => 1
    (..2).begin  # => nil

Related: Range#first, Range#end.

;T;0;;;I"
begin;F;I"
Range;T;[o;;I" ;F;I"	Elem;Fo;;I"rReturns an element from `self` selected by a binary search.

See [Binary Searching](rdoc-ref:bsearch.rdoc).

;T;0;;;I"bsearch;F;I"
Range;T;[o;;I" ;F;I"Enumerator[Elem, Elem?];To;;I" ;F;I"
Elem?;To;;I" ;F;I"
Elem?;To;;I"lReturns `true` if the given argument is within `self`, `false` otherwise.

With non-range argument `object`, evaluates with `<=` and `<`.

For range `self` with included end value (`#exclude_end? == false`), evaluates
thus:

    self.begin <= object <= self.end

Examples:

    r = (1..4)
    r.cover?(1)     # => true
    r.cover?(4)     # => true
    r.cover?(0)     # => false
    r.cover?(5)     # => false
    r.cover?('foo') # => false

    r = ('a'..'d')
    r.cover?('a')     # => true
    r.cover?('d')     # => true
    r.cover?(' ')     # => false
    r.cover?('e')     # => false
    r.cover?(0)       # => false

For range `r` with excluded end value (`#exclude_end? == true`), evaluates
thus:

    r.begin <= object < r.end

Examples:

    r = (1...4)
    r.cover?(1)     # => true
    r.cover?(3)     # => true
    r.cover?(0)     # => false
    r.cover?(4)     # => false
    r.cover?('foo') # => false

    r = ('a'...'d')
    r.cover?('a')     # => true
    r.cover?('c')     # => true
    r.cover?(' ')     # => false
    r.cover?('d')     # => false
    r.cover?(0)       # => false

With range argument `range`, compares the first and last elements of `self`
and `range`:

    r = (1..4)
    r.cover?(1..4)     # => true
    r.cover?(0..4)     # => false
    r.cover?(1..5)     # => false
    r.cover?('a'..'d') # => false

    r = (1...4)
    r.cover?(1..3)     # => true
    r.cover?(1..4)     # => false

If begin and end are numeric, #cover? behaves like #include?

    (1..3).cover?(1.5) # => true
    (1..3).include?(1.5) # => true

But when not numeric, the two methods may differ:

    ('a'..'d').cover?('cc')   # => true
    ('a'..'d').include?('cc') # => false

Returns `false` if either:

*   The begin value of `self` is larger than its end value.
*   An internal call to `<=>` returns `nil`; that is, the operands are not
    comparable.


Related: Range#include?.

;T;0;;;I"cover?;F;I"
Range;T;[o;;I"untyped obj;T;I"	bool;To;;I"With a block given, passes each element of `self` to the block:

    a = []
    (1..4).each {|element| a.push(element) } # => 1..4
    a # => [1, 2, 3, 4]

Raises an exception unless `self.first.respond_to?(:succ)`.

With no block given, returns an enumerator.

;T;0;;;I"	each;F;I"
Range;T;[o;;I" ;F;I"	self;To;;I" ;F;I"Enumerator[Elem, self];To;;I"ŸReturns the object that defines the end of `self`.

    (1..4).end  # => 4
    (1...4).end # => 4
    (1..).end   # => nil

Related: Range#begin, Range#last.

;T;0;;;I"end;F;I"
Range;T;[o;;I" ;F;I"	Elem;Fo;;I"Returns `true` if `self` excludes its end value; `false` otherwise:

    Range.new(2, 5).exclude_end?       # => false
    Range.new(2, 5, true).exclude_end? # => true
    (2..5).exclude_end?                # => false
    (2...5).exclude_end?               # => true

;T;0;;;I"exclude_end?;F;I"
Range;T;[o;;I" ;F;I"	bool;To;;I"With no argument, returns the first element of `self`, if it exists:

    (1..4).first     # => 1
    ('a'..'d').first # => "a"

With non-negative integer argument `n` given, returns the first `n` elements
in an array:

    (1..10).first(3) # => [1, 2, 3]
    (1..10).first(0) # => []
    (1..4).first(50) # => [1, 2, 3, 4]

Raises an exception if there is no first element:

    (..4).first # Raises RangeError

;T;0;;;I"
first;F;I"
Range;T;[o;;I" ;F;I"	Elem;Fo;;I"::Integer n;T;I"Array[Elem];To;;I"¦Returns the integer hash value for `self`. Two range objects `r0` and `r1`
have the same hash value if and only if `r0.eql?(r1)`.

Related: Range#eql?, Object#hash.

;T;0;;;I"	hash;F;I"
Range;T;[o;;I" ;F;I"Integer;To;;I"Returns `true` if `object` is an element of `self`, `false` otherwise:

    (1..4).include?(2)        # => true
    (1..4).include?(5)        # => false
    (1..4).include?(4)        # => true
    (1...4).include?(4)       # => false
    ('a'..'d').include?('b')  # => true
    ('a'..'d').include?('e')  # => false
    ('a'..'d').include?('B')  # => false
    ('a'..'d').include?('d')  # => true
    ('a'...'d').include?('d') # => false

If begin and end are numeric, #include? behaves like #cover?

    (1..3).include?(1.5) # => true
    (1..3).cover?(1.5) # => true

But when not numeric, the two methods may differ:

    ('a'..'d').include?('cc') # => false
    ('a'..'d').cover?('cc')   # => true

Related: Range#cover?.

Range#member? is an alias for Range#include?.

;T;0;;;I"include?;F;I"
Range;T;[o;;I"untyped obj;T;I"	bool;To;;I"‘Returns a new range based on the given objects `begin` and `end`. Optional
argument `exclude_end` determines whether object `end` is included as the last
object in the range:

    Range.new(2, 5).to_a            # => [2, 3, 4, 5]
    Range.new(2, 5, true).to_a      # => [2, 3, 4]
    Range.new('a', 'd').to_a        # => ["a", "b", "c", "d"]
    Range.new('a', 'd', true).to_a  # => ["a", "b", "c"]

;T;0;;;I"initialize;F;I"
Range;T;[o;;I"/Elem from, Elem to, ?::boolish exclude_end;T;I"	void;To;;I"uReturns a string representation of `self`, including `begin.inspect` and
`end.inspect`:

    (1..4).inspect  # => "1..4"
    (1...4).inspect # => "1...4"
    (1..).inspect   # => "1.."
    (..4).inspect   # => "..4"

Note that returns from #to_s and #inspect may differ:

    ('a'..'d').to_s    # => "a..d"
    ('a'..'d').inspect # => "\"a\"..\"d\""

Related: Range#to_s.

;T;0;;;I"inspect;F;I"
Range;T;[o;;I" ;F;I"String;To;;I"ñWith no argument, returns the last element of `self`, if it exists:

    (1..4).last     # => 4
    ('a'..'d').last # => "d"

Note that `last` with no argument returns the end element of `self` even if
#exclude_end? is `true`:

    (1...4).last     # => 4
    ('a'...'d').last # => "d"

With non-negative integer argument `n` given, returns the last `n` elements in
an array:

    (1..10).last(3) # => [8, 9, 10]
    (1..10).last(0) # => []
    (1..4).last(50) # => [1, 2, 3, 4]

Note that `last` with argument does not return the end element of `self` if
#exclude_end? it `true`:

    (1...4).last(3)     # => [1, 2, 3]
    ('a'...'d').last(3) # => ["a", "b", "c"]

Raises an exception if there is no last element:

    (1..).last # Raises RangeError

;T;0;;;I"	last;F;I"
Range;T;[o;;I" ;F;I"	Elem;Fo;;I"::Integer n;T;I"Array[Elem];To;;I"6Returns the maximum value in `self`, using method `<=>` or a given block for
comparison.

With no argument and no block given, returns the maximum-valued element of
`self`.

    (1..4).max     # => 4
    ('a'..'d').max # => "d"
    (-4..-1).max   # => -1

With non-negative integer argument `n` given, and no block given, returns the
`n` maximum-valued elements of `self` in an array:

    (1..4).max(2)     # => [4, 3]
    ('a'..'d').max(2) # => ["d", "c"]
    (-4..-1).max(2)   # => [-1, -2]
    (1..4).max(50)    # => [4, 3, 2, 1]

If a block is given, it is called:

*   First, with the first two element of `self`.
*   Then, sequentially, with the so-far maximum value and the next element of
    `self`.


To illustrate:

    (1..4).max {|a, b| p [a, b]; a <=> b } # => 4

Output:

    [2, 1]
    [3, 2]
    [4, 3]

With no argument and a block given, returns the return value of the last call
to the block:

    (1..4).max {|a, b| -(a <=> b) } # => 1

With non-negative integer argument `n` given, and a block given, returns the
return values of the last `n` calls to the block in an array:

    (1..4).max(2) {|a, b| -(a <=> b) }  # => [1, 2]
    (1..4).max(50) {|a, b| -(a <=> b) } # => [1, 2, 3, 4]

Returns an empty array if `n` is zero:

    (1..4).max(0)                      # => []
    (1..4).max(0) {|a, b| -(a <=> b) } # => []

Returns `nil` or an empty array if:

*   The begin value of the range is larger than the end value:

        (4..1).max                         # => nil
        (4..1).max(2)                      # => []
        (4..1).max {|a, b| -(a <=> b) }    # => nil
        (4..1).max(2) {|a, b| -(a <=> b) } # => []

*   The begin value of an exclusive range is equal to the end value:

        (1...1).max                          # => nil
        (1...1).max(2)                       # => []
        (1...1).max  {|a, b| -(a <=> b) }    # => nil
        (1...1).max(2)  {|a, b| -(a <=> b) } # => []


Raises an exception if either:

*   `self` is a endless range: `(1..)`.
*   A block is given and `self` is a beginless range.


Related: Range#min, Range#minmax.

;T;0;;;I"max;F;I"
Range;T;[	o;;I" ;F;I"	Elem;Fo;;I" ;F;I"	Elem;Fo;;I"::Integer n;T;I"Array[Elem];To;;I"::Integer n;T;I"Array[Elem];To;;I"7Returns the minimum value in `self`, using method `<=>` or a given block for
comparison.

With no argument and no block given, returns the minimum-valued element of
`self`.

    (1..4).min     # => 1
    ('a'..'d').min # => "a"
    (-4..-1).min   # => -4

With non-negative integer argument `n` given, and no block given, returns the
`n` minimum-valued elements of `self` in an array:

    (1..4).min(2)     # => [1, 2]
    ('a'..'d').min(2) # => ["a", "b"]
    (-4..-1).min(2)   # => [-4, -3]
    (1..4).min(50)    # => [1, 2, 3, 4]

If a block is given, it is called:

*   First, with the first two element of `self`.
*   Then, sequentially, with the so-far minimum value and the next element of
    `self`.


To illustrate:

    (1..4).min {|a, b| p [a, b]; a <=> b } # => 1

Output:

    [2, 1]
    [3, 1]
    [4, 1]

With no argument and a block given, returns the return value of the last call
to the block:

    (1..4).min {|a, b| -(a <=> b) } # => 4

With non-negative integer argument `n` given, and a block given, returns the
return values of the last `n` calls to the block in an array:

    (1..4).min(2) {|a, b| -(a <=> b) }  # => [4, 3]
    (1..4).min(50) {|a, b| -(a <=> b) } # => [4, 3, 2, 1]

Returns an empty array if `n` is zero:

    (1..4).min(0)                      # => []
    (1..4).min(0) {|a, b| -(a <=> b) } # => []

Returns `nil` or an empty array if:

*   The begin value of the range is larger than the end value:

        (4..1).min                         # => nil
        (4..1).min(2)                      # => []
        (4..1).min {|a, b| -(a <=> b) }    # => nil
        (4..1).min(2) {|a, b| -(a <=> b) } # => []

*   The begin value of an exclusive range is equal to the end value:

        (1...1).min                          # => nil
        (1...1).min(2)                       # => []
        (1...1).min  {|a, b| -(a <=> b) }    # => nil
        (1...1).min(2)  {|a, b| -(a <=> b) } # => []


Raises an exception if either:

*   `self` is a beginless range: `(..4)`.
*   A block is given and `self` is an endless range.


Related: Range#max, Range#minmax.

;T;0;;;I"min;F;I"
Range;T;[	o;;I" ;F;I"	Elem;Fo;;I" ;F;I"	Elem;Fo;;I"::Integer n;T;I"Array[Elem];To;;I"::Integer n;T;I"Array[Elem];To;;I"ýReturns the count of elements in `self` if both begin and end values are
numeric; otherwise, returns `nil`:

    (1..4).size      # => 4
    (1...4).size     # => 3
    (1..).size       # => Infinity
    ('a'..'z').size  #=> nil

Related: Range#count.

;T;0;;;I"	size;F;I"
Range;T;[o;;I" ;F;I"Integer?;To;;I" ;F;I"Float?;To;;I"ÞIterates over the elements of `self`.

With a block given and no argument, calls the block each element of the range;
returns `self`:

    a = []
    (1..5).step {|element| a.push(element) } # => 1..5
    a # => [1, 2, 3, 4, 5]
    a = []
    ('a'..'e').step {|element| a.push(element) } # => "a".."e"
    a # => ["a", "b", "c", "d", "e"]

With a block given and a positive integer argument `n` given, calls the block
with element `0`, element `n`, element `2n`, and so on:

    a = []
    (1..5).step(2) {|element| a.push(element) } # => 1..5
    a # => [1, 3, 5]
    a = []
    ('a'..'e').step(2) {|element| a.push(element) } # => "a".."e"
    a # => ["a", "c", "e"]

With no block given, returns an enumerator, which will be of class
Enumerator::ArithmeticSequence if `self` is numeric; otherwise of class
Enumerator:

    e = (1..5).step(2) # => ((1..5).step(2))
    e.class            # => Enumerator::ArithmeticSequence
    ('a'..'e').step # => #<Enumerator: ...>

Related: Range#%.

;T;0;;;I"	step;F;I"
Range;T;[o;;I"?::Integer n;T;I"	self;To;;I"?::Integer n;T;I"Enumerator[Elem, void];To;;I"fReturns a string representation of `self`, including `begin.to_s` and
`end.to_s`:

    (1..4).to_s  # => "1..4"
    (1...4).to_s # => "1...4"
    (1..).to_s   # => "1.."
    (..4).to_s   # => "..4"

Note that returns from #to_s and #inspect may differ:

    ('a'..'d').to_s    # => "a..d"
    ('a'..'d').inspect # => "\"a\"..\"d\""

Related: Range#inspect.

;T;0;;;I"	to_s;F;I"
Range;T;[o;;I" ;F;I"String;To;;I"¯Returns `true` if and only if:

*   `other` is a range.
*   `other.begin eql? self.begin`.
*   `other.end eql? self.end`.
*   `other.exclude_end? == self.exclude_end?`.


Otherwise returns `false`.

    r = (1..5)
    r.eql?(1..5)                  # => true
    r = Range.new(1, 5)
    r.eql?('foo')                 # => false
    r.eql?(2..5)                  # => false
    r.eql?(1..4)                  # => false
    r.eql?(1...5)                 # => false
    r.eql?(Range.new(1, 5, true)) # => false

Note that even with the same argument, the return values of #== and #eql? can
differ:

    (1..2) == (1..2.0)   # => true
    (1..2).eql? (1..2.0) # => false

Related: Range#==.

;T;0;;;I"	eql?;F;I"
Range;T;[o;;I"untyped obj;T;I"	bool;To;;I"Returns `true` if `object` is an element of `self`, `false` otherwise:

    (1..4).include?(2)        # => true
    (1..4).include?(5)        # => false
    (1..4).include?(4)        # => true
    (1...4).include?(4)       # => false
    ('a'..'d').include?('b')  # => true
    ('a'..'d').include?('e')  # => false
    ('a'..'d').include?('B')  # => false
    ('a'..'d').include?('d')  # => true
    ('a'...'d').include?('d') # => false

If begin and end are numeric, #include? behaves like #cover?

    (1..3).include?(1.5) # => true
    (1..3).cover?(1.5) # => true

But when not numeric, the two methods may differ:

    ('a'..'d').include?('cc') # => false
    ('a'..'d').cover?('cc')   # => true

Related: Range#cover?.

Range#member? is an alias for Range#include?.

;T;0;;;I"member?;F;I"
Range;T;[o;;I"untyped obj;T;I"	bool;To; ;0;0;	I"
Range;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"lDeserializes JSON string by constructing new Range object with arguments `a`
serialized by `to_json`.

;T;0;;;I"json_create;F;I"
Range;T;[o;;I"7::Hash[::String, ::String | [ A, A, bool ]] object;T;I"Range[A];To;;I"XReturns a hash, that will be turned into a JSON object and represent this
object.

;T;0;;;I"as_json;F;I"
Range;T;[o;;I"*untyped;T;I"4Hash[::String, ::String | [ Elem, Elem, bool ]];To;;I"œStores class name (Range) with JSON array of arguments `a` which include
`first` (integer), `last` (integer), and `exclude_end?` (boolean) as JSON
string.

;T;0;;;I"to_json;F;I"
Range;T;[o;;I"?::JSON::State state;T;I"String;To; ;I"çA rational number can be represented as a pair of integer numbers: a/b (b>0),
where a is the numerator and b is the denominator. Integer a equals rational
a/1 mathematically.

You can create a Rational object explicitly with:

*   A [rational
    literal](doc/syntax/literals_rdoc.html#label-Rational+Literals).


You can convert certain objects to Rationals with:

*   Method [Rational](Kernel.html#method-i-Rational).


Examples

    Rational(1)      #=> (1/1)
    Rational(2, 3)   #=> (2/3)
    Rational(4, -6)  #=> (-2/3) # Reduced.
    3.to_r           #=> (3/1)
    2/3r             #=> (2/3)

You can also create rational objects from floating-point numbers or strings.

    Rational(0.3)    #=> (5404319552844595/18014398509481984)
    Rational('0.3')  #=> (3/10)
    Rational('2/3')  #=> (2/3)

    0.3.to_r         #=> (5404319552844595/18014398509481984)
    '0.3'.to_r       #=> (3/10)
    '2/3'.to_r       #=> (2/3)
    0.3.rationalize  #=> (3/10)

A rational object is an exact number, which helps you to write programs
without any rounding errors.

    10.times.inject(0) {|t| t + 0.1 }              #=> 0.9999999999999999
    10.times.inject(0) {|t| t + Rational('0.1') }  #=> (1/1)

However, when an expression includes an inexact component (numerical value or
operation), it will produce an inexact result.

    Rational(10) / 3   #=> (10/3)
    Rational(10) / 3.0 #=> 3.3333333333333335

    Rational(-8) ** Rational(1, 3)
                       #=> (1.0000000000000002+1.7320508075688772i)

;T;0;	I"Rational;T;
[ ;[ ;0;[ ;[ ;0;I"Numeric;To;;0;0;;;I"%;F;I"Rational;T;[	o;;I"::Integer;T;I"Rational;To;;I"::Float;T;I"
Float;To;;I"::Rational;T;I"Rational;To;;I"::Numeric;T;I"Numeric;To;;I"Performs multiplication.

    Rational(2, 3)  * Rational(2, 3)   #=> (4/9)
    Rational(900)   * Rational(1)      #=> (900/1)
    Rational(-2, 9) * Rational(-9, 2)  #=> (1/1)
    Rational(9, 8)  * 4                #=> (9/2)
    Rational(20, 9) * 9.8              #=> 21.77777777777778

;T;0;;;I"*;F;I"Rational;T;[o;;I"::Integer;T;I"Rational;To;;I"::Rational;T;I"Rational;To;;I"T;T;I"T;Fo;;I"?Performs exponentiation.

    Rational(2)    ** Rational(3)     #=> (8/1)
    Rational(10)   ** -2              #=> (1/100)
    Rational(10)   ** -2.0            #=> 0.01
    Rational(-4)   ** Rational(1, 2)  #=> (0.0+2.0i)
    Rational(1, 2) ** 0               #=> (1/1)
    Rational(1, 2) ** 0.0             #=> 1.0

;T;0;;;I"**;F;I"Rational;T;[o;;I"::Complex;T;I"Complex;To;;I"::Numeric;T;I"Numeric;To;;I"Performs addition.

    Rational(2, 3)  + Rational(2, 3)   #=> (4/3)
    Rational(900)   + Rational(1)      #=> (901/1)
    Rational(-2, 9) + Rational(-9, 2)  #=> (-85/18)
    Rational(9, 8)  + 4                #=> (41/8)
    Rational(20, 9) + 9.8              #=> 12.022222222222222

;T;0;;;I"+;F;I"Rational;T;[o;;I"::Float;T;I"
Float;To;;I"::Complex;T;I"Complex;To;;I"::Numeric;T;I"Rational;To;;0;0;;;I"+@;F;I"Rational;T;[o;;I" ;F;I"Rational;To;;I" Performs subtraction.

    Rational(2, 3)  - Rational(2, 3)   #=> (0/1)
    Rational(900)   - Rational(1)      #=> (899/1)
    Rational(-2, 9) - Rational(-9, 2)  #=> (77/18)
    Rational(9, 8)  - 4                #=> (-23/8)
    Rational(20, 9) - 9.8              #=> -7.577777777777778

;T;0;;;I"-;F;I"Rational;T;[o;;I"::Float;T;I"
Float;To;;I"::Complex;T;I"Complex;To;;I"::Numeric;T;I"Rational;To;;I"Negates `rat`.

;T;0;;;I"-@;F;I"Rational;T;[o;;I" ;F;I"Rational;To;;I"Performs division.

    Rational(2, 3)  / Rational(2, 3)   #=> (1/1)
    Rational(900)   / Rational(1)      #=> (900/1)
    Rational(-2, 9) / Rational(-9, 2)  #=> (4/81)
    Rational(9, 8)  / 4                #=> (9/32)
    Rational(20, 9) / 9.8              #=> 0.22675736961451246

;T;0;;;I"/;F;I"Rational;T;[o;;I"::Float;T;I"
Float;To;;I"::Complex;T;I"Complex;To;;I"::Numeric;T;I"Rational;To;;I"³Returns -1, 0, or +1 depending on whether `rational` is less than, equal to,
or greater than `numeric`.

`nil` is returned if the two values are incomparable.

    Rational(2, 3) <=> Rational(2, 3)  #=> 0
    Rational(5)    <=> 5               #=> 0
    Rational(2, 3) <=> Rational(1, 3)  #=> 1
    Rational(1, 3) <=> 1               #=> -1
    Rational(1, 3) <=> 0.3             #=> 1

    Rational(1, 3) <=> "0.3"           #=> nil

;T;0;;;I"<=>;F;I"Rational;T;[o;;I"::Integer | ::Rational;T;I"Integer;To;;I"untyped;T;I"Integer?;To;;I".Returns `true` if `rat` equals `object` numerically.

    Rational(2, 3)  == Rational(2, 3)   #=> true
    Rational(5)     == 5                #=> true
    Rational(0)     == 0.0              #=> true
    Rational('1/3') == 0.33             #=> false
    Rational('1/2') == '1/2'            #=> false

;T;0;;;I"==;F;I"Rational;T;[o;;I"untyped;T;I"	bool;To;;I"‘Returns the absolute value of `rat`.

    (1/2r).abs    #=> (1/2)
    (-1/2r).abs   #=> (1/2)

Rational#magnitude is an alias for Rational#abs.

;T;0;;;I"abs;F;I"Rational;T;[o;;I" ;F;I"Rational;To;;0;0;;;I"	abs2;F;I"Rational;T;[o;;I" ;F;I"Rational;To;;0;0;;;I"
angle;F;I"Rational;T;[o;;I" ;F;I"Integer | ::Float;To;;I"€Returns the smallest number greater than or equal to `rat` with a precision of
`ndigits` decimal digits (default: 0).

When the precision is negative, the returned value is an integer with at least
`ndigits.abs` trailing zeros.

Returns a rational when `ndigits` is positive, otherwise returns an integer.

    Rational(3).ceil      #=> 3
    Rational(2, 3).ceil   #=> 1
    Rational(-3, 2).ceil  #=> -1

      #    decimal      -  1  2  3 . 4  5  6
      #                   ^  ^  ^  ^   ^  ^
      #   precision      -3 -2 -1  0  +1 +2

    Rational('-123.456').ceil(+1).to_f  #=> -123.4
    Rational('-123.456').ceil(-1)       #=> -120

;T;0;;;I"	ceil;F;I"Rational;T;[o;;I" ;F;I"Integer;To;;I"::Integer digits;T;I"Integer | ::Rational;To;;0;0;;;I"coerce;F;I"Rational;T;[o;;I"::Numeric;T;I"[ ::Numeric, ::Numeric ];To;;0;0;;;I"	conj;F;I"Rational;T;[o;;I" ;F;I"Rational;To;;0;0;;;I"conjugate;F;I"Rational;T;[o;;I" ;F;I"Rational;To;;I"åReturns the denominator (always positive).

    Rational(7).denominator             #=> 1
    Rational(7, 1).denominator          #=> 1
    Rational(9, -4).denominator         #=> 4
    Rational(-2, -10).denominator       #=> 5

;T;0;;;I"denominator;F;I"Rational;T;[o;;I" ;F;I"Integer;To;;0;0;;;I"div;F;I"Rational;T;[o;;I"::Numeric;T;I"Integer;To;;0;0;;;I"divmod;F;I"Rational;T;[o;;I"::Numeric;T;I"[ ::Numeric, ::Numeric ];To;;0;0;;;I"dup;F;I"Rational;T;[o;;I" ;F;I"	self;To;;0;0;;;I"	eql?;F;I"Rational;T;[o;;I"untyped;T;I"	bool;To;;I"ÞPerforms division and returns the value as a Float.

    Rational(2, 3).fdiv(1)       #=> 0.6666666666666666
    Rational(2, 3).fdiv(0.5)     #=> 1.3333333333333333
    Rational(2).fdiv(3)          #=> 0.6666666666666666

;T;0;;;I"	fdiv;F;I"Rational;T;[o;;I"::Numeric;T;I"
Float;To;;0;0;;;I"finite?;F;I"Rational;T;[o;;I" ;F;I"	bool;To;;I"Returns the largest number less than or equal to `rat` with a precision of
`ndigits` decimal digits (default: 0).

When the precision is negative, the returned value is an integer with at least
`ndigits.abs` trailing zeros.

Returns a rational when `ndigits` is positive, otherwise returns an integer.

    Rational(3).floor      #=> 3
    Rational(2, 3).floor   #=> 0
    Rational(-3, 2).floor  #=> -2

      #    decimal      -  1  2  3 . 4  5  6
      #                   ^  ^  ^  ^   ^  ^
      #   precision      -3 -2 -1  0  +1 +2

    Rational('-123.456').floor(+1).to_f  #=> -123.5
    Rational('-123.456').floor(-1)       #=> -130

;T;0;;;I"
floor;F;I"Rational;T;[o;;I" ;F;I"Integer;To;;I"::Integer digits;T;I"Integer | ::Rational;To;;I" ;T;0;;;I"	hash;F;I"Rational;T;[o;;I" ;F;I"Integer;To;;0;0;;;I"i;F;I"Rational;T;[o;;I" ;F;I"Complex;To;;0;0;;;I"	imag;F;I"Rational;T;[o;;I" ;F;I"Integer;To;;0;0;;;I"imaginary;F;I"Rational;T;[o;;I" ;F;I"Integer;To;;0;0;;;I"infinite?;F;I"Rational;T;[o;;I" ;F;I"Integer?;To;;I"¬Returns the value as a string for inspection.

    Rational(2).inspect      #=> "(2/1)"
    Rational(-8, 6).inspect  #=> "(-4/3)"
    Rational('1/2').inspect  #=> "(1/2)"

;T;0;;;I"inspect;F;I"Rational;T;[o;;I" ;F;I"String;To;;0;0;;;I"integer?;F;I"Rational;T;[o;;I" ;F;I"	bool;To;;0;0;;;I"modulo;F;I"Rational;T;[o;;I"::Float;T;I"
Float;To;;I"::Numeric;T;I"Rational;To;;I".Returns `true` if `rat` is less than 0.

;T;0;;;I"negative?;F;I"Rational;T;[o;;I" ;F;I"	bool;To;;0;0;;;I"nonzero?;F;I"Rational;T;[o;;I" ;F;I"
self?;To;;I"¶Returns the numerator.

    Rational(7).numerator        #=> 7
    Rational(7, 1).numerator     #=> 7
    Rational(9, -4).numerator    #=> -9
    Rational(-2, -10).numerator  #=> 1

;T;0;;;I"numerator;F;I"Rational;T;[o;;I" ;F;I"Integer;To;;0;0;;;I"
polar;F;I"Rational;T;[o;;I" ;F;I"([ ::Rational, ::Integer | ::Float ];To;;I"1Returns `true` if `rat` is greater than 0.

;T;0;;;I"positive?;F;I"Rational;T;[o;;I" ;F;I"	bool;To;;I"Performs division.

    Rational(2, 3)  / Rational(2, 3)   #=> (1/1)
    Rational(900)   / Rational(1)      #=> (900/1)
    Rational(-2, 9) / Rational(-9, 2)  #=> (4/81)
    Rational(9, 8)  / 4                #=> (9/32)
    Rational(20, 9) / 9.8              #=> 0.22675736961451246

;T;0;;;I"quo;F;I"Rational;T;[o;;I"::Float;T;I"
Float;To;;I"::Complex;T;I"Complex;To;;I"::Numeric;T;I"Rational;To;;I"JReturns a simpler approximation of the value if the optional argument `eps` is
given (rat-|eps| <= result <= rat+|eps|), self otherwise.

    r = Rational(5033165, 16777216)
    r.rationalize                    #=> (5033165/16777216)
    r.rationalize(Rational('0.01'))  #=> (3/10)
    r.rationalize(Rational('0.1'))   #=> (1/3)

;T;0;;;I"rationalize;F;I"Rational;T;[o;;I"?::Numeric eps;T;I"Rational;To;;0;0;;;I"	real;F;I"Rational;T;[o;;I" ;F;I"Rational;To;;0;0;;;I"
real?;F;I"Rational;T;[o;;I" ;F;I"	true;Fo;;0;0;;;I"	rect;F;I"Rational;T;[o;;I" ;F;I"[ ::Rational, ::Numeric ];To;;0;0;;;I"remainder;F;I"Rational;T;[o;;I"::Float;T;I"
Float;To;;I"::Numeric;T;I"Rational;To;;I"¶Returns `rat` rounded to the nearest value with a precision of `ndigits`
decimal digits (default: 0).

When the precision is negative, the returned value is an integer with at least
`ndigits.abs` trailing zeros.

Returns a rational when `ndigits` is positive, otherwise returns an integer.

    Rational(3).round      #=> 3
    Rational(2, 3).round   #=> 1
    Rational(-3, 2).round  #=> -2

      #    decimal      -  1  2  3 . 4  5  6
      #                   ^  ^  ^  ^   ^  ^
      #   precision      -3 -2 -1  0  +1 +2

    Rational('-123.456').round(+1).to_f  #=> -123.5
    Rational('-123.456').round(-1)       #=> -120

The optional `half` keyword argument is available similar to Float#round.

    Rational(25, 100).round(1, half: :up)    #=> (3/10)
    Rational(25, 100).round(1, half: :down)  #=> (1/5)
    Rational(25, 100).round(1, half: :even)  #=> (1/5)
    Rational(35, 100).round(1, half: :up)    #=> (2/5)
    Rational(35, 100).round(1, half: :down)  #=> (3/10)
    Rational(35, 100).round(1, half: :even)  #=> (2/5)
    Rational(-25, 100).round(1, half: :up)   #=> (-3/10)
    Rational(-25, 100).round(1, half: :down) #=> (-1/5)
    Rational(-25, 100).round(1, half: :even) #=> (-1/5)

;T;0;;;I"
round;F;I"Rational;T;[o;;I"?half: :up | :down | :even;T;I"Integer;To;;I"1::Integer digits, ?half: :up | :down | :even;T;I"Integer | ::Rational;To;;0;0;;;I"	step;F;I"Rational;T;[	o;;I"&?::Numeric limit, ?::Numeric step;T;I"	self;To;;I"&?::Numeric limit, ?::Numeric step;T;I"!Enumerator[::Rational, self];To;;I"#?by: ::Numeric, ?to: ::Numeric;T;I"	self;To;;I"#?by: ::Numeric, ?to: ::Numeric;T;I"!Enumerator[::Rational, self];To;;0;0;;;I"	to_c;F;I"Rational;T;[o;;I" ;F;I"Complex;To;;I"¹Returns the value as a Float.

    Rational(2).to_f      #=> 2.0
    Rational(9, 4).to_f   #=> 2.25
    Rational(-3, 4).to_f  #=> -0.75
    Rational(20, 3).to_f  #=> 6.666666666666667

;T;0;;;I"	to_f;F;I"Rational;T;[o;;I" ;F;I"
Float;To;;I"øReturns the truncated value as an integer.

Equivalent to Rational#truncate.

    Rational(2, 3).to_i    #=> 0
    Rational(3).to_i       #=> 3
    Rational(300.6).to_i   #=> 300
    Rational(98, 71).to_i  #=> 1
    Rational(-31, 2).to_i  #=> -15

;T;0;;;I"	to_i;F;I"Rational;T;[o;;I" ;F;I"Integer;To;;I"^Returns self.

    Rational(2).to_r      #=> (2/1)
    Rational(-8, 6).to_r  #=> (-4/3)

;T;0;;;I"	to_r;F;I"Rational;T;[o;;I" ;F;I"Rational;To;;I"ŽReturns the value as a string.

    Rational(2).to_s      #=> "2/1"
    Rational(-8, 6).to_s  #=> "-4/3"
    Rational('1/2').to_s  #=> "1/2"

;T;0;;;I"	to_s;F;I"Rational;T;[o;;I" ;F;I"String;To;;I"}Returns `rat` truncated (toward zero) to a precision of `ndigits` decimal
digits (default: 0).

When the precision is negative, the returned value is an integer with at least
`ndigits.abs` trailing zeros.

Returns a rational when `ndigits` is positive, otherwise returns an integer.

    Rational(3).truncate      #=> 3
    Rational(2, 3).truncate   #=> 0
    Rational(-3, 2).truncate  #=> -1

      #    decimal      -  1  2  3 . 4  5  6
      #                   ^  ^  ^  ^   ^  ^
      #   precision      -3 -2 -1  0  +1 +2

    Rational('-123.456').truncate(+1).to_f  #=> -123.4
    Rational('-123.456').truncate(-1)       #=> -120

;T;0;;;I"truncate;F;I"Rational;T;[o;;I" ;F;I"Integer;To;;I"::Integer ndigits;T;I"Integer | ::Rational;To;;0;0;;;I"
zero?;F;I"Rational;T;[o;;I" ;F;I"	bool;To; ;0;0;	I"Rational;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"Returns the value as a BigDecimal.

The required `precision` parameter is used to determine the number of
significant digits for the result.

    require 'bigdecimal'
    require 'bigdecimal/util'

    Rational(22, 7).to_d(3)   # => 0.314e1

See also BigDecimal::new.

;T;0;;;I"	to_d;F;I"Rational;T;[o;;I"::Integer precision;T;I"BigDecimal;To; ;0;0;	I"Rational;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"oDeserializes JSON string by converting numerator value `n`, denominator value
`d`, to a Rational object.

;T;0;;;I"json_create;F;I"Rational;T;[o;;I"2::Hash[::String, ::String | ::Integer] object;T;I"instance;To;;I"XReturns a hash, that will be turned into a JSON object and represent this
object.

;T;0;;;I"as_json;F;I"Rational;T;[o;;I"*untyped;T;I")Hash[::String, ::String | ::Integer];To;;I"kStores class name (Rational) along with numerator value `n` and denominator
value `d` as JSON string

;T;0;;;I"to_json;F;I"Rational;T;[o;;I"?::JSON::State state;T;I"String;To;;I"/The module storing Ruby interpreter configurations on building.

This file was created by mkconfig.rb when ruby was built.  It contains build
information for ruby which is used e.g. by mkmf to build compatible native
extensions.  Any changes made to this file will be lost the next time ruby is
built.

;T;0;	I"RbConfig;T;
[ ;[ ;0;[ ;[ o;;I"xexpands variable with given `val` value.

    RbConfig.expand("$(bindir)") # => /home/foobar/all-ruby/ruby19x/bin

;T;0;;;I"expand;F;I"RbConfig;T;[o;;I"5::String val, ?::Hash[::String, ::String] config;T;I"String;To;;0;0;;;I"fire_update!;F;I"RbConfig;T;[o;;I"e::String key, ::String val, ?::Hash[::String, ::String] mkconf, ?::Hash[::String, ::String] conf;T;I"Array[::String]?;To;;0;0;;;I"	ruby;F;I"RbConfig;T;[o;;I" ;F;I"String;To;;0;0;	I"RBS;T;
[ ;[ ;0;[ ;[ o;;0;0;	I"RBS;T;
[ ;[ ;0;[ ;[ o;;0;0;	I"RBS;T;
[ ;[ ;0;[ ;[ o;;0;0;	I"RBS::Unnamed;T;
[ ;[ ;0;[ ;[ o;;0;0;	I"RBS::Unnamed;T;
[ ;[ ;0;[ ;[ o;;0;0;	I"RBS::Unnamed;T;
[ ;[ ;0;[ ;[ o; ;I"}`ARGF` is a stream designed for use in scripts that process files given as
command-line arguments or passed in via STDIN.

The arguments passed to your script are stored in the `ARGV` Array, one
argument per element. `ARGF` assumes that any arguments that aren't filenames
have been removed from `ARGV`. For example:

    $ ruby argf.rb --verbose file1 file2

    ARGV  #=> ["--verbose", "file1", "file2"]
    option = ARGV.shift #=> "--verbose"
    ARGV  #=> ["file1", "file2"]

You can now use `ARGF` to work with a concatenation of each of these named
files. For instance, `ARGF.read` will return the contents of *file1* followed
by the contents of *file2*.

After a file in `ARGV` has been read `ARGF` removes it from the Array. Thus,
after all files have been read `ARGV` will be empty.

You can manipulate `ARGV` yourself to control what `ARGF` operates on. If you
remove a file from `ARGV`, it is ignored by `ARGF`; if you add files to
`ARGV`, they are treated as if they were named on the command line. For
example:

    ARGV.replace ["file1"]
    ARGF.readlines # Returns the contents of file1 as an Array
    ARGV           #=> []
    ARGV.replace ["file2", "file3"]
    ARGF.read      # Returns the contents of file2 and file3

If `ARGV` is empty, `ARGF` acts as if it contained STDIN, i.e. the data piped
to your script. For example:

    $ echo "glark" | ruby -e 'p ARGF.read'
    "glark\n"

;T;0;	I"RBS::Unnamed::ARGFClass;T;
[ ;[I"Enumerable;T;0;[ ;[ ;0;0o;;I"¸Returns the `ARGV` array, which contains the arguments passed to your script,
one per element.

For example:

    $ ruby argf.rb -v glark.txt

    ARGF.argv   #=> ["-v", "glark.txt"]

;T;0;;;I"	argv;F;I"RBS::Unnamed::ARGFClass;T;[o;;I" ;F;I"Array[::String];To;;I"þPuts `ARGF` into binary mode. Once a stream is in binary mode, it cannot be
reset to non-binary mode. This option has the following effects:

*   Newline conversion is disabled.
*   Encoding conversion is disabled.
*   Content is treated as ASCII-8BIT.

;T;0;;;I"binmode;F;I"RBS::Unnamed::ARGFClass;T;[o;;I" ;F;I"	self;To;;I"ÊReturns true if `ARGF` is being read in binary mode; false otherwise. To
enable binary mode use `ARGF.binmode`.

For example:

    ARGF.binmode?  #=> false
    ARGF.binmode
    ARGF.binmode?  #=> true

;T;0;;;I"binmode?;F;I"RBS::Unnamed::ARGFClass;T;[o;;I" ;F;I"	bool;To;;I"Closes the current file and skips to the next file in ARGV. If there are no
more files to open, just closes the current file. `STDIN` will not be closed.

For example:

    $ ruby argf.rb foo bar

    ARGF.filename  #=> "foo"
    ARGF.close
    ARGF.filename  #=> "bar"
    ARGF.close

;T;0;;;I"
close;F;I"RBS::Unnamed::ARGFClass;T;[o;;I" ;F;I"	self;To;;I"}Returns *true* if the current file has been closed; *false* otherwise. Use
`ARGF.close` to actually close the current file.

;T;0;;;I"closed?;F;I"RBS::Unnamed::ARGFClass;T;[o;;I" ;F;I"	bool;To;;I"3Returns an enumerator which iterates over each line (separated by *sep*, which
defaults to your platform's newline character) of each file in `ARGV`. If a
block is supplied, each line in turn will be yielded to the block, otherwise
an enumerator is returned. The optional *limit* argument is an `Integer`
specifying the maximum length of each line; longer lines will be split
according to this limit.

This method allows you to treat the files supplied on the command line as a
single file consisting of the concatenation of each named file. After the last
line of the first file has been returned, the first line of the second file is
returned. The `ARGF.filename` and `ARGF.lineno` methods can be used to
determine the filename of the current line and line number of the whole input,
respectively.

For example, the following code prints out each line of each named file
prefixed with its line number, displaying the filename once per file:

    ARGF.each_line do |line|
      puts ARGF.filename if ARGF.file.lineno == 1
      puts "#{ARGF.file.lineno}: #{line}"
    end

While the following code prints only the first file's name at first, and the
contents with line number counted through all named files.

    ARGF.each_line do |line|
      puts ARGF.filename if ARGF.lineno == 1
      puts "#{ARGF.lineno}: #{line}"
    end

;T;0;;;I"	each;F;I"RBS::Unnamed::ARGFClass;T;[o;;I"$?::String sep, ?::Integer limit;T;I"	self;To;;I"$?::String sep, ?::Integer limit;T;I"Enumerator[::String, self];To;;I"+Iterates over each byte of each file in `ARGV`. A byte is returned as an
`Integer` in the range 0..255.

This method allows you to treat the files supplied on the command line as a
single file consisting of the concatenation of each named file. After the last
byte of the first file has been returned, the first byte of the second file is
returned. The `ARGF.filename` method can be used to determine the filename of
the current byte.

If no block is given, an enumerator is returned instead.

For example:

    ARGF.bytes.to_a  #=> [35, 32, ... 95, 10]

;T;0;;;I"each_byte;F;I"RBS::Unnamed::ARGFClass;T;[o;;I" ;F;I"	self;To;;I" ;F;I" Enumerator[::Integer, self];To;;I"àIterates over each character of each file in `ARGF`.

This method allows you to treat the files supplied on the command line as a
single file consisting of the concatenation of each named file. After the last
character of the first file has been returned, the first character of the
second file is returned. The `ARGF.filename` method can be used to determine
the name of the file in which the current character appears.

If no block is given, an enumerator is returned instead.

;T;0;;;I"each_char;F;I"RBS::Unnamed::ARGFClass;T;[o;;I" ;F;I"	self;To;;I" ;F;I"Enumerator[::String, self];To;;I"àIterates over each codepoint of each file in `ARGF`.

This method allows you to treat the files supplied on the command line as a
single file consisting of the concatenation of each named file. After the last
codepoint of the first file has been returned, the first codepoint of the
second file is returned. The `ARGF.filename` method can be used to determine
the name of the file in which the current codepoint appears.

If no block is given, an enumerator is returned instead.

;T;0;;;I"each_codepoint;F;I"RBS::Unnamed::ARGFClass;T;[o;;I" ;F;I"	self;To;;I" ;F;I" Enumerator[::Integer, self];To;;I"3Returns an enumerator which iterates over each line (separated by *sep*, which
defaults to your platform's newline character) of each file in `ARGV`. If a
block is supplied, each line in turn will be yielded to the block, otherwise
an enumerator is returned. The optional *limit* argument is an `Integer`
specifying the maximum length of each line; longer lines will be split
according to this limit.

This method allows you to treat the files supplied on the command line as a
single file consisting of the concatenation of each named file. After the last
line of the first file has been returned, the first line of the second file is
returned. The `ARGF.filename` and `ARGF.lineno` methods can be used to
determine the filename of the current line and line number of the whole input,
respectively.

For example, the following code prints out each line of each named file
prefixed with its line number, displaying the filename once per file:

    ARGF.each_line do |line|
      puts ARGF.filename if ARGF.file.lineno == 1
      puts "#{ARGF.file.lineno}: #{line}"
    end

While the following code prints only the first file's name at first, and the
contents with line number counted through all named files.

    ARGF.each_line do |line|
      puts ARGF.filename if ARGF.lineno == 1
      puts "#{ARGF.lineno}: #{line}"
    end

;T;0;;;I"each_line;F;I"RBS::Unnamed::ARGFClass;T;[o;;I"$?::String sep, ?::Integer limit;T;I"	self;To;;I"$?::String sep, ?::Integer limit;T;I"Enumerator[::String, self];To;;I"€Returns true if the current file in `ARGF` is at end of file, i.e. it has no
data to read. The stream must be opened for reading or an `IOError` will be
raised.

    $ echo "eof" | ruby argf.rb

    ARGF.eof?                 #=> false
    3.times { ARGF.readchar }
    ARGF.eof?                 #=> false
    ARGF.readchar             #=> "\n"
    ARGF.eof?                 #=> true

;T;0;;;I"eof;F;I"RBS::Unnamed::ARGFClass;T;[o;;I" ;F;I"	bool;To;;I"€Returns true if the current file in `ARGF` is at end of file, i.e. it has no
data to read. The stream must be opened for reading or an `IOError` will be
raised.

    $ echo "eof" | ruby argf.rb

    ARGF.eof?                 #=> false
    3.times { ARGF.readchar }
    ARGF.eof?                 #=> false
    ARGF.readchar             #=> "\n"
    ARGF.eof?                 #=> true

;T;0;;;I"	eof?;F;I"RBS::Unnamed::ARGFClass;T;[o;;I" ;F;I"	bool;To;;I"zReturns the external encoding for files read from `ARGF` as an `Encoding`
object. The external encoding is the encoding of the text as stored in a file.
Contrast with `ARGF.internal_encoding`, which is the encoding used to
represent this text within Ruby.

To set the external encoding use `ARGF.set_encoding`.

For example:

    ARGF.external_encoding  #=>  #<Encoding:UTF-8>

;T;0;;;I"external_encoding;F;I"RBS::Unnamed::ARGFClass;T;[o;;I" ;F;I"Encoding;To;;I",Returns the current file as an `IO` or `File` object. `$stdin` is returned
when the current file is STDIN.

For example:

    $ echo "foo" > foo
    $ echo "bar" > bar

    $ ruby argf.rb foo bar

    ARGF.file      #=> #<File:foo>
    ARGF.read(5)   #=> "foo\nb"
    ARGF.file      #=> #<File:bar>

;T;0;;;I"	file;F;I"RBS::Unnamed::ARGFClass;T;[o;;I" ;F;I"IO | ::File;To;;I"QReturns the current filename. "-" is returned when the current file is STDIN.

For example:

    $ echo "foo" > foo
    $ echo "bar" > bar
    $ echo "glark" > glark

    $ ruby argf.rb foo bar glark

    ARGF.filename  #=> "foo"
    ARGF.read(5)   #=> "foo\nb"
    ARGF.filename  #=> "bar"
    ARGF.skip
    ARGF.filename  #=> "glark"

;T;0;;;I"filename;F;I"RBS::Unnamed::ARGFClass;T;[o;;I" ;F;I"String;To;;I"¦Returns an integer representing the numeric file descriptor for the current
file. Raises an `ArgumentError` if there isn't a current file.

    ARGF.fileno    #=> 3

;T;0;;;I"fileno;F;I"RBS::Unnamed::ARGFClass;T;[o;;I" ;F;I"Integer;To;;I"Gets the next 8-bit byte (0..255) from `ARGF`. Returns `nil` if called at the
end of the stream.

For example:

    $ echo "foo" > file
    $ ruby argf.rb file

    ARGF.getbyte #=> 102
    ARGF.getbyte #=> 111
    ARGF.getbyte #=> 111
    ARGF.getbyte #=> 10
    ARGF.getbyte #=> nil

;T;0;;;I"getbyte;F;I"RBS::Unnamed::ARGFClass;T;[o;;I" ;F;I"Integer?;To;;I"Reads the next character from `ARGF` and returns it as a `String`. Returns
`nil` at the end of the stream.

`ARGF` treats the files named on the command line as a single file created by
concatenating their contents. After returning the last character of the first
file, it returns the first character of the second file, and so on.

For example:

    $ echo "foo" > file
    $ ruby argf.rb file

    ARGF.getc  #=> "f"
    ARGF.getc  #=> "o"
    ARGF.getc  #=> "o"
    ARGF.getc  #=> "\n"
    ARGF.getc  #=> nil
    ARGF.getc  #=> nil

;T;0;;;I"	getc;F;I"RBS::Unnamed::ARGFClass;T;[o;;I" ;F;I"String?;To;;I"{Returns the next line from the current file in `ARGF`.

By default lines are assumed to be separated by `$/`; to use a different
character as a separator, supply it as a `String` for the *sep* argument.

The optional *limit* argument specifies how many characters of each line to
return. By default all characters are returned.

See IO.readlines for details about getline_args.

;T;0;;;I"	gets;F;I"RBS::Unnamed::ARGFClass;T;[o;;I"$?::String sep, ?::Integer limit;T;I"String?;To;;I"¾Returns the file extension appended to the names of modified files under
in-place edit mode. This value can be set using `ARGF.inplace_mode=` or
passing the `-i` switch to the Ruby binary.

;T;0;;;I"inplace_mode;F;I"RBS::Unnamed::ARGFClass;T;[o;;I" ;F;I"String?;To;;I"ÒSets the filename extension for in-place editing mode to the given String.
Each file being edited has this value appended to its filename. The modified
file is saved under this new name.

For example:

    $ ruby argf.rb file.txt

    ARGF.inplace_mode = '.bak'
    ARGF.each_line do |line|
      print line.sub("foo","bar")
    end

Each line of *file.txt* has the first occurrence of "foo" replaced with "bar",
then the new line is written out to *file.txt.bak*.

;T;0;;;I"inplace_mode=;F;I"RBS::Unnamed::ARGFClass;T;[o;;I"::String;T;I"	self;To;;I"‘Returns the internal encoding for strings read from `ARGF` as an `Encoding`
object.

If `ARGF.set_encoding` has been called with two encoding names, the second is
returned. Otherwise, if `Encoding.default_external` has been set, that value
is returned. Failing that, if a default external encoding was specified on the
command-line, that value is used. If the encoding is unknown, `nil` is
returned.

;T;0;;;I"internal_encoding;F;I"RBS::Unnamed::ARGFClass;T;[o;;I" ;F;I"Encoding;To;;I"ÑReturns the current line number of ARGF as a whole. This value can be set
manually with `ARGF.lineno=`.

For example:

    ARGF.lineno   #=> 0
    ARGF.readline #=> "This is line 1\n"
    ARGF.lineno   #=> 1

;T;0;;;I"lineno;F;I"RBS::Unnamed::ARGFClass;T;[o;;I" ;F;I"Integer;To;;I"Sets the line number of `ARGF` as a whole to the given `Integer`.

`ARGF` sets the line number automatically as you read data, so normally you
will not need to set it explicitly. To access the current line number use
`ARGF.lineno`.

For example:

    ARGF.lineno      #=> 0
    ARGF.readline    #=> "This is line 1\n"
    ARGF.lineno      #=> 1
    ARGF.lineno = 0  #=> 0
    ARGF.lineno      #=> 0

;T;0;;;I"lineno=;F;I"RBS::Unnamed::ARGFClass;T;[o;;I"::Integer;T;I"untyped;To;;I"QReturns the current filename. "-" is returned when the current file is STDIN.

For example:

    $ echo "foo" > foo
    $ echo "bar" > bar
    $ echo "glark" > glark

    $ ruby argf.rb foo bar glark

    ARGF.filename  #=> "foo"
    ARGF.read(5)   #=> "foo\nb"
    ARGF.filename  #=> "bar"
    ARGF.skip
    ARGF.filename  #=> "glark"

;T;0;;;I"	path;F;I"RBS::Unnamed::ARGFClass;T;[o;;I" ;F;I"String;To;;I"Returns the current offset (in bytes) of the current file in `ARGF`.

    ARGF.pos    #=> 0
    ARGF.gets   #=> "This is line one\n"
    ARGF.pos    #=> 17

;T;0;;;I"pos;F;I"RBS::Unnamed::ARGFClass;T;[o;;I" ;F;I"Integer;To;;I"‹Seeks to the position given by *position* (in bytes) in `ARGF`.

For example:

    ARGF.pos = 17
    ARGF.gets   #=> "This is line two\n"

;T;0;;;I"	pos=;F;I"RBS::Unnamed::ARGFClass;T;[o;;I"::Integer;T;I"Integer;To;;I"ïWrites the given object(s) to *ios*. Returns `nil`.

The stream must be opened for writing. Each given object that isn't a string
will be converted by calling its `to_s` method. When called without arguments,
prints the contents of `$_`.

If the output field separator (`$,`) is not `nil`, it is inserted between
objects. If the output record separator (`$\`) is not `nil`, it is appended to
the output.

    $stdout.print("This is ", 100, " percent.\n")

*produces:*

    This is 100 percent.

;T;0;;;I"
print;F;I"RBS::Unnamed::ARGFClass;T;[o;;I"*untyped args;T;I"nil;To;;I"}Formats and writes to *ios*, converting parameters under control of the format
string. See Kernel#sprintf for details.

;T;0;;;I"printf;F;I"RBS::Unnamed::ARGFClass;T;[o;;I"*::String format_string, *untyped args;T;I"nil;To;;I"ûIf *obj* is Numeric, write the character whose code is the least-significant
byte of *obj*.  If *obj* is String, write the first character of *obj* to
*ios*.  Otherwise, raise TypeError.

    $stdout.putc "A"
    $stdout.putc 65

*produces:*

    AA

;T;0;;;I"	putc;F;I"RBS::Unnamed::ARGFClass;T;[o;;I"::Numeric | ::String obj;T;I"untyped;To;;I"BWrites the given object(s) to *ios*. Writes a newline after any that do not
already end with a newline sequence. Returns `nil`.

The stream must be opened for writing. If called with an array argument,
writes each element on a new line. Each given object that isn't a string or
array will be converted by calling its `to_s` method. If called without
arguments, outputs a single newline.

    $stdout.puts("this", "is", ["a", "test"])

*produces:*

    this
    is
    a
    test

Note that `puts` always uses newlines and is not affected by the output record
separator (`$\`).

;T;0;;;I"	puts;F;I"RBS::Unnamed::ARGFClass;T;[o;;I"*untyped obj;T;I"nil;To;;I"AReads *length* bytes from ARGF. The files named on the command line are
concatenated and treated as a single file by this method, so when called
without arguments the contents of this pseudo file are returned in their
entirety.

*length* must be a non-negative integer or `nil`.

If *length* is a positive integer, `read` tries to read *length* bytes without
any conversion (binary mode). It returns `nil` if an EOF is encountered before
anything can be read. Fewer than *length* bytes are returned if an EOF is
encountered during the read. In the case of an integer *length*, the resulting
string is always in ASCII-8BIT encoding.

If *length* is omitted or is `nil`, it reads until EOF and the encoding
conversion is applied, if applicable. A string is returned even if EOF is
encountered before any data is read.

If *length* is zero, it returns an empty string (`""`).

If the optional *outbuf* argument is present, it must reference a String,
which will receive the data. The *outbuf* will contain only the received data
after the method call even if it is not empty at the beginning.

For example:

    $ echo "small" > small.txt
    $ echo "large" > large.txt
    $ ./glark.rb small.txt large.txt

    ARGF.read      #=> "small\nlarge"
    ARGF.read(200) #=> "small\nlarge"
    ARGF.read(2)   #=> "sm"
    ARGF.read(0)   #=> ""

Note that this method behaves like the fread() function in C. This means it
retries to invoke read(2) system calls to read data with the specified length.
If you need the behavior like a single read(2) system call, consider
ARGF#readpartial or ARGF#read_nonblock.

;T;0;;;I"	read;F;I"RBS::Unnamed::ARGFClass;T;[o;;I"%?::int? length, ?::string outbuf;T;I"String?;To;;I"NReads at most *maxlen* bytes from the ARGF stream in non-blocking mode.

;T;0;;;I"read_nonblock;F;I"RBS::Unnamed::ARGFClass;T;[o;;I"3::int maxlen, ?::string buf, **untyped options;T;I"String;To;;I"oReads the next 8-bit byte from ARGF and returns it as an `Integer`. Raises an
`EOFError` after the last byte of the last file has been read.

For example:

    $ echo "foo" > file
    $ ruby argf.rb file

    ARGF.readbyte  #=> 102
    ARGF.readbyte  #=> 111
    ARGF.readbyte  #=> 111
    ARGF.readbyte  #=> 10
    ARGF.readbyte  #=> end of file reached (EOFError)

;T;0;;;I"readbyte;F;I"RBS::Unnamed::ARGFClass;T;[o;;I" ;F;I"Integer;To;;I"uReads the next character from `ARGF` and returns it as a `String`. Raises an
`EOFError` after the last character of the last file has been read.

For example:

    $ echo "foo" > file
    $ ruby argf.rb file

    ARGF.readchar  #=> "f"
    ARGF.readchar  #=> "o"
    ARGF.readchar  #=> "o"
    ARGF.readchar  #=> "\n"
    ARGF.readchar  #=> end of file reached (EOFError)

;T;0;;;I"readchar;F;I"RBS::Unnamed::ARGFClass;T;[o;;I" ;F;I"String;To;;I"zReturns the next line from the current file in `ARGF`.

By default lines are assumed to be separated by `$/`; to use a different
character as a separator, supply it as a `String` for the *sep* argument.

The optional *limit* argument specifies how many characters of each line to
return. By default all characters are returned.

An `EOFError` is raised at the end of the file.

;T;0;;;I"readline;F;I"RBS::Unnamed::ARGFClass;T;[o;;I"$?::String sep, ?::Integer limit;T;I"String;To;;I"äReads `ARGF`'s current file in its entirety, returning an `Array` of its
lines, one line per element. Lines are assumed to be separated by *sep*.

    lines = ARGF.readlines
    lines[0]                #=> "This is line one\n"

;T;0;;;I"readlines;F;I"RBS::Unnamed::ARGFClass;T;[o;;I"$?::String sep, ?::Integer limit;T;I"Array[::String];To;;I"Reads at most *maxlen* bytes from the ARGF stream.

If the optional *outbuf* argument is present, it must reference a String,
which will receive the data. The *outbuf* will contain only the received data
after the method call even if it is not empty at the beginning.

It raises EOFError on end of ARGF stream. Since ARGF stream is a concatenation
of multiple files, internally EOF is occur for each file. ARGF.readpartial
returns empty strings for EOFs except the last one and raises EOFError for the
last one.

;T;0;;;I"readpartial;F;I"RBS::Unnamed::ARGFClass;T;[o;;I"#::int maxlen, ?::string outbuf;T;I"String;To;;I"çPositions the current file to the beginning of input, resetting `ARGF.lineno`
to zero.

    ARGF.readline   #=> "This is line one\n"
    ARGF.rewind     #=> 0
    ARGF.lineno     #=> 0
    ARGF.readline   #=> "This is line one\n"

;T;0;;;I"rewind;F;I"RBS::Unnamed::ARGFClass;T;[o;;I" ;F;I"Integer;To;;I"ƒSeeks to offset *amount* (an `Integer`) in the `ARGF` stream according to the
value of *whence*. See IO#seek for further details.

;T;0;;;I"	seek;F;I"RBS::Unnamed::ARGFClass;T;[o;;I"(::Integer amount, ?::Integer whence;T;I"Integer;To;;I"ëIf single argument is specified, strings read from ARGF are tagged with the
encoding specified.

If two encoding names separated by a colon are given, e.g. "ascii:utf-8", the
read string is converted from the first encoding (external encoding) to the
second encoding (internal encoding), then tagged with the second encoding.

If two arguments are specified, they must be encoding objects or encoding
names. Again, the first specifies the external encoding; the second specifies
the internal encoding.

If the external encoding and the internal encoding are specified, the optional
`Hash` argument can be used to adjust the conversion process. The structure of
this hash is explained in the String#encode documentation.

For example:

    ARGF.set_encoding('ascii')         # Tag the input as US-ASCII text
    ARGF.set_encoding(Encoding::UTF_8) # Tag the input as UTF-8 text
    ARGF.set_encoding('utf-8','ascii') # Transcode the input from US-ASCII
                                       # to UTF-8.

;T;0;;;I"set_encoding;F;I"RBS::Unnamed::ARGFClass;T;[o;;I"M::String | ::Encoding ext_or_ext_int_enc, ?::String | ::Encoding int_enc;T;I"	self;To;;I"ÔSets the current file to the next file in ARGV. If there aren't any more files
it has no effect.

For example:

    $ ruby argf.rb foo bar
    ARGF.filename  #=> "foo"
    ARGF.skip
    ARGF.filename  #=> "bar"

;T;0;;;I"	skip;F;I"RBS::Unnamed::ARGFClass;T;[o;;I" ;F;I"	self;To;;I"Returns the current offset (in bytes) of the current file in `ARGF`.

    ARGF.pos    #=> 0
    ARGF.gets   #=> "This is line one\n"
    ARGF.pos    #=> 17

;T;0;;;I"	tell;F;I"RBS::Unnamed::ARGFClass;T;[o;;I" ;F;I"Integer;To;;I"äReads `ARGF`'s current file in its entirety, returning an `Array` of its
lines, one line per element. Lines are assumed to be separated by *sep*.

    lines = ARGF.readlines
    lines[0]                #=> "This is line one\n"

;T;0;;;I"	to_a;F;I"RBS::Unnamed::ARGFClass;T;[o;;I"$?::String sep, ?::Integer limit;T;I"Array[::String];To;;I"¦Returns an integer representing the numeric file descriptor for the current
file. Raises an `ArgumentError` if there isn't a current file.

    ARGF.fileno    #=> 3

;T;0;;;I"	to_i;F;I"RBS::Unnamed::ARGFClass;T;[o;;I" ;F;I"Integer;To;;I"âReturns an `IO` object representing the current file. This will be a `File`
object unless the current file is a stream such as STDIN.

For example:

    ARGF.to_io    #=> #<File:glark.txt>
    ARGF.to_io    #=> #<IO:<STDIN>>

;T;0;;;I"
to_io;F;I"RBS::Unnamed::ARGFClass;T;[o;;I" ;F;I"IO;To;;I"Returns "ARGF".

;T;0;;;I"	to_s;F;I"RBS::Unnamed::ARGFClass;T;[o;;I" ;F;I"String;To;;I"QReturns IO instance tied to *ARGF* for writing if inplace mode is enabled.

;T;0;;;I"to_write_io;F;I"RBS::Unnamed::ARGFClass;T;[o;;I" ;F;I"IO;To;;I"'Writes *string* if inplace mode.

;T;0;;;I"
write;F;I"RBS::Unnamed::ARGFClass;T;[o;;I"::_ToS string;T;I"Integer;To;;0;0;;;I"initialize;F;I"RBS::Unnamed::ARGFClass;T;[o;;I"*::String argv;T;I"	void;To;;0;0;;;I"initialize_copy;F;I"RBS::Unnamed::ARGFClass;T;[o;;I"self orig;T;I"	self;To; ;I"üENV is a hash-like accessor for environment variables.

### Interaction with the Operating System

The ENV object interacts with the operating system's environment variables:

*   When you get the value for a name in ENV, the value is retrieved from
    among the current environment variables.
*   When you create or set a name-value pair in ENV, the name and value are
    immediately set in the environment variables.
*   When you delete a name-value pair in ENV, it is immediately deleted from
    the environment variables.


### Names and Values

Generally, a name or value is a String.

#### Valid Names and Values

Each name or value must be one of the following:

*   A String.
*   An object that responds to #to_str by returning a String, in which case
    that String will be used as the name or value.


#### Invalid Names and Values

A new name:

*   May not be the empty string:
        ENV[''] = '0'
        # Raises Errno::EINVAL (Invalid argument - ruby_setenv())

*   May not contain character `"="`:
        ENV['='] = '0'
        # Raises Errno::EINVAL (Invalid argument - ruby_setenv(=))


A new name or value:

*   May not be a non-String that does not respond to #to_str:

        ENV['foo'] = Object.new
        # Raises TypeError (no implicit conversion of Object into String)
        ENV[Object.new] = '0'
        # Raises TypeError (no implicit conversion of Object into String)

*   May not contain the NUL character `"\0"`:

        ENV['foo'] = "\0"
        # Raises ArgumentError (bad environment variable value: contains null byte)
        ENV["\0"] == '0'
        # Raises ArgumentError (bad environment variable name: contains null byte)

*   May not have an ASCII-incompatible encoding such as UTF-16LE or
    ISO-2022-JP:

        ENV['foo'] = '0'.force_encoding(Encoding::ISO_2022_JP)
        # Raises ArgumentError (bad environment variable name: ASCII incompatible encoding: ISO-2022-JP)
        ENV["foo".force_encoding(Encoding::ISO_2022_JP)] = '0'
        # Raises ArgumentError (bad environment variable name: ASCII incompatible encoding: ISO-2022-JP)


### About Ordering

ENV enumerates its name/value pairs in the order found in the operating
system's environment variables. Therefore the ordering of ENV content is
OS-dependent, and may be indeterminate.

This will be seen in:
*   A Hash returned by an ENV method.
*   An Enumerator returned by an ENV method.
*   An Array returned by ENV.keys, ENV.values, or ENV.to_a.
*   The String returned by ENV.inspect.
*   The Array returned by ENV.shift.
*   The name returned by ENV.key.


### About the Examples
Some methods in ENV return ENV itself. Typically, there are many environment
variables. It's not useful to display a large ENV in the examples here, so
most example snippets begin by resetting the contents of ENV:
*   ENV.replace replaces ENV with a new collection of entries.
*   ENV.clear empties ENV.


## What's Here

First, what's elsewhere. Class ENV:

*   Inherits from [class
    Object](Object.html#class-Object-label-What-27s+Here).
*   Extends [module
    Enumerable](Enumerable.html#module-Enumerable-label-What-27s+Here),


Here, class ENV provides methods that are useful for:

*   [Querying](#class-ENV-label-Methods+for+Querying)
*   [Assigning](#class-ENV-label-Methods+for+Assigning)
*   [Deleting](#class-ENV-label-Methods+for+Deleting)
*   [Iterating](#class-ENV-label-Methods+for+Iterating)
*   [Converting](#class-ENV-label-Methods+for+Converting)
*   [And more ....](#class-ENV-label-More+Methods)


### Methods for Querying

    ::[]
:       Returns the value for the given environment variable name if it
        exists:

    ::empty?
:       Returns whether ENV is empty.

    ::has_value?, ::value?
:       Returns whether the given value is in ENV.

    ::include?, ::has_key?, ::key?, ::member?
:       Returns whether the given name is in ENV.

    ::key
:       Returns the name of the first entry with the given value.

    ::size, ::length
:       Returns the number of entries.

    ::value?
:       Returns whether any entry has the given value.



### Methods for Assigning

    ::[]=, ::store
:       Creates, updates, or deletes the named environment variable.

    ::clear
:       Removes every environment variable; returns ENV:

    ::update, ::merge!
:       Adds to ENV each key/value pair in the given hash.

    ::replace
:       Replaces the entire content of the ENV with the name/value pairs in
        the given hash.



### Methods for Deleting

    ::delete
:       Deletes the named environment variable name if it exists.

    ::delete_if
:       Deletes entries selected by the block.

    ::keep_if
:       Deletes entries not selected by the block.

    ::reject!
:       Similar to #delete_if, but returns `nil` if no change was made.

    ::select!, ::filter!
:       Deletes entries selected by the block.

    ::shift
:       Removes and returns the first entry.



### Methods for Iterating

    ::each, ::each_pair
:       Calls the block with each name/value pair.

    ::each_key
:       Calls the block with each name.

    ::each_value
:       Calls the block with each value.



### Methods for Converting

    ::assoc
:       Returns a 2-element array containing the name and value of the named
        environment variable if it exists:

    ::clone
:       Returns ENV (and issues a warning).

    ::except
:       Returns a hash of all name/value pairs except those given.

    ::fetch
:       Returns the value for the given name.

    ::inspect
:       Returns the contents of ENV as a string.

    ::invert
:       Returns a hash whose keys are the ENV values, and whose values are the
        corresponding ENV names.

    ::keys
:       Returns an array of all names.

    ::rassoc
:       Returns the name and value of the first found entry that has the given
        value.

    ::reject
:       Returns a hash of those entries not rejected by the block.

    ::select, ::filter
:       Returns a hash of name/value pairs selected by the block.

    ::slice
:       Returns a hash of the given names and their corresponding values.

    ::to_a
:       Returns the entries as an array of 2-element Arrays.

    ::to_h
:       Returns a hash of entries selected by the block.

    ::to_hash
:       Returns a hash of all entries.

    ::to_s
:       Returns the string `'ENV'`.

    ::values
:       Returns all values as an array.

    ::values_at
:       Returns an array of the values for the given name.



### More Methods

    ::dup
:       Raises an exception.

    ::freeze
:       Raises an exception.

    ::rehash
:       Returns `nil`, without modifying ENV.

;T;0;	I"RBS::Unnamed::ENVClass;T;
[ ;[I"Enumerable;T;0;[ ;[ ;0;0o;;I"Returns the value for the environment variable `name` if it exists:
    ENV['foo'] = '0'
    ENV['foo'] # => "0"

Returns `nil` if the named variable does not exist.

Raises an exception if `name` is invalid. See [Invalid Names and
Values](#class-ENV-label-Invalid+Names+and+Values).

;T;0;;;I"[];F;I"RBS::Unnamed::ENVClass;T;[o;;I"::String name;T;I"String?;To;;I"KIf `name` is the name of an environment variable, returns its value:
    ENV['foo'] = '0'
    ENV.fetch('foo') # => '0'

Otherwise if a block is given (but not a default value), yields `name` to the
block and returns the block's return value:
    ENV.fetch('foo') { |name| :need_not_return_a_string } # => :need_not_return_a_string

Otherwise if a default value is given (but not a block), returns the default
value:
    ENV.delete('foo')
    ENV.fetch('foo', :default_need_not_be_a_string) # => :default_need_not_be_a_string

If the environment variable does not exist and both default and block are
given, issues a warning ("warning: block supersedes default value argument"),
yields `name` to the block, and returns the block's return value:
    ENV.fetch('foo', :default) { |name| :block_return } # => :block_return

Raises KeyError if `name` is valid, but not found, and neither default value
nor block is given:
    ENV.fetch('foo') # Raises KeyError (key not found: "foo")

Raises an exception if `name` is invalid. See [Invalid Names and
Values](#class-ENV-label-Invalid+Names+and+Values).

;T;0;;;I"
fetch;F;I"RBS::Unnamed::ENVClass;T;[o;;I"::String name;T;I"String;To;;I"::String name, X default;T;I"String | X;To;;I"::String name;T;I"String | X;To;;I"‘ENV.store is an alias for ENV.[]=.

Creates, updates, or deletes the named environment variable, returning the
value. Both `name` and `value` may be instances of String. See [Valid Names
and Values](#class-ENV-label-Valid+Names+and+Values).

*   If the named environment variable does not exist:
    *   If `value` is `nil`, does nothing.
            ENV.clear
            ENV['foo'] = nil # => nil
            ENV.include?('foo') # => false
            ENV.store('bar', nil) # => nil
            ENV.include?('bar') # => false

    *   If `value` is not `nil`, creates the environment variable with `name`
        and `value`:
            # Create 'foo' using ENV.[]=.
            ENV['foo'] = '0' # => '0'
            ENV['foo'] # => '0'
            # Create 'bar' using ENV.store.
            ENV.store('bar', '1') # => '1'
            ENV['bar'] # => '1'


*   If the named environment variable exists:
    *   If `value` is not `nil`, updates the environment variable with value
        `value`:
            # Update 'foo' using ENV.[]=.
            ENV['foo'] = '2' # => '2'
            ENV['foo'] # => '2'
            # Update 'bar' using ENV.store.
            ENV.store('bar', '3') # => '3'
            ENV['bar'] # => '3'

    *   If `value` is `nil`, deletes the environment variable:
            # Delete 'foo' using ENV.[]=.
            ENV['foo'] = nil # => nil
            ENV.include?('foo') # => false
            # Delete 'bar' using ENV.store.
            ENV.store('bar', nil) # => nil
            ENV.include?('bar') # => false



Raises an exception if `name` or `value` is invalid. See [Invalid Names and
Values](#class-ENV-label-Invalid+Names+and+Values).

;T;0;;;I"[]=;F;I"RBS::Unnamed::ENVClass;T;[o;;I"#::String name, ::String? value;T;I"String?;To;;I"“Yields each environment variable name and its value as a 2-element Array:
    h = {}
    ENV.each_pair { |name, value| h[name] = value } # => ENV
    h # => {"bar"=>"1", "foo"=>"0"}

Returns an Enumerator if no block given:
    h = {}
    e = ENV.each_pair # => #<Enumerator: {"bar"=>"1", "foo"=>"0"}:each_pair>
    e.each { |name, value| h[name] = value } # => ENV
    h # => {"bar"=>"1", "foo"=>"0"}

;T;0;;;I"	each;F;I"RBS::Unnamed::ENVClass;T;[o;;I" ;F;I"-Enumerator[[ ::String, ::String ], self];To;;I" ;F;I"	self;To;;I"“Yields each environment variable name and its value as a 2-element Array:
    h = {}
    ENV.each_pair { |name, value| h[name] = value } # => ENV
    h # => {"bar"=>"1", "foo"=>"0"}

Returns an Enumerator if no block given:
    h = {}
    e = ENV.each_pair # => #<Enumerator: {"bar"=>"1", "foo"=>"0"}:each_pair>
    e.each { |name, value| h[name] = value } # => ENV
    h # => {"bar"=>"1", "foo"=>"0"}

;T;0;;;I"each_pair;F;I"RBS::Unnamed::ENVClass;T;[o;;I" ;F;I"-Enumerator[[ ::String, ::String ], self];To;;I" ;F;I"	self;To;;I"’Yields each environment variable name:
    ENV.replace('foo' => '0', 'bar' => '1') # => ENV
    names = []
    ENV.each_key { |name| names.push(name) } # => ENV
    names # => ["bar", "foo"]

Returns an Enumerator if no block given:
    e = ENV.each_key # => #<Enumerator: {"bar"=>"1", "foo"=>"0"}:each_key>
    names = []
    e.each { |name| names.push(name) } # => ENV
    names # => ["bar", "foo"]

;T;0;;;I"each_key;F;I"RBS::Unnamed::ENVClass;T;[o;;I" ;F;I"#Enumerator[[ ::String ], self];To;;I" ;F;I"	self;To;;I"›Yields each environment variable value:
    ENV.replace('foo' => '0', 'bar' => '1') # => ENV
    values = []
    ENV.each_value { |value| values.push(value) } # => ENV
    values # => ["1", "0"]

Returns an Enumerator if no block given:
    e = ENV.each_value # => #<Enumerator: {"bar"=>"1", "foo"=>"0"}:each_value>
    values = []
    e.each { |value| values.push(value) } # => ENV
    values # => ["1", "0"]

;T;0;;;I"each_value;F;I"RBS::Unnamed::ENVClass;T;[o;;I" ;F;I"#Enumerator[[ ::String ], self];To;;I" ;F;I"	self;To;;I"àDeletes the environment variable with `name` if it exists and returns its
value:
    ENV['foo'] = '0'
    ENV.delete('foo') # => '0'

If a block is not given and the named environment variable does not exist,
returns `nil`.

If a block given and the environment variable does not exist, yields `name` to
the block and returns the value of the block:
    ENV.delete('foo') { |name| name * 2 } # => "foofoo"

If a block given and the environment variable exists, deletes the environment
variable and returns its value (ignoring the block):
    ENV['foo'] = '0'
    ENV.delete('foo') { |name| raise 'ignored' } # => "0"

Raises an exception if `name` is invalid. See [Invalid Names and
Values](#class-ENV-label-Invalid+Names+and+Values).

;T;0;;;I"delete;F;I"RBS::Unnamed::ENVClass;T;[o;;I"::String name;T;I"String?;To;;I"::String name;T;I"String;To;;I"ýYields each environment variable name and its value as a 2-element Array,
deleting each environment variable for which the block returns a truthy value,
and returning ENV (regardless of whether any deletions):
    ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
    ENV.delete_if { |name, value| name.start_with?('b') } # => ENV
    ENV # => {"foo"=>"0"}
    ENV.delete_if { |name, value| name.start_with?('b') } # => ENV

Returns an Enumerator if no block given:
    ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
    e = ENV.delete_if # => #<Enumerator: {"bar"=>"1", "baz"=>"2", "foo"=>"0"}:delete_if!>
    e.each { |name, value| name.start_with?('b') } # => ENV
    ENV # => {"foo"=>"0"}
    e.each { |name, value| name.start_with?('b') } # => ENV

;T;0;;;I"delete_if;F;I"RBS::Unnamed::ENVClass;T;[o;;I" ;F;I"-Enumerator[[ ::String, ::String ], self];To;;I" ;F;I"	self;To;;I"kYields each environment variable name and its value as a 2-element Array,
deleting each environment variable for which the block returns `false` or
`nil`, and returning ENV:
    ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
    ENV.keep_if { |name, value| name.start_with?('b') } # => ENV
    ENV # => {"bar"=>"1", "baz"=>"2"}

Returns an Enumerator if no block given:
    ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
    e = ENV.keep_if # => #<Enumerator: {"bar"=>"1", "baz"=>"2", "foo"=>"0"}:keep_if>
    e.each { |name, value| name.start_with?('b') } # => ENV
    ENV # => {"bar"=>"1", "baz"=>"2"}

;T;0;;;I"keep_if;F;I"RBS::Unnamed::ENVClass;T;[o;;I" ;F;I"-Enumerator[[ ::String, ::String ], self];To;;I" ;F;I"	self;To;;I"êReturns a Hash of the given ENV names and their corresponding values:
    ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2', 'bat' => '3')
    ENV.slice('foo', 'baz') # => {"foo"=>"0", "baz"=>"2"}
    ENV.slice('baz', 'foo') # => {"baz"=>"2", "foo"=>"0"}

Raises an exception if any of the `names` is invalid (see [Invalid Names and
Values](#class-ENV-label-Invalid+Names+and+Values)):
    ENV.slice('foo', 'bar', :bat) # Raises TypeError (no implicit conversion of Symbol into String)

;T;0;;;I"
slice;F;I"RBS::Unnamed::ENVClass;T;[o;;I"*::String names;T;I"Hash[::String, ::String];To;;I"æReturns a hash except the given keys from ENV and their values.

    ENV                       #=> {"LANG"=>"en_US.UTF-8", "TERM"=>"xterm-256color", "HOME"=>"/Users/rhc"}
    ENV.except("TERM","HOME") #=> {"LANG"=>"en_US.UTF-8"}

;T;0;;;I"except;F;I"RBS::Unnamed::ENVClass;T;[o;;I"*::String names;T;I"Hash[::String, ::String];To;;I"Removes every environment variable; returns ENV:
    ENV.replace('foo' => '0', 'bar' => '1')
    ENV.size # => 2
    ENV.clear # => ENV
    ENV.size # => 0

;T;0;;;I"
clear;F;I"RBS::Unnamed::ENVClass;T;[o;;I" ;F;I"	self;To;;I"ÿYields each environment variable name and its value as a 2-element Array.
Returns a Hash whose items are determined by the block. When the block returns
a truthy value, the name/value pair is added to the return Hash; otherwise the
pair is ignored:
    ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
    ENV.reject { |name, value| name.start_with?('b') } # => {"foo"=>"0"}

Returns an Enumerator if no block given:
    e = ENV.reject
    e.each { |name, value| name.start_with?('b') } # => {"foo"=>"0"}

;T;0;;;I"reject;F;I"RBS::Unnamed::ENVClass;T;[o;;I" ;F;I"-Enumerator[[ ::String, ::String ], self];To;;I" ;F;I"	self;To;;I"9Similar to ENV.delete_if, but returns `nil` if no changes were made.

Yields each environment variable name and its value as a 2-element Array,
deleting each environment variable for which the block returns a truthy value,
and returning ENV (if any deletions) or `nil` (if not):
    ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
    ENV.reject! { |name, value| name.start_with?('b') } # => ENV
    ENV # => {"foo"=>"0"}
    ENV.reject! { |name, value| name.start_with?('b') } # => nil

Returns an Enumerator if no block given:
    ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
    e = ENV.reject! # => #<Enumerator: {"bar"=>"1", "baz"=>"2", "foo"=>"0"}:reject!>
    e.each { |name, value| name.start_with?('b') } # => ENV
    ENV # => {"foo"=>"0"}
    e.each { |name, value| name.start_with?('b') } # => nil

;T;0;;;I"reject!;F;I"RBS::Unnamed::ENVClass;T;[o;;I" ;F;I".Enumerator[[ ::String, ::String ], self?];To;;I" ;F;I"
self?;To;;I" ENV.filter is an alias for ENV.select.

Yields each environment variable name and its value as a 2-element Array,
returning a Hash of the names and values for which the block returns a truthy
value:
    ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
    ENV.select { |name, value| name.start_with?('b') } # => {"bar"=>"1", "baz"=>"2"}
    ENV.filter { |name, value| name.start_with?('b') } # => {"bar"=>"1", "baz"=>"2"}

Returns an Enumerator if no block given:
    e = ENV.select # => #<Enumerator: {"bar"=>"1", "baz"=>"2", "foo"=>"0"}:select>
    e.each { |name, value | name.start_with?('b') } # => {"bar"=>"1", "baz"=>"2"}
    e = ENV.filter # => #<Enumerator: {"bar"=>"1", "baz"=>"2", "foo"=>"0"}:filter>
    e.each { |name, value | name.start_with?('b') } # => {"bar"=>"1", "baz"=>"2"}

;T;0;;;I"select;F;I"RBS::Unnamed::ENVClass;T;[o;;I" ;F;I"CEnumerator[[ ::String, ::String ], ::Hash[::String, ::String]];To;;I" ;F;I"Hash[::String, ::String];To;;I"äENV.filter! is an alias for ENV.select!.

Yields each environment variable name and its value as a 2-element Array,
deleting each entry for which the block returns `false` or `nil`, and
returning ENV if any deletions made, or `nil` otherwise:

    ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
    ENV.select! { |name, value| name.start_with?('b') } # => ENV
    ENV # => {"bar"=>"1", "baz"=>"2"}
    ENV.select! { |name, value| true } # => nil

    ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
    ENV.filter! { |name, value| name.start_with?('b') } # => ENV
    ENV # => {"bar"=>"1", "baz"=>"2"}
    ENV.filter! { |name, value| true } # => nil

Returns an Enumerator if no block given:

    ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
    e = ENV.select! # => #<Enumerator: {"bar"=>"1", "baz"=>"2"}:select!>
    e.each { |name, value| name.start_with?('b') } # => ENV
    ENV # => {"bar"=>"1", "baz"=>"2"}
    e.each { |name, value| true } # => nil

    ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
    e = ENV.filter! # => #<Enumerator: {"bar"=>"1", "baz"=>"2"}:filter!>
    e.each { |name, value| name.start_with?('b') } # => ENV
    ENV # => {"bar"=>"1", "baz"=>"2"}
    e.each { |name, value| true } # => nil

;T;0;;;I"select!;F;I"RBS::Unnamed::ENVClass;T;[o;;I" ;F;I".Enumerator[[ ::String, ::String ], self?];To;;I" ;F;I"
self?;To;;I"³Removes the first environment variable from ENV and returns a 2-element Array
containing its name and value:
    ENV.replace('foo' => '0', 'bar' => '1')
    ENV.to_hash # => {'bar' => '1', 'foo' => '0'}
    ENV.shift # => ['bar', '1']
    ENV.to_hash # => {'foo' => '0'}

Exactly which environment variable is "first" is OS-dependent. See [About
Ordering](#class-ENV-label-About+Ordering).

Returns `nil` if the environment is empty.

;T;0;;;I"
shift;F;I"RBS::Unnamed::ENVClass;T;[o;;I" ;F;I"[ ::String, ::String ]?;To;;I"ñReturns a Hash whose keys are the ENV values, and whose values are the
corresponding ENV names:
    ENV.replace('foo' => '0', 'bar' => '1')
    ENV.invert # => {"1"=>"bar", "0"=>"foo"}

For a duplicate ENV value, overwrites the hash entry:
    ENV.replace('foo' => '0', 'bar' => '0')
    ENV.invert # => {"0"=>"foo"}

Note that the order of the ENV processing is OS-dependent, which means that
the order of overwriting is also OS-dependent. See [About
Ordering](#class-ENV-label-About+Ordering).

;T;0;;;I"invert;F;I"RBS::Unnamed::ENVClass;T;[o;;I" ;F;I"Hash[::String, ::String];To;;I"”Replaces the entire content of the environment variables with the name/value
pairs in the given `hash`; returns ENV.

Replaces the content of ENV with the given pairs:
    ENV.replace('foo' => '0', 'bar' => '1') # => ENV
    ENV.to_hash # => {"bar"=>"1", "foo"=>"0"}

Raises an exception if a name or value is invalid (see [Invalid Names and
Values](#class-ENV-label-Invalid+Names+and+Values)):
    ENV.replace('foo' => '0', :bar => '1') # Raises TypeError (no implicit conversion of Symbol into String)
    ENV.replace('foo' => '0', 'bar' => 1) # Raises TypeError (no implicit conversion of Integer into String)
    ENV.to_hash # => {"bar"=>"1", "foo"=>"0"}

;T;0;;;I"replace;F;I"RBS::Unnamed::ENVClass;T;[o;;I"::Hash[::String, ::String];T;I"	self;To;;I"½ENV.update is an alias for ENV.merge!.

Adds to ENV each key/value pair in the given `hash`; returns ENV:
    ENV.replace('foo' => '0', 'bar' => '1')
    ENV.merge!('baz' => '2', 'bat' => '3') # => {"bar"=>"1", "bat"=>"3", "baz"=>"2", "foo"=>"0"}

Deletes the ENV entry for a hash value that is `nil`:
    ENV.merge!('baz' => nil, 'bat' => nil) # => {"bar"=>"1", "foo"=>"0"}

For an already-existing name, if no block given, overwrites the ENV value:
    ENV.merge!('foo' => '4') # => {"bar"=>"1", "foo"=>"4"}

For an already-existing name, if block given, yields the name, its ENV value,
and its hash value; the block's return value becomes the new name:
    ENV.merge!('foo' => '5') { |name, env_val, hash_val | env_val + hash_val } # => {"bar"=>"1", "foo"=>"45"}

Raises an exception if a name or value is invalid (see [Invalid Names and
Values](#class-ENV-label-Invalid+Names+and+Values));
    ENV.replace('foo' => '0', 'bar' => '1')
    ENV.merge!('foo' => '6', :bar => '7', 'baz' => '9') # Raises TypeError (no implicit conversion of Symbol into String)
    ENV # => {"bar"=>"1", "foo"=>"6"}
    ENV.merge!('foo' => '7', 'bar' => 8, 'baz' => '9') # Raises TypeError (no implicit conversion of Integer into String)
    ENV # => {"bar"=>"1", "foo"=>"7"}

Raises an exception if the block returns an invalid name: (see [Invalid Names
and Values](#class-ENV-label-Invalid+Names+and+Values)):
    ENV.merge!('bat' => '8', 'foo' => '9') { |name, env_val, hash_val | 10 } # Raises TypeError (no implicit conversion of Integer into String)
    ENV # => {"bar"=>"1", "bat"=>"8", "foo"=>"7"}

Note that for the exceptions above, hash pairs preceding an invalid name or
value are processed normally; those following are ignored.

;T;0;;;I"update;F;I"RBS::Unnamed::ENVClass;T;[o;;I" ::Hash[::String, ::String?];T;I"	self;To;;I" ::Hash[::String, ::String?];T;I"	self;To;;I"S(Provided for compatibility with Hash.)

Does not modify ENV; returns `nil`.

;T;0;;;I"rehash;F;I"RBS::Unnamed::ENVClass;T;[o;;I" ;F;I"nil;To;;I"½Returns the contents of ENV as an Array of 2-element Arrays, each of which is
a name/value pair:
    ENV.replace('foo' => '0', 'bar' => '1')
    ENV.to_a # => [["bar", "1"], ["foo", "0"]]

;T;0;;;I"	to_a;F;I"RBS::Unnamed::ENVClass;T;[o;;I" ;F;I""Array[[ ::String, ::String ]];To;;I"4Returns String 'ENV':
    ENV.to_s # => "ENV"

;T;0;;;I"	to_s;F;I"RBS::Unnamed::ENVClass;T;[o;;I" ;F;I"
"ENV";To;;I"Returns the name of the first environment variable with `value`, if it exists:
    ENV.replace('foo' => '0', 'bar' => '0')
    ENV.key('0') # => "foo"

The order in which environment variables are examined is OS-dependent. See
[About Ordering](#class-ENV-label-About+Ordering).

Returns `nil` if there is no such value.

Raises an exception if `value` is invalid:
    ENV.key(Object.new) # raises TypeError (no implicit conversion of Object into String)

See [Invalid Names and Values](#class-ENV-label-Invalid+Names+and+Values).

;T;0;;;I"key;F;I"RBS::Unnamed::ENVClass;T;[o;;I"::String value;T;I"String?;To;;I"ƒReturns the count of environment variables:
    ENV.replace('foo' => '0', 'bar' => '1')
    ENV.length # => 2
    ENV.size # => 2

;T;0;;;I"	size;F;I"RBS::Unnamed::ENVClass;T;[o;;I" ;F;I"Integer;To;;I"¢Returns `true` when there are no environment variables, `false` otherwise:
    ENV.clear
    ENV.empty? # => true
    ENV['foo'] = '0'
    ENV.empty? # => false

;T;0;;;I"empty?;F;I"RBS::Unnamed::ENVClass;T;[o;;I" ;F;I"	bool;To;;I" Returns all variable names in an Array:
    ENV.replace('foo' => '0', 'bar' => '1')
    ENV.keys # => ['bar', 'foo']

The order of the names is OS-dependent. See [About
Ordering](#class-ENV-label-About+Ordering).

Returns the empty Array if ENV is empty.

;T;0;;;I"	keys;F;I"RBS::Unnamed::ENVClass;T;[o;;I" ;F;I"Array[::String];To;;I"Returns all environment variable values in an Array:
    ENV.replace('foo' => '0', 'bar' => '1')
    ENV.values # => ['1', '0']

The order of the values is OS-dependent. See [About
Ordering](#class-ENV-label-About+Ordering).

Returns the empty Array if ENV is empty.

;T;0;;;I"values;F;I"RBS::Unnamed::ENVClass;T;[o;;I" ;F;I"Array[::String];To;;I"öReturns an Array containing the environment variable values associated with
the given names:
    ENV.replace('foo' => '0', 'bar' => '1', 'baz' => '2')
    ENV.values_at('foo', 'baz') # => ["0", "2"]

Returns `nil` in the Array for each name that is not an ENV name:
    ENV.values_at('foo', 'bat', 'bar', 'bam') # => ["0", nil, "1", nil]

Returns an empty Array if no names given.

Raises an exception if any name is invalid. See [Invalid Names and
Values](#class-ENV-label-Invalid+Names+and+Values).

;T;0;;;I"values_at;F;I"RBS::Unnamed::ENVClass;T;[o;;I"*::String names;T;I"Array[::String?];To;;I"ENV.has_key?, ENV.member?, and ENV.key? are aliases for ENV.include?.

Returns `true` if there is an environment variable with the given `name`:
    ENV.replace('foo' => '0', 'bar' => '1')
    ENV.include?('foo') # => true

Returns `false` if `name` is a valid String and there is no such environment
variable:
    ENV.include?('baz') # => false

Returns `false` if `name` is the empty String or is a String containing
character `'='`:
    ENV.include?('') # => false
    ENV.include?('=') # => false

Raises an exception if `name` is a String containing the NUL character `"\0"`:
    ENV.include?("\0") # Raises ArgumentError (bad environment variable name: contains null byte)

Raises an exception if `name` has an encoding that is not ASCII-compatible:
    ENV.include?("\xa1\xa1".force_encoding(Encoding::UTF_16LE))
    # Raises ArgumentError (bad environment variable name: ASCII incompatible encoding: UTF-16LE)

Raises an exception if `name` is not a String:
    ENV.include?(Object.new) # TypeError (no implicit conversion of Object into String)

;T;0;;;I"include?;F;I"RBS::Unnamed::ENVClass;T;[o;;I"::String name;T;I"	bool;To;;I"Returns `true` if `value` is the value for some environment variable name,
`false` otherwise:
    ENV.replace('foo' => '0', 'bar' => '1')
    ENV.value?('0') # => true
    ENV.has_value?('0') # => true
    ENV.value?('2') # => false
    ENV.has_value?('2') # => false

;T;0;;;I"has_value?;F;I"RBS::Unnamed::ENVClass;T;[o;;I"::String value;T;I"	bool;To;;I"”Returns a Hash containing all name/value pairs from ENV:
    ENV.replace('foo' => '0', 'bar' => '1')
    ENV.to_hash # => {"bar"=>"1", "foo"=>"0"}

;T;0;;;I"to_hash;F;I"RBS::Unnamed::ENVClass;T;[o;;I" ;F;I"Hash[::String, ::String];To;;I"Returns a 2-element Array containing the name and value of the environment
variable for `name` if it exists:
    ENV.replace('foo' => '0', 'bar' => '1')
    ENV.assoc('foo') # => ['foo', '0']

Returns `nil` if `name` is a valid String and there is no such environment
variable.

Returns `nil` if `name` is the empty String or is a String containing
character `'='`.

Raises an exception if `name` is a String containing the NUL character `"\0"`:
    ENV.assoc("\0") # Raises ArgumentError (bad environment variable name: contains null byte)

Raises an exception if `name` has an encoding that is not ASCII-compatible:
    ENV.assoc("\xa1\xa1".force_encoding(Encoding::UTF_16LE))
    # Raises ArgumentError (bad environment variable name: ASCII incompatible encoding: UTF-16LE)

Raises an exception if `name` is not a String:
    ENV.assoc(Object.new) # TypeError (no implicit conversion of Object into String)

;T;0;;;I"
assoc;F;I"RBS::Unnamed::ENVClass;T;[o;;I"::String name;T;I"[ ::String, ::String ]?;To;;I"šReturns a 2-element Array containing the name and value of the **first**
**found** environment variable that has value `value`, if one exists:
    ENV.replace('foo' => '0', 'bar' => '0')
    ENV.rassoc('0') # => ["bar", "0"]

The order in which environment variables are examined is OS-dependent. See
[About Ordering](#class-ENV-label-About+Ordering).

Returns `nil` if there is no such environment variable.

;T;0;;;I"rassoc;F;I"RBS::Unnamed::ENVClass;T;[o;;I"::String value;T;I"[ ::String, ::String ]?;To; ;0;0;	I"RBS::Unnamed::Random_Base;T;
[ ;[I"#RBS::Unnamed::Random_Formatter;T;0;[ ;[ ;0;0o;;I"ÆCreates a new PRNG using `seed` to set the initial state. If `seed` is
omitted, the generator is initialized with Random.new_seed.

See Random.srand for more information on the use of seed values.

;T;0;;;I"initialize;F;I"RBS::Unnamed::Random_Base;T;[o;;I"?::Integer seed;T;I"	void;To;;I"When `max` is an Integer, `rand` returns a random integer greater than or
equal to zero and less than `max`. Unlike Kernel.rand, when `max` is a
negative integer or zero, `rand` raises an ArgumentError.

    prng = Random.new
    prng.rand(100)       # => 42

When `max` is a Float, `rand` returns a random floating point number between
0.0 and `max`, including 0.0 and excluding `max`.

    prng.rand(1.5)       # => 1.4600282860034115

When `range` is a Range, `rand` returns a random number where
`range.member?(number) == true`.

    prng.rand(5..9)      # => one of [5, 6, 7, 8, 9]
    prng.rand(5...9)     # => one of [5, 6, 7, 8]
    prng.rand(5.0..9.0)  # => between 5.0 and 9.0, including 9.0
    prng.rand(5.0...9.0) # => between 5.0 and 9.0, excluding 9.0

Both the beginning and ending values of the range must respond to subtract
(`-`) and add (`+`)methods, or rand will raise an ArgumentError.

;T;0;;;I"	rand;F;I"RBS::Unnamed::Random_Base;T;[o;;I" ;F;I"
Float;To;;I"'::Integer | ::Range[::Integer] max;T;I"Integer;To;;I"#::Float | ::Range[::Float] max;T;I"
Float;To;;I"µReturns a random binary string containing `size` bytes.

    random_string = Random.new.bytes(10) # => "\xD7:R\xAB?\x83\xCE\xFAkO"
    random_string.size                   # => 10

;T;0;;;I"
bytes;F;I"RBS::Unnamed::Random_Base;T;[o;;I"::Integer size;T;I"String;To;;I"\Returns the seed value used to initialize the generator. This may be used to
initialize another generator with the same state at a later time, causing it
to produce the same sequence of numbers.

    prng1 = Random.new(1234)
    prng1.seed       #=> 1234
    prng1.rand(100)  #=> 47

    prng2 = Random.new(prng1.seed)
    prng2.rand(100)  #=> 47

;T;0;;;I"	seed;F;I"RBS::Unnamed::Random_Base;T;[o;;I" ;F;I"Integer;To;;I"5Generate a random number in the given range as Random does

    prng.random_number       #=> 0.5816771641321361
    prng.random_number(1000) #=> 485
    prng.random_number(1..6) #=> 3
    prng.rand                #=> 0.5816771641321361
    prng.rand(1000)          #=> 485
    prng.rand(1..6)          #=> 3

;T;0;	I"#RBS::Unnamed::Random_Formatter;T;
[ ;[ ;0;[ ;[ o;;I" Random::Formatter#base64 generates a random base64 string.

The argument *n* specifies the length, in bytes, of the random number to be
generated. The length of the result string is about 4/3 of *n*.

If *n* is not specified or is nil, 16 is assumed. It may be larger in the
future.

The result may contain A-Z, a-z, 0-9, "+", "/" and "=".

    require 'random/formatter'

    prng.base64 #=> "/2BuBuLf3+WfSKyQbRcc/A=="
    prng.base64 #=> "6BbW0pxO0YENxn38HMUbcQ=="

See RFC 3548 for the definition of base64.

;T;0;;;I"base64;F;I"#RBS::Unnamed::Random_Formatter;T;[o;;I"?::Integer? n;T;I"String;To;;I"×Random::Formatter#hex generates a random hexadecimal string.

The argument *n* specifies the length, in bytes, of the random number to be
generated. The length of the resulting hexadecimal string is twice of *n*.

If *n* is not specified or is nil, 16 is assumed. It may be larger in the
future.

The result may contain 0-9 and a-f.

    require 'random/formatter'

    prng.hex #=> "eb693ec8252cd630102fd0d0fb7c3485"
    prng.hex #=> "91dc3bfb4de5b11d029d376634589b61"

;T;0;;;I"hex;F;I"#RBS::Unnamed::Random_Formatter;T;[o;;I"?::Integer? n;T;I"String;To;;I"PGenerates formatted random number from raw random bytes. See Random#rand.

;T;0;;;I"	rand;F;I"#RBS::Unnamed::Random_Formatter;T;[o;;I" ;F;I"
Float;To;;I"?::Float? n;T;I"
Float;To;;I"?::Integer? n;T;I"Integer;To;;I"?::Numeric? n;T;I"Numeric;To;;I"?::Range[::Float]? n;T;I"
Float;To;;I"?::Range[::Integer]? n;T;I"Integer;To;;I"?::Range[::Numeric]? n;T;I"Numeric;To;;0;0;;;I"random_bytes;F;I"#RBS::Unnamed::Random_Formatter;T;[o;;I"?::Integer? n;T;I"String;To;;I"PGenerates formatted random number from raw random bytes. See Random#rand.

;T;0;;;I"random_number;F;I"#RBS::Unnamed::Random_Formatter;T;[o;;I" ;F;I"
Float;To;;I"?::Float? n;T;I"
Float;To;;I"?::Integer? n;T;I"Integer;To;;I"?::Numeric? n;T;I"Numeric;To;;I"?::Range[::Float]? n;T;I"
Float;To;;I"?::Range[::Integer]? n;T;I"Integer;To;;I"?::Range[::Numeric]? n;T;I"Numeric;To;;I"¦Random::Formatter#urlsafe_base64 generates a random URL-safe base64 string.

The argument *n* specifies the length, in bytes, of the random number to be
generated. The length of the result string is about 4/3 of *n*.

If *n* is not specified or is nil, 16 is assumed. It may be larger in the
future.

The boolean argument *padding* specifies the padding. If it is false or nil,
padding is not generated. Otherwise padding is generated. By default, padding
is not generated because "=" may be used as a URL delimiter.

The result may contain A-Z, a-z, 0-9, "-" and "_". "=" is also used if
*padding* is true.

    require 'random/formatter'

    prng.urlsafe_base64 #=> "b4GOKm4pOYU_-BOXcrUGDg"
    prng.urlsafe_base64 #=> "UZLdOkzop70Ddx-IJR0ABg"

    prng.urlsafe_base64(nil, true) #=> "i0XQ-7gglIsHGV2_BNPrdQ=="
    prng.urlsafe_base64(nil, true) #=> "-M8rLhr7JEpJlqFGUMmOxg=="

See RFC 3548 for the definition of URL-safe base64.

;T;0;;;I"urlsafe_base64;F;I"#RBS::Unnamed::Random_Formatter;T;[o;;I"&?::Integer? n, ?::boolish padding;T;I"String;To;;I"Random::Formatter#uuid generates a random v4 UUID (Universally Unique
IDentifier).

    require 'random/formatter'

    prng.uuid #=> "2d931510-d99f-494a-8c67-87feb05e1594"
    prng.uuid #=> "bad85eb9-0713-4da7-8d36-07a8e4b00eab"
    prng.uuid #=> "62936e70-1815-439b-bf89-8492855a7e6b"

The version 4 UUID is purely random (except the version). It doesn't contain
meaningful information such as MAC addresses, timestamps, etc.

The result contains 122 random bits (15.25 random bytes).

See RFC 4122 for details of UUID.

;T;0;;;I"	uuid;F;I"#RBS::Unnamed::Random_Formatter;T;[o;;I" ;F;I"String;To; ;I"—Refinement is a class of the `self` (current context) inside `refine`
statement. It allows to import methods from other modules, see
#import_methods.

;T;0;	I"Refinement;T;
[ ;[ ;0;[ ;[ ;0;I"Module;To;;I"žImports methods from modules. Unlike Module#include, Refinement#import_methods
copies methods and adds them into the refinement, so the refinement is
activated in the imported methods.

Note that due to method copying, only methods defined in Ruby code can be
imported.

    module StrUtils
      def indent(level)
        ' ' * level + self
      end
    end

    module M
      refine String do
        import_methods StrUtils
      end
    end

    using M
    "foo".indent(3)
    #=> "   foo"

    module M
      refine String do
        import_methods Enumerable
        # Can't import method which is not defined with Ruby code: Enumerable#drop
      end
    end

;T;0;;;I"import_methods;F;I"Refinement;T;[o;;I"*::Module;T;I"	self;To; ;I"voA Regexp holds a regular expression, used to match a pattern against strings.
Regexps are created using the `/.../` and `%r{...}` literals, and by the
Regexp::new constructor.

You can create a Regexp object explicitly with:

*   A [regexp literal](doc/syntax/literals_rdoc.html#label-Regexp+Literals).


Regular expressions (*regexp*s) are patterns which describe the contents of a
string. They're used for testing whether a string contains a given pattern, or
extracting the portions that match. They are created with the `/`*pat*`/` and
`%r{`*pat*`}` literals or the `Regexp.new` constructor.

A regexp is usually delimited with forward slashes (`/`). For example:

    /hay/ =~ 'haystack'   #=> 0
    /y/.match('haystack') #=> #<MatchData "y">

If a string contains the pattern it is said to *match*. A literal string
matches itself.

Here 'haystack' does not contain the pattern 'needle', so it doesn't match:

    /needle/.match('haystack') #=> nil

Here 'haystack' contains the pattern 'hay', so it matches:

    /hay/.match('haystack')    #=> #<MatchData "hay">

Specifically, `/st/` requires that the string contains the letter *s* followed
by the letter *t*, so it matches *haystack*, also.

## `=~` and Regexp#match

Pattern matching may be achieved by using `=~` operator or Regexp#match
method.

### `=~` operator

`=~` is Ruby's basic pattern-matching operator.  When one operand is a regular
expression and the other is a string then the regular expression is used as a
pattern to match against the string.  (This operator is equivalently defined
by Regexp and String so the order of String and Regexp do not matter. Other
classes may have different implementations of `=~`.)  If a match is found, the
operator returns index of first match in string, otherwise it returns `nil`.

    /hay/ =~ 'haystack'   #=> 0
    'haystack' =~ /hay/   #=> 0
    /a/   =~ 'haystack'   #=> 1
    /u/   =~ 'haystack'   #=> nil

Using `=~` operator with a String and Regexp the `$~` global variable is set
after a successful match.  `$~` holds a MatchData object. Regexp.last_match is
equivalent to `$~`.

### Regexp#match method

The #match method returns a MatchData object:

    /st/.match('haystack')   #=> #<MatchData "st">

## Metacharacters and Escapes

The following are *metacharacters* `(`, `)`, `[`, `]`, `{`, `}`, `.`, `?`,
`+`, `*`. They have a specific meaning when appearing in a pattern. To match
them literally they must be backslash-escaped. To match a backslash literally,
backslash-escape it: `\\\`.

    /1 \+ 2 = 3\?/.match('Does 1 + 2 = 3?') #=> #<MatchData "1 + 2 = 3?">
    /a\\\\b/.match('a\\\\b')                    #=> #<MatchData "a\\b">

Patterns behave like double-quoted strings and can contain the same backslash
escapes (the meaning of `\s` is different, however, see
[below](#label-Character+Classes)).

    /\s\u{6771 4eac 90fd}/.match("Go to æ±äº¬éƒ½")
        #=> #<MatchData " æ±äº¬éƒ½">

Arbitrary Ruby expressions can be embedded into patterns with the `#{...}`
construct.

    place = "æ±äº¬éƒ½"
    /#{place}/.match("Go to æ±äº¬éƒ½")
        #=> #<MatchData "æ±äº¬éƒ½">

## Character Classes

A *character class* is delimited with square brackets (`[`, `]`) and lists
characters that may appear at that point in the match. `/[ab]/` means *a* or
*b*, as opposed to `/ab/` which means *a* followed by *b*.

    /W[aeiou]rd/.match("Word") #=> #<MatchData "Word">

Within a character class the hyphen (`-`) is a metacharacter denoting an
inclusive range of characters. `[abcd]` is equivalent to `[a-d]`. A range can
be followed by another range, so `[abcdwxyz]` is equivalent to `[a-dw-z]`. The
order in which ranges or individual characters appear inside a character class
is irrelevant.

    /[0-9a-f]/.match('9f') #=> #<MatchData "9">
    /[9f]/.match('9f')     #=> #<MatchData "9">

If the first character of a character class is a caret (`^`) the class is
inverted: it matches any character *except* those named.

    /[^a-eg-z]/.match('f') #=> #<MatchData "f">

A character class may contain another character class. By itself this isn't
useful because `[a-z[0-9]]` describes the same set as `[a-z0-9]`. However,
character classes also support the `&&` operator which performs set
intersection on its arguments. The two can be combined as follows:

    /[a-w&&[^c-g]z]/ # ([a-w] AND ([^c-g] OR z))

This is equivalent to:

    /[abh-w]/

The following metacharacters also behave like character classes:

*   `/./` - Any character except a newline.
*   `/./m` - Any character (the `m` modifier enables multiline mode)
*   `/\w/` - A word character (`[a-zA-Z0-9_]`)
*   `/\W/` - A non-word character (`[^a-zA-Z0-9_]`). Please take a look at
    [Bug #4044](https://bugs.ruby-lang.org/issues/4044) if using `/\W/` with
    the `/i` modifier.
*   `/\d/` - A digit character (`[0-9]`)
*   `/\D/` - A non-digit character (`[^0-9]`)
*   `/\h/` - A hexdigit character (`[0-9a-fA-F]`)
*   `/\H/` - A non-hexdigit character (`[^0-9a-fA-F]`)
*   `/\s/` - A whitespace character: `/[ \t\r\n\f\v]/`
*   `/\S/` - A non-whitespace character: `/[^ \t\r\n\f\v]/`
*   `/\R/` - A linebreak: `\n`, `\v`, `\f`, `\r` `\u0085` (NEXT LINE),
    `\u2028` (LINE SEPARATOR), `\u2029` (PARAGRAPH SEPARATOR) or `\r\n`.


POSIX *bracket expressions* are also similar to character classes. They
provide a portable alternative to the above, with the added benefit that they
encompass non-ASCII characters. For instance, `/\d/` matches only the ASCII
decimal digits (0-9); whereas `/[[:digit:]]/` matches any character in the
Unicode *Nd* category.

*   `/[[:alnum:]]/` - Alphabetic and numeric character
*   `/[[:alpha:]]/` - Alphabetic character
*   `/[[:blank:]]/` - Space or tab
*   `/[[:cntrl:]]/` - Control character
*   `/[[:digit:]]/` - Digit
*   `/[[:graph:]]/` - Non-blank character (excludes spaces, control
    characters, and similar)
*   `/[[:lower:]]/` - Lowercase alphabetical character
*   `/[[:print:]]/` - Like [:graph:], but includes the space character
*   `/[[:punct:]]/` - Punctuation character
*   `/[[:space:]]/` - Whitespace character (`[:blank:]`, newline, carriage
    return, etc.)
*   `/[[:upper:]]/` - Uppercase alphabetical
*   `/[[:xdigit:]]/` - Digit allowed in a hexadecimal number (i.e., 0-9a-fA-F)


Ruby also supports the following non-POSIX character classes:

*   `/[[:word:]]/` - A character in one of the following Unicode general
    categories *Letter*, *Mark*, *Number*, *Connector_Punctuation*
*   `/[[:ascii:]]/` - A character in the ASCII character set

        # U+06F2 is "EXTENDED ARABIC-INDIC DIGIT TWO"
        /[[:digit:]]/.match("\u06F2")    #=> #<MatchData "\u{06F2}">
        /[[:upper:]][[:lower:]]/.match("Hello") #=> #<MatchData "He">
        /[[:xdigit:]][[:xdigit:]]/.match("A6")  #=> #<MatchData "A6">


## Repetition

The constructs described so far match a single character. They can be followed
by a repetition metacharacter to specify how many times they need to occur.
Such metacharacters are called *quantifiers*.

*   `*` - Zero or more times
*   `+` - One or more times
*   `?` - Zero or one times (optional)
*   `{`*n*`}` - Exactly *n* times
*   `{`*n*`,}` - *n* or more times
*   `{,`*m*`}` - *m* or less times
*   `{`*n*`,`*m*`}` - At least *n* and at most *m* times


At least one uppercase character ('H'), at least one lowercase character
('e'), two 'l' characters, then one 'o':

    "Hello".match(/[[:upper:]]+[[:lower:]]+l{2}o/) #=> #<MatchData "Hello">

### Greedy match

Repetition is *greedy* by default: as many occurrences as possible are matched
while still allowing the overall match to succeed. By contrast, *lazy*
matching makes the minimal amount of matches necessary for overall success.
Most greedy metacharacters can be made lazy by following them with `?`. For
the `{n}` pattern, because it specifies an exact number of characters to match
and not a variable number of characters, the `?` metacharacter instead makes
the repeated pattern optional.

Both patterns below match the string. The first uses a greedy quantifier so
'.+' matches '<a><b>'; the second uses a lazy quantifier so '.+?' matches
'<a>':

    /<.+>/.match("<a><b>")  #=> #<MatchData "<a><b>">
    /<.+?>/.match("<a><b>") #=> #<MatchData "<a>">

### Possessive match

A quantifier followed by `+` matches *possessively*: once it has matched it
does not backtrack. They behave like greedy quantifiers, but having matched
they refuse to "give up" their match even if this jeopardises the overall
match.

    /<.*><.+>/.match("<a><b>") #=> #<MatchData "<a><b>">
    /<.*+><.+>/.match("<a><b>") #=> nil
    /<.*><.++>/.match("<a><b>") #=> nil

## Capturing

Parentheses can be used for *capturing*. The text enclosed by the *n*th group
of parentheses can be subsequently referred to with *n*. Within a pattern use
the *backreference* `\n` (e.g. `\1`); outside of the pattern use
`MatchData[n]` (e.g. `MatchData[1]`).

In this example, `'at'` is captured by the first group of parentheses, then
referred to later with `\1`:

    /[csh](..) [csh]\1 in/.match("The cat sat in the hat")
        #=> #<MatchData "cat sat in" 1:"at">

Regexp#match returns a MatchData object which makes the captured text
available with its #[] method:

    /[csh](..) [csh]\1 in/.match("The cat sat in the hat")[1] #=> 'at'

While Ruby supports an arbitrary number of numbered captured groups, only
groups 1-9 are supported using the `\n` backreference syntax.

Ruby also supports `\0` as a special backreference, which references the
entire matched string.  This is also available at `MatchData[0]`.  Note that
the `\0` backreference cannot be used inside the regexp, as backreferences can
only be used after the end of the capture group, and the `\0` backreference
uses the implicit capture group of the entire match.  However, you can use
this backreference when doing substitution:

    "The cat sat in the hat".gsub(/[csh]at/, '\0s')
      # => "The cats sats in the hats"

### Named captures

Capture groups can be referred to by name when defined with the
`(?<`*name*`>)` or `(?'`*name*`')` constructs.

    /\$(?<dollars>\d+)\.(?<cents>\d+)/.match("$3.67")
        #=> #<MatchData "$3.67" dollars:"3" cents:"67">
    /\$(?<dollars>\d+)\.(?<cents>\d+)/.match("$3.67")[:dollars] #=> "3"

Named groups can be backreferenced with `\k<`*name*`>`, where *name* is the
group name.

    /(?<vowel>[aeiou]).\k<vowel>.\k<vowel>/.match('ototomy')
        #=> #<MatchData "ototo" vowel:"o">

**Note**: A regexp can't use named backreferences and numbered backreferences
simultaneously. Also, if a named capture is used in a regexp, then parentheses
used for grouping which would otherwise result in a unnamed capture are
treated as non-capturing.

    /(\w)(\w)/.match("ab").captures # => ["a", "b"]
    /(\w)(\w)/.match("ab").named_captures # => {}

    /(?<c>\w)(\w)/.match("ab").captures # => ["a"]
    /(?<c>\w)(\w)/.match("ab").named_captures # => {"c"=>"a"}

When named capture groups are used with a literal regexp on the left-hand side
of an expression and the `=~` operator, the captured text is also assigned to
local variables with corresponding names.

    /\$(?<dollars>\d+)\.(?<cents>\d+)/ =~ "$3.67" #=> 0
    dollars #=> "3"

## Grouping

Parentheses also *group* the terms they enclose, allowing them to be
quantified as one *atomic* whole.

The pattern below matches a vowel followed by 2 word characters:

    /[aeiou]\w{2}/.match("Caenorhabditis elegans") #=> #<MatchData "aen">

Whereas the following pattern matches a vowel followed by a word character,
twice, i.e. `[aeiou]\w[aeiou]\w`: 'enor'.

    /([aeiou]\w){2}/.match("Caenorhabditis elegans")
        #=> #<MatchData "enor" 1:"or">

The `(?:`...`)` construct provides grouping without capturing. That is, it
combines the terms it contains into an atomic whole without creating a
backreference. This benefits performance at the slight expense of readability.

The first group of parentheses captures 'n' and the second 'ti'. The second
group is referred to later with the backreference `\2`:

    /I(n)ves(ti)ga\2ons/.match("Investigations")
        #=> #<MatchData "Investigations" 1:"n" 2:"ti">

The first group of parentheses is now made non-capturing with '?:', so it
still matches 'n', but doesn't create the backreference. Thus, the
backreference `\1` now refers to 'ti'.

    /I(?:n)ves(ti)ga\1ons/.match("Investigations")
        #=> #<MatchData "Investigations" 1:"ti">

### Atomic Grouping

Grouping can be made *atomic* with `(?>`*pat*`)`. This causes the
subexpression *pat* to be matched independently of the rest of the expression
such that what it matches becomes fixed for the remainder of the match, unless
the entire subexpression must be abandoned and subsequently revisited. In this
way *pat* is treated as a non-divisible whole. Atomic grouping is typically
used to optimise patterns so as to prevent the regular expression engine from
backtracking needlessly.

The `"` in the pattern below matches the first character of the string, then
`.*` matches *Quote"*. This causes the overall match to fail, so the text
matched by `.*` is backtracked by one position, which leaves the final
character of the string available to match `"`

    /".*"/.match('"Quote"')     #=> #<MatchData "\"Quote\"">

If `.*` is grouped atomically, it refuses to backtrack *Quote"*, even though
this means that the overall match fails

    /"(?>.*)"/.match('"Quote"') #=> nil

## Subexpression Calls

The `\g<`*name*`>` syntax matches the previous subexpression named *name*,
which can be a group name or number, again. This differs from backreferences
in that it re-executes the group rather than simply trying to re-match the
same text.

This pattern matches a *(* character and assigns it to the `paren` group,
tries to call that the `paren` sub-expression again but fails, then matches a
literal *)*:

    /\A(?<paren>\(\g<paren>*\))*\z/ =~ '()'

    /\A(?<paren>\(\g<paren>*\))*\z/ =~ '(())' #=> 0
    # ^1
    #      ^2
    #           ^3
    #                 ^4
    #      ^5
    #           ^6
    #                      ^7
    #                       ^8
    #                       ^9
    #                           ^10

1.  Matches at the beginning of the string, i.e. before the first character.
2.  Enters a named capture group called `paren`
3.  Matches a literal *(*, the first character in the string
4.  Calls the `paren` group again, i.e. recurses back to the second step
5.  Re-enters the `paren` group
6.  Matches a literal *(*, the second character in the string
7.  Try to call `paren` a third time, but fail because doing so would prevent
    an overall successful match
8.  Match a literal *)*, the third character in the string. Marks the end of
    the second recursive call
9.  Match a literal *)*, the fourth character in the string
10. Match the end of the string


## Alternation

The vertical bar metacharacter (`|`) combines several expressions into a
single one that matches any of the expressions. Each expression is an
*alternative*.

    /\w(and|or)\w/.match("Feliformia") #=> #<MatchData "form" 1:"or">
    /\w(and|or)\w/.match("furandi")    #=> #<MatchData "randi" 1:"and">
    /\w(and|or)\w/.match("dissemblance") #=> nil

## Character Properties

The `\p{}` construct matches characters with the named property, much like
POSIX bracket classes.

*   `/\p{Alnum}/` - Alphabetic and numeric character
*   `/\p{Alpha}/` - Alphabetic character
*   `/\p{Blank}/` - Space or tab
*   `/\p{Cntrl}/` - Control character
*   `/\p{Digit}/` - Digit
*   `/\p{Graph}/` - Non-blank character (excludes spaces, control characters,
    and similar)
*   `/\p{Lower}/` - Lowercase alphabetical character
*   `/\p{Print}/` - Like `\p{Graph}`, but includes the space character
*   `/\p{Punct}/` - Punctuation character
*   `/\p{Space}/` - Whitespace character (`[:blank:]`, newline, carriage
    return, etc.)
*   `/\p{Upper}/` - Uppercase alphabetical
*   `/\p{XDigit}/` - Digit allowed in a hexadecimal number (i.e., 0-9a-fA-F)
*   `/\p{Word}/` - A member of one of the following Unicode general category
    *Letter*, *Mark*, *Number*, *Connector_Punctuation*
*   `/\p{ASCII}/` - A character in the ASCII character set
*   `/\p{Any}/` - Any Unicode character (including unassigned characters)
*   `/\p{Assigned}/` - An assigned character


A Unicode character's *General Category* value can also be matched with
`\p{`*Ab*`}` where *Ab* is the category's abbreviation as described below:

*   `/\p{L}/` - 'Letter'
*   `/\p{Ll}/` - 'Letter: Lowercase'
*   `/\p{Lm}/` - 'Letter: Mark'
*   `/\p{Lo}/` - 'Letter: Other'
*   `/\p{Lt}/` - 'Letter: Titlecase'
*   `/\p{Lu}/` - 'Letter: Uppercase
*   `/\p{Lo}/` - 'Letter: Other'
*   `/\p{M}/` - 'Mark'
*   `/\p{Mn}/` - 'Mark: Nonspacing'
*   `/\p{Mc}/` - 'Mark: Spacing Combining'
*   `/\p{Me}/` - 'Mark: Enclosing'
*   `/\p{N}/` - 'Number'
*   `/\p{Nd}/` - 'Number: Decimal Digit'
*   `/\p{Nl}/` - 'Number: Letter'
*   `/\p{No}/` - 'Number: Other'
*   `/\p{P}/` - 'Punctuation'
*   `/\p{Pc}/` - 'Punctuation: Connector'
*   `/\p{Pd}/` - 'Punctuation: Dash'
*   `/\p{Ps}/` - 'Punctuation: Open'
*   `/\p{Pe}/` - 'Punctuation: Close'
*   `/\p{Pi}/` - 'Punctuation: Initial Quote'
*   `/\p{Pf}/` - 'Punctuation: Final Quote'
*   `/\p{Po}/` - 'Punctuation: Other'
*   `/\p{S}/` - 'Symbol'
*   `/\p{Sm}/` - 'Symbol: Math'
*   `/\p{Sc}/` - 'Symbol: Currency'
*   `/\p{Sc}/` - 'Symbol: Currency'
*   `/\p{Sk}/` - 'Symbol: Modifier'
*   `/\p{So}/` - 'Symbol: Other'
*   `/\p{Z}/` - 'Separator'
*   `/\p{Zs}/` - 'Separator: Space'
*   `/\p{Zl}/` - 'Separator: Line'
*   `/\p{Zp}/` - 'Separator: Paragraph'
*   `/\p{C}/` - 'Other'
*   `/\p{Cc}/` - 'Other: Control'
*   `/\p{Cf}/` - 'Other: Format'
*   `/\p{Cn}/` - 'Other: Not Assigned'
*   `/\p{Co}/` - 'Other: Private Use'
*   `/\p{Cs}/` - 'Other: Surrogate'


Lastly, `\p{}` matches a character's Unicode *script*. The following scripts
are supported: *Arabic*, *Armenian*, *Balinese*, *Bengali*, *Bopomofo*,
*Braille*, *Buginese*, *Buhid*, *Canadian_Aboriginal*, *Carian*, *Cham*,
*Cherokee*, *Common*, *Coptic*, *Cuneiform*, *Cypriot*, *Cyrillic*, *Deseret*,
*Devanagari*, *Ethiopic*, *Georgian*, *Glagolitic*, *Gothic*, *Greek*,
*Gujarati*, *Gurmukhi*, *Han*, *Hangul*, *Hanunoo*, *Hebrew*, *Hiragana*,
*Inherited*, *Kannada*, *Katakana*, *Kayah_Li*, *Kharoshthi*, *Khmer*, *Lao*,
*Latin*, *Lepcha*, *Limbu*, *Linear_B*, *Lycian*, *Lydian*, *Malayalam*,
*Mongolian*, *Myanmar*, *New_Tai_Lue*, *Nko*, *Ogham*, *Ol_Chiki*,
*Old_Italic*, *Old_Persian*, *Oriya*, *Osmanya*, *Phags_Pa*, *Phoenician*,
*Rejang*, *Runic*, *Saurashtra*, *Shavian*, *Sinhala*, *Sundanese*,
*Syloti_Nagri*, *Syriac*, *Tagalog*, *Tagbanwa*, *Tai_Le*, *Tamil*, *Telugu*,
*Thaana*, *Thai*, *Tibetan*, *Tifinagh*, *Ugaritic*, *Vai*, and *Yi*.

Unicode codepoint U+06E9 is named "ARABIC PLACE OF SAJDAH" and belongs to the
Arabic script:

    /\p{Arabic}/.match("\u06E9") #=> #<MatchData "\u06E9">

All character properties can be inverted by prefixing their name with a caret
(`^`).

Letter 'A' is not in the Unicode Ll (Letter; Lowercase) category, so this
match succeeds:

    /\p{^Ll}/.match("A") #=> #<MatchData "A">

## Anchors

Anchors are metacharacter that match the zero-width positions between
characters, *anchoring* the match to a specific position.

*   `^` - Matches beginning of line
*   `$` - Matches end of line
*   `\A` - Matches beginning of string.
*   `\Z` - Matches end of string. If string ends with a newline, it matches
    just before newline
*   `\z` - Matches end of string
*   `\G` - Matches first matching position:

    In methods like `String#gsub` and `String#scan`, it changes on each
    iteration. It initially matches the beginning of subject, and in each
    following iteration it matches where the last match finished.

        "    a b c".gsub(/ /, '_')    #=> "____a_b_c"
        "    a b c".gsub(/\G /, '_')  #=> "____a b c"

    In methods like `Regexp#match` and `String#match` that take an (optional)
    offset, it matches where the search begins.

        "hello, world".match(/,/, 3)    #=> #<MatchData ",">
        "hello, world".match(/\G,/, 3)  #=> nil

*   `\b` - Matches word boundaries when outside brackets; backspace (0x08)
    when inside brackets
*   `\B` - Matches non-word boundaries
*   `(?=`*pat*`)` - *Positive lookahead* assertion: ensures that the following
    characters match *pat*, but doesn't include those characters in the
    matched text
*   `(?!`*pat*`)` - *Negative lookahead* assertion: ensures that the following
    characters do not match *pat*, but doesn't include those characters in the
    matched text
*   `(?<=`*pat*`)` - *Positive lookbehind* assertion: ensures that the
    preceding characters match *pat*, but doesn't include those characters in
    the matched text
*   `(?<!`*pat*`)` - *Negative lookbehind* assertion: ensures that the
    preceding characters do not match *pat*, but doesn't include those
    characters in the matched text
*   `\K` - Uses an positive lookbehind of the content preceding `\K` in the
    regexp.  For example, the following two regexps are almost equivalent:

        /ab\Kc/
        /(?<=ab)c/

    As are the following two regexps:

        /(a)\K(b)\Kc/
        /(?<=(?<=(a))(b))c/


If a pattern isn't anchored it can begin at any point in the string:

    /real/.match("surrealist") #=> #<MatchData "real">

Anchoring the pattern to the beginning of the string forces the match to start
there. 'real' doesn't occur at the beginning of the string, so now the match
fails:

    /\Areal/.match("surrealist") #=> nil

The match below fails because although 'Demand' contains 'and', the pattern
does not occur at a word boundary.

    /\band/.match("Demand")

Whereas in the following example 'and' has been anchored to a non-word
boundary so instead of matching the first 'and' it matches from the fourth
letter of 'demand' instead:

    /\Band.+/.match("Supply and demand curve") #=> #<MatchData "and curve">

The pattern below uses positive lookahead and positive lookbehind to match
text appearing in  tags without including the tags in the match:

    /(?<=<b>)\w+(?=<\/b>)/.match("Fortune favours the <b>bold</b>")
        #=> #<MatchData "bold">

## Options

The end delimiter for a regexp can be followed by one or more single-letter
options which control how the pattern can match.

*   `/pat/i` - Ignore case
*   `/pat/m` - Treat a newline as a character matched by `.`
*   `/pat/x` - Ignore whitespace and comments in the pattern
*   `/pat/o` - Perform `#{}` interpolation only once


`i`, `m`, and `x` can also be applied on the subexpression level with the
`(?`*on*`-`*off*`)` construct, which enables options *on*, and disables
options *off* for the expression enclosed by the parentheses:

    /a(?i:b)c/.match('aBc')   #=> #<MatchData "aBc">
    /a(?-i:b)c/i.match('ABC') #=> nil

Additionally, these options can also be toggled for the remainder of the
pattern:

    /a(?i)bc/.match('abC') #=> #<MatchData "abC">

Options may also be used with `Regexp.new`:

    Regexp.new("abc", Regexp::IGNORECASE)                     #=> /abc/i
    Regexp.new("abc", Regexp::MULTILINE)                      #=> /abc/m
    Regexp.new("abc # Comment", Regexp::EXTENDED)             #=> /abc # Comment/x
    Regexp.new("abc", Regexp::IGNORECASE | Regexp::MULTILINE) #=> /abc/mi

## Free-Spacing Mode and Comments

As mentioned above, the `x` option enables *free-spacing* mode. Literal white
space inside the pattern is ignored, and the octothorpe (`#`) character
introduces a comment until the end of the line. This allows the components of
the pattern to be organized in a potentially more readable fashion.

A contrived pattern to match a number with optional decimal places:

    float_pat = /\A
        [[:digit:]]+ # 1 or more digits before the decimal point
        (\.          # Decimal point
            [[:digit:]]+ # 1 or more digits after the decimal point
        )? # The decimal point and following digits are optional
    \Z/x
    float_pat.match('3.14') #=> #<MatchData "3.14" 1:".14">

There are a number of strategies for matching whitespace:

*   Use a pattern such as `\s` or `\p{Space}`.
*   Use escaped whitespace such as `\ `, i.e. a space preceded by a backslash.
*   Use a character class such as `[ ]`.


Comments can be included in a non-`x` pattern with the `(?#`*comment*`)`
construct, where *comment* is arbitrary text ignored by the regexp engine.

Comments in regexp literals cannot include unescaped terminator characters.

## Encoding

Regular expressions are assumed to use the source encoding. This can be
overridden with one of the following modifiers.

*   `/`*pat*`/u` - UTF-8
*   `/`*pat*`/e` - EUC-JP
*   `/`*pat*`/s` - Windows-31J
*   `/`*pat*`/n` - ASCII-8BIT


A regexp can be matched against a string when they either share an encoding,
or the regexp's encoding is *US-ASCII* and the string's encoding is
ASCII-compatible.

If a match between incompatible encodings is attempted an
`Encoding::CompatibilityError` exception is raised.

The `Regexp#fixed_encoding?` predicate indicates whether the regexp has a
*fixed* encoding, that is one incompatible with ASCII. A regexp's encoding can
be explicitly fixed by supplying `Regexp::FIXEDENCODING` as the second
argument of `Regexp.new`:

    r = Regexp.new("a".force_encoding("iso-8859-1"),Regexp::FIXEDENCODING)
    r =~ "a\u3042"
       # raises Encoding::CompatibilityError: incompatible encoding regexp match
       #         (ISO-8859-1 regexp with UTF-8 string)

## Special global variables

Pattern matching sets some global variables :
*   `$~` is equivalent to Regexp.last_match;
*   `$&` contains the complete matched text;
*   `$`` contains string before match;
*   `$'` contains string after match;
*   `$1`, `$2` and so on contain text matching first, second, etc capture
    group;
*   `$+` contains last capture group.


Example:

    m = /s(\w{2}).*(c)/.match('haystack') #=> #<MatchData "stac" 1:"ta" 2:"c">
    $~                                    #=> #<MatchData "stac" 1:"ta" 2:"c">
    Regexp.last_match                     #=> #<MatchData "stac" 1:"ta" 2:"c">

    $&      #=> "stac"
            # same as m[0]
    $`      #=> "hay"
            # same as m.pre_match
    $'      #=> "k"
            # same as m.post_match
    $1      #=> "ta"
            # same as m[1]
    $2      #=> "c"
            # same as m[2]
    $3      #=> nil
            # no third group in pattern
    $+      #=> "c"
            # same as m[-1]

These global variables are thread-local and method-local variables.

## Performance

Certain pathological combinations of constructs can lead to abysmally bad
performance.

Consider a string of 25 *a*s, a *d*, 4 *a*s, and a *c*.

    s = 'a' * 25 + 'd' + 'a' * 4 + 'c'
    #=> "aaaaaaaaaaaaaaaaaaaaaaaaadaaaac"

The following patterns match instantly as you would expect:

    /(b|a)/ =~ s #=> 0
    /(b|a+)/ =~ s #=> 0
    /(b|a+)*/ =~ s #=> 0

However, the following pattern takes appreciably longer:

    /(b|a+)*c/ =~ s #=> 26

This happens because an atom in the regexp is quantified by both an immediate
`+` and an enclosing `*` with nothing to differentiate which is in control of
any particular character. The nondeterminism that results produces
super-linear performance. (Consult *Mastering Regular Expressions* (3rd ed.),
pp 222, by *Jeffery Friedl*, for an in-depth analysis). This particular case
can be fixed by use of atomic grouping, which prevents the unnecessary
backtracking:

    (start = Time.now) && /(b|a+)*c/ =~ s && (Time.now - start)
       #=> 24.702736882
    (start = Time.now) && /(?>b|a+)*c/ =~ s && (Time.now - start)
       #=> 0.000166571

A similar case is typified by the following example, which takes approximately
60 seconds to execute for me:

Match a string of 29 *a*s against a pattern of 29 optional *a*s followed by 29
mandatory *a*s:

    Regexp.new('a?' * 29 + 'a' * 29) =~ 'a' * 29

The 29 optional *a*s match the string, but this prevents the 29 mandatory *a*s
that follow from matching. Ruby must then backtrack repeatedly so as to
satisfy as many of the optional matches as it can while still matching the
mandatory 29. It is plain to us that none of the optional matches can succeed,
but this fact unfortunately eludes Ruby.

The best way to improve performance is to significantly reduce the amount of
backtracking needed.  For this case, instead of individually matching 29
optional *a*s, a range of optional *a*s can be matched all at once with
*a{0,29}*:

    Regexp.new('a{0,29}' + 'a' * 29) =~ 'a' * 29

;T;0;	I"Regexp;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"¨Constructs a new regular expression from `pattern`, which can be either a
String or a Regexp (in which case that regexp's options are propagated), and
new options may not be specified (a change as of Ruby 1.8).

If `options` is an Integer, it should be one or more of the constants
Regexp::EXTENDED, Regexp::IGNORECASE, and Regexp::MULTILINE, *or*-ed together.
 Otherwise, if `options` is not `nil` or `false`, the regexp will be case
insensitive.

    r1 = Regexp.new('^a-z+:\\s+\w+') #=> /^a-z+:\s+\w+/
    r2 = Regexp.new('cat', true)     #=> /cat/i
    r3 = Regexp.new(r2)              #=> /cat/i
    r4 = Regexp.new('dog', Regexp::EXTENDED | Regexp::IGNORECASE) #=> /dog/ix

;T;0;;;I"initialize;F;I"Regexp;T;[o;;I"G::String string, ?::Integer | nil | false options, ?::String kcode;T;I"Object;To;;I"::Regexp regexp;T;I"	void;To;;I"Escapes any characters that would have special meaning in a regular
expression. Returns a new escaped string with the same or compatible encoding.
For any string, `Regexp.new(Regexp.escape(*str*))=~*str`* will be true.

    Regexp.escape('\*?{}.')   #=> \\\*\?\{\}\.

;T;0;;;I"escape;F;I"Regexp;T;[o;;I"::String | ::Symbol str;T;I"String;To;;I"MThe first form returns the MatchData object generated by the last successful
pattern match.  Equivalent to reading the special global variable `$~` (see
Special global variables in Regexp for details).

The second form returns the *n*th field in this MatchData object. *n* can be a
string or symbol to reference a named capture.

Note that the last_match is local to the thread and method scope of the method
that did the pattern match.

    /c(.)t/ =~ 'cat'        #=> 0
    Regexp.last_match       #=> #<MatchData "cat" 1:"a">
    Regexp.last_match(0)    #=> "cat"
    Regexp.last_match(1)    #=> "a"
    Regexp.last_match(2)    #=> nil

    /(?<lhs>\w+)\s*=\s*(?<rhs>\w+)/ =~ "var = val"
    Regexp.last_match       #=> #<MatchData "var = val" lhs:"var" rhs:"val">
    Regexp.last_match(:lhs) #=> "var"
    Regexp.last_match(:rhs) #=> "val"

;T;0;;;I"last_match;F;I"Regexp;T;[o;;I" ;F;I"MatchData?;To;;I"::Integer n;T;I"String?;To;;I"::Symbol | ::String n;T;I"String?;To;;I"Escapes any characters that would have special meaning in a regular
expression. Returns a new escaped string with the same or compatible encoding.
For any string, `Regexp.new(Regexp.escape(*str*))=~*str`* will be true.

    Regexp.escape('\*?{}.')   #=> \\\*\?\{\}\.

;T;0;;;I"
quote;F;I"Regexp;T;[o;;I"::String | ::Symbol str;T;I"String;To;;I"vTry to convert *obj* into a Regexp, using to_regexp method. Returns converted
regexp or nil if *obj* cannot be converted for any reason.

    Regexp.try_convert(/re/)         #=> /re/
    Regexp.try_convert("re")         #=> nil

    o = Object.new
    Regexp.try_convert(o)            #=> nil
    def o.to_regexp() /foo/ end
    Regexp.try_convert(o)            #=> /foo/

;T;0;;;I"try_convert;F;I"Regexp;T;[o;;I"untyped obj;T;I"Regexp?;To;;I"Return a Regexp object that is the union of the given *pattern*s, i.e., will
match any of its parts. The *pattern*s can be Regexp objects, in which case
their options will be preserved, or Strings. If no patterns are given, returns
`/(?!)/`.  The behavior is unspecified if any given *pattern* contains
capture.

    Regexp.union                         #=> /(?!)/
    Regexp.union("penzance")             #=> /penzance/
    Regexp.union("a+b*c")                #=> /a\+b\*c/
    Regexp.union("skiing", "sledding")   #=> /skiing|sledding/
    Regexp.union(["skiing", "sledding"]) #=> /skiing|sledding/
    Regexp.union(/dogs/, /cats/i)        #=> /(?-mix:dogs)|(?i-mx:cats)/

Note: the arguments for ::union will try to be converted into a regular
expression literal via #to_regexp.

;T;0;;;I"
union;F;I"Regexp;T;[o;;I" ;F;I"Regexp;To;;I"8::String | ::Regexp pat1, *::String | ::Regexp pat2;T;I"Regexp;To;;I"!::Array[::String | ::Regexp];T;I"Regexp;To;;I"Equality---Two regexps are equal if their patterns are identical, they have
the same character set code, and their `casefold?` values are the same.

    /abc/  == /abc/x   #=> false
    /abc/  == /abc/i   #=> false
    /abc/  == /abc/u   #=> false
    /abc/u == /abc/n   #=> false

;T;0;;;I"==;F;I"Regexp;T;[o;;I"untyped other;T;I"	bool;To;;I"˜Case Equality---Used in case statements.

    a = "HELLO"
    case a
    when /\A[a-z]*\z/; print "Lower case\n"
    when /\A[A-Z]*\z/; print "Upper case\n"
    else;              print "Mixed case\n"
    end
    #=> "Upper case"

Following a regular expression literal with the #=== operator allows you to
compare against a String.

    /^[a-z]*$/ === "HELLO" #=> false
    /^[A-Z]*$/ === "HELLO" #=> true

;T;0;;;I"===;F;I"Regexp;T;[o;;I"untyped other;T;I"	bool;To;;I"çMatch---Matches *rxp* against *str*.

    /at/ =~ "input data"   #=> 7
    /ax/ =~ "input data"   #=> nil

If `=~` is used with a regexp literal with named captures, captured strings
(or nil) is assigned to local variables named by the capture names.

    /(?<lhs>\w+)\s*=\s*(?<rhs>\w+)/ =~ "  x = y  "
    p lhs    #=> "x"
    p rhs    #=> "y"

If it is not matched, nil is assigned for the variables.

    /(?<lhs>\w+)\s*=\s*(?<rhs>\w+)/ =~ "  x = "
    p lhs    #=> nil
    p rhs    #=> nil

This assignment is implemented in the Ruby parser. The parser detects
'regexp-literal =~ expression' for the assignment. The regexp must be a
literal without interpolation and placed at left hand side.

The assignment does not occur if the regexp is not a literal.

    re = /(?<lhs>\w+)\s*=\s*(?<rhs>\w+)/
    re =~ "  x = y  "
    p lhs    # undefined local variable
    p rhs    # undefined local variable

A regexp interpolation, `#{}`, also disables the assignment.

    rhs_pat = /(?<rhs>\w+)/
    /(?<lhs>\w+)\s*=\s*#{rhs_pat}/ =~ "x = y"
    p lhs    # undefined local variable

The assignment does not occur if the regexp is placed at the right hand side.

    "  x = y  " =~ /(?<lhs>\w+)\s*=\s*(?<rhs>\w+)/
    p lhs, rhs # undefined local variable

;T;0;;;I"=~;F;I"Regexp;T;[o;;I"::String? str;T;I"Integer?;To;;I"£Returns the value of the case-insensitive flag.

    /a/.casefold?           #=> false
    /a/i.casefold?          #=> true
    /(?i:a)/.casefold?      #=> false

;T;0;;;I"casefold?;F;I"Regexp;T;[o;;I" ;F;I"	bool;To;;I"GReturns the Encoding object that represents the encoding of obj.

;T;0;;;I"encoding;F;I"Regexp;T;[o;;I" ;F;I"Encoding;To;;I"Equality---Two regexps are equal if their patterns are identical, they have
the same character set code, and their `casefold?` values are the same.

    /abc/  == /abc/x   #=> false
    /abc/  == /abc/i   #=> false
    /abc/  == /abc/u   #=> false
    /abc/u == /abc/n   #=> false

;T;0;;;I"	eql?;F;I"Regexp;T;[o;;I"untyped other;T;I"	bool;To;;I")Returns false if rxp is applicable to a string with any ASCII compatible
encoding. Returns true otherwise.

    r = /a/
    r.fixed_encoding?                               #=> false
    r =~ "\u{6666} a"                               #=> 2
    r =~ "\xa1\xa2 a".force_encoding("euc-jp")      #=> 2
    r =~ "abc".force_encoding("euc-jp")             #=> 0

    r = /a/u
    r.fixed_encoding?                               #=> true
    r.encoding                                      #=> #<Encoding:UTF-8>
    r =~ "\u{6666} a"                               #=> 2
    r =~ "\xa1\xa2".force_encoding("euc-jp")        #=> Encoding::CompatibilityError
    r =~ "abc".force_encoding("euc-jp")             #=> 0

    r = /\u{6666}/
    r.fixed_encoding?                               #=> true
    r.encoding                                      #=> #<Encoding:UTF-8>
    r =~ "\u{6666} a"                               #=> 0
    r =~ "\xa1\xa2".force_encoding("euc-jp")        #=> Encoding::CompatibilityError
    r =~ "abc".force_encoding("euc-jp")             #=> nil

;T;0;;;I"fixed_encoding?;F;I"Regexp;T;[o;;I" ;F;I"	bool;To;;I"fProduce a hash based on the text and options of this regular expression.

See also Object#hash.

;T;0;;;I"	hash;F;I"Regexp;T;[o;;I" ;F;I"Integer;To;;I"ÉProduce a nicely formatted string-version of *rxp*. Perhaps surprisingly,
`#inspect` actually produces the more natural version of the string than
`#to_s`.

    /ab+c/ix.inspect        #=> "/ab+c/ix"

;T;0;;;I"inspect;F;I"Regexp;T;[o;;I" ;F;I"String;To;;I"©Returns a MatchData object describing the match, or `nil` if there was no
match. This is equivalent to retrieving the value of the special variable `$~`
following a normal match.  If the second parameter is present, it specifies
the position in the string to begin the search.

    /(.)(.)(.)/.match("abc")[2]   #=> "b"
    /(.)(.)/.match("abc", 1)[2]   #=> "c"

If a block is given, invoke the block with MatchData if match succeed, so that
you can write

    /M(.*)/.match("Matz") do |m|
      puts m[0]
      puts m[1]
    end

instead of

    if m = /M(.*)/.match("Matz")
      puts m[0]
      puts m[1]
    end

The return value is a value from block execution in this case.

;T;0;;;I"
match;F;I"Regexp;T;[o;;I"8::String? | ::Symbol | ::_ToStr str, ?::Integer pos;T;I"MatchData?;To;;I"8::String? | ::Symbol | ::_ToStr str, ?::Integer pos;T;I"T?;To;;I"xReturns `true` or `false` to indicate whether the regexp is matched or not
without updating $~ and other related variables. If the second parameter is
present, it specifies the position in the string to begin the search.

    /R.../.match?("Ruby")    #=> true
    /R.../.match?("Ruby", 1) #=> false
    /P.../.match?("Ruby")    #=> false
    $&                       #=> nil

;T;0;;;I"match?;F;I"Regexp;T;[o;;I"8::String? | ::Symbol | ::_ToStr str, ?::Integer pos;T;I"	bool;To;;I"ÅReturns a hash representing information about named captures of *rxp*.

A key of the hash is a name of the named captures. A value of the hash is an
array which is list of indexes of corresponding named captures.

    /(?<foo>.)(?<bar>.)/.named_captures
    #=> {"foo"=>[1], "bar"=>[2]}

    /(?<foo>.)(?<foo>.)/.named_captures
    #=> {"foo"=>[1, 2]}

If there are no named captures, an empty hash is returned.

    /(.)(.)/.named_captures
    #=> {}

;T;0;;;I"named_captures;F;I"Regexp;T;[o;;I" ;F;I"'Hash[::String, ::Array[::Integer]];To;;I"ÓReturns a list of names of captures as an array of strings.

    /(?<foo>.)(?<bar>.)(?<baz>.)/.names
    #=> ["foo", "bar", "baz"]

    /(?<foo>.)(?<foo>.)/.names
    #=> ["foo"]

    /(.)(.)/.names
    #=> []

;T;0;;;I"
names;F;I"Regexp;T;[o;;I" ;F;I"Array[::String];To;;I"¼Returns the set of bits corresponding to the options used when creating this
Regexp (see Regexp::new for details. Note that additional bits may be set in
the returned options: these are used internally by the regular expression
code. These extra bits are ignored if the options are passed to Regexp::new.

    Regexp::IGNORECASE                  #=> 1
    Regexp::EXTENDED                    #=> 2
    Regexp::MULTILINE                   #=> 4

    /cat/.options                       #=> 0
    /cat/ix.options                     #=> 3
    Regexp.new('cat', true).options     #=> 1
    /\xa1\xa2/e.options                 #=> 16

    r = /cat/ix
    Regexp.new(r.source, r.options)     #=> /cat/ix

;T;0;;;I"options;F;I"Regexp;T;[o;;I" ;F;I"Integer;To;;I"¢Returns the original string of the pattern.

    /ab+c/ix.source #=> "ab+c"

Note that escape sequences are retained as is.

    /\x20\+/.source  #=> "\\x20\\+"

;T;0;;;I"source;F;I"Regexp;T;[o;;I" ;F;I"String;To;;I"¶Returns a string containing the regular expression and its options (using the
`(?opts:source)` notation. This string can be fed back in to Regexp::new to a
regular expression with the same semantics as the original. (However,
`Regexp#==` may not return true when comparing the two, as the source of the
regular expression itself may differ, as the example shows).  Regexp#inspect
produces a generally more readable version of *rxp*.

    r1 = /ab+c/ix           #=> /ab+c/ix
    s1 = r1.to_s            #=> "(?ix-m:ab+c)"
    r2 = Regexp.new(s1)     #=> /(?ix-m:ab+c)/
    r1 == r2                #=> false
    r1.source               #=> "ab+c"
    r2.source               #=> "(?ix-m:ab+c)"

;T;0;;;I"	to_s;F;I"Regexp;T;[o;;I" ;F;I"String;To;;I"|Match---Matches *rxp* against the contents of `$_`. Equivalent to *`rxp* =~
$_`.

    $_ = "input data"
    ~ /at/   #=> 7

;T;0;;;I"~;F;I"Regexp;T;[o;;I" ;F;I"Integer?;To;;0;0;;;I"initialize_copy;F;I"Regexp;T;[o;;I"self object;T;I"	self;To; ;0;0;	I"Regexp;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"‡Deserializes JSON string by constructing new Regexp object with source `s`
(Regexp or String) and options `o` serialized by `to_json`

;T;0;;;I"json_create;F;I"Regexp;T;[o;;I"2::Hash[::String, ::String | ::Integer] object;T;I"instance;To;;I"XReturns a hash, that will be turned into a JSON object and represent this
object.

;T;0;;;I"as_json;F;I"Regexp;T;[o;;I"*untyped;T;I")Hash[::String, ::String | ::Integer];To;;I"cStores class name (Regexp) with options `o` and source `s` (Regexp or String)
as JSON string

;T;0;;;I"to_json;F;I"Regexp;T;[o;;I"?::JSON::State state;T;I"String;To; ;I"gThe RubyVM module only exists on MRI. `RubyVM` is not defined in other Ruby
implementations such as JRuby and TruffleRuby.

The RubyVM module provides some access to MRI internals. This module is for
very limited purposes, such as debugging, prototyping, and research.  Normal
users must not use it. This module is not portable between Ruby
implementations.

;T;0;	I"RubyVM;T;
[ ;[ ;0;[ ;[ ;0;I"Object;To; ;I"’The InstructionSequence class represents a compiled sequence of instructions
for the Virtual Machine used in MRI. Not all implementations of Ruby may
implement this class, and for the implementations that implement it, the
methods defined and behavior of the methods can change in any version.

With it, you can get a handle to the instructions that make up a method or a
proc, compile strings of Ruby code down to VM instructions, and disassemble
instruction sequences to strings for easy inspection. It is mostly useful if
you want to learn how YARV works, but it also lets you control various
settings for the Ruby iseq compiler.

You can find the source for the VM instructions in `insns.def` in the Ruby
source.

The instruction sequence results will almost certainly change as Ruby changes,
so example output in this documentation may be different from what you see.

Of course, this class is MRI specific.

;T;0;	I" RubyVM::InstructionSequence;T;
[ ;[ ;0;[ ;[ ;0;I"Object;To;;I"æMany operating systems allow signals to be sent to running processes. Some
signals have a defined effect on the process, while others may be trapped at
the code level and acted upon. For example, your process may trap the USR1
signal and use it to toggle debugging, and may use TERM to initiate a
controlled shutdown.

    pid = fork do
      Signal.trap("USR1") do
        $debug = !$debug
        puts "Debug now: #$debug"
      end
      Signal.trap("TERM") do
        puts "Terminating..."
        shutdown()
      end
      # . . . do some work . . .
    end

    Process.detach(pid)

    # Controlling program:
    Process.kill("USR1", pid)
    # ...
    Process.kill("USR1", pid)
    # ...
    Process.kill("TERM", pid)

produces:
     Debug now: true
     Debug now: false
    Terminating...

The list of available signal names and their interpretation is system
dependent. Signal delivery semantics may also vary between systems; in
particular signal delivery may not always be reliable.

;T;0;	I"Signal;T;
[ ;[ ;0;[ ;[ o;;I"óReturns a list of signal names mapped to the corresponding underlying signal
numbers.

    Signal.list   #=> {"EXIT"=>0, "HUP"=>1, "INT"=>2, "QUIT"=>3, "ILL"=>4, "TRAP"=>5, "IOT"=>6, "ABRT"=>6, "FPE"=>8, "KILL"=>9, "BUS"=>7, "SEGV"=>11, "SYS"=>31, "PIPE"=>13, "ALRM"=>14, "TERM"=>15, "URG"=>23, "STOP"=>19, "TSTP"=>20, "CONT"=>18, "CHLD"=>17, "CLD"=>17, "TTIN"=>21, "TTOU"=>22, "IO"=>29, "XCPU"=>24, "XFSZ"=>25, "VTALRM"=>26, "PROF"=>27, "WINCH"=>28, "USR1"=>10, "USR2"=>12, "PWR"=>30, "POLL"=>29}

;T;0;;;I"	list;F;I"Signal;T;[o;;I" ;F;I"Hash[::String, ::Integer];To;;I"ÏConvert signal number to signal name. Returns `nil` if the signo is an invalid
signal number.

    Signal.trap("INT") { |signo| puts Signal.signame(signo) }
    Process.kill("INT", 0)

*produces:*

    INT

;T;0;;;I"signame;F;I"Signal;T;[o;;I"::Integer arg0;T;I"String?;To;;I"
Specifies the handling of signals. The first parameter is a signal name (a
string such as ``SIGALRM'', ``SIGUSR1'', and so on) or a signal number. The
characters ``SIG'' may be omitted from the signal name. The command or block
specifies code to be run when the signal is raised. If the command is the
string ``IGNORE'' or ``SIG_IGN'', the signal will be ignored. If the command
is ``DEFAULT'' or ``SIG_DFL'', the Ruby's default handler will be invoked. If
the command is ``EXIT'', the script will be terminated by the signal. If the
command is ``SYSTEM_DEFAULT'', the operating system's default handler will be
invoked. Otherwise, the given command or block will be run. The special signal
name ``EXIT'' or signal number zero will be invoked just prior to program
termination. trap returns the previous handler for the given signal.

    Signal.trap(0, proc { puts "Terminating: #{$$}" })
    Signal.trap("CLD")  { puts "Child died" }
    fork && Process.wait

produces:
    Terminating: 27461
    Child died
    Terminating: 27460

;T;0;;;I"	trap;F;I"Signal;T;[o;;I"=::Integer | ::String | ::Symbol signal, ?untyped command;T;I"String | ::Proc;To;;I"+::Integer | ::String | ::Symbol signal;T;I"String | ::Proc;To; ;I"mIA String object has an arbitrary sequence of bytes, typically representing
text or binary data. A String object may be created using String::new or as
literals.

String objects differ from Symbol objects in that Symbol objects are designed
to be used as identifiers, instead of text or data.

You can create a String object explicitly with:

*   A [string literal](doc/syntax/literals_rdoc.html#label-String+Literals).
*   A [heredoc
    literal](doc/syntax/literals_rdoc.html#label-Here+Document+Literals).


You can convert certain objects to Strings with:

*   Method [String](Kernel.html#method-i-String).


Some String methods modify `self`. Typically, a method whose name ends with
`!` modifies `self` and returns `self`; often a similarly named method
(without the `!`) returns a new string.

In general, if there exist both bang and non-bang version of method, the bang!
mutates and the non-bang! does not. However, a method without a bang can also
mutate, such as String#replace.

## Substitution Methods

These methods perform substitutions:

*   String#sub: One substitution (or none); returns a new string.
*   String#sub!: One substitution (or none); returns `self`.
*   String#gsub: Zero or more substitutions; returns a new string.
*   String#gsub!: Zero or more substitutions; returns `self`.


Each of these methods takes:

*   A first argument, `pattern` (string or regexp), that specifies the
    substring(s) to be replaced.

*   Either of these:

    *   A second argument, `replacement` (string or hash), that determines the
        replacing string.
    *   A block that will determine the replacing string.



The examples in this section mostly use methods String#sub and String#gsub;
the principles illustrated apply to all four substitution methods.

**Argument `pattern`**

Argument `pattern` is commonly a regular expression:

    s = 'hello'
    s.sub(/[aeiou]/, '*')  # => "h*llo"
    s.gsub(/[aeiou]/, '*') # => "h*ll*"
    s.gsub(/[aeiou]/, '')  # => "hll"
    s.sub(/ell/, 'al')     # => "halo"
    s.gsub(/xyzzy/, '*')   # => "hello"
    'THX1138'.gsub(/\d+/, '00') # => "THX00"

When `pattern` is a string, all its characters are treated as ordinary
characters (not as regexp special characters):

    'THX1138'.gsub('\d+', '00') # => "THX1138"

**\String `replacement`**

If `replacement` is a string, that string will determine the replacing string
that is to be substituted for the matched text.

Each of the examples above uses a simple string as the replacing string.

String `replacement` may contain back-references to the pattern's captures:

*   `\n` (*n* a non-negative integer) refers to `$n`.
*   `\k<name>` refers to the named capture `name`.


See regexp.rdoc for details.

Note that within the string `replacement`, a character combination such as
`$&` is treated as ordinary text, and not as a special match variable.
However, you may refer to some special match variables using these
combinations:

*   `\&` and `\0` correspond to `$&`, which contains the complete matched
    text.
*   `\'` corresponds to `$'`, which contains string after match.
*   `\`` corresponds to `$``, which contains string before match.
*   `+` corresponds to `$+`, which contains last capture group.


See regexp.rdoc for details.

Note that `\\\` is interpreted as an escape, i.e., a single backslash.

Note also that a string literal consumes backslashes. See [String
Literals](doc/syntax/literals_rdoc.html#label-String+Literals) for details
about string literals.

A back-reference is typically preceded by an additional backslash. For
example, if you want to write a back-reference `\&` in `replacement` with a
double-quoted string literal, you need to write `"..\\\\&.."`.

If you want to write a non-back-reference string `\&` in `replacement`, you
need first to escape the backslash to prevent this method from interpreting it
as a back-reference, and then you need to escape the backslashes again to
prevent a string literal from consuming them: `"..\\\\\\\\&.."`.

You may want to use the block form to avoid a lot of backslashes.

**\Hash `replacement`**

If argument `replacement` is a hash, and `pattern` matches one of its keys,
the replacing string is the value for that key:

    h = {'foo' => 'bar', 'baz' => 'bat'}
    'food'.sub('foo', h) # => "bard"

Note that a symbol key does not match:

    h = {foo: 'bar', baz: 'bat'}
    'food'.sub('foo', h) # => "d"

**Block**

In the block form, the current match string is passed to the block; the
block's return value becomes the replacing string:

     s = '@'
    '1234'.gsub(/\d/) {|match| s.succ! } # => "ABCD"

Special match variables such as `$1`, `$2`, `$``, `$&`, and `$'` are set
appropriately.

## What's Here

First, what's elsewhere. Class String:

*   Inherits from [class
    Object](Object.html#class-Object-label-What-27s+Here).
*   Includes [module
    Comparable](Comparable.html#module-Comparable-label-What-27s+Here).


Here, class String provides methods that are useful for:

*   [Creating a String](#class-String-label-Methods+for+Creating+a+String)
*   [Frozen/Unfrozen
    Strings](#class-String-label-Methods+for+a+Frozen-2FUnfrozen+String)
*   [Querying](#class-String-label-Methods+for+Querying)
*   [Comparing](#class-String-label-Methods+for+Comparing)
*   [Modifying a String](#class-String-label-Methods+for+Modifying+a+String)
*   [Converting to New
    String](#class-String-label-Methods+for+Converting+to+New+String)
*   [Converting to
    Non-String](#class-String-label-Methods+for+Converting+to+Non--5CString)
*   [Iterating](#class-String-label-Methods+for+Iterating)


### Methods for Creating a String

    ::new
:       Returns a new string.

    ::try_convert
:       Returns a new string created from a given object.



### Methods for a Frozen/Unfrozen String

    [#+string](#method-i-2B-40)
:       Returns a string that is not frozen: `self`, if not frozen; `self.dup`
        otherwise.

    [#-string](#method-i-2D-40)
:       Returns a string that is frozen: `self`, if already frozen;
        `self.freeze` otherwise.

    #freeze
:       Freezes `self`, if not already frozen; returns `self`.



### Methods for Querying

*Counts*

    #length, #size
:       Returns the count of characters (not bytes).

    #empty?
:       Returns `true` if `self.length` is zero; `false` otherwise.

    #bytesize
:       Returns the count of bytes.

    #count
:       Returns the count of substrings matching given strings.



*Substrings*

    [#=~](#method-i-3D~)
:       Returns the index of the first substring that matches a given Regexp
        or other object; returns `nil` if no match is found.

    #index
:       Returns the index of the *first* occurrence of a given substring;
        returns `nil` if none found.

    #rindex
:       Returns the index of the *last* occurrence of a given substring;
        returns `nil` if none found.

    #include?
:       Returns `true` if the string contains a given substring; `false`
        otherwise.

    #match
:       Returns a MatchData object if the string matches a given Regexp; `nil`
        otherwise.

    #match?
:       Returns `true` if the string matches a given Regexp; `false`
        otherwise.

    #start_with?
:       Returns `true` if the string begins with any of the given substrings.

    #end_with?
:       Returns `true` if the string ends with any of the given substrings.



*Encodings*

    #encoding
:       Returns the Encoding object that represents the encoding of the
        string.

    #unicode_normalized?
:       Returns `true` if the string is in Unicode normalized form; `false`
        otherwise.

    #valid_encoding?
:       Returns `true` if the string contains only characters that are valid
        for its encoding.

    #ascii_only?
:       Returns `true` if the string has only ASCII characters; `false`
        otherwise.



*Other*

    #sum
:       Returns a basic checksum for the string: the sum of each byte.

    #hash
:       Returns the integer hash code.



### Methods for Comparing

    [#==, #===](#method-i-3D-3D)
:       Returns `true` if a given other string has the same content as `self`.

    #eql?
:       Returns `true` if the content is the same as the given other string.

    [#<=>](#method-i-3C-3D-3E)
:       Returns -1, 0, or 1 as a given other string is smaller than, equal to,
        or larger than `self`.

    #casecmp
:       Ignoring case, returns -1, 0, or 1 as a given other string is smaller
        than, equal to, or larger than `self`.

    #casecmp?
:       Returns `true` if the string is equal to a given string after Unicode
        case folding; `false` otherwise.



### Methods for Modifying a String

Each of these methods modifies `self`.

*Insertion*

    #insert
:       Returns `self` with a given string inserted at a given offset.

    #<<
:       Returns `self` concatenated with a given string or integer.



*Substitution*

    #sub!
:       Replaces the first substring that matches a given pattern with a given
        replacement string; returns `self` if any changes, `nil` otherwise.

    #gsub!
:       Replaces each substring that matches a given pattern with a given
        replacement string; returns `self` if any changes, `nil` otherwise.

    #succ!, #next!
:       Returns `self` modified to become its own successor.

    #replace
:       Returns `self` with its entire content replaced by a given string.

    #reverse!
:       Returns `self` with its characters in reverse order.

    #setbyte
:       Sets the byte at a given integer offset to a given value; returns the
        argument.

    #tr!
:       Replaces specified characters in `self` with specified replacement
        characters; returns `self` if any changes, `nil` otherwise.

    #tr_s!
:       Replaces specified characters in `self` with specified replacement
        characters, removing duplicates from the substrings that were
        modified; returns `self` if any changes, `nil` otherwise.



*Casing*

    #capitalize!
:       Upcases the initial character and downcases all others; returns `self`
        if any changes, `nil` otherwise.

    #downcase!
:       Downcases all characters; returns `self` if any changes, `nil`
        otherwise.

    #upcase!
:       Upcases all characters; returns `self` if any changes, `nil`
        otherwise.

    #swapcase!
:       Upcases each downcase character and downcases each upcase character;
        returns `self` if any changes, `nil` otherwise.



*Encoding*

    #encode!
:       Returns `self` with all characters transcoded from one given encoding
        into another.

    #unicode_normalize!
:       Unicode-normalizes `self`; returns `self`.

    #scrub!
:       Replaces each invalid byte with a given character; returns `self`.

    #force_encoding
:       Changes the encoding to a given encoding; returns `self`.



*Deletion*

    #clear
:       Removes all content, so that `self` is empty; returns `self`.

    #slice!, #[]=
:       Removes a substring determined by a given index, start/length, range,
        regexp, or substring.

    #squeeze!
:       Removes contiguous duplicate characters; returns `self`.

    #delete!
:       Removes characters as determined by the intersection of substring
        arguments.

    #lstrip!
:       Removes leading whitespace; returns `self` if any changes, `nil`
        otherwise.

    #rstrip!
:       Removes trailing whitespace; returns `self` if any changes, `nil`
        otherwise.

    #strip!
:       Removes leading and trailing whitespace; returns `self` if any
        changes, `nil` otherwise.

    #chomp!
:       Removes trailing record separator, if found; returns `self` if any
        changes, `nil` otherwise.

    #chop!
:       Removes trailing whitespace if found, otherwise removes the last
        character; returns `self` if any changes, `nil` otherwise.



### Methods for Converting to New String

Each of these methods returns a new String based on `self`, often just a
modified copy of `self`.

*Extension*

    #*
:       Returns the concatenation of multiple copies of `self`,

    #+
:       Returns the concatenation of `self` and a given other string.

    #center
:       Returns a copy of `self` centered between pad substring.

    #concat
:       Returns the concatenation of `self` with given other strings.

    #prepend
:       Returns the concatenation of a given other string with `self`.

    #ljust
:       Returns a copy of `self` of a given length, right-padded with a given
        other string.

    #rjust
:       Returns a copy of `self` of a given length, left-padded with a given
        other string.



*Encoding*

    #b
:       Returns a copy of `self` with ASCII-8BIT encoding.

    #scrub
:       Returns a copy of `self` with each invalid byte replaced with a given
        character.

    #unicode_normalize
:       Returns a copy of `self` with each character Unicode-normalized.

    #encode
:       Returns a copy of `self` with all characters transcoded from one given
        encoding into another.



*Substitution*

    #dump
:       Returns a copy of +self with all non-printing characters replaced by
        xHH notation and all special characters escaped.

    #undump
:       Returns a copy of +self with all `\xNN` notation replace by `\uNNNN`
        notation and all escaped characters unescaped.

    #sub
:       Returns a copy of `self` with the first substring matching a given
        pattern replaced with a given replacement string;.

    #gsub
:       Returns a copy of `self` with each substring that matches a given
        pattern replaced with a given replacement string.

    #succ, #next
:       Returns the string that is the successor to `self`.

    #reverse
:       Returns a copy of `self` with its characters in reverse order.

    #tr
:       Returns a copy of `self` with specified characters replaced with
        specified replacement characters.

    #tr_s
:       Returns a copy of `self` with specified characters replaced with
        specified replacement characters, removing duplicates from the
        substrings that were modified.

    #%
:       Returns the string resulting from formatting a given object into
        `self`



*Casing*

    #capitalize
:       Returns a copy of `self` with the first character upcased and all
        other characters downcased.

    #downcase
:       Returns a copy of `self` with all characters downcased.

    #upcase
:       Returns a copy of `self` with all characters upcased.

    #swapcase
:       Returns a copy of `self` with all upcase characters downcased and all
        downcase characters upcased.



*Deletion*

    #delete
:       Returns a copy of `self` with characters removed

    #delete_prefix
:       Returns a copy of `self` with a given prefix removed.

    #delete_suffix
:       Returns a copy of `self` with a given suffix removed.

    #lstrip
:       Returns a copy of `self` with leading whitespace removed.

    #rstrip
:       Returns a copy of `self` with trailing whitespace removed.

    #strip
:       Returns a copy of `self` with leading and trailing whitespace removed.

    #chomp
:       Returns a copy of `self` with a trailing record separator removed, if
        found.

    #chop
:       Returns a copy of `self` with trailing whitespace or the last
        character removed.

    #squeeze
:       Returns a copy of `self` with contiguous duplicate characters removed.

    #[], #slice
:       Returns a substring determined by a given index, start/length, or
        range, or string.

    #byteslice
:       Returns a substring determined by a given index, start/length, or
        range.

    #chr
:       Returns the first character.



*Duplication*

    #to_s, $to_str
:       If `self` is a subclass of String, returns `self` copied into a
        String; otherwise, returns `self`.



### Methods for Converting to Non-String

Each of these methods converts the contents of `self` to a non-String.

*Characters, Bytes, and Clusters*

    #bytes
:       Returns an array of the bytes in `self`.

    #chars
:       Returns an array of the characters in `self`.

    #codepoints
:       Returns an array of the integer ordinals in `self`.

    #getbyte
:       Returns an integer byte as determined by a given index.

    #grapheme_clusters
:       Returns an array of the grapheme clusters in `self`.



*Splitting*

    #lines
:       Returns an array of the lines in `self`, as determined by a given
        record separator.

    #partition
:       Returns a 3-element array determined by the first substring that
        matches a given substring or regexp,

    #rpartition
:       Returns a 3-element array determined by the last substring that
        matches a given substring or regexp,

    #split
:       Returns an array of substrings determined by a given delimiter --
        regexp or string -- or, if a block given, passes those substrings to
        the block.



*Matching*

    #scan
:       Returns an array of substrings matching a given regexp or string, or,
        if a block given, passes each matching substring to the  block.

    #unpack
:       Returns an array of substrings extracted from `self` according to a
        given format.

    #unpack1
:       Returns the first substring extracted from `self` according to a given
        format.



*Numerics*

    #hex
:       Returns the integer value of the leading characters, interpreted as
        hexadecimal digits.

    #oct
:       Returns the integer value of the leading characters, interpreted as
        octal digits.

    #ord
:       Returns the integer ordinal of the first character in `self`.

    #to_i
:       Returns the integer value of leading characters, interpreted as an
        integer.

    #to_f
:       Returns the floating-point value of leading characters, interpreted as
        a floating-point number.



*Strings and Symbols*

    #inspect
:       Returns copy of `self`, enclosed in double-quotes, with special
        characters escaped.

    #to_sym, #intern
:       Returns the symbol corresponding to `self`.



### Methods for Iterating

    #each_byte
:       Calls the given block with each successive byte in `self`.

    #each_char
:       Calls the given block with each successive character in `self`.

    #each_codepoint
:       Calls the given block with each successive integer codepoint in
        `self`.

    #each_grapheme_cluster
:       Calls the given block with each successive grapheme cluster in `self`.

    #each_line
:       Calls the given block with each successive line in `self`, as
        determined by a given record separator.

    #upto
:       Calls the given block with each string value returned by successive
        calls to #succ.

;T;0;	I"String;T;
[ ;[I"Comparable;T;0;[ ;[ ;0;0o;;I"If `object` is a String object, returns `object`.

Otherwise if `object` responds to `:to_str`, calls `object.to_str` and returns
the result.

Returns `nil` if `object` does not respond to `:to_str`.

Raises an exception unless `object.to_str` returns a String object.

;T;0;;;I"try_convert;F;I"String;T;[o;;I"untyped obj;T;I"String?;To;;I"ëReturns the result of formatting `object` into the format specification `self`
(see Kernel#sprintf for formatting details):

    "%05d" % 123 # => "00123"

If `self` contains multiple substitutions, `object` must be an Array or Hash
containing the values to be substituted:

    "%-5s: %016x" % [ "ID", self.object_id ] # => "ID   : 00002b054ec93168"
    "foo = %{foo}" % {foo: 'bar'} # => "foo = bar"
    "foo = %{foo}, baz = %{baz}" % {foo: 'bar', baz: 'bat'} # => "foo = bar, baz = bat"

;T;0;;;I"%;F;I"String;T;[o;;I"::Hash[::Symbol, untyped];T;I"String;To;;I"::Array[untyped];T;I"String;To;;I"untyped arg;T;I"String;To;;I"}Returns a new String containing `integer` copies of `self`:

    "Ho! " * 3 # => "Ho! Ho! Ho! "
    "Ho! " * 0 # => ""

;T;0;;;I"*;F;I"String;T;[o;;I"::int n;T;I"String;To;;I"~Returns a new String containing `other_string` concatenated to `self`:

    "Hello from " + self.to_s # => "Hello from main"

;T;0;;;I"+;F;I"String;T;[o;;I"::string other_str;T;I"String;To;;I"cReturns `self` if `self` is not frozen.

Otherwise. returns `self.dup`, which is not frozen.

;T;0;;;I"+@;F;I"String;T;[o;;I" ;F;I"String;To;;I"¥Returns a frozen, possibly pre-existing copy of the string.

The returned String will be deduplicated as long as it does not have any
instance variables set on it.

;T;0;;;I"-@;F;I"String;T;[o;;I" ;F;I"String;To;;I"QConcatenates `object` to `self` and returns `self`:

    s = 'foo'
    s << 'bar' # => "foobar"
    s          # => "foobar"

If `object` is an Integer, the value is considered a codepoint and converted
to a character before concatenation:

    s = 'foo'
    s << 33 # => "foo!"

Related: String#concat, which takes multiple arguments.

;T;0;;;I"<<;F;I"String;T;[o;;I"*::string | ::Integer str_or_codepoint;T;I"String;To;;I"mCompares `self` and `other_string`, returning:

*   -1 if `other_string` is larger.
*   0 if the two are equal.
*   1 if `other_string` is smaller.
*   `nil` if the two are incomparable.


Examples:

    'foo' <=> 'foo' # => 0
    'foo' <=> 'food' # => -1
    'food' <=> 'foo' # => 1
    'FOO' <=> 'foo' # => -1
    'foo' <=> 'FOO' # => 1
    'foo' <=> 1 # => nil

;T;0;;;I"<=>;F;I"String;T;[o;;I"::string other;T;I"Integer;To;;I"untyped other;T;I"Integer?;To;;I"»Returns `true` if `object` has the same length and content; as `self`; `false`
otherwise:

    s = 'foo'
    s == 'foo' # => true
    s == 'food' # => false
    s == 'FOO' # => false

Returns `false` if the two strings' encodings are not compatible:
    "\u{e4 f6 fc}".encode("ISO-8859-1") == ("\u{c4 d6 dc}") # => false

If `object` is not an instance of String but responds to `to_str`, then the
two strings are compared using `object.==`.

;T;0;;;I"==;F;I"String;T;[o;;I"untyped obj;T;I"	bool;To;;I"»Returns `true` if `object` has the same length and content; as `self`; `false`
otherwise:

    s = 'foo'
    s == 'foo' # => true
    s == 'food' # => false
    s == 'FOO' # => false

Returns `false` if the two strings' encodings are not compatible:
    "\u{e4 f6 fc}".encode("ISO-8859-1") == ("\u{c4 d6 dc}") # => false

If `object` is not an instance of String but responds to `to_str`, then the
two strings are compared using `object.==`.

;T;0;;;I"===;F;I"String;T;[o;;I"untyped obj;T;I"	bool;To;;I"›Returns the Integer index of the first substring that matches the given
`regexp`, or `nil` if no match found:

    'foo' =~ /f/ # => 0
    'foo' =~ /o/ # => 1
    'foo' =~ /x/ # => nil

Note: also updates [Regexp-related global
variables](Regexp.html#class-Regexp-label-Special+global+variables).

If the given `object` is not a Regexp, returns the value returned by `object
=~ self`.

Note that `string =~ regexp` is different from `regexp =~ string` (see
[Regexp#=~](https://ruby-doc.org/core-2.7.1/Regexp.html#method-i-3D-7E)):

    number= nil
    "no. 9" =~ /(?<number>\d+)/
    number # => nil (not assigned)
    /(?<number>\d+)/ =~ "no. 9"
    number #=> "9"

;T;0;;;I"=~;F;I"String;T;[o;;I"untyped obj;T;I"Integer?;To;;I"?	Returns the substring of `self` specified by the arguments.

When the single Integer argument `index` is given, returns the 1-character
substring found in `self` at offset `index`:

    'bar'[2] # => "r"

Counts backward from the end of `self` if `index` is negative:

    'foo'[-3] # => "f"

Returns `nil` if `index` is out of range:

    'foo'[3] # => nil
    'foo'[-4] # => nil

When the two Integer arguments  `start` and `length` are given, returns the
substring of the given `length` found in `self` at offset `start`:

    'foo'[0, 2] # => "fo"
    'foo'[0, 0] # => ""

Counts backward from the end of `self` if `start` is negative:

    'foo'[-2, 2] # => "oo"

Special case: returns a new empty String if `start` is equal to the length of
`self`:

    'foo'[3, 2] # => ""

Returns `nil` if `start` is out of range:

    'foo'[4, 2] # => nil
    'foo'[-4, 2] # => nil

Returns the trailing substring of `self` if `length` is large:

    'foo'[1, 50] # => "oo"

Returns `nil` if `length` is negative:

    'foo'[0, -1] # => nil

When the single Range argument `range` is given, derives `start` and `length`
values from the given `range`, and returns values as above:

*   `'foo'[0..1]` is equivalent to `'foo'[0, 2]`.
*   `'foo'[0...1]` is equivalent to `'foo'[0, 1]`.


When the Regexp argument `regexp` is given, and the `capture` argument is `0`,
returns the first matching substring found in `self`, or `nil` if none found:

    'foo'[/o/] # => "o"
    'foo'[/x/] # => nil
    s = 'hello there'
    s[/[aeiou](.)\1/] # => "ell"
    s[/[aeiou](.)\1/, 0] # => "ell"

If argument `capture` is given and not `0`, it should be either an Integer
capture group index or a String or Symbol capture group name; the method call
returns only the specified capture (see [Regexp
Capturing](Regexp.html#class-Regexp-label-Capturing)):

    s = 'hello there'
    s[/[aeiou](.)\1/, 1] # => "l"
    s[/(?<vowel>[aeiou])(?<non_vowel>[^aeiou])/, "non_vowel"] # => "l"
    s[/(?<vowel>[aeiou])(?<non_vowel>[^aeiou])/, :vowel] # => "e"

If an invalid capture group index is given, `nil` is returned.  If an invalid
capture group name is given, `IndexError` is raised.

When the single String argument `substring` is given, returns the substring
from `self` if found, otherwise `nil`:

    'foo'['oo'] # => "oo"
    'foo'['xx'] # => nil

String#slice is an alias for String#[].

;T;0;;;I"[];F;I"String;T;[o;;I"::int index;T;I"String?;To;;I"::int start, ::int length;T;I"String?;To;;I"3::Range[::Integer] | ::Range[::Integer?] range;T;I"String?;To;;I"::Regexp regexp;T;I"String?;To;;I".::Regexp regexp, ::int | ::String capture;T;I"String?;To;;I"::String match_str;T;I"String?;To;;I"þElement Assignment---Replaces some or all of the content of *str*. The portion
of the string affected is determined using the same criteria as String#[]. If
the replacement string is not the same length as the text it is replacing, the
string will be adjusted accordingly. If the regular expression or string is
used as the index doesn't match a position in the string, IndexError is
raised. If the regular expression form is used, the optional second Integer
allows you to specify which portion of the match to replace (effectively using
the MatchData indexing rules. The forms that take an Integer will raise an
IndexError if the value is out of range; the Range form will raise a
RangeError, and the Regexp and String will raise an IndexError on negative
match.

;T;0;;;I"[]=;F;I"String;T;[o;;I" ::int pos, ::String new_str;T;I"String;To;;I"5::int begin_pos, ::int end_pos, ::String new_str;T;I"String;To;;I"E::Range[::Integer] | ::Range[::Integer?] range, ::String new_str;T;I"String;To;;I"&::Regexp regexp, ::String new_str;T;I"String;To;;I"5::Regexp regexp, ::int capture, ::String new_str;T;I"String;To;;I"5::Regexp regexp, ::String name, ::String new_str;T;I"String;To;;I")::String other_str, ::String new_str;T;I"String;To;;I"¾Returns true for a string which has only ASCII characters.

    "abc".force_encoding("UTF-8").ascii_only?          #=> true
    "abc\u{6666}".force_encoding("UTF-8").ascii_only?  #=> false

;T;0;;;I"ascii_only?;F;I"String;T;[o;;I" ;F;I"	bool;To;;I"<Returns a copied string whose encoding is ASCII-8BIT.

;T;0;;;I"b;F;I"String;T;[o;;I" ;F;I"String;To;;I"¥Returns an array of bytes in *str*.  This is a shorthand for
`str.each_byte.to_a`.

If a block is given, which is a deprecated form, works the same as
`each_byte`.

;T;0;;;I"
bytes;F;I"String;T;[o;;I" ;F;I"Array[::Integer];To;;I" ;F;I"String;To;;I"Returns the count  of bytes in `self`:

    "\x80\u3042".bytesize # => 4
    "hello".bytesize # => 5

Related: String#length.

;T;0;;;I"bytesize;F;I"String;T;[o;;I" ;F;I"Integer;To;;I"•Returns a substring of `self`, or `nil` if the substring cannot be
constructed.

With integer arguments `index` and `length` given, returns the substring
beginning at the given `index` of the given `length` (if possible), or `nil`
if `length` is negative or `index` falls outside of `self`:

    s = '0123456789' # => "0123456789"
    s.byteslice(2)   # => "2"
    s.byteslice(200) # => nil
    s.byteslice(4, 3)  # => "456"
    s.byteslice(4, 30) # => "456789"
    s.byteslice(4, -1) # => nil
    s.byteslice(40, 2) # => nil

In either case above, counts backwards from the end of `self` if `index` is
negative:

    s = '0123456789'   # => "0123456789"
    s.byteslice(-4)    # => "6"
    s.byteslice(-4, 3) # => "678"

With Range argument `range` given, returns `byteslice(range.begin,
range.size)`:

    s = '0123456789'    # => "0123456789"
    s.byteslice(4..6)   # => "456"
    s.byteslice(-6..-4) # => "456"
    s.byteslice(5..2)   # => "" # range.size is zero.
    s.byteslice(40..42) # => nil

In all cases, a returned string has the same encoding as `self`:

    s.encoding              # => #<Encoding:UTF-8>
    s.byteslice(4).encoding # => #<Encoding:UTF-8>

;T;0;;;I"byteslice;F;I"String;T;[o;;I"::int start, ?::int length;T;I"String?;To;;I"3::Range[::Integer] | ::Range[::Integer?] range;T;I"String?;To;;I"XReturns a string containing the characters in `self`; the first character is
upcased; the remaining characters are downcased:

    s = 'hello World!' # => "hello World!"
    s.capitalize       # => "Hello world!"

The casing may be affected by the given `options`; see [Case
Mapping](doc/case_mapping_rdoc.html).

Related: String#capitalize!.

;T;0;;;I"capitalize;F;I"String;T;[	o;;I" ;F;I"String;To;;I"#:ascii | :lithuanian | :turkic;T;I"String;To;;I":lithuanian, :turkic;T;I"String;To;;I":turkic, :lithuanian;T;I"String;To;;I"©Upcases the first character in `self`; downcases the remaining characters;
returns `self` if any changes were made, `nil` otherwise:

    s = 'hello World!' # => "hello World!"
    s.capitalize!      # => "Hello world!"
    s                  # => "Hello world!"
    s.capitalize!      # => nil

The casing may be affected by the given `options`; see [Case
Mapping](doc/case_mapping_rdoc.html).

Related: String#capitalize.

;T;0;;;I"capitalize!;F;I"String;T;[	o;;I" ;F;I"String?;To;;I"#:ascii | :lithuanian | :turkic;T;I"String?;To;;I":lithuanian, :turkic;T;I"String?;To;;I":turkic, :lithuanian;T;I"String?;To;;I"øCompares `self.downcase` and `other_string.downcase`; returns:

*   -1 if `other_string.downcase` is larger.
*   0 if the two are equal.
*   1 if `other_string.downcase` is smaller.
*   `nil` if the two are incomparable.


Examples:

    'foo'.casecmp('foo') # => 0
    'foo'.casecmp('food') # => -1
    'food'.casecmp('foo') # => 1
    'FOO'.casecmp('foo') # => 0
    'foo'.casecmp('FOO') # => 0
    'foo'.casecmp(1) # => nil

See [Case Mapping](doc/case_mapping_rdoc.html).

Related: String#casecmp?.

;T;0;;;I"casecmp;F;I"String;T;[o;;I"untyped other;T;I"Integer?;To;;I"½Returns `true` if `self` and `other_string` are equal after Unicode case
folding, otherwise `false`:

    'foo'.casecmp?('foo') # => true
    'foo'.casecmp?('food') # => false
    'food'.casecmp?('foo') # => false
    'FOO'.casecmp?('foo') # => true
    'foo'.casecmp?('FOO') # => true

Returns `nil` if the two values are incomparable:

    'foo'.casecmp?(1) # => nil

See [Case Mapping](doc/case_mapping_rdoc.html).

Related: String#casecmp.

;T;0;;;I"casecmp?;F;I"String;T;[o;;I"untyped other;T;I"
bool?;To;;I"XCenters `str` in `width`.  If `width` is greater than the length of `str`,
returns a new String of length `width` with `str` centered and padded with
`padstr`; otherwise, returns `str`.

    "hello".center(4)         #=> "hello"
    "hello".center(20)        #=> "       hello        "
    "hello".center(20, '123') #=> "1231231hello12312312"

;T;0;;;I"center;F;I"String;T;[o;;I""::int width, ?::string padstr;T;I"String;To;;I"ªReturns an array of characters in *str*.  This is a shorthand for
`str.each_char.to_a`.

If a block is given, which is a deprecated form, works the same as
`each_char`.

;T;0;;;I"
chars;F;I"String;T;[o;;I" ;F;I"Array[::String];To;;I" ;F;I"String;To;;I"Returns a new String with the given record separator removed from the end of
*str* (if present). If `$/` has not been changed from the default Ruby record
separator, then `chomp` also removes carriage return characters (that is, it
will remove `\n`, `\r`, and `\r\n`). If `$/` is an empty string, it will
remove all trailing newlines from the string.

    "hello".chomp                #=> "hello"
    "hello\n".chomp              #=> "hello"
    "hello\r\n".chomp            #=> "hello"
    "hello\n\r".chomp            #=> "hello\n"
    "hello\r".chomp              #=> "hello"
    "hello \n there".chomp       #=> "hello \n there"
    "hello".chomp("llo")         #=> "he"
    "hello\r\n\r\n".chomp('')    #=> "hello"
    "hello\r\n\r\r\n".chomp('')  #=> "hello\r\n\r"

;T;0;;;I"
chomp;F;I"String;T;[o;;I"?::string separator;T;I"String;To;;I"vModifies *str* in place as described for String#chomp, returning *str*, or
`nil` if no modifications were made.

;T;0;;;I"chomp!;F;I"String;T;[o;;I"?::string separator;T;I"String?;To;;I"ÜReturns a new String with the last character removed.  If the string ends with
`\r\n`, both characters are removed. Applying `chop` to an empty string
returns an empty string. String#chomp is often a safer alternative, as it
leaves the string unchanged if it doesn't end in a record separator.

    "string\r\n".chop   #=> "string"
    "string\n\r".chop   #=> "string\n"
    "string\n".chop     #=> "string"
    "string".chop       #=> "strin"
    "x".chop.chop       #=> ""

;T;0;;;I"	chop;F;I"String;T;[o;;I" ;F;I"String;To;;I"{Processes *str* as for String#chop, returning *str*, or `nil` if *str* is the
empty string.  See also String#chomp!.

;T;0;;;I"
chop!;F;I"String;T;[o;;I" ;F;I"String?;To;;I"rReturns a string containing the first character of `self`:

    s = 'foo' # => "foo"
    s.chr     # => "f"

;T;0;;;I"chr;F;I"String;T;[o;;I" ;F;I"String;To;;I"VRemoves the contents of `self`:

    s = 'foo' # => "foo"
    s.clear   # => ""

;T;0;;;I"
clear;F;I"String;T;[o;;I" ;F;I"String;To;;I"ÐReturns an array of the Integer ordinals of the characters in *str*.  This is
a shorthand for `str.each_codepoint.to_a`.

If a block is given, which is a deprecated form, works the same as
`each_codepoint`.

;T;0;;;I"codepoints;F;I"String;T;[o;;I" ;F;I"Array[::Integer];To;;I" ;F;I"String;To;;I"°Concatenates each object in `objects` to `self` and returns `self`:

    s = 'foo'
    s.concat('bar', 'baz') # => "foobarbaz"
    s                      # => "foobarbaz"

For each given object `object` that is an Integer, the value is considered a
codepoint and converted to a character before concatenation:

    s = 'foo'
    s.concat(32, 'bar', 32, 'baz') # => "foo bar baz"

Related: String#<<, which takes a single argument.

;T;0;;;I"concat;F;I"String;T;[o;;I"+*::string | ::Integer str_or_codepoint;T;I"String;To;;I"IEach `other_str` parameter defines a set of characters to count.  The
intersection of these sets defines the characters to count in `str`.  Any
`other_str` that starts with a caret `^` is negated.  The sequence `c1-c2`
means all characters between c1 and c2.  The backslash character `\` can be
used to escape `^` or `-` and is otherwise ignored unless it appears at the
end of a sequence or the end of a `other_str`.

    a = "hello world"
    a.count "lo"                   #=> 5
    a.count "lo", "o"              #=> 2
    a.count "hello", "^l"          #=> 4
    a.count "ej-m"                 #=> 4

    "hello^world".count "\\^aeiou" #=> 4
    "hello-world".count "a\\-eo"   #=> 4

    c = "hello world\\r\\n"
    c.count "\\"                   #=> 2
    c.count "\\A"                  #=> 0
    c.count "X-\\w"                #=> 3

;T;0;;;I"
count;F;I"String;T;[o;;I"-::string other_str, *::string other_strs;T;I"Integer;To;;I"K	Returns the string generated by calling `crypt(3)` standard library function
with `str` and `salt_str`, in this order, as its arguments.  Please do not use
this method any longer.  It is legacy; provided only for backward
compatibility with ruby scripts in earlier days.  It is bad to use in
contemporary programs for several reasons:

*   Behaviour of C's `crypt(3)` depends on the OS it is run.  The generated
    string lacks data portability.

*   On some OSes such as Mac OS, `crypt(3)` never fails (i.e. silently ends up
    in unexpected results).

*   On some OSes such as Mac OS, `crypt(3)` is not thread safe.

*   So-called "traditional" usage of `crypt(3)` is very very very weak.
    According to its manpage, Linux's traditional `crypt(3)` output has only
    2**56 variations; too easy to brute force today.  And this is the default
    behaviour.

*   In order to make things robust some OSes implement so-called "modular"
    usage. To go through, you have to do a complex build-up of the `salt_str`
    parameter, by hand. Failure in generation of a proper salt string tends
    not to yield any errors; typos in parameters are normally not detectable.

    *   For instance, in the following example, the second invocation of
        String#crypt is wrong; it has a typo in "round=" (lacks "s").  However
        the call does not fail and something unexpected is generated.

            "foo".crypt("$5$rounds=1000$salt$") # OK, proper usage
            "foo".crypt("$5$round=1000$salt$")  # Typo not detected


*   Even in the "modular" mode, some hash functions are considered archaic and
    no longer recommended at all; for instance module `$1$` is officially
    abandoned by its author: see http://phk.freebsd.dk/sagas/md5crypt_eol/ .
    For another instance module `$3$` is considered completely broken: see the
    manpage of FreeBSD.

*   On some OS such as Mac OS, there is no modular mode. Yet, as written
    above, `crypt(3)` on Mac OS never fails. This means even if you build up a
    proper salt string it generates a traditional DES hash anyways, and there
    is no way for you to be aware of.

        "foo".crypt("$5$rounds=1000$salt$") # => "$5fNPQMxC5j6."


If for some reason you cannot migrate to other secure contemporary password
hashing algorithms, install the string-crypt gem and `require 'string/crypt'`
to continue using it.

;T;0;;;I"
crypt;F;I"String;T;[o;;I"::string salt_str;T;I"String;To;;I"WReturns a copy of *str* with all characters in the intersection of its
arguments deleted. Uses the same rules for building the set of characters as
String#count.

    "hello".delete "l","lo"        #=> "heo"
    "hello".delete "lo"            #=> "he"
    "hello".delete "aeiou", "^e"   #=> "hell"
    "hello".delete "ej-m"          #=> "ho"

;T;0;;;I"delete;F;I"String;T;[o;;I"-::string other_str, *::string other_strs;T;I"String;To;;I"cPerforms a `delete` operation in place, returning *str*, or `nil` if *str* was
not modified.

;T;0;;;I"delete!;F;I"String;T;[o;;I"-::string other_str, *::string other_strs;T;I"String?;To;;I"Returns a copy of *str* with leading `prefix` deleted.

    "hello".delete_prefix("hel") #=> "lo"
    "hello".delete_prefix("llo") #=> "hello"

;T;0;;;I"delete_prefix;F;I"String;T;[o;;I"::string prefix;T;I"String;To;;I"£Deletes leading `prefix` from *str*, returning `nil` if no change was made.

    "hello".delete_prefix!("hel") #=> "lo"
    "hello".delete_prefix!("llo") #=> nil

;T;0;;;I"delete_prefix!;F;I"String;T;[o;;I"::string prefix;T;I"String?;To;;I"‘Returns a copy of *str* with trailing `suffix` deleted.

    "hello".delete_suffix("llo") #=> "he"
    "hello".delete_suffix("hel") #=> "hello"

;T;0;;;I"delete_suffix;F;I"String;T;[o;;I"::string suffix;T;I"String;To;;I"¤Deletes trailing `suffix` from *str*, returning `nil` if no change was made.

    "hello".delete_suffix!("llo") #=> "he"
    "hello".delete_suffix!("hel") #=> nil

;T;0;;;I"delete_suffix!;F;I"String;T;[o;;I"::string suffix;T;I"String?;To;;I"7Returns a string containing the downcased characters in `self`:

    s = 'Hello World!' # => "Hello World!"
    s.downcase         # => "hello world!"

The casing may be affected by the given `options`; see [Case
Mapping](doc/case_mapping_rdoc.html).

Related: String#downcase!, String#upcase, String#upcase!.

;T;0;;;I"downcase;F;I"String;T;[	o;;I" ;F;I"String;To;;I"+:ascii | :fold | :lithuanian | :turkic;T;I"String;To;;I":lithuanian, :turkic;T;I"String;To;;I":turkic, :lithuanian;T;I"String;To;;I"ŸDowncases the characters in `self`; returns `self` if any changes were made,
`nil` otherwise:

    s = 'Hello World!' # => "Hello World!"
    s.downcase!        # => "hello world!"
    s                  # => "hello world!"
    s.downcase!        # => nil

The casing may be affected by the given `options`; see [Case
Mapping](doc/case_mapping_rdoc.html).

Related: String#downcase, String#upcase, String#upcase!.

;T;0;;;I"downcase!;F;I"String;T;[	o;;I" ;F;I"String?;To;;I"+:ascii | :fold | :lithuanian | :turkic;T;I"String?;To;;I":lithuanian, :turkic;T;I"String?;To;;I":turkic, :lithuanian;T;I"String?;To;;I"GReturns a printable version of `self`, enclosed in double-quotes, with special
characters escaped, and with non-printing characters replaced by hexadecimal
notation:

    "hello \n ''".dump    # => "\"hello \\n ''\""
    "\f\x00\xff\\\"".dump # => "\"\\f\\x00\\xFF\\\\\\\"\""

Related: String#undump (inverse of String#dump).

;T;0;;;I"	dump;F;I"String;T;[o;;I" ;F;I"String;To;;I"¯Passes each byte in *str* to the given block, or returns an enumerator if no
block is given.

    "hello".each_byte {|c| print c, ' ' }

*produces:*

    104 101 108 108 111

;T;0;;;I"each_byte;F;I"String;T;[o;;I" ;F;I"	self;To;;I" ;F;I" Enumerator[::Integer, self];To;;I"ªPasses each character in *str* to the given block, or returns an enumerator if
no block is given.

    "hello".each_char {|c| print c, ' ' }

*produces:*

    h e l l o

;T;0;;;I"each_char;F;I"String;T;[o;;I" ;F;I"	self;To;;I" ;F;I"Enumerator[::String, self];To;;I"®Passes the Integer ordinal of each character in *str*, also known as a
*codepoint* when applied to Unicode strings to the given block.  For encodings
other than UTF-8/UTF-16(BE|LE)/UTF-32(BE|LE), values are directly derived from
the binary representation of each character.

If no block is given, an enumerator is returned instead.

    "hello\u0639".each_codepoint {|c| print c, ' ' }

*produces:*

    104 101 108 108 111 1593

;T;0;;;I"each_codepoint;F;I"String;T;[o;;I" ;F;I"	self;To;;I" ;F;I" Enumerator[::Integer, self];To;;I"LPasses each grapheme cluster in *str* to the given block, or returns an
enumerator if no block is given. Unlike String#each_char, this enumerates by
grapheme clusters defined by Unicode Standard Annex #29
http://unicode.org/reports/tr29/

    "a\u0300".each_char.to_a.size #=> 2
    "a\u0300".each_grapheme_cluster.to_a.size #=> 1

;T;0;;;I"each_grapheme_cluster;F;I"String;T;[o;;I" ;F;I"	self;To;;I" ;F;I"Enumerator[::String, self];To;;I"ŸSplits *str* using the supplied parameter as the record separator (`$/` by
default), passing each substring in turn to the supplied block.  If a
zero-length record separator is supplied, the string is split into paragraphs
delimited by multiple successive newlines.

If `chomp` is `true`, `separator` will be removed from the end of each line.

If no block is given, an enumerator is returned instead.

    "hello\nworld".each_line {|s| p s}
    # prints:
    #   "hello\n"
    #   "world"

    "hello\nworld".each_line('l') {|s| p s}
    # prints:
    #   "hel"
    #   "l"
    #   "o\nworl"
    #   "d"

    "hello\n\n\nworld".each_line('') {|s| p s}
    # prints
    #   "hello\n\n"
    #   "world"

    "hello\nworld".each_line(chomp: true) {|s| p s}
    # prints:
    #   "hello"
    #   "world"

    "hello\nworld".each_line('l', chomp: true) {|s| p s}
    # prints:
    #   "he"
    #   ""
    #   "o\nwor"
    #   "d"

;T;0;;;I"each_line;F;I"String;T;[o;;I"+?::string separator, ?chomp: ::boolish;T;I"	self;To;;I"+?::string separator, ?chomp: ::boolish;T;I"Enumerator[::String, self];To;;I"•Returns `true` if the length of `self` is zero, `false` otherwise:

    "hello".empty? # => false
    " ".empty? # => false
    "".empty? # => true

;T;0;;;I"empty?;F;I"String;T;[o;;I" ;F;I"	bool;To;;I"šThe first form returns a copy of `str` transcoded to encoding `encoding`. The
second form returns a copy of `str` transcoded from src_encoding to
dst_encoding. The last form returns a copy of `str` transcoded to
`Encoding.default_internal`.

By default, the first and second form raise Encoding::UndefinedConversionError
for characters that are undefined in the destination encoding, and
Encoding::InvalidByteSequenceError for invalid byte sequences in the source
encoding. The last form by default does not raise exceptions but uses
replacement strings.

The `options` keyword arguments give details for conversion. The arguments
are:

:invalid
:   If the value is `:replace`, #encode replaces invalid byte sequences in
    `str` with the replacement character.  The default is to raise the
    Encoding::InvalidByteSequenceError exception
:undef
:   If the value is `:replace`, #encode replaces characters which are
    undefined in the destination encoding with the replacement character. The
    default is to raise the Encoding::UndefinedConversionError.
:replace
:   Sets the replacement string to the given value. The default replacement
    string is "uFFFD" for Unicode encoding forms, and "?" otherwise.
:fallback
:   Sets the replacement string by the given object for undefined character.
    The object should be a Hash, a Proc, a Method, or an object which has []
    method. Its key is an undefined character encoded in the source encoding
    of current transcoder. Its value can be any encoding until it can be
    converted into the destination encoding of the transcoder.
:xml
:   The value must be `:text` or `:attr`. If the value is `:text` #encode
    replaces undefined characters with their (upper-case hexadecimal) numeric
    character references. '&', '<', and '>' are converted to "&amp;", "&lt;",
    and "&gt;", respectively. If the value is `:attr`, #encode also quotes the
    replacement result (using '"'), and replaces '"' with "&quot;".
:cr_newline
:   Replaces LF ("n") with CR ("r") if value is true.
:crlf_newline
:   Replaces LF ("n") with CRLF ("r\n") if value is true.
:universal_newline
:   Replaces CRLF ("r\n") and CR ("r") with LF ("n") if value is true.

;T;0;;;I"encode;F;I"String;T;[o;;I"ê?::encoding encoding, ?::encoding from_encoding, ?invalid: :replace ?, ?undef: :replace ?, ?replace: ::String, ?fallback: ::String::encode_fallback, ?xml: :text | :attr, ?universal_newline: true, ?cr_newline: true, ?crlf_newline: true;T;I"String;To;;I"3The first form transcodes the contents of *str* from str.encoding to
`encoding`. The second form transcodes the contents of *str* from src_encoding
to dst_encoding. The `options` keyword arguments give details for conversion.
See String#encode for details. Returns the string even if no changes were
made.

;T;0;;;I"encode!;F;I"String;T;[o;;I"ê?::encoding encoding, ?::encoding from_encoding, ?invalid: :replace ?, ?undef: :replace ?, ?replace: ::String, ?fallback: ::String::encode_fallback, ?xml: :text | :attr, ?universal_newline: true, ?cr_newline: true, ?crlf_newline: true;T;I"	self;To;;I"GReturns the Encoding object that represents the encoding of obj.

;T;0;;;I"encoding;F;I"String;T;[o;;I" ;F;I"Encoding;To;;I"Returns true if `str` ends with one of the `suffixes` given.

    "hello".end_with?("ello")               #=> true

    # returns true if one of the +suffixes+ matches.
    "hello".end_with?("heaven", "ello")     #=> true
    "hello".end_with?("heaven", "paradise") #=> false

;T;0;;;I"end_with?;F;I"String;T;[o;;I"*::string suffixes;T;I"	bool;To;;I"MReturns `true` if `object` has the same length and content; as `self`; `false`
otherwise:

    s = 'foo'
    s.eql?('foo') # => true
    s.eql?('food') # => false
    s.eql?('FOO') # => false

Returns `false` if the two strings' encodings are not compatible:

    "\u{e4 f6 fc}".encode("ISO-8859-1").eql?("\u{c4 d6 dc}") # => false

;T;0;;;I"	eql?;F;I"String;T;[o;;I"untyped other;T;I"	bool;To;;I";Changes the encoding to `encoding` and returns self.

;T;0;;;I"force_encoding;F;I"String;T;[o;;I"#::string | ::Encoding encoding;T;I"	self;To;;I" ;T;0;;;I"freeze;F;I"String;T;[o;;I" ;F;I"	self;To;;I"¢Returns the byte at zero-based `index` as an integer:

    s = 'abcde'  # => "abcde"
    s.getbyte(0) # => 97
    s.getbyte(1) # => 98

Related: String#setbyte.

;T;0;;;I"getbyte;F;I"String;T;[o;;I"::int index;T;I"Integer?;To;;I"ÉReturns an array of grapheme clusters in *str*.  This is a shorthand for
`str.each_grapheme_cluster.to_a`.

If a block is given, which is a deprecated form, works the same as
`each_grapheme_cluster`.

;T;0;;;I"grapheme_clusters;F;I"String;T;[o;;I" ;F;I"Array[::String];To;;I"Returns a copy of `self` with all occurrences of the given `pattern` replaced.

See [Substitution Methods](#class-String-label-Substitution+Methods).

Returns an Enumerator if no `replacement` and no block given.

Related: String#sub, String#sub!, String#gsub!.

;T;0;;;I"	gsub;F;I"String;T;[	o;;I"6::Regexp | ::string pattern, ::string replacement;T;I"String;To;;I"A::Regexp | ::string pattern, ::Hash[::String, ::String] hash;T;I"String;To;;I" ::Regexp | ::string pattern;T;I"String;To;;I" ::Regexp | ::string pattern;T;I"Enumerator[::String, self];To;;I"/Performs the specified substring replacement(s) on `self`; returns `self` if
any replacement occurred, `nil` otherwise.

See [Substitution Methods](#class-String-label-Substitution+Methods).

Returns an Enumerator if no `replacement` and no block given.

Related: String#sub, String#gsub, String#sub!.

;T;0;;;I"
gsub!;F;I"String;T;[	o;;I"6::Regexp | ::string pattern, ::string replacement;T;I"String?;To;;I"A::Regexp | ::string pattern, ::Hash[::String, ::String] hash;T;I"String?;To;;I" ::Regexp | ::string pattern;T;I"String?;To;;I" ::Regexp | ::string pattern;T;I"Enumerator[::String, self];To;;I"…Returns the integer hash value for `self`. The value is based on the length,
content and encoding of `self`.

Related: Object#hash.

;T;0;;;I"	hash;F;I"String;T;[o;;I" ;F;I"Integer;To;;I" Treats leading characters from *str* as a string of hexadecimal digits (with
an optional sign and an optional `0x`) and returns the corresponding number.
Zero is returned on error.

    "0x0a".hex     #=> 10
    "-1234".hex    #=> -4660
    "0".hex        #=> 0
    "wombat".hex   #=> 0

;T;0;;;I"hex;F;I"String;T;[o;;I" ;F;I"Integer;To;;I"¹Returns `true` if `self` contains `other_string`, `false` otherwise:

    s = 'foo'
    s.include?('f')    # => true
    s.include?('fo')   # => true
    s.include?('food') # => false

;T;0;;;I"include?;F;I"String;T;[o;;I"::string other_str;T;I"	bool;To;;I"TReturns the Integer index of the first occurrence of the given `substring`, or
`nil` if none found:

    'foo'.index('f') # => 0
    'foo'.index('o') # => 1
    'foo'.index('oo') # => 1
    'foo'.index('ooo') # => nil

Returns the Integer index of the first match for the given Regexp `regexp`, or
`nil` if none found:

    'foo'.index(/f/) # => 0
    'foo'.index(/o/) # => 1
    'foo'.index(/oo/) # => 1
    'foo'.index(/ooo/) # => nil

Integer argument `offset`, if given, specifies the position in the string to
begin the search:

    'foo'.index('o', 1) # => 1
    'foo'.index('o', 2) # => 2
    'foo'.index('o', 3) # => nil

If `offset` is negative, counts backward from the end of `self`:

    'foo'.index('o', -1) # => 2
    'foo'.index('o', -2) # => 1
    'foo'.index('o', -3) # => 1
    'foo'.index('o', -4) # => nil

Related: String#rindex.

;T;0;;;I"
index;F;I"String;T;[o;;I"8::Regexp | ::string substr_or_regexp, ?::int offset;T;I"Integer?;To;;I"€Inserts the given `other_string` into `self`; returns `self`.

If the Integer `index` is positive, inserts `other_string` at offset `index`:

    'foo'.insert(1, 'bar') # => "fbaroo"

If the Integer `index` is negative, counts backward from the end of `self` and
inserts `other_string` at offset `index+1` (that is, *after* `self[index]`):

    'foo'.insert(-2, 'bar') # => "fobaro"

;T;0;;;I"insert;F;I"String;T;[o;;I"$::int index, ::string other_str;T;I"String;To;;I"ÎReturns a printable version of `self`, enclosed in double-quotes, and with
special characters escaped:

    s = "foo\tbar\tbaz\n"
    # => "foo\tbar\tbaz\n"
    s.inspect
    # => "\"foo\\tbar\\tbaz\\n\""

;T;0;;;I"inspect;F;I"String;T;[o;;I" ;F;I"String;To;;I"ºReturns the Symbol corresponding to *str*, creating the symbol if it did not
previously exist. See Symbol#id2name.

    "Koala".intern         #=> :Koala
    s = 'cat'.to_sym       #=> :cat
    s == :cat              #=> true
    s = '@cat'.to_sym      #=> :@cat
    s == :@cat             #=> true

This can also be used to create symbols that cannot be represented using the
`:xxx` notation.

    'cat and dog'.to_sym   #=> :"cat and dog"

;T;0;;;I"intern;F;I"String;T;[o;;I" ;F;I"Symbol;To;;I"¹Returns the count of characters (not bytes) in `self`:

    "\x80\u3042".length # => 2
    "hello".length # => 5

String#size is an alias for String#length.

Related: String#bytesize.

;T;0;;;I"length;F;I"String;T;[o;;I" ;F;I"Integer;To;;I"Returns an array of lines in *str* split using the supplied record separator
(`$/` by default).  This is a shorthand for `str.each_line(separator,
getline_args).to_a`.

If `chomp` is `true`, `separator` will be removed from the end of each line.

    "hello\nworld\n".lines              #=> ["hello\n", "world\n"]
    "hello  world".lines(' ')           #=> ["hello ", " ", "world"]
    "hello\nworld\n".lines(chomp: true) #=> ["hello", "world"]

If a block is given, which is a deprecated form, works the same as
`each_line`.

;T;0;;;I"
lines;F;I"String;T;[o;;I"+?::string separator, ?chomp: ::boolish;T;I"Array[::String];To;;I"MIf *integer* is greater than the length of *str*, returns a new String of
length *integer* with *str* left justified and padded with *padstr*;
otherwise, returns *str*.

    "hello".ljust(4)            #=> "hello"
    "hello".ljust(20)           #=> "hello               "
    "hello".ljust(20, '1234')   #=> "hello123412341234123"

;T;0;;;I"
ljust;F;I"String;T;[o;;I"$::int integer, ?::string padstr;T;I"String;To;;I"ðReturns a copy of the receiver with leading whitespace removed. See also
String#rstrip and String#strip.

Refer to String#strip for the definition of whitespace.

    "  hello  ".lstrip   #=> "hello  "
    "hello".lstrip       #=> "hello"

;T;0;;;I"lstrip;F;I"String;T;[o;;I" ;F;I"String;To;;I";Removes leading whitespace from the receiver. Returns the altered receiver, or
`nil` if no change was made. See also String#rstrip! and String#strip!.

Refer to String#strip for the definition of whitespace.

    "  hello  ".lstrip!  #=> "hello  "
    "hello  ".lstrip!    #=> nil
    "hello".lstrip!      #=> nil

;T;0;;;I"lstrip!;F;I"String;T;[o;;I" ;F;I"
self?;To;;I"(Returns a Matchdata object (or `nil`) based on `self` and the given `pattern`.

Note: also updates [Regexp-related global
variables](Regexp.html#class-Regexp-label-Special+global+variables).

*   Computes `regexp` by converting `pattern` (if not already a Regexp).
        regexp = Regexp.new(pattern)

*   Computes `matchdata`, which will be either a MatchData object or `nil`
    (see Regexp#match):
        matchdata = <tt>regexp.match(self)


With no block given, returns the computed `matchdata`:

    'foo'.match('f') # => #<MatchData "f">
    'foo'.match('o') # => #<MatchData "o">
    'foo'.match('x') # => nil

If Integer argument `offset` is given, the search begins at index `offset`:

    'foo'.match('f', 1) # => nil
    'foo'.match('o', 1) # => #<MatchData "o">

With a block given, calls the block with the computed `matchdata` and returns
the block's return value:

    'foo'.match(/o/) {|matchdata| matchdata } # => #<MatchData "o">
    'foo'.match(/x/) {|matchdata| matchdata } # => nil
    'foo'.match(/f/, 1) {|matchdata| matchdata } # => nil

;T;0;;;I"
match;F;I"String;T;[o;;I",::Regexp | ::string pattern, ?::int pos;T;I"MatchData?;To;;I",::Regexp | ::string pattern, ?::int pos;T;I"A;Fo;;I"Returns `true` or `false` based on whether a match is found for `self` and
`pattern`.

Note: does not update [Regexp-related global
variables](Regexp.html#class-Regexp-label-Special+global+variables).

Computes `regexp` by converting `pattern` (if not already a Regexp).
    regexp = Regexp.new(pattern)

Returns `true` if `self+.match(regexp)` returns a Matchdata object, `false`
otherwise:

    'foo'.match?(/o/) # => true
    'foo'.match?('o') # => true
    'foo'.match?(/x/) # => false

If Integer argument `offset` is given, the search begins at index `offset`:
    'foo'.match?('f', 1) # => false
    'foo'.match?('o', 1) # => true

;T;0;;;I"match?;F;I"String;T;[o;;I",::Regexp | ::string pattern, ?::int pos;T;I"	bool;To;;I"óReturns the successor to `self`. The successor is calculated by incrementing
characters.

The first character to be incremented is the rightmost alphanumeric: or, if no
alphanumerics, the rightmost character:

    'THX1138'.succ # => "THX1139"
    '<<koala>>'.succ # => "<<koalb>>"
    '***'.succ # => '**+'

The successor to a digit is another digit, "carrying" to the next-left
character for a "rollover" from 9 to 0, and prepending another digit if
necessary:

    '00'.succ # => "01"
    '09'.succ # => "10"
    '99'.succ # => "100"

The successor to a letter is another letter of the same case, carrying to the
next-left character for a rollover, and prepending another same-case letter if
necessary:

    'aa'.succ # => "ab"
    'az'.succ # => "ba"
    'zz'.succ # => "aaa"
    'AA'.succ # => "AB"
    'AZ'.succ # => "BA"
    'ZZ'.succ # => "AAA"

The successor to a non-alphanumeric character is the next character in the
underlying character set's collating sequence, carrying to the next-left
character for a rollover, and prepending another character if necessary:

    s = 0.chr * 3
    s # => "\x00\x00\x00"
    s.succ # => "\x00\x00\x01"
    s = 255.chr * 3
    s # => "\xFF\xFF\xFF"
    s.succ # => "\x01\x00\x00\x00"

Carrying can occur between and among mixtures of alphanumeric characters:

    s = 'zz99zz99'
    s.succ # => "aaa00aa00"
    s = '99zz99zz'
    s.succ # => "100aa00aa"

The successor to an empty String is a new empty String:

    ''.succ # => ""

String#next is an alias for String#succ.

;T;0;;;I"	next;F;I"String;T;[o;;I" ;F;I"String;To;;I"{Equivalent to String#succ, but modifies `self` in place; returns `self`.

String#next! is an alias for String#succ!.

;T;0;;;I"
next!;F;I"String;T;[o;;I" ;F;I"	self;To;;I"^Treats leading characters of *str* as a string of octal digits (with an
optional sign) and returns the corresponding number.  Returns 0 if the
conversion fails.

    "123".oct       #=> 83
    "-377".oct      #=> -255
    "bad".oct       #=> 0
    "0377bad".oct   #=> 255

If `str` starts with `0`, radix indicators are honored. See Kernel#Integer.

;T;0;;;I"oct;F;I"String;T;[o;;I" ;F;I"Integer;To;;I"YReturns the Integer ordinal of a one-character string.

    "a".ord         #=> 97

;T;0;;;I"ord;F;I"String;T;[o;;I" ;F;I"Integer;To;;I"[Searches *sep* or pattern (*regexp*) in the string and returns the part before
it, the match, and the part after it. If it is not found, returns two empty
strings and *str*.

    "hello".partition("l")         #=> ["he", "l", "lo"]
    "hello".partition("x")         #=> ["hello", "", ""]
    "hello".partition(/.l/)        #=> ["h", "el", "lo"]

;T;0;;;I"partition;F;I"String;T;[o;;I"&::Regexp | ::string sep_or_regexp;T;I"%[ ::String, ::String, ::String ];To;;I"ÉPrepends each string in `other_strings` to `self` and returns `self`:

    s = 'foo'
    s.prepend('bar', 'baz') # => "barbazfoo"
    s                       # => "barbazfoo"

Related: String#concat.

;T;0;;;I"prepend;F;I"String;T;[o;;I"*::string other_strs;T;I"String;To;;I"‡Replaces the contents of `self` with the contents of `other_string`:

    s = 'foo'        # => "foo"
    s.replace('bar') # => "bar"

;T;0;;;I"replace;F;I"String;T;[o;;I"::string other_str;T;I"String;To;;I"uReturns a new string with the characters from `self` in reverse order.

    'stressed'.reverse # => "desserts"

;T;0;;;I"reverse;F;I"String;T;[o;;I" ;F;I"String;To;;I"€Returns `self` with its characters reversed:

    s = 'stressed'
    s.reverse! # => "desserts"
    s          # => "desserts"

;T;0;;;I"reverse!;F;I"String;T;[o;;I" ;F;I"	self;To;;I"™Returns the Integer index of the *last* occurrence of the given `substring`,
or `nil` if none found:

    'foo'.rindex('f') # => 0
    'foo'.rindex('o') # => 2
    'foo'.rindex('oo') # => 1
    'foo'.rindex('ooo') # => nil

Returns the Integer index of the *last* match for the given Regexp `regexp`,
or `nil` if none found:

    'foo'.rindex(/f/) # => 0
    'foo'.rindex(/o/) # => 2
    'foo'.rindex(/oo/) # => 1
    'foo'.rindex(/ooo/) # => nil

The *last* match means starting at the possible last position, not the last of
longest matches.

    'foo'.rindex(/o+/) # => 2
    $~ #=> #<MatchData "o">

To get the last longest match, needs to combine with negative lookbehind.

    'foo'.rindex(/(?<!o)o+/) # => 1
    $~ #=> #<MatchData "oo">

Or String#index with negative lookforward.

    'foo'.index(/o+(?!.*o)/) # => 1
    $~ #=> #<MatchData "oo">

Integer argument `offset`, if given and non-negative, specifies the maximum
starting position in the
    string to _end_ the search:

     'foo'.rindex('o', 0) # => nil
     'foo'.rindex('o', 1) # => 1
     'foo'.rindex('o', 2) # => 2
     'foo'.rindex('o', 3) # => 2

If `offset` is a negative Integer, the maximum starting position in the string
to *end* the search is the sum of the string's length and `offset`:

    'foo'.rindex('o', -1) # => 2
    'foo'.rindex('o', -2) # => 1
    'foo'.rindex('o', -3) # => nil
    'foo'.rindex('o', -4) # => nil

Related: String#index.

;T;0;;;I"rindex;F;I"String;T;[o;;I"5::string | ::Regexp substr_or_regexp, ?::int pos;T;I"Integer?;To;;I"NIf *integer* is greater than the length of *str*, returns a new String of
length *integer* with *str* right justified and padded with *padstr*;
otherwise, returns *str*.

    "hello".rjust(4)            #=> "hello"
    "hello".rjust(20)           #=> "               hello"
    "hello".rjust(20, '1234')   #=> "123412341234123hello"

;T;0;;;I"
rjust;F;I"String;T;[o;;I"$::int integer, ?::string padstr;T;I"String;To;;I"Searches *sep* or pattern (*regexp*) in the string from the end of the string,
and returns the part before it, the match, and the part after it. If it is not
found, returns two empty strings and *str*.

    "hello".rpartition("l")         #=> ["hel", "l", "o"]
    "hello".rpartition("x")         #=> ["", "", "hello"]
    "hello".rpartition(/.l/)        #=> ["he", "ll", "o"]

The match from the end means starting at the possible last position, not the
last of longest matches.

    "hello".rpartition(/l+/)        #=> ["hel", "l", "o"]

To partition at the last longest match, needs to combine with negative
lookbehind.

    "hello".rpartition(/(?<!l)l+/)  #=> ["he", "ll", "o"]

Or String#partition with negative lookforward.

    "hello".partition(/l+(?!.*l)/)  #=> ["he", "ll", "o"]

;T;0;;;I"rpartition;F;I"String;T;[o;;I"&::string | ::Regexp sep_or_regexp;T;I"%[ ::String, ::String, ::String ];To;;I"ñReturns a copy of the receiver with trailing whitespace removed. See also
String#lstrip and String#strip.

Refer to String#strip for the definition of whitespace.

    "  hello  ".rstrip   #=> "  hello"
    "hello".rstrip       #=> "hello"

;T;0;;;I"rstrip;F;I"String;T;[o;;I" ;F;I"String;To;;I"<Removes trailing whitespace from the receiver. Returns the altered receiver,
or `nil` if no change was made. See also String#lstrip! and String#strip!.

Refer to String#strip for the definition of whitespace.

    "  hello  ".rstrip!  #=> "  hello"
    "  hello".rstrip!    #=> nil
    "hello".rstrip!      #=> nil

;T;0;;;I"rstrip!;F;I"String;T;[o;;I" ;F;I"
self?;To;;I"5Both forms iterate through *str*, matching the pattern (which may be a Regexp
or a String). For each match, a result is generated and either added to the
result array or passed to the block. If the pattern contains no groups, each
individual result consists of the matched string, `$&`.  If the pattern
contains groups, each individual result is itself an array containing one
entry per group.

    a = "cruel world"
    a.scan(/\w+/)        #=> ["cruel", "world"]
    a.scan(/.../)        #=> ["cru", "el ", "wor"]
    a.scan(/(...)/)      #=> [["cru"], ["el "], ["wor"]]
    a.scan(/(..)(..)/)   #=> [["cr", "ue"], ["l ", "wo"]]

And the block form:

    a.scan(/\w+/) {|w| print "<<#{w}>> " }
    print "\n"
    a.scan(/(.)(.)/) {|x,y| print y, x }
    print "\n"

*produces:*

    <<cruel>> <<world>>
    rceu lowlr

;T;0;;;I"	scan;F;I"String;T;[o;;I" ::Regexp | ::string pattern;T;I"(Array[::String | ::Array[::String]];To;;I" ::Regexp | ::string pattern;T;I"	self;To;;I"~If the string is invalid byte sequence then replace invalid bytes with given
replacement character, else returns self. If block is given, replace invalid
bytes with returned value of the block.

    "abc\u3042\x81".scrub #=> "abc\u3042\uFFFD"
    "abc\u3042\x81".scrub("*") #=> "abc\u3042*"
    "abc\u3042\xE3\x80".scrub{|bytes| '<'+bytes.unpack1('H*')+'>' } #=> "abc\u3042<e380>"

;T;0;;;I"
scrub;F;I"String;T;[o;;I"?::string repl;T;I"String;To;;I" ;F;I"String;To;;I"If the string is invalid byte sequence then replace invalid bytes with given
replacement character, else returns self. If block is given, replace invalid
bytes with returned value of the block.

    "abc\u3042\x81".scrub! #=> "abc\u3042\uFFFD"
    "abc\u3042\x81".scrub!("*") #=> "abc\u3042*"
    "abc\u3042\xE3\x80".scrub!{|bytes| '<'+bytes.unpack1('H*')+'>' } #=> "abc\u3042<e380>"

;T;0;;;I"scrub!;F;I"String;T;[o;;I"?::string repl;T;I"	self;To;;I" ;F;I"	self;To;;I"ÂSets the byte at zero-based `index` to `integer`; returns `integer`:

    s = 'abcde'      # => "abcde"
    s.setbyte(0, 98) # => 98
    s                # => "bbcde"

Related: String#getbyte.

;T;0;;;I"setbyte;F;I"String;T;[o;;I"::int index, ::int integer;T;I"int;To;;I"˜Removes the substring of `self` specified by the arguments; returns the
removed substring.

See String#[] for details about the arguments that specify the substring.

A few examples:

    string = "This is a string"
    string.slice!(2)        #=> "i"
    string.slice!(3..6)     #=> " is "
    string.slice!(/s.*t/)   #=> "sa st"
    string.slice!("r")      #=> "r"
    string                  #=> "Thing"

;T;0;;;I"slice!;F;I"String;T;[	o;;I""::int integer, ?::int integer;T;I"String?;To;;I"3::Range[::Integer] | ::Range[::Integer?] range;T;I"String?;To;;I"/::Regexp regexp, ?::int | ::String capture;T;I"String?;To;;I"::String other_str;T;I"String?;To;;I"Divides *str* into substrings based on a delimiter, returning an array of
these substrings.

If *pattern* is a String, then its contents are used as the delimiter when
splitting *str*. If *pattern* is a single space, *str* is split on whitespace,
with leading and trailing whitespace and runs of contiguous whitespace
characters ignored.

If *pattern* is a Regexp, *str* is divided where the pattern matches. Whenever
the pattern matches a zero-length string, *str* is split into individual
characters. If *pattern* contains groups, the respective matches will be
returned in the array as well.

If *pattern* is `nil`, the value of `$;` is used. If `$;` is `nil` (which is
the default), *str* is split on whitespace as if ' ' were specified.

If the *limit* parameter is omitted, trailing null fields are suppressed. If
*limit* is a positive number, at most that number of split substrings will be
returned (captured groups will be returned as well, but are not counted
towards the limit). If *limit* is `1`, the entire string is returned as the
only entry in an array. If negative, there is no limit to the number of fields
returned, and trailing null fields are not suppressed.

When the input `str` is empty an empty Array is returned as the string is
considered to have no fields to split.

    " now's  the time ".split       #=> ["now's", "the", "time"]
    " now's  the time ".split(' ')  #=> ["now's", "the", "time"]
    " now's  the time".split(/ /)   #=> ["", "now's", "", "the", "time"]
    "1, 2.34,56, 7".split(%r{,\s*}) #=> ["1", "2.34", "56", "7"]
    "hello".split(//)               #=> ["h", "e", "l", "l", "o"]
    "hello".split(//, 3)            #=> ["h", "e", "llo"]
    "hi mom".split(%r{\s*})         #=> ["h", "i", "m", "o", "m"]

    "mellow yellow".split("ello")   #=> ["m", "w y", "w"]
    "1,2,,3,4,,".split(',')         #=> ["1", "2", "", "3", "4"]
    "1,2,,3,4,,".split(',', 4)      #=> ["1", "2", "", "3,4,,"]
    "1,2,,3,4,,".split(',', -4)     #=> ["1", "2", "", "3", "4", "", ""]

    "1:2:3".split(/(:)()()/, 2)     #=> ["1", ":", "", "", "2:3"]

    "".split(',', -1)               #=> []

If a block is given, invoke the block with each split substring.

;T;0;;;I"
split;F;I"String;T;[o;;I"/?::Regexp | ::string pattern, ?::int limit;T;I"Array[::String];To;;I"/?::Regexp | ::string pattern, ?::int limit;T;I"	self;To;;I"ûBuilds a set of characters from the *other_str* parameter(s) using the
procedure described for String#count. Returns a new string where runs of the
same character that occur in this set are replaced by a single character. If
no arguments are given, all runs of identical characters are replaced by a
single character.

    "yellow moon".squeeze                  #=> "yelow mon"
    "  now   is  the".squeeze(" ")         #=> " now is the"
    "putters shoot balls".squeeze("m-z")   #=> "puters shot balls"

;T;0;;;I"squeeze;F;I"String;T;[o;;I"*::string other_str;T;I"String;To;;I"YSqueezes *str* in place, returning either *str*, or `nil` if no changes were
made.

;T;0;;;I"squeeze!;F;I"String;T;[o;;I"*::string other_str;T;I"
self?;To;;I"‰Returns true if `str` starts with one of the `prefixes` given. Each of the
`prefixes` should be a String or a Regexp.

    "hello".start_with?("hell")               #=> true
    "hello".start_with?(/H/i)                 #=> true

    # returns true if one of the prefixes matches.
    "hello".start_with?("heaven", "hell")     #=> true
    "hello".start_with?("heaven", "paradise") #=> false

;T;0;;;I"start_with?;F;I"String;T;[o;;I"*::string prefixes;T;I"	bool;To;;I"yReturns a copy of the receiver with leading and trailing whitespace removed.

Whitespace is defined as any of the following characters: null, horizontal
tab, line feed, vertical tab, form feed, carriage return, space.

    "    hello    ".strip   #=> "hello"
    "\tgoodbye\r\n".strip   #=> "goodbye"
    "\x00\t\n\v\f\r ".strip #=> ""
    "hello".strip           #=> "hello"

;T;0;;;I"
strip;F;I"String;T;[o;;I" ;F;I"String;To;;I"ùRemoves leading and trailing whitespace from the receiver. Returns the altered
receiver, or `nil` if there was no change.

Refer to String#strip for the definition of whitespace.

    "  hello  ".strip!  #=> "hello"
    "hello".strip!      #=> nil

;T;0;;;I"strip!;F;I"String;T;[o;;I" ;F;I"
self?;To;;I"éReturns a copy of `self` with only the first occurrence (not all occurrences)
of the given `pattern` replaced.

See [Substitution Methods](#class-String-label-Substitution+Methods).

Related: String#sub!, String#gsub, String#gsub!.

;T;0;;;I"sub;F;I"String;T;[o;;I"S::Regexp | ::string pattern, ::string | ::Hash[::String, ::String] replacement;T;I"String;To;;I" ::Regexp | ::string pattern;T;I"String;To;;I"ÞReturns `self` with only the first occurrence (not all occurrences) of the
given `pattern` replaced.

See [Substitution Methods](#class-String-label-Substitution+Methods).

Related: String#sub, String#gsub, String#gsub!.

;T;0;;;I"	sub!;F;I"String;T;[o;;I"S::Regexp | ::string pattern, ::string | ::Hash[::String, ::String] replacement;T;I"
self?;To;;I" ::Regexp | ::string pattern;T;I"String?;To;;I"óReturns the successor to `self`. The successor is calculated by incrementing
characters.

The first character to be incremented is the rightmost alphanumeric: or, if no
alphanumerics, the rightmost character:

    'THX1138'.succ # => "THX1139"
    '<<koala>>'.succ # => "<<koalb>>"
    '***'.succ # => '**+'

The successor to a digit is another digit, "carrying" to the next-left
character for a "rollover" from 9 to 0, and prepending another digit if
necessary:

    '00'.succ # => "01"
    '09'.succ # => "10"
    '99'.succ # => "100"

The successor to a letter is another letter of the same case, carrying to the
next-left character for a rollover, and prepending another same-case letter if
necessary:

    'aa'.succ # => "ab"
    'az'.succ # => "ba"
    'zz'.succ # => "aaa"
    'AA'.succ # => "AB"
    'AZ'.succ # => "BA"
    'ZZ'.succ # => "AAA"

The successor to a non-alphanumeric character is the next character in the
underlying character set's collating sequence, carrying to the next-left
character for a rollover, and prepending another character if necessary:

    s = 0.chr * 3
    s # => "\x00\x00\x00"
    s.succ # => "\x00\x00\x01"
    s = 255.chr * 3
    s # => "\xFF\xFF\xFF"
    s.succ # => "\x01\x00\x00\x00"

Carrying can occur between and among mixtures of alphanumeric characters:

    s = 'zz99zz99'
    s.succ # => "aaa00aa00"
    s = '99zz99zz'
    s.succ # => "100aa00aa"

The successor to an empty String is a new empty String:

    ''.succ # => ""

String#next is an alias for String#succ.

;T;0;;;I"	succ;F;I"String;T;[o;;I" ;F;I"String;To;;I"{Equivalent to String#succ, but modifies `self` in place; returns `self`.

String#next! is an alias for String#succ!.

;T;0;;;I"
succ!;F;I"String;T;[o;;I" ;F;I"String;To;;I"Returns a basic *n*-bit checksum of the characters in *str*, where *n* is the
optional Integer parameter, defaulting to 16. The result is simply the sum of
the binary value of each byte in *str* modulo `2**n - 1`. This is not a
particularly good checksum.

;T;0;;;I"sum;F;I"String;T;[o;;I"?::int n;T;I"Integer;To;;I"oReturns a string containing the characters in `self`, with cases reversed;
each uppercase character is downcased; each lowercase character is upcased:

    s = 'Hello World!' # => "Hello World!"
    s.swapcase         # => "hELLO wORLD!"

The casing may be affected by the given `options`; see [Case
Mapping](doc/case_mapping_rdoc.html).

Related: String#swapcase!.

;T;0;;;I"swapcase;F;I"String;T;[	o;;I" ;F;I"String;To;;I"#:ascii | :lithuanian | :turkic;T;I"String;To;;I":lithuanian, :turkic;T;I"String;To;;I":turkic, :lithuanian;T;I"String;To;;I"§Upcases each lowercase character in `self`; downcases uppercase character;
returns `self` if any changes were made, `nil` otherwise:

    s = 'Hello World!' # => "Hello World!"
    s.swapcase!        # => "hELLO wORLD!"
    s                  # => "Hello World!"
    ''.swapcase!       # => nil

The casing may be affected by the given `options`; see [Case
Mapping](doc/case_mapping_rdoc.html).

Related: String#swapcase.

;T;0;;;I"swapcase!;F;I"String;T;[	o;;I" ;F;I"
self?;To;;I"#:ascii | :lithuanian | :turkic;T;I"
self?;To;;I":lithuanian, :turkic;T;I"
self?;To;;I":turkic, :lithuanian;T;I"
self?;To;;I"€Returns a complex which denotes the string form.  The parser ignores leading
whitespaces and trailing garbage.  Any digit sequences can be separated by an
underscore.  Returns zero for null or garbage string.

    '9'.to_c           #=> (9+0i)
    '2.5'.to_c         #=> (2.5+0i)
    '2.5/1'.to_c       #=> ((5/2)+0i)
    '-3/2'.to_c        #=> ((-3/2)+0i)
    '-i'.to_c          #=> (0-1i)
    '45i'.to_c         #=> (0+45i)
    '3-4i'.to_c        #=> (3-4i)
    '-4e2-4e-2i'.to_c  #=> (-400.0-0.04i)
    '-0.0-0.0i'.to_c   #=> (-0.0-0.0i)
    '1/2+3/4i'.to_c    #=> ((1/2)+(3/4)*i)
    'ruby'.to_c        #=> (0+0i)

See Kernel.Complex.

;T;0;;;I"	to_c;F;I"String;T;[o;;I" ;F;I"Complex;To;;I"XReturns the result of interpreting leading characters in `self` as a Float:

    '3.14159'.to_f  # => 3.14159
    '1.234e-2'.to_f # => 0.01234

Characters past a leading valid number (in the given `base`) are ignored:

    '3.14 (pi to two places)'.to_f # => 3.14

Returns zero if there is no leading valid number:

    'abcdef'.to_f # => 0.0

;T;0;;;I"	to_f;F;I"String;T;[o;;I" ;F;I"
Float;To;;I"®Returns the result of interpreting leading characters in `self` as an integer
in the given `base` (which must be in (2..36)):

    '123456'.to_i     # => 123456
    '123def'.to_i(16) # => 1195503

Characters past a leading valid number (in the given `base`) are ignored:

    '12.345'.to_i   # => 12
    '12345'.to_i(2) # => 1

Returns zero if there is no leading valid number:

    'abcdef'.to_i # => 0
    '2'.to_i(2)   # => 0

;T;0;;;I"	to_i;F;I"String;T;[o;;I"?::int base;T;I"Integer;To;;I"4Returns the result of interpreting leading characters in `str` as a rational.
Leading whitespace and extraneous characters past the end of a valid number
are ignored. Digit sequences can be separated by an underscore. If there is
not a valid number at the start of `str`, zero is returned.  This method never
raises an exception.

    '  2  '.to_r       #=> (2/1)
    '300/2'.to_r       #=> (150/1)
    '-9.2'.to_r        #=> (-46/5)
    '-9.2e2'.to_r      #=> (-920/1)
    '1_234_567'.to_r   #=> (1234567/1)
    '21 June 09'.to_r  #=> (21/1)
    '21/06/09'.to_r    #=> (7/2)
    'BWV 1079'.to_r    #=> (0/1)

NOTE: "0.3".to_r isn't the same as 0.3.to_r.  The former is equivalent to
"3/10".to_r, but the latter isn't so.

    "0.3".to_r == 3/10r  #=> true
    0.3.to_r   == 3/10r  #=> false

See also Kernel#Rational.

;T;0;;;I"	to_r;F;I"String;T;[o;;I" ;F;I"Rational;To;;I"–Returns `self` if `self` is a String, or `self` converted to a String if
`self` is a subclass of String.

String#to_str is an alias for String#to_s.

;T;0;;;I"	to_s;F;I"String;T;[o;;I" ;F;I"String;To;;I"–Returns `self` if `self` is a String, or `self` converted to a String if
`self` is a subclass of String.

String#to_str is an alias for String#to_s.

;T;0;;;I"to_str;F;I"String;T;[o;;I" ;F;I"String;To;;I"ºReturns the Symbol corresponding to *str*, creating the symbol if it did not
previously exist. See Symbol#id2name.

    "Koala".intern         #=> :Koala
    s = 'cat'.to_sym       #=> :cat
    s == :cat              #=> true
    s = '@cat'.to_sym      #=> :@cat
    s == :@cat             #=> true

This can also be used to create symbols that cannot be represented using the
`:xxx` notation.

    'cat and dog'.to_sym   #=> :"cat and dog"

;T;0;;;I"to_sym;F;I"String;T;[o;;I" ;F;I"Symbol;To;;I"~Returns a copy of `str` with the characters in `from_str` replaced by the
corresponding characters in `to_str`.  If `to_str` is shorter than `from_str`,
it is padded with its last character in order to maintain the correspondence.

    "hello".tr('el', 'ip')      #=> "hippo"
    "hello".tr('aeiou', '*')    #=> "h*ll*"
    "hello".tr('aeiou', 'AA*')  #=> "hAll*"

Both strings may use the `c1-c2` notation to denote ranges of characters, and
`from_str` may start with a `^`, which denotes all characters except those
listed.

    "hello".tr('a-y', 'b-z')    #=> "ifmmp"
    "hello".tr('^aeiou', '*')   #=> "*e**o"

The backslash character `\` can be used to escape `^` or `-` and is otherwise
ignored unless it appears at the end of a range or the end of the `from_str`
or `to_str`:

    "hello^world".tr("\\^aeiou", "*") #=> "h*ll**w*rld"
    "hello-world".tr("a\\-eo", "*")   #=> "h*ll**w*rld"

    "hello\r\nworld".tr("\r", "")   #=> "hello\nworld"
    "hello\r\nworld".tr("\\r", "")  #=> "hello\r\nwold"
    "hello\r\nworld".tr("\\\r", "") #=> "hello\nworld"

    "X['\\b']".tr("X\\", "")   #=> "['b']"
    "X['\\b']".tr("X-\\]", "") #=> "'b'"

;T;0;;;I"tr;F;I"String;T;[o;;I"'::string from_str, ::string to_str;T;I"String;To;;I"uTranslates *str* in place, using the same rules as String#tr. Returns *str*,
or `nil` if no changes were made.

;T;0;;;I"tr!;F;I"String;T;[o;;I"'::string from_str, ::string to_str;T;I"String?;To;;I"Processes a copy of *str* as described under String#tr, then removes duplicate
characters in regions that were affected by the translation.

    "hello".tr_s('l', 'r')     #=> "hero"
    "hello".tr_s('el', '*')    #=> "h*o"
    "hello".tr_s('el', 'hx')   #=> "hhxo"

;T;0;;;I"	tr_s;F;I"String;T;[o;;I"'::string from_str, ::string to_str;T;I"String;To;;I"lPerforms String#tr_s processing on *str* in place, returning *str*, or `nil`
if no changes were made.

;T;0;;;I"
tr_s!;F;I"String;T;[o;;I"'::string from_str, ::string to_str;T;I"String?;To;;I";Returns an unescaped version of `self`:

    s_orig = "\f\x00\xff\\\""    # => "\f\u0000\xFF\\\""
    s_dumped = s_orig.dump       # => "\"\\f\\x00\\xFF\\\\\\\"\""
    s_undumped = s_dumped.undump # => "\f\u0000\xFF\\\""
    s_undumped == s_orig         # => true

Related: String#dump (inverse of String#undump).

;T;0;;;I"undump;F;I"String;T;[o;;I" ;F;I"String;To;;I"bUnicode Normalization---Returns a normalized form of `str`, using Unicode
normalizations NFC, NFD, NFKC, or NFKD. The normalization form used is
determined by `form`, which can be any of the four values `:nfc`, `:nfd`,
`:nfkc`, or `:nfkd`. The default is `:nfc`.

If the string is not in a Unicode Encoding, then an Exception is raised. In
this context, 'Unicode Encoding' means any of UTF-8, UTF-16BE/LE, and
UTF-32BE/LE, as well as GB18030, UCS_2BE, and UCS_4BE. Anything other than
UTF-8 is implemented by converting to UTF-8, which makes it slower than UTF-8.

    "a\u0300".unicode_normalize        #=> "\u00E0"
    "a\u0300".unicode_normalize(:nfc)  #=> "\u00E0"
    "\u00E0".unicode_normalize(:nfd)   #=> "a\u0300"
    "\xE0".force_encoding('ISO-8859-1').unicode_normalize(:nfd)
                                       #=> Encoding::CompatibilityError raised

;T;0;;;I"unicode_normalize;F;I"String;T;[o;;I"!?:nfc | :nfd | :nfkc | :nfkd;T;I"String;To;;I"]Destructive version of String#unicode_normalize, doing Unicode normalization
in place.

;T;0;;;I"unicode_normalize!;F;I"String;T;[o;;I"!?:nfc | :nfd | :nfkc | :nfkd;T;I"String;To;;I"lChecks whether `str` is in Unicode normalization form `form`, which can be any
of the four values `:nfc`, `:nfd`, `:nfkc`, or `:nfkd`. The default is `:nfc`.

If the string is not in a Unicode Encoding, then an Exception is raised. For
details, see String#unicode_normalize.

    "a\u0300".unicode_normalized?        #=> false
    "a\u0300".unicode_normalized?(:nfd)  #=> true
    "\u00E0".unicode_normalized?         #=> true
    "\u00E0".unicode_normalized?(:nfd)   #=> false
    "\xE0".force_encoding('ISO-8859-1').unicode_normalized?
                                         #=> Encoding::CompatibilityError raised

;T;0;;;I"unicode_normalized?;F;I"String;T;[o;;I"!?:nfc | :nfd | :nfkc | :nfkd;T;I"	bool;To;;I"ÑDecodes *str* (which may contain binary data) according to the format string,
returning an array of each value extracted. The format string consists of a
sequence of single-character directives, summarized in the table at the end of
this entry. Each directive may be followed by a number, indicating the number
of times to repeat with this directive. An asterisk (```*`'') will use up all
remaining elements. The directives `sSiIlL` may each be followed by an
underscore (```_`'') or exclamation mark (```!`'') to use the underlying
platform's native size for the specified type; otherwise, it uses a
platform-independent consistent size. Spaces are ignored in the format string.

See also String#unpack1,  Array#pack.

    "abc \0\0abc \0\0".unpack('A6Z6')   #=> ["abc", "abc "]
    "abc \0\0".unpack('a3a3')           #=> ["abc", " \000\000"]
    "abc \0abc \0".unpack('Z*Z*')       #=> ["abc ", "abc "]
    "aa".unpack('b8B8')                 #=> ["10000110", "01100001"]
    "aaa".unpack('h2H2c')               #=> ["16", "61", 97]
    "\xfe\xff\xfe\xff".unpack('sS')     #=> [-2, 65534]
    "now=20is".unpack('M*')             #=> ["now is"]
    "whole".unpack('xax2aX2aX1aX2a')    #=> ["h", "e", "l", "l", "o"]

This table summarizes the various formats and the Ruby classes returned by
each.

    Integer       |         |
    Directive     | Returns | Meaning
    ------------------------------------------------------------------
    C             | Integer | 8-bit unsigned (unsigned char)
    S             | Integer | 16-bit unsigned, native endian (uint16_t)
    L             | Integer | 32-bit unsigned, native endian (uint32_t)
    Q             | Integer | 64-bit unsigned, native endian (uint64_t)
    J             | Integer | pointer width unsigned, native endian (uintptr_t)
                  |         |
    c             | Integer | 8-bit signed (signed char)
    s             | Integer | 16-bit signed, native endian (int16_t)
    l             | Integer | 32-bit signed, native endian (int32_t)
    q             | Integer | 64-bit signed, native endian (int64_t)
    j             | Integer | pointer width signed, native endian (intptr_t)
                  |         |
    S_ S!         | Integer | unsigned short, native endian
    I I_ I!       | Integer | unsigned int, native endian
    L_ L!         | Integer | unsigned long, native endian
    Q_ Q!         | Integer | unsigned long long, native endian (ArgumentError
                  |         | if the platform has no long long type.)
    J!            | Integer | uintptr_t, native endian (same with J)
                  |         |
    s_ s!         | Integer | signed short, native endian
    i i_ i!       | Integer | signed int, native endian
    l_ l!         | Integer | signed long, native endian
    q_ q!         | Integer | signed long long, native endian (ArgumentError
                  |         | if the platform has no long long type.)
    j!            | Integer | intptr_t, native endian (same with j)
                  |         |
    S> s> S!> s!> | Integer | same as the directives without ">" except
    L> l> L!> l!> |         | big endian
    I!> i!>       |         |
    Q> q> Q!> q!> |         | "S>" is the same as "n"
    J> j> J!> j!> |         | "L>" is the same as "N"
                  |         |
    S< s< S!< s!< | Integer | same as the directives without "<" except
    L< l< L!< l!< |         | little endian
    I!< i!<       |         |
    Q< q< Q!< q!< |         | "S<" is the same as "v"
    J< j< J!< j!< |         | "L<" is the same as "V"
                  |         |
    n             | Integer | 16-bit unsigned, network (big-endian) byte order
    N             | Integer | 32-bit unsigned, network (big-endian) byte order
    v             | Integer | 16-bit unsigned, VAX (little-endian) byte order
    V             | Integer | 32-bit unsigned, VAX (little-endian) byte order
                  |         |
    U             | Integer | UTF-8 character
    w             | Integer | BER-compressed integer (see Array#pack)

    Float        |         |
    Directive    | Returns | Meaning
    -----------------------------------------------------------------
    D d          | Float   | double-precision, native format
    F f          | Float   | single-precision, native format
    E            | Float   | double-precision, little-endian byte order
    e            | Float   | single-precision, little-endian byte order
    G            | Float   | double-precision, network (big-endian) byte order
    g            | Float   | single-precision, network (big-endian) byte order

    String       |         |
    Directive    | Returns | Meaning
    -----------------------------------------------------------------
    A            | String  | arbitrary binary string (remove trailing nulls and ASCII spaces)
    a            | String  | arbitrary binary string
    Z            | String  | null-terminated string
    B            | String  | bit string (MSB first)
    b            | String  | bit string (LSB first)
    H            | String  | hex string (high nibble first)
    h            | String  | hex string (low nibble first)
    u            | String  | UU-encoded string
    M            | String  | quoted-printable, MIME encoding (see RFC2045)
    m            | String  | base64 encoded string (RFC 2045) (default)
                 |         | base64 encoded string (RFC 4648) if followed by 0
    P            | String  | pointer to a structure (fixed-length string)
    p            | String  | pointer to a null-terminated string

    Misc.        |         |
    Directive    | Returns | Meaning
    -----------------------------------------------------------------
    @            | ---     | skip to the offset given by the length argument
    X            | ---     | skip backward one byte
    x            | ---     | skip forward one byte

The keyword *offset* can be given to start the decoding after skipping the
specified amount of bytes:
    "abc".unpack("C*") # => [97, 98, 99]
    "abc".unpack("C*", offset: 2) # => [99]
    "abc".unpack("C*", offset: 4) # => offset outside of string (ArgumentError)

HISTORY

*   J, J! j, and j! are available since Ruby 2.3.
*   Q_, Q!, q_, and q! are available since Ruby 2.1.
*   I!<, i!<, I!>, and i!> are available since Ruby 1.9.3.

;T;0;;;I"unpack;F;I"String;T;[o;;I"(::String format, ?offset: ::Integer;T;I"0Array[::Integer | ::Float | ::String | nil];To;;I"ŸDecodes *str* (which may contain binary data) according to the format string,
returning the first value extracted.

See also String#unpack, Array#pack.

Contrast with String#unpack:

    "abc \0\0abc \0\0".unpack('A6Z6')   #=> ["abc", "abc "]
    "abc \0\0abc \0\0".unpack1('A6Z6')  #=> "abc"

In that case data would be lost but often it's the case that the array only
holds one value, especially when unpacking binary data. For instance:

    "\xff\x00\x00\x00".unpack("l")         #=>  [255]
    "\xff\x00\x00\x00".unpack1("l")        #=>  255

Thus unpack1 is convenient, makes clear the intention and signals the expected
return value to those reading the code.

The keyword *offset* can be given to start the decoding after skipping the
specified amount of bytes:
    "abc".unpack1("C*") # => 97
    "abc".unpack1("C*", offset: 2) # => 99
    "abc".unpack1("C*", offset: 4) # => offset outside of string (ArgumentError)

;T;0;;;I"unpack1;F;I"String;T;[o;;I"::String format;T;I"'Integer | ::Float | ::String | nil;To;;I"7Returns a string containing the upcased characters in `self`:

    s = 'Hello World!' # => "Hello World!"
    s.upcase           # => "HELLO WORLD!"

The casing may be affected by the given `options`; see [Case
Mapping](doc/case_mapping_rdoc.html).

Related: String#upcase!, String#downcase, String#downcase!.

;T;0;;;I"upcase;F;I"String;T;[	o;;I" ;F;I"String;To;;I"#:ascii | :lithuanian | :turkic;T;I"String;To;;I":lithuanian, :turkic;T;I"String;To;;I":turkic, :lithuanian;T;I"String;To;;I"ŸUpcases the characters in `self`; returns `self` if any changes were made,
`nil` otherwise:

    s = 'Hello World!' # => "Hello World!"
    s.upcase!          # => "HELLO WORLD!"
    s                  # => "HELLO WORLD!"
    s.upcase!          # => nil

The casing may be affected by the given `options`; see [Case
Mapping](doc/case_mapping_rdoc.html).

Related: String#upcase, String#downcase, String#downcase!.

;T;0;;;I"upcase!;F;I"String;T;[	o;;I" ;F;I"
self?;To;;I"#:ascii | :lithuanian | :turkic;T;I"
self?;To;;I":lithuanian, :turkic;T;I"
self?;To;;I":turkic, :lithuanian;T;I"
self?;To;;I"ðWith a block given, calls the block with each String value returned by
successive calls to String#succ; the first value is `self`, the next is
`self.succ`, and so on; the sequence terminates when value `other_string` is
reached; returns `self`:

    'a8'.upto('b6') {|s| print s, ' ' } # => "a8"

Output:

    a8 a9 b0 b1 b2 b3 b4 b5 b6

If argument `exclusive` is given as a truthy object, the last value is
omitted:

    'a8'.upto('b6', true) {|s| print s, ' ' } # => "a8"

Output:

    a8 a9 b0 b1 b2 b3 b4 b5

If `other_string` would not be reached, does not call the block:

    '25'.upto('5') {|s| fail s }
    'aa'.upto('a') {|s| fail s }

With no block given, returns a new Enumerator:

    'a8'.upto('b6') # => #<Enumerator: "a8":upto("b6")>

;T;0;;;I"	upto;F;I"String;T;[o;;I"-::string other_str, ?::boolish exclusive;T;I"Enumerator[::String, self];To;;I"-::string other_str, ?::boolish exclusive;T;I"	self;To;;I"ýReturns true for a string which is encoded correctly.

    "\xc2\xa1".force_encoding("UTF-8").valid_encoding?  #=> true
    "\xc2".force_encoding("UTF-8").valid_encoding?      #=> false
    "\x80".force_encoding("UTF-8").valid_encoding?      #=> false

;T;0;;;I"valid_encoding?;F;I"String;T;[o;;I" ;F;I"	bool;To;;I"3Returns a new String that is a copy of `string`.

With no arguments, returns the empty string with the Encoding `ASCII-8BIT`:
    s = String.new
    s # => ""
    s.encoding # => #<Encoding:ASCII-8BIT>

With the single String argument `string`, returns a copy of `string` with the
same encoding as `string`:
    s = String.new("Que veut dire \u{e7}a?")
    s # => "Que veut dire \u{e7}a?"
    s.encoding # => #<Encoding:UTF-8>

Literal strings like `""` or here-documents always use [script
encoding](Encoding.html#class-Encoding-label-Script+encoding), unlike
String.new.

With keyword `encoding`, returns a copy of `str` with the specified encoding:
    s = String.new(encoding: 'ASCII')
    s.encoding # => #<Encoding:US-ASCII>
    s = String.new('foo', encoding: 'ASCII')
    s.encoding # => #<Encoding:US-ASCII>

Note that these are equivalent:
    s0 = String.new('foo', encoding: 'ASCII')
    s1 = 'foo'.force_encoding('ASCII')
    s0.encoding == s1.encoding # => true

With keyword `capacity`, returns a copy of `str`; the given `capacity` may set
the size of the internal buffer, which may affect performance:
    String.new(capacity: 1) # => ""
    String.new(capacity: 4096) # => ""

The `string`, `encoding`, and `capacity` arguments may all be used together:

    String.new('hello', encoding: 'UTF-8', capacity: 25)

;T;0;;;I"initialize;F;I"String;T;[o;;I";?::string str, ?encoding: ::encoding, ?capacity: ::int;T;I"	void;To; ;0;0;	I"String;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"Returns the result of interpreting leading characters in `str` as a
BigDecimal.

    require 'bigdecimal'
    require 'bigdecimal/util'

    "0.5".to_d             # => 0.5e0
    "123.45e1".to_d        # => 0.12345e4
    "45.67 degrees".to_d   # => 0.4567e2

See also BigDecimal::new.

;T;0;;;I"	to_d;F;I"String;T;[o;;I" ;F;I"BigDecimal;To; ;0;0;	I"String;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"ŠThis string should be encoded with UTF-8 A call to this method
returns a JSON string encoded with UTF16 big endian characters as
\u????.

;T;0;;;I"to_json;F;I"String;T;[o;;I"?::JSON::State state;T;I"String;To; ;0;0;	I"String;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"{Escapes `str` so that it can be safely used in a Bourne shell command line.

See Shellwords.shellescape for details.

;T;0;;;I"shellescape;F;I"String;T;[o;;I" ;F;I"String;To;;I"Splits `str` into an array of tokens in the same way the UNIX Bourne shell
does.

See Shellwords.shellsplit for details.

;T;0;;;I"shellsplit;F;I"String;T;[o;;I" ;F;I"Array[::String];To; ;I"§Pseudo I/O on String object, with interface corresponding to IO.

Commonly used to simulate `$stdio` or `$stderr`

### Examples

    require 'stringio'

    # Writing stream emulation
    io = StringIO.new
    io.puts "Hello World"
    io.string #=> "Hello World\n"

    # Reading stream emulation
    io = StringIO.new "first\nsecond\nlast\n"
    io.getc #=> "f"
    io.gets #=> "irst\n"
    io.read #=> "second\nlast\n"

;T;0;	I"StringIO;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"CCreates new StringIO instance from with *string* and *mode*.

;T;0;;;I"initialize;F;I"StringIO;T;[o;;I"&?::String string, ?::String? mode;T;I"	void;To;;I"­Equivalent to StringIO.new except that when it is called with a block, it
yields with the new instance and closes it, and returns the result which
returned from the block.

;T;0;;;I"	open;F;I"StringIO;T;[o;;I"&?::String string, ?::String? mode;T;I"U;Fo;;0;0;;;I"<<;F;I"StringIO;T;[o;;I"untyped arg0;T;I"	self;To;;I"4Puts stream into binary mode. See IO#binmode.

;T;0;;;I"binmode;F;I"StringIO;T;[o;;I" ;F;I"	self;To;;I"‚Closes a StringIO. The stream is unavailable for any further data operations;
an `IOError` is raised if such an attempt is made.

;T;0;;;I"
close;F;I"StringIO;T;[o;;I" ;F;I"nil;To;;I"cCloses the read end of a StringIO.  Will raise an `IOError` if the receiver is
not readable.

;T;0;;;I"close_read;F;I"StringIO;T;[o;;I" ;F;I"nil;To;;I"fCloses the write end of a StringIO.  Will raise an  `IOError` if the receiver
is not writeable.

;T;0;;;I"close_write;F;I"StringIO;T;[o;;I" ;F;I"nil;To;;I"LReturns `true` if the stream is completely closed, `false` otherwise.

;T;0;;;I"closed?;F;I"StringIO;T;[o;;I" ;F;I"	bool;To;;I"GReturns `true` if the stream is not readable, `false` otherwise.

;T;0;;;I"closed_read?;F;I"StringIO;T;[o;;I" ;F;I"	bool;To;;I"GReturns `true` if the stream is not writable, `false` otherwise.

;T;0;;;I"closed_write?;F;I"StringIO;T;[o;;I" ;F;I"	bool;To;;I"See IO#each.

;T;0;;;I"	each;F;I"StringIO;T;[o;;I"7?::String sep, ?::Integer limit, ?chomp: ::boolish;T;I"	self;To;;I"7?::String sep, ?::Integer limit, ?chomp: ::boolish;T;I"Enumerator[::String, self];To;;I"See IO#each_byte.

;T;0;;;I"each_byte;F;I"StringIO;T;[o;;I" ;F;I"	self;To;;I" ;F;I" Enumerator[::Integer, self];To;;I"See IO#each_char.

;T;0;;;I"each_char;F;I"StringIO;T;[o;;I" ;F;I"	self;To;;I" ;F;I"Enumerator[::String, self];To;;I"See IO#each_codepoint.

;T;0;;;I"each_codepoint;F;I"StringIO;T;[o;;I" ;F;I"	self;To;;I" ;F;I" Enumerator[::Integer, self];To;;I"‘Returns true if the stream is at the end of the data (underlying string). The
stream must be opened for reading or an `IOError` will be raised.

;T;0;;;I"eof;F;I"StringIO;T;[o;;I" ;F;I"	bool;To;;I""Raises NotImplementedError.

;T;0;;;I"
fcntl;F;I"StringIO;T;[o;;I"4::Integer integer_cmd, ::String | ::Integer arg;T;I"Integer;To;;I"4Returns `nil`.  Just for compatibility to IO.

;T;0;;;I"fileno;F;I"StringIO;T;[o;;I" ;F;I"nil;To;;I"?Returns an object itself.  Just for compatibility to IO.

;T;0;;;I"
flush;F;I"StringIO;T;[o;;I" ;F;I"	self;To;;I"0Returns 0.  Just for compatibility to IO.

;T;0;;;I"
fsync;F;I"StringIO;T;[o;;I" ;F;I"Integer?;To;;I"See IO#getbyte.

;T;0;;;I"getbyte;F;I"StringIO;T;[o;;I" ;F;I"Integer?;To;;I"See IO#getc.

;T;0;;;I"	getc;F;I"StringIO;T;[o;;I" ;F;I"String?;To;;I"See IO#gets.

;T;0;;;I"	gets;F;I"StringIO;T;[o;;I"7?::String sep, ?::Integer limit, ?chomp: ::boolish;T;I"String?;To;;I"gReturns the Encoding of the internal string if conversion is specified.
Otherwise returns `nil`.

;T;0;;;I"internal_encoding;F;I"StringIO;T;[o;;I" ;F;I"Encoding;To;;I"Returns the Encoding object that represents the encoding of the file. If the
stream is write mode and no encoding is specified, returns `nil`.

;T;0;;;I"external_encoding;F;I"StringIO;T;[o;;I" ;F;I"Encoding;To;;I"6Returns `false`.  Just for compatibility to IO.

;T;0;;;I"isatty;F;I"StringIO;T;[o;;I" ;F;I"	bool;To;;I"$Returns the current line number. The stream must be opened for reading.
`lineno` counts the number of times  `gets` is called, rather than the number
of newlines  encountered. The two values will differ if `gets` is  called with
a separator other than newline.  See also the  `$.` variable.

;T;0;;;I"lineno;F;I"StringIO;T;[o;;I" ;F;I"Integer;To;;I"gManually sets the current line number to the given value. `$.` is updated only
on the next read.

;T;0;;;I"lineno=;F;I"StringIO;T;[o;;I"::Integer arg0;T;I"Integer;To;;I"4Returns `nil`.  Just for compatibility to IO.

;T;0;;;I"pid;F;I"StringIO;T;[o;;I" ;F;I"nil;To;;I"-Returns the current offset (in bytes).

;T;0;;;I"pos;F;I"StringIO;T;[o;;I" ;F;I"Integer;To;;I".Seeks to the given position (in bytes).

;T;0;;;I"	pos=;F;I"StringIO;T;[o;;I"::Integer arg0;T;I"Integer;To;;0;0;;;I"
print;F;I"StringIO;T;[o;;I"*untyped arg0;T;I"nil;To;;0;0;;;I"printf;F;I"StringIO;T;[o;;I"*::String format_string, *untyped arg0;T;I"nil;To;;I"See IO#putc.

;T;0;;;I"	putc;F;I"StringIO;T;[o;;I"::Numeric | ::String arg0;T;I"untyped;To;;0;0;;;I"	puts;F;I"StringIO;T;[o;;I"*untyped arg0;T;I"nil;To;;I"See IO#read.

;T;0;;;I"	read;F;I"StringIO;T;[o;;I"%?::int? length, ?::string outbuf;T;I"String?;To;;0;0;;;I"read_nonblock;F;I"StringIO;T;[o;;I"::int len, ?::string buf;T;I"String;To;;0;0;;;I"readbyte;F;I"StringIO;T;[o;;I" ;F;I"Integer;To;;0;0;;;I"readchar;F;I"StringIO;T;[o;;I" ;F;I"String;To;;0;0;;;I"readline;F;I"StringIO;T;[o;;I"$?::String sep, ?::Integer limit;T;I"String;To;;I"See IO#readlines.

;T;0;;;I"readlines;F;I"StringIO;T;[o;;I"7?::String sep, ?::Integer limit, ?chomp: ::boolish;T;I"Array[::String];To;;0;0;;;I"readpartial;F;I"StringIO;T;[o;;I"#::int maxlen, ?::string outbuf;T;I"String;To;;I"gReinitializes the stream with the given *other_StrIO* or *string* and *mode*
(see StringIO#new).

;T;0;;;I"reopen;F;I"StringIO;T;[o;;I"::StringIO other;T;I"	self;To;;I"'::String other, ?::String mode_str;T;I"	self;To;;I"RPositions the stream to the beginning of input, resetting `lineno` to zero.

;T;0;;;I"rewind;F;I"StringIO;T;[o;;I" ;F;I"Integer;To;;I"gSeeks to a given offset *amount* in the stream according to the value of
*whence* (see IO#seek).

;T;0;;;I"	seek;F;I"StringIO;T;[o;;I"(::Integer amount, ?::Integer whence;T;I"Integer;To;;I"ÖSpecify the encoding of the StringIO as *ext_enc*. Use the default external
encoding if *ext_enc* is nil. 2nd argument *int_enc* and optional hash *opt*
argument are ignored; they are for API compatibility to IO.

;T;0;;;I"set_encoding;F;I"StringIO;T;[o;;I".?::String | ::Encoding ext_or_ext_int_enc;T;I"	self;To;;I"N?::String | ::Encoding ext_or_ext_int_enc, ?::String | ::Encoding int_enc;T;I"	self;To;;I";Returns underlying String object, the subject of IO.

;T;0;;;I"string;F;I"StringIO;T;[o;;I" ;F;I"String;To;;I";Changes underlying String object, the subject of IO.

;T;0;;;I"string=;F;I"StringIO;T;[o;;I"::String str;T;I"String;To;;I"-Returns the size of the buffer string.

;T;0;;;I"	size;F;I"StringIO;T;[o;;I" ;F;I"Integer;To;;I"Returns `true` always.

;T;0;;;I"	sync;F;I"StringIO;T;[o;;I" ;F;I"	bool;To;;I"EReturns the argument unchanged.  Just for compatibility to IO.

;T;0;;;I"
sync=;F;I"StringIO;T;[o;;I"::boolish;T;I"	bool;To;;0;0;;;I"sysread;F;I"StringIO;T;[o;;I"&::Integer maxlen, ::String outbuf;T;I"String;To;;0;0;;;I"syswrite;F;I"StringIO;T;[o;;I"::String arg0;T;I"Integer;To;;I"-Returns the current offset (in bytes).

;T;0;;;I"	tell;F;I"StringIO;T;[o;;I" ;F;I"Integer;To;;I"6Returns `false`.  Just for compatibility to IO.

;T;0;;;I"	tty?;F;I"StringIO;T;[o;;I" ;F;I"	bool;To;;I"See IO#ungetbyte

;T;0;;;I"ungetbyte;F;I"StringIO;T;[o;;I"::String | ::Integer arg0;T;I"nil;To;;I"ÙPushes back one character (passed as a parameter) such that a subsequent
buffered read will return it.  There is no limitation for multiple pushbacks
including pushing back behind the beginning of the buffer string.

;T;0;;;I"ungetc;F;I"StringIO;T;[o;;I"::String arg0;T;I"nil;To;;I"çAppends the given string to the underlying buffer string. The stream must be
opened for writing.  If the argument is not a string, it will be converted to
a string using `to_s`. Returns the number of bytes written.  See IO#write.

;T;0;;;I"
write;F;I"StringIO;T;[o;;I"::String arg0;T;I"Integer;To;;I"1This is a deprecated alias for #each_byte.

;T;0;;;I"
bytes;F;I"StringIO;T;[o;;I" ;F;I"	self;To;;I" ;F;I" Enumerator[::Integer, self];To;;I"1This is a deprecated alias for #each_char.

;T;0;;;I"
chars;F;I"StringIO;T;[o;;I" ;F;I"	self;To;;I" ;F;I"Enumerator[::String, self];To;;I"6This is a deprecated alias for #each_codepoint.

;T;0;;;I"codepoints;F;I"StringIO;T;[o;;I" ;F;I"	self;To;;I" ;F;I" Enumerator[::Integer, self];To;;I"See IO#each.

;T;0;;;I"each_line;F;I"StringIO;T;[o;;I"7?::String sep, ?::Integer limit, ?chomp: ::boolish;T;I"	self;To;;I"7?::String sep, ?::Integer limit, ?chomp: ::boolish;T;I"Enumerator[::String, self];To;;I"‘Returns true if the stream is at the end of the data (underlying string). The
stream must be opened for reading or an `IOError` will be raised.

;T;0;;;I"	eof?;F;I"StringIO;T;[o;;I" ;F;I"	bool;To;;I"1This is a deprecated alias for #each_line.

;T;0;;;I"
lines;F;I"StringIO;T;[o;;I"$?::String sep, ?::Integer limit;T;I"	self;To;;I"$?::String sep, ?::Integer limit;T;I"Enumerator[::String, self];To; ;I"ïClass Struct provides a convenient way to create a simple class that can store
and fetch values.

This example creates a subclass of `Struct`, `Struct::Customer`; the first
argument, a string, is the name of the subclass; the other arguments, symbols,
determine the *members* of the new subclass.

    Customer = Struct.new('Customer', :name, :address, :zip)
    Customer.name       # => "Struct::Customer"
    Customer.class      # => Class
    Customer.superclass # => Struct

Corresponding to each member are two methods, a writer and a reader, that
store and fetch values:

    methods = Customer.instance_methods false
    methods # => [:zip, :address=, :zip=, :address, :name, :name=]

An instance of the subclass may be created, and its members assigned values,
via method `::new`:

    joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
    joe # => #<struct Struct::Customer name="Joe Smith", address="123 Maple, Anytown NC", zip=12345>

The member values may be managed thus:

    joe.name    # => "Joe Smith"
    joe.name = 'Joseph Smith'
    joe.name    # => "Joseph Smith"

And thus; note that member name may be expressed as either a string or a
symbol:

    joe[:name]  # => "Joseph Smith"
    joe[:name] = 'Joseph Smith, Jr.'
    joe['name'] # => "Joseph Smith, Jr."

See Struct::new.

## What's Here

First, what's elsewhere. Class Struct:

*   Inherits from [class
    Object](Object.html#class-Object-label-What-27s+Here).
*   Includes [module
    Enumerable](Enumerable.html#module-Enumerable-label-What-27s+Here), which
    provides dozens of additional methods.


Here, class Struct provides methods that are useful for:

*   [Creating a Struct
    Subclass](#class-Struct-label-Methods+for+Creating+a+Struct+Subclass)
*   [Querying](#class-Struct-label-Methods+for+Querying)
*   [Comparing](#class-Struct-label-Methods+for+Comparing)
*   [Fetching](#class-Struct-label-Methods+for+Fetching)
*   [Assigning](#class-Struct-label-Methods+for+Assigning)
*   [Iterating](#class-Struct-label-Methods+for+Iterating)
*   [Converting](#class-Struct-label-Methods+for+Converting)


### Methods for Creating a Struct Subclass

::new
:   Returns a new subclass of Struct.


### Methods for Querying

#hash
:   Returns the integer hash code.
#length, #size
:   Returns the number of members.


### Methods for Comparing

[#==](#method-i-3D-3D)
:   Returns whether a given object is equal to `self`, using `==` to compare
    member values.
#eql?
:   Returns whether a given object is equal to `self`, using `eql?` to compare
    member values.


### Methods for Fetching

#[]
:   Returns the value associated with a given member name.
#to_a, #values, #deconstruct
:   Returns the member values in `self` as an array.
#deconstruct_keys
:   Returns a hash of the name/value pairs for given member names.
#dig
:   Returns the object in nested objects that is specified by a given member
    name and additional arguments.
#members
:   Returns an array of the member names.
#select, #filter
:   Returns an array of member values from `self`, as selected by the given
    block.
#values_at
:   Returns an array containing values for given member names.


### Methods for Assigning

#[]=
:   Assigns a given value to a given member name.


### Methods for Iterating

#each
:   Calls a given block with each member name.
#each_pair
:   Calls a given block with each member name/value pair.


### Methods for Converting

#inspect, #to_s
:   Returns a string representation of `self`.
#to_h
:   Returns a hash of the member name/value pairs in `self`.

;T;0;	I"Struct;T;
[ ;[I"Enumerable;T;0;[ ;[ ;0;I"Object;To;;I"¦`Struct.new` returns a new subclass of `Struct`.  The new subclass:

*   May be anonymous, or may have the name given by `class_name`.
*   May have members as given by `member_names`.
*   May have initialization via ordinary arguments (the default) or via
    keyword arguments (if `keyword_init: true` is given).


The new subclass has its own method `::new`; thus:

    Foo = Struct.new('Foo', :foo, :bar) # => Struct::Foo
    f = Foo.new(0, 1)                   # => #<struct Struct::Foo foo=0, bar=1>

**\Class Name**

With string argument `class_name`, returns a new subclass of `Struct` named
`Struct::*class_name`*:

    Foo = Struct.new('Foo', :foo, :bar) # => Struct::Foo
    Foo.name                            # => "Struct::Foo"
    Foo.superclass                      # => Struct

Without string argument `class_name`, returns a new anonymous subclass of
`Struct`:

    Struct.new(:foo, :bar).name # => nil

**Block**

With a block given, the created subclass is yielded to the block:

    Customer = Struct.new('Customer', :name, :address) do |new_class|
      p "The new subclass is #{new_class}"
      def greeting
        "Hello #{name} at #{address}"
      end
    end           # => Struct::Customer
    dave = Customer.new('Dave', '123 Main')
    dave # =>     #<struct Struct::Customer name="Dave", address="123 Main">
    dave.greeting # => "Hello Dave at 123 Main"

Output, from `Struct.new`:

    "The new subclass is Struct::Customer"

**Member Names**

Symbol arguments `member_names` determines the members of the new subclass:

    Struct.new(:foo, :bar).members        # => [:foo, :bar]
    Struct.new('Foo', :foo, :bar).members # => [:foo, :bar]

The new subclass has instance methods corresponding to `member_names`:

    Foo = Struct.new('Foo', :foo, :bar)
    Foo.instance_methods(false) # => [:foo, :bar, :foo=, :bar=]
    f = Foo.new                 # => #<struct Struct::Foo foo=nil, bar=nil>
    f.foo                       # => nil
    f.foo = 0                   # => 0
    f.bar                       # => nil
    f.bar = 1                   # => 1
    f                           # => #<struct Struct::Foo foo=0, bar=1>

**Singleton Methods**

A subclass returned by Struct.new has these singleton methods:

*   Method `::new ` creates an instance of the subclass:

        Foo.new          # => #<struct Struct::Foo foo=nil, bar=nil>
        Foo.new(0)       # => #<struct Struct::Foo foo=0, bar=nil>
        Foo.new(0, 1)    # => #<struct Struct::Foo foo=0, bar=1>
        Foo.new(0, 1, 2) # Raises ArgumentError: struct size differs

    Method `::[]` is an alias for method `::new`.

*   Method `:inspect` returns a string representation of the subclass:

        Foo.inspect
        # => "Struct::Foo"

*   Method `::members` returns an array of the member names:

        Foo.members # => [:foo, :bar]


**Keyword Argument**

By default, the arguments for initializing an instance of the new subclass are
ordinary arguments (not keyword arguments). With optional keyword argument
`keyword_init: true`, the new subclass is initialized with keyword arguments:

    # Without keyword_init: true.
    Foo = Struct.new('Foo', :foo, :bar)
    Foo                     # => Struct::Foo
    Foo.new(0, 1)           # => #<struct Struct::Foo foo=0, bar=1>
    # With keyword_init: true.
    Bar = Struct.new(:foo, :bar, keyword_init: true)
    Bar # =>                # => Bar(keyword_init: true)
    Bar.new(bar: 1, foo: 0) # => #<struct Bar foo=0, bar=1>

;T;0;;;I"initialize;F;I"Struct;T;[o;;I"R::Struct::attribute_name, *::Struct::attribute_name, ?keyword_init: ::boolish;T;I"	void;To;;I"_Calls the given block with the value of each member; returns `self`:

    Customer = Struct.new(:name, :address, :zip)
    joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
    joe.each {|value| p value }

Output:

    "Joe Smith"
    "123 Maple, Anytown NC"
    12345

Returns an Enumerator if no block is given.

Related: #each_pair.

;T;0;;;I"	each;F;I"Struct;T;[o;;I" ;F;I"Enumerator[Elem?, self];To;;I" ;F;I"	self;To;;I"¤Returns the member names of the Struct descendant as an array:

    Customer = Struct.new(:name, :address, :zip)
    Customer.members # => [:name, :address, :zip]

;T;0;;;I"members;F;I"Struct;T;[o;;I" ;F;I"Array[::Symbol];To;;I"KReturns `true` if the class was initialized with `keyword_init: true`.
Otherwise returns `nil` or `false`.

Examples:
    Foo = Struct.new(:a)
    Foo.keyword_init? # => nil
    Bar = Struct.new(:a, keyword_init: true)
    Bar.keyword_init? # => true
    Baz = Struct.new(:a, keyword_init: false)
    Baz.keyword_init? # => false

;T;0;;;I"keyword_init?;F;I"Struct;T;[o;;I" ;F;I"true | false | nil;Fo; ;0;0;	I"Struct;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"jDeserializes JSON string by constructing new Struct object with values `v`
serialized by `to_json`.

;T;0;;;I"json_create;F;I"Struct;T;[o;;I"6::Hash[::String, ::String | ::Array[Elem]] object;T;I"Struct[Elem];To;;I"XReturns a hash, that will be turned into a JSON object and represent this
object.

;T;0;;;I"as_json;F;I"Struct;T;[o;;I"*untyped;T;I"-Hash[::String, ::String | ::Array[Elem]];To;;I"lStores class name (Struct) with Struct values `v` as a JSON string. Only named
structs are supported.

;T;0;;;I"to_json;F;I"Struct;T;[o;;I"?::JSON::State state;T;I"String;To; ;I"Symbol objects represent named identifiers inside the Ruby interpreter.

You can create a Symbol object explicitly with:

*   A [symbol literal](doc/syntax/literals_rdoc.html#label-Symbol+Literals).


The same Symbol object will be created for a given name or string for the
duration of a program's execution, regardless of the context or meaning of
that name. Thus if `Fred` is a constant in one context, a method in another,
and a class in a third, the Symbol `:Fred` will be the same object in all
three contexts.

    module One
      class Fred
      end
      $f1 = :Fred
    end
    module Two
      Fred = 1
      $f2 = :Fred
    end
    def Fred()
    end
    $f3 = :Fred
    $f1.object_id   #=> 2514190
    $f2.object_id   #=> 2514190
    $f3.object_id   #=> 2514190

Constant, method, and variable names are returned as symbols:

    module One
      Two = 2
      def three; 3 end
      @four = 4
      @@five = 5
      $six = 6
    end
    seven = 7

    One.constants
    # => [:Two]
    One.instance_methods(true)
    # => [:three]
    One.instance_variables
    # => [:@four]
    One.class_variables
    # => [:@@five]
    global_variables.grep(/six/)
    # => [:$six]
    local_variables
    # => [:seven]

Symbol objects are different from String objects in that Symbol objects
represent identifiers, while String objects represent text or data.

## What's Here

First, what's elsewhere. Class Symbol:

*   Inherits from [class
    Object](Object.html#class-Object-label-What-27s+Here).
*   Includes [module
    Comparable](Comparable.html#module-Comparable-label-What-27s+Here).


Here, class Symbol provides methods that are useful for:

*   [Querying](#class-Symbol-label-Methods+for+Querying)
*   [Comparing](#class-Symbol-label-Methods+for+Comparing)
*   [Converting](#class-Symbol-label-Methods+for+Converting)


### Methods for Querying

    ::all_symbols
:       Returns an array of the symbols currently in Ruby's symbol table.

    [#=~](#method-i-3D~)
:       Returns the index of the first substring in symbol that matches a
        given Regexp or other object; returns `nil` if no match is found.

    #[], #slice
:       Returns a substring of symbol determined by a given index,
        start/length, or range, or string.

    #empty?
:       Returns `true` if `self.length` is zero; `false` otherwise.

    #encoding
:       Returns the Encoding object that represents the encoding of symbol.

    #end_with?
:       Returns `true` if symbol ends with any of the given strings.

    #match
:       Returns a MatchData object if symbol matches a given Regexp; `nil`
        otherwise.

    #match?
:       Returns `true` if symbol matches a given Regexp; `false` otherwise.

    #length, #size
:       Returns the number of characters in symbol.

    #start_with?
:       Returns `true` if symbol starts with any of the given strings.



### Methods for Comparing

    [#<=>](#method-i-3C-3D-3E)
:       Returns -1, 0, or 1 as a given symbol is smaller than, equal to, or
        larger than symbol.

    [#==, #===](#method-i-3D-3D)
:       Returns `true` if a given symbol has the same content and encoding.

    #casecmp
:       Ignoring case, returns -1, 0, or 1 as a given symbol is smaller than,
        equal to, or larger than symbol.

    #casecmp?
:       Returns `true` if symbol is equal to a given symbol after Unicode case
        folding; `false` otherwise.



### Methods for Converting

    #capitalize
:       Returns symbol with the first character upcased and all other
        characters downcased.

    #downcase
:       Returns symbol with all characters downcased.

    #inspect
:       Returns the string representation of `self` as a symbol literal.

    #name
:       Returns the frozen string corresponding to symbol.

    #succ, #next
:       Returns the symbol that is the successor to symbol.

    #swapcase
:       Returns symbol with all upcase characters downcased and all downcase
        characters upcased.

    #to_proc
:       Returns a Proc object which responds to the method named by symbol.

    #to_s, #id2name
:       Returns the string corresponding to `self`.

    #to_sym, #intern
:       Returns `self`.

    #upcase
:       Returns symbol with all characters upcased.

;T;0;	I"Symbol;T;
[ ;[I"Comparable;T;0;[ ;[ ;0;0o;;I"öReturns an array of all the symbols currently in Ruby's symbol table.

    Symbol.all_symbols.size    #=> 903
    Symbol.all_symbols[1,20]   #=> [:floor, :ARGV, :Binding, :symlink,
                                    :chown, :EOFError, :$;, :String,
                                    :LOCK_SH, :"setuid?", :$<,
                                    :default_proc, :compact, :extend,
                                    :Tms, :getwd, :$=, :ThreadGroup,
                                    :wait2, :$>]

;T;0;;;I"all_symbols;F;I"Symbol;T;[o;;I" ;F;I"Array[::Symbol];To;;I""Compares `symbol` with `other_symbol` after calling #to_s on each of the
symbols. Returns -1, 0, +1, or `nil` depending on whether `symbol` is less
than, equal to, or greater than `other_symbol`.

`nil` is returned if the two values are incomparable.

See String#<=> for more information.

;T;0;;;I"<=>;F;I"Symbol;T;[o;;I"::Symbol other;T;I"Integer;To;;I"untyped other;T;I"Integer?;To;;I"QEquality---If *sym* and *obj* are exactly the same symbol, returns `true`.

;T;0;;;I"==;F;I"Symbol;T;[o;;I"untyped obj;T;I"	bool;To;;I"QEquality---If *sym* and *obj* are exactly the same symbol, returns `true`.

;T;0;;;I"===;F;I"Symbol;T;[o;;I"untyped obj;T;I"	bool;To;;I"!Returns `sym.to_s =~ obj`.

;T;0;;;I"=~;F;I"Symbol;T;[o;;I"untyped obj;T;I"Integer?;To;;I"Returns `sym.to_s[]`.

;T;0;;;I"[];F;I"Symbol;T;[o;;I"::int index;T;I"String?;To;;I"::int start, ::int length;T;I"String?;To;;I"::Range[::Integer?] range;T;I"String?;To;;I"::Regexp regexp;T;I"String?;To;;I".::Regexp regexp, ::int | ::String capture;T;I"String?;To;;I"::String match_str;T;I"String?;To;;I"JEquivalent to `sym.to_s.capitalize.to_sym`.

See String#capitalize.

;T;0;;;I"capitalize;F;I"Symbol;T;[	o;;I" ;F;I"Symbol;To;;I"#:ascii | :lithuanian | :turkic;T;I"Symbol;To;;I":lithuanian, :turkic;T;I"Symbol;To;;I":turkic, :lithuanian;T;I"Symbol;To;;I"pCase-insensitive version of [Symbol#<=>](#method-i-3C-3D-3E):

    :aBcDeF.casecmp(:abcde)   # => 1
    :aBcDeF.casecmp(:abcdef)  # => 0
    :aBcDeF.casecmp(:abcdefg) # => -1
    :abcdef.casecmp(:ABCDEF)  # => 0

Returns `nil` if the two symbols have incompatible encodings, or if
`other_symbol` is not a symbol:

    sym = "\u{e4 f6 fc}".encode("ISO-8859-1").to_sym
    other_sym = :"\u{c4 d6 dc}"
    sym.casecmp(other_sym) # => nil
    :foo.casecmp(2)        # => nil

Currently, case-insensitivity only works on characters A-Z/a-z, not all of
Unicode. This is different from Symbol#casecmp?.

Related: Symbol#casecmp?.

;T;0;;;I"casecmp;F;I"Symbol;T;[o;;I"untyped other;T;I"Integer?;To;;I"ÛReturns `true` if `sym` and `other_symbol` are equal after Unicode case
folding, `false` if they are not equal:

    :aBcDeF.casecmp?(:abcde)                  # => false
    :aBcDeF.casecmp?(:abcdef)                 # => true
    :aBcDeF.casecmp?(:abcdefg)                # => false
    :abcdef.casecmp?(:ABCDEF)                 # => true
    :"\u{e4 f6 fc}".casecmp?(:"\u{c4 d6 dc}") #=> true

Returns `nil` if the two symbols have incompatible encodings, or if
`other_symbol` is not a symbol:

    sym = "\u{e4 f6 fc}".encode("ISO-8859-1").to_sym
    other_sym = :"\u{c4 d6 dc}"
    sym.casecmp?(other_sym) # => nil
    :foo.casecmp?(2)        # => nil

See [Case Mapping](doc/case_mapping_rdoc.html).

Related: Symbol#casecmp.

;T;0;;;I"casecmp?;F;I"Symbol;T;[o;;I"untyped other;T;I"
bool?;To;;I"_Equivalent to `sym.to_s.downcase.to_sym`.

See String#downcase.

Related: Symbol#upcase.

;T;0;;;I"downcase;F;I"Symbol;T;[	o;;I" ;F;I"Symbol;To;;I"+:ascii | :fold | :lithuanian | :turkic;T;I"Symbol;To;;I":lithuanian, :turkic;T;I"Symbol;To;;I":turkic, :lithuanian;T;I"Symbol;To;;I"+Returns whether *sym* is :"" or not.

;T;0;;;I"empty?;F;I"Symbol;T;[o;;I" ;F;I"	bool;To;;I"IReturns the Encoding object that represents the encoding of *sym*.

;T;0;;;I"encoding;F;I"Symbol;T;[o;;I" ;F;I"Encoding;To;;I"Returns true if `sym` ends with one of the `suffixes` given.

    :hello.end_with?("ello")               #=> true

    # returns true if one of the +suffixes+ matches.
    :hello.end_with?("heaven", "ello")     #=> true
    :hello.end_with?("heaven", "paradise") #=> false

;T;0;;;I"end_with?;F;I"Symbol;T;[o;;I"*::string suffixes;T;I"	bool;To;;I"ÙReturns the name or string corresponding to *sym*.

    :fred.id2name   #=> "fred"
    :ginger.to_s    #=> "ginger"

Note that this string is not frozen (unlike the symbol itself). To get a
frozen string, use #name.

;T;0;;;I"id2name;F;I"Symbol;T;[o;;I" ;F;I"String;To;;I"`Returns the representation of *sym* as a symbol literal.

    :fred.inspect   #=> ":fred"

;T;0;;;I"inspect;F;I"Symbol;T;[o;;I" ;F;I"String;To;;I"„In general, `to_sym` returns the Symbol corresponding to an object. As *sym*
is already a symbol, `self` is returned in this case.

;T;0;;;I"intern;F;I"Symbol;T;[o;;I" ;F;I"Symbol;To;;I"!Same as `sym.to_s.length`.

;T;0;;;I"length;F;I"Symbol;T;[o;;I" ;F;I"Integer;To;;I" Returns `sym.to_s.match`.

;T;0;;;I"
match;F;I"Symbol;T;[o;;I",::Regexp | ::string pattern, ?::int pos;T;I"MatchData?;To;;I",::Regexp | ::string pattern, ?::int pos;T;I"untyped;To;;I"!Returns `sym.to_s.match?`.

;T;0;;;I"match?;F;I"Symbol;T;[o;;I",::Regexp | ::string pattern, ?::int pos;T;I"	bool;To;;I"&Same as `sym.to_s.succ.intern`.

;T;0;;;I"	next;F;I"Symbol;T;[o;;I" ;F;I"Symbol;To;;I"…Returns true if `sym` starts with one of the `prefixes` given. Each of the
`prefixes` should be a String or a Regexp.

    :hello.start_with?("hell")               #=> true
    :hello.start_with?(/H/i)                 #=> true

    # returns true if one of the prefixes matches.
    :hello.start_with?("heaven", "hell")     #=> true
    :hello.start_with?("heaven", "paradise") #=> false

;T;0;;;I"start_with?;F;I"Symbol;T;[o;;I"*::string prefixes;T;I"	bool;To;;I"FEquivalent to `sym.to_s.swapcase.to_sym`.

See String#swapcase.

;T;0;;;I"swapcase;F;I"Symbol;T;[	o;;I" ;F;I"Symbol;To;;I"#:ascii | :lithuanian | :turkic;T;I"Symbol;To;;I":lithuanian, :turkic;T;I"Symbol;To;;I":turkic, :lithuanian;T;I"Symbol;To;;I"|Returns a *Proc* object which responds to the given method by *sym*.

    (1..3).collect(&:to_s)  #=> ["1", "2", "3"]

;T;0;;;I"to_proc;F;I"Symbol;T;[o;;I" ;F;I"	Proc;To;;I"BEquivalent to `sym.to_s.upcase.to_sym`.

See String#upcase.

;T;0;;;I"upcase;F;I"Symbol;T;[	o;;I" ;F;I"Symbol;To;;I"#:ascii | :lithuanian | :turkic;T;I"Symbol;To;;I":lithuanian, :turkic;T;I"Symbol;To;;I":turkic, :lithuanian;T;I"Symbol;To;;0;0;;;I"
clone;F;I"Symbol;T;[o;;I"?freeze: true?;T;I"	self;To; ;0;0;	I"Symbol;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"aDeserializes JSON string by converting the `string` value stored in the object
to a Symbol

;T;0;;;I"json_create;F;I"Symbol;T;[o;;I"&::Hash[::String, ::String] object;T;I"instance;To;;I"XReturns a hash, that will be turned into a JSON object and represent this
object.

;T;0;;;I"as_json;F;I"Symbol;T;[o;;I"*untyped;T;I"Hash[::String, ::String];To;;I"XStores class name (Symbol) with String representation of Symbol as a JSON
string.

;T;0;;;I"to_json;F;I"Symbol;T;[o;;I"?::JSON::State state;T;I"String;To; ;I"’Threads are the Ruby implementation for a concurrent programming model.

Programs that require multiple threads of execution are a perfect candidate
for Ruby's Thread class.

For example, we can create a new thread separate from the main thread's
execution using ::new.

    thr = Thread.new { puts "What's the big deal" }

Then we are able to pause the execution of the main thread and allow our new
thread to finish, using #join:

    thr.join #=> "What's the big deal"

If we don't call `thr.join` before the main thread terminates, then all other
threads including `thr` will be killed.

Alternatively, you can use an array for handling multiple threads at once,
like in the following example:

    threads = []
    threads << Thread.new { puts "What's the big deal" }
    threads << Thread.new { 3.times { puts "Threads are fun!" } }

After creating a few threads we wait for them all to finish consecutively.

    threads.each { |thr| thr.join }

To retrieve the last value of a thread, use #value

    thr = Thread.new { sleep 1; "Useful value" }
    thr.value #=> "Useful value"

### Thread initialization

In order to create new threads, Ruby provides ::new, ::start, and ::fork. A
block must be provided with each of these methods, otherwise a ThreadError
will be raised.

When subclassing the Thread class, the `initialize` method of your subclass
will be ignored by ::start and ::fork. Otherwise, be sure to call super in
your `initialize` method.

### Thread termination

For terminating threads, Ruby provides a variety of ways to do this.

The class method ::kill, is meant to exit a given thread:

    thr = Thread.new { sleep }
    Thread.kill(thr) # sends exit() to thr

Alternatively, you can use the instance method #exit, or any of its aliases
#kill or #terminate.

    thr.exit

### Thread status

Ruby provides a few instance methods for querying the state of a given thread.
To get a string with the current thread's state use #status

    thr = Thread.new { sleep }
    thr.status # => "sleep"
    thr.exit
    thr.status # => false

You can also use #alive? to tell if the thread is running or sleeping, and
#stop? if the thread is dead or sleeping.

### Thread variables and scope

Since threads are created with blocks, the same rules apply to other Ruby
blocks for variable scope. Any local variables created within this block are
accessible to only this thread.

#### Fiber-local vs. Thread-local

Each fiber has its own bucket for Thread#[] storage. When you set a new
fiber-local it is only accessible within this Fiber. To illustrate:

    Thread.new {
      Thread.current[:foo] = "bar"
      Fiber.new {
        p Thread.current[:foo] # => nil
      }.resume
    }.join

This example uses #[] for getting and #[]= for setting fiber-locals, you can
also use #keys to list the fiber-locals for a given thread and #key? to check
if a fiber-local exists.

When it comes to thread-locals, they are accessible within the entire scope of
the thread. Given the following example:

    Thread.new{
      Thread.current.thread_variable_set(:foo, 1)
      p Thread.current.thread_variable_get(:foo) # => 1
      Fiber.new{
        Thread.current.thread_variable_set(:foo, 2)
        p Thread.current.thread_variable_get(:foo) # => 2
      }.resume
      p Thread.current.thread_variable_get(:foo)   # => 2
    }.join

You can see that the thread-local `:foo` carried over into the fiber and was
changed to `2` by the end of the thread.

This example makes use of #thread_variable_set to create new thread-locals,
and #thread_variable_get to reference them.

There is also #thread_variables to list all thread-locals, and
#thread_variable? to check if a given thread-local exists.

### Exception handling

When an unhandled exception is raised inside a thread, it will terminate. By
default, this exception will not propagate to other threads. The exception is
stored and when another thread calls #value or #join, the exception will be
re-raised in that thread.

    t = Thread.new{ raise 'something went wrong' }
    t.value #=> RuntimeError: something went wrong

An exception can be raised from outside the thread using the Thread#raise
instance method, which takes the same parameters as Kernel#raise.

Setting Thread.abort_on_exception = true, Thread#abort_on_exception = true, or
$DEBUG = true will cause a subsequent unhandled exception raised in a thread
to be automatically re-raised in the main thread.

With the addition of the class method ::handle_interrupt, you can now handle
exceptions asynchronously with threads.

### Scheduling

Ruby provides a few ways to support scheduling threads in your program.

The first way is by using the class method ::stop, to put the current running
thread to sleep and schedule the execution of another thread.

Once a thread is asleep, you can use the instance method #wakeup to mark your
thread as eligible for scheduling.

You can also try ::pass, which attempts to pass execution to another thread
but is dependent on the OS whether a running thread will switch or not. The
same goes for #priority, which lets you hint to the thread scheduler which
threads you want to take precedence when passing execution. This method is
also dependent on the OS and may be ignored on some platforms.

;T;0;	I"Thread;T;
[ ;[ ;0;[ ;[ ;0;I"Object;To;;I"aReturns the currently executing thread.

    Thread.current   #=> #<Thread:0x401bdf4c run>

;T;0;;;I"current;F;I"Thread;T;[o;;I" ;F;I"Thread;To;;I"Returns the main thread.

;T;0;;;I"	main;F;I"Thread;T;[o;;I" ;F;I"Thread;To;;I"äAttribute Reference---Returns the value of a fiber-local variable (current
thread's root fiber if not explicitly inside a Fiber), using either a symbol
or a string name. If the specified variable does not exist, returns `nil`.

    [
      Thread.new { Thread.current["name"] = "A" },
      Thread.new { Thread.current[:name]  = "B" },
      Thread.new { Thread.current["name"] = "C" }
    ].each do |th|
      th.join
      puts "#{th.inspect}: #{th[:name]}"
    end

This will produce:

    #<Thread:0x00000002a54220 dead>: A
    #<Thread:0x00000002a541a8 dead>: B
    #<Thread:0x00000002a54130 dead>: C

Thread#[] and Thread#[]= are not thread-local but fiber-local. This confusion
did not exist in Ruby 1.8 because fibers are only available since Ruby 1.9.
Ruby 1.9 chooses that the methods behaves fiber-local to save following idiom
for dynamic scope.

    def meth(newvalue)
      begin
        oldvalue = Thread.current[:name]
        Thread.current[:name] = newvalue
        yield
      ensure
        Thread.current[:name] = oldvalue
      end
    end

The idiom may not work as dynamic scope if the methods are thread-local and a
given block switches fiber.

    f = Fiber.new {
      meth(1) {
        Fiber.yield
      }
    }
    meth(2) {
      f.resume
    }
    f.resume
    p Thread.current[:name]
    #=> nil if fiber-local
    #=> 2 if thread-local (The value 2 is leaked to outside of meth method.)

For thread-local variables, please see #thread_variable_get and
#thread_variable_set.

;T;0;;;I"[];F;I"Thread;T;[o;;I"::String | ::Symbol key;T;I"untyped;To;;I"ÜAttribute Assignment---Sets or creates the value of a fiber-local variable,
using either a symbol or a string.

See also Thread#[].

For thread-local variables, please see #thread_variable_set and
#thread_variable_get.

;T;0;;;I"[]=;F;I"Thread;T;[o;;I"+::String | ::Symbol key, untyped value;T;I"untyped;To;;I"îReturns `true` if `thr` is running or sleeping.

    thr = Thread.new { }
    thr.join                #=> #<Thread:0x401b3fb0 dead>
    Thread.current.alive?   #=> true
    thr.alive?              #=> false

See also #stop? and #status.

;T;0;;;I"alive?;F;I"Thread;T;[o;;I" ;F;I"	bool;To;;I"ŸTerminates `thr` and schedules another thread to be run, returning the
terminated Thread.  If this is the main thread, or the last thread, exits the
process.

;T;0;;;I"	kill;F;I"Thread;T;[o;;I" ;F;I"Thread?;To;;I"íReturns the status of the thread-local ``abort on exception'' condition for
this `thr`.

The default is `false`.

See also #abort_on_exception=.

There is also a class level method to set this for all threads, see
::abort_on_exception.

;T;0;;;I"abort_on_exception;F;I"Thread;T;[o;;I" ;F;I"	bool;To;;I"õWhen set to `true`, if this `thr` is aborted by an exception, the raised
exception will be re-raised in the main thread.

See also #abort_on_exception.

There is also a class level method to set this for all threads, see
::abort_on_exception=.

;T;0;;;I"abort_on_exception=;F;I"Thread;T;[o;;I"!::boolish abort_on_exception;T;I"untyped;To;;I"bAdds *proc* as a handler for tracing.

See Thread#set_trace_func and Kernel#set_trace_func.

;T;0;;;I"add_trace_func;F;I"Thread;T;[o;;I"untyped proc;T;I"untyped;To;;I":Returns the current backtrace of the target thread.

;T;0;;;I"backtrace;F;I"Thread;T;[o;;I"*untyped args;T;I"Array[untyped];To;;I"þReturns the execution stack for the target thread---an array containing
backtrace location objects.

See Thread::Backtrace::Location for more information.

This method behaves similarly to Kernel#caller_locations except it applies to
a specific thread.

;T;0;;;I"backtrace_locations;F;I"Thread;T;[o;;I"*untyped args;T;I"Array[untyped]?;To;;I"ŸTerminates `thr` and schedules another thread to be run, returning the
terminated Thread.  If this is the main thread, or the last thread, exits the
process.

;T;0;;;I"	exit;F;I"Thread;T;[o;;I" ;F;I"Thread?;To;;I"GReturns a fiber-local for the given key. If the key can't be found, there are
several options: With no other arguments, it will raise a KeyError exception;
if *default* is given, then that will be returned; if the optional code block
is specified, then that will be run and its result returned.  See Thread#[]
and Hash#fetch.

;T;0;;;I"
fetch;F;I"Thread;T;[o;;I"*untyped sym;T;I"untyped;To;;I"vReturns the ThreadGroup which contains the given thread.

    Thread.main.group   #=> #<ThreadGroup:0x4029d914>

;T;0;;;I"
group;F;I"Thread;T;[o;;I" ;F;I"ThreadGroup?;To;;I"¤Creates a new thread executing the given block.

Any `args` given to ::new will be passed to the block:

    arr = []
    a, b, c = 1, 2, 3
    Thread.new(a,b,c) { |d,e,f| arr << d << e << f }.join
    arr #=> [1, 2, 3]

A ThreadError exception is raised if ::new is called without a block.

If you're going to subclass Thread, be sure to call super in your `initialize`
method, otherwise a ThreadError will be raised.

;T;0;;;I"initialize;F;I"Thread;T;[o;;I"*untyped;T;I"	void;To;;I"´The calling thread will suspend execution and run this `thr`.

Does not return until `thr` exits or until the given `limit` seconds have
passed.

If the time limit expires, `nil` will be returned, otherwise `thr` is
returned.

Any threads not joined will be killed when the main program exits.

If `thr` had previously raised an exception and the ::abort_on_exception or
$DEBUG flags are not set, (so the exception has not yet been processed), it
will be processed at this time.

    a = Thread.new { print "a"; sleep(10); print "b"; print "c" }
    x = Thread.new { print "x"; Thread.pass; print "y"; print "z" }
    x.join # Let thread x finish, thread a will be killed on exit.
    #=> "axyz"

The following example illustrates the `limit` parameter.

    y = Thread.new { 4.times { sleep 0.1; puts 'tick... ' }}
    puts "Waiting" until y.join(0.15)

This will produce:

    tick...
    Waiting
    tick...
    Waiting
    tick...
    tick...

;T;0;;;I"	join;F;I"Thread;T;[o;;I"*untyped limit;T;I"Thread;To;;I"ÄReturns `true` if the given string (or symbol) exists as a fiber-local
variable.

    me = Thread.current
    me[:oliver] = "a"
    me.key?(:oliver)    #=> true
    me.key?(:stanley)   #=> false

;T;0;;;I"	key?;F;I"Thread;T;[o;;I"::Symbol sym;T;I"	bool;To;;I"Returns an array of the names of the fiber-local variables (as Symbols).

    thr = Thread.new do
      Thread.current[:cat] = 'meow'
      Thread.current["dog"] = 'woof'
    end
    thr.join   #=> #<Thread:0x401b3f10 dead>
    thr.keys   #=> [:dog, :cat]

;T;0;;;I"	keys;F;I"Thread;T;[o;;I" ;F;I"Array[::Symbol];To;;I"#show the name of the thread.

;T;0;;;I"	name;F;I"Thread;T;[o;;I" ;F;I"String;To;;I"iset given name to the ruby thread. On some platform, it may set the name to
pthread and/or kernel.

;T;0;;;I"
name=;F;I"Thread;T;[o;;I"untyped name;T;I"untyped;To;;I"ÍReturn the native thread ID which is used by the Ruby thread.

The ID depends on the OS. (not POSIX thread ID returned by pthread_self(3))
*   On Linux it is TID returned by gettid(2).
*   On macOS it is the system-wide unique integral ID of thread returned by
    pthread_threadid_np(3).
*   On FreeBSD it is the unique integral ID of the thread returned by
    pthread_getthreadid_np(3).
*   On Windows it is the thread identifier returned by GetThreadId().
*   On other platforms, it raises NotImplementedError.


NOTE: If the thread is not associated yet or already deassociated with a
native thread, it returns *nil*. If the Ruby implementation uses M:N thread
model, the ID may change depending on the timing.

;T;0;;;I"native_thread_id;F;I"Thread;T;[o;;I" ;F;I"Integer;To;;I"ÇReturns whether or not the asynchronous queue is empty for the target thread.

If `error` is given, then check only for `error` type deferred events.

See ::pending_interrupt? for more information.

;T;0;;;I"pending_interrupt?;F;I"Thread;T;[o;;I"*untyped args;T;I"	bool;To;;I"€Returns the priority of *thr*. Default is inherited from the current thread
which creating the new thread, or zero for the initial main thread;
higher-priority thread will run more frequently than lower-priority threads
(but lower-priority threads can also run).

This is just hint for Ruby thread scheduler.  It may be ignored on some
platform.

    Thread.current.priority   #=> 0

;T;0;;;I"priority;F;I"Thread;T;[o;;I" ;F;I"Integer;To;;I"ýSets the priority of *thr* to *integer*. Higher-priority threads will run more
frequently than lower-priority threads (but lower-priority threads can also
run).

This is just hint for Ruby thread scheduler.  It may be ignored on some
platform.

    count1 = count2 = 0
    a = Thread.new do
          loop { count1 += 1 }
        end
    a.priority = -1

    b = Thread.new do
          loop { count2 += 1 }
        end
    b.priority = -2
    sleep 1   #=> 1
    count1    #=> 622504
    count2    #=> 5832

;T;0;;;I"priority=;F;I"Thread;T;[o;;I"::Integer priority;T;I"untyped;To;;I"BReturns the status of the thread-local ``report on exception'' condition for
this `thr`.

The default value when creating a Thread is the value of the global flag
Thread.report_on_exception.

See also #report_on_exception=.

There is also a class level method to set this for all new threads, see
::report_on_exception=.

;T;0;;;I"report_on_exception;F;I"Thread;T;[o;;I" ;F;I"	bool;To;;I" When set to `true`, a message is printed on $stderr if an exception kills this
`thr`.  See ::report_on_exception for details.

See also #report_on_exception.

There is also a class level method to set this for all new threads, see
::report_on_exception=.

;T;0;;;I"report_on_exception=;F;I"Thread;T;[o;;I""::boolish report_on_exception;T;I"untyped;To;;I"Wakes up `thr`, making it eligible for scheduling.

    a = Thread.new { puts "a"; Thread.stop; puts "c" }
    sleep 0.1 while a.status!='sleep'
    puts "Got here"
    a.run
    a.join

This will produce:

    a
    Got here
    c

See also the instance method #wakeup.

;T;0;;;I"run;F;I"Thread;T;[o;;I" ;F;I"Thread;To;;I"sReturns the safe level.

This method is obsolete because $SAFE is a process global state. Simply
check $SAFE.
;T;0;;;I"safe_level;F;I"Thread;T;[o;;I" ;F;I"Integer;To;;I"ØReturns the status of `thr`.

`"sleep"`
:   Returned if this thread is sleeping or waiting on I/O
`"run"`
:   When this thread is executing
`"aborting"`
:   If this thread is aborting
`false`
:   When this thread is terminated normally
`nil`
:   If terminated with an exception.


    a = Thread.new { raise("die now") }
    b = Thread.new { Thread.stop }
    c = Thread.new { Thread.exit }
    d = Thread.new { sleep }
    d.kill                  #=> #<Thread:0x401b3678 aborting>
    a.status                #=> nil
    b.status                #=> "sleep"
    c.status                #=> false
    d.status                #=> "aborting"
    Thread.current.status   #=> "run"

See also the instance methods #alive? and #stop?

;T;0;;;I"status;F;I"Thread;T;[o;;I" ;F;I"(::String | bool)?;To;;I"·Returns `true` if `thr` is dead or sleeping.

    a = Thread.new { Thread.stop }
    b = Thread.current
    a.stop?   #=> true
    b.stop?   #=> false

See also #alive? and #status.

;T;0;;;I"
stop?;F;I"Thread;T;[o;;I" ;F;I"	bool;To;;I"ŸTerminates `thr` and schedules another thread to be run, returning the
terminated Thread.  If this is the main thread, or the last thread, exits the
process.

;T;0;;;I"terminate;F;I"Thread;T;[o;;I" ;F;I"Thread?;To;;I"gReturns `true` if the given string (or symbol) exists as a thread-local
variable.

    me = Thread.current
    me.thread_variable_set(:oliver, "a")
    me.thread_variable?(:oliver)    #=> true
    me.thread_variable?(:stanley)   #=> false

Note that these are not fiber local variables.  Please see Thread#[] and
Thread#thread_variable_get for more details.

;T;0;;;I"thread_variable?;F;I"Thread;T;[o;;I"::String | ::Symbol key;T;I"	bool;To;;I"mReturns the value of a thread local variable that has been set.  Note that
these are different than fiber local values.  For fiber local values, please
see Thread#[] and Thread#[]=.

Thread local values are carried along with threads, and do not respect fibers.
 For example:

    Thread.new {
      Thread.current.thread_variable_set("foo", "bar") # set a thread local
      Thread.current["foo"] = "bar"                    # set a fiber local

      Fiber.new {
        Fiber.yield [
          Thread.current.thread_variable_get("foo"), # get the thread local
          Thread.current["foo"],                     # get the fiber local
        ]
      }.resume
    }.join.value # => ['bar', nil]

The value "bar" is returned for the thread local, where nil is returned for
the fiber local.  The fiber is executed in the same thread, so the thread
local values are available.

;T;0;;;I"thread_variable_get;F;I"Thread;T;[o;;I"untyped key;T;I"untyped;To;;I"±Sets a thread local with `key` to `value`.  Note that these are local to
threads, and not to fibers.  Please see Thread#thread_variable_get and
Thread#[] for more information.

;T;0;;;I"thread_variable_set;F;I"Thread;T;[o;;I"untyped key, untyped value;T;I"untyped;To;;I"·Returns an array of the names of the thread-local variables (as Symbols).

    thr = Thread.new do
      Thread.current.thread_variable_set(:cat, 'meow')
      Thread.current.thread_variable_set("dog", 'woof')
    end
    thr.join               #=> #<Thread:0x401b3f10 dead>
    thr.thread_variables   #=> [:dog, :cat]

Note that these are not fiber local variables.  Please see Thread#[] and
Thread#thread_variable_get for more details.

;T;0;;;I"thread_variables;F;I"Thread;T;[o;;I" ;F;I"Array[::Symbol];To;;I"Waits for `thr` to complete, using #join, and returns its value or raises the
exception which terminated the thread.

    a = Thread.new { 2 + 2 }
    a.value   #=> 4

    b = Thread.new { raise 'something went wrong' }
    b.value   #=> RuntimeError: something went wrong

;T;0;;;I"
value;F;I"Thread;T;[o;;I" ;F;I"untyped;To;;I"*Marks a given thread as eligible for scheduling, however it may still remain
blocked on I/O.

**Note:** This does not invoke the scheduler, see #run for more information.

    c = Thread.new { Thread.stop; puts "hey!" }
    sleep 0.1 while c.status!='sleep'
    c.wakeup
    c.join
    #=> "hey!"

;T;0;;;I"wakeup;F;I"Thread;T;[o;;I" ;F;I"Thread;To;;I"ªReturns the status of the global ``abort on exception'' condition.

The default is `false`.

When set to `true`, if any thread is aborted by an exception, the raised
exception will be re-raised in the main thread.

Can also be specified by the global $DEBUG flag or command line option `-d`.

See also ::abort_on_exception=.

There is also an instance level method to set this for a specific thread, see
#abort_on_exception.

;T;0;;;I"abort_on_exception;F;I"Thread;T;[o;;I" ;F;I"untyped;To;;I"oWhen set to `true`, if any thread is aborted by an exception, the raised
exception will be re-raised in the main thread. Returns the new state.

    Thread.abort_on_exception = true
    t1 = Thread.new do
      puts  "In new thread"
      raise "Exception from thread"
    end
    sleep(1)
    puts "not reached"

This will produce:

    In new thread
    prog.rb:4: Exception from thread (RuntimeError)
     from prog.rb:2:in `initialize'
     from prog.rb:2:in `new'
     from prog.rb:2

See also ::abort_on_exception.

There is also an instance level method to set this for a specific thread, see
#abort_on_exception=.

;T;0;;;I"abort_on_exception=;F;I"Thread;T;[o;;I"untyped abort_on_exception;T;I"untyped;To;;I"JWraps the block in a single, VM-global
[Mutex\#synchronize](https://ruby-doc.org/core-2.6.3/Mutex.html#method-i-synchronize)
, returning the value of the block. A thread executing inside the
exclusive section will only block other threads which also use the
[::exclusive](Thread.downloaded.ruby_doc#method-c-exclusive) mechanism.
;T;0;;;I"exclusive;F;I"Thread;T;[o;;I" ;F;I"untyped;To;;I"àTerminates the currently running thread and schedules another thread to be
run.

If this thread is already marked to be killed, ::exit returns the Thread.

If this is the main thread, or the last  thread, exit the process.

;T;0;;;I"	exit;F;I"Thread;T;[o;;I" ;F;I"untyped;To;;I" Basically the same as ::new. However, if class Thread is subclassed, then
calling `start` in that subclass will not invoke the subclass's `initialize`
method.

;T;0;;;I"	fork;F;I"Thread;T;[o;;I"*untyped args;T;I"untyped;To;;I"Changes asynchronous interrupt timing.

*interrupt* means asynchronous event and corresponding procedure by
Thread#raise, Thread#kill, signal trap (not supported yet) and main thread
termination (if main thread terminates, then all other thread will be killed).

The given `hash` has pairs like `ExceptionClass => :TimingSymbol`. Where the
ExceptionClass is the interrupt handled by the given block. The TimingSymbol
can be one of the following symbols:

`:immediate`
:   Invoke interrupts immediately.
`:on_blocking`
:   Invoke interrupts while *BlockingOperation*.
`:never`
:   Never invoke all interrupts.


*BlockingOperation* means that the operation will block the calling thread,
such as read and write.  On CRuby implementation, *BlockingOperation* is any
operation executed without GVL.

Masked asynchronous interrupts are delayed until they are enabled. This method
is similar to sigprocmask(3).

### NOTE

Asynchronous interrupts are difficult to use.

If you need to communicate between threads, please consider to use another way
such as Queue.

Or use them with deep understanding about this method.

### Usage

In this example, we can guard from Thread#raise exceptions.

Using the `:never` TimingSymbol the RuntimeError exception will always be
ignored in the first block of the main thread. In the second
::handle_interrupt block we can purposefully handle RuntimeError exceptions.

    th = Thread.new do
      Thread.handle_interrupt(RuntimeError => :never) {
        begin
          # You can write resource allocation code safely.
          Thread.handle_interrupt(RuntimeError => :immediate) {
            # ...
          }
        ensure
          # You can write resource deallocation code safely.
        end
      }
    end
    Thread.pass
    # ...
    th.raise "stop"

While we are ignoring the RuntimeError exception, it's safe to write our
resource allocation code. Then, the ensure block is where we can safely
deallocate your resources.

#### Guarding from Timeout::Error

In the next example, we will guard from the Timeout::Error exception. This
will help prevent from leaking resources when Timeout::Error exceptions occur
during normal ensure clause. For this example we use the help of the standard
library Timeout, from lib/timeout.rb

    require 'timeout'
    Thread.handle_interrupt(Timeout::Error => :never) {
      timeout(10){
        # Timeout::Error doesn't occur here
        Thread.handle_interrupt(Timeout::Error => :on_blocking) {
          # possible to be killed by Timeout::Error
          # while blocking operation
        }
        # Timeout::Error doesn't occur here
      }
    }

In the first part of the `timeout` block, we can rely on Timeout::Error being
ignored. Then in the `Timeout::Error => :on_blocking` block, any operation
that will block the calling thread is susceptible to a Timeout::Error
exception being raised.

#### Stack control settings

It's possible to stack multiple levels of ::handle_interrupt blocks in order
to control more than one ExceptionClass and TimingSymbol at a time.

    Thread.handle_interrupt(FooError => :never) {
      Thread.handle_interrupt(BarError => :never) {
         # FooError and BarError are prohibited.
      }
    }

#### Inheritance with ExceptionClass

All exceptions inherited from the ExceptionClass parameter will be considered.

    Thread.handle_interrupt(Exception => :never) {
      # all exceptions inherited from Exception are prohibited.
    }

For handling all interrupts, use `Object` and not `Exception` as the
ExceptionClass, as kill/terminate interrupts are not handled by `Exception`.

;T;0;;;I"handle_interrupt;F;I"Thread;T;[o;;I"untyped hash;T;I"untyped;To;;I"Causes the given `thread` to exit, see also Thread::exit.

    count = 0
    a = Thread.new { loop { count += 1 } }
    sleep(0.1)       #=> 0
    Thread.kill(a)   #=> #<Thread:0x401b3d30 dead>
    count            #=> 93947
    a.alive?         #=> false

;T;0;;;I"	kill;F;I"Thread;T;[o;;I"::Thread thread;T;I"untyped;To;;I"oReturns an array of Thread objects for all threads that are either runnable or
stopped.

    Thread.new { sleep(200) }
    Thread.new { 1000000.times {|i| i*i } }
    Thread.new { Thread.stop }
    Thread.list.each {|t| p t}

This will produce:

    #<Thread:0x401b3e84 sleep>
    #<Thread:0x401b3f38 run>
    #<Thread:0x401b3fb0 sleep>
    #<Thread:0x401bdf4c run>

;T;0;;;I"	list;F;I"Thread;T;[o;;I" ;F;I"untyped;To;;I"Give the thread scheduler a hint to pass execution to another thread. A
running thread may or may not switch, it depends on OS and processor.

;T;0;;;I"	pass;F;I"Thread;T;[o;;I" ;F;I"untyped;To;;I"6Returns whether or not the asynchronous queue is empty.

Since Thread::handle_interrupt can be used to defer asynchronous events, this
method can be used to determine if there are any deferred events.

If you find this method returns true, then you may finish `:never` blocks.

For example, the following method processes deferred asynchronous events
immediately.

    def Thread.kick_interrupt_immediately
      Thread.handle_interrupt(Object => :immediate) {
        Thread.pass
      }
    end

If `error` is given, then check only for `error` type deferred events.

### Usage

    th = Thread.new{
      Thread.handle_interrupt(RuntimeError => :on_blocking){
        while true
          ...
          # reach safe point to invoke interrupt
          if Thread.pending_interrupt?
            Thread.handle_interrupt(Object => :immediate){}
          end
          ...
        end
      }
    }
    ...
    th.raise # stop thread

This example can also be written as the following, which you should use to
avoid asynchronous interrupts.

    flag = true
    th = Thread.new{
      Thread.handle_interrupt(RuntimeError => :on_blocking){
        while true
          ...
          # reach safe point to invoke interrupt
          break if flag == false
          ...
        end
      }
    }
    ...
    flag = false # stop thread

;T;0;;;I"pending_interrupt?;F;I"Thread;T;[o;;I"*untyped args;T;I"	bool;To;;I"kReturns the status of the global ``report on exception'' condition.

The default is `true` since Ruby 2.5.

All threads created when this flag is true will report a message on $stderr if
an exception kills the thread.

    Thread.new { 1.times { raise } }

will produce this output on $stderr:

    #<Thread:...> terminated with exception (report_on_exception is true):
    Traceback (most recent call last):
            2: from -e:1:in `block in <main>'
            1: from -e:1:in `times'

This is done to catch errors in threads early. In some cases, you might not
want this output. There are multiple ways to avoid the extra output:

*   If the exception is not intended, the best is to fix the cause of the
    exception so it does not happen anymore.
*   If the exception is intended, it might be better to rescue it closer to
    where it is raised rather then let it kill the Thread.
*   If it is guaranteed the Thread will be joined with Thread#join or
    Thread#value, then it is safe to disable this report with
    `Thread.current.report_on_exception = false` when starting the Thread.
    However, this might handle the exception much later, or not at all if the
    Thread is never joined due to the parent thread being blocked, etc.


See also ::report_on_exception=.

There is also an instance level method to set this for a specific thread, see
#report_on_exception=.

;T;0;;;I"report_on_exception;F;I"Thread;T;[o;;I" ;F;I"untyped;To;;I"àReturns the new state. When set to `true`, all threads created afterwards will
inherit the condition and report a message on $stderr if an exception kills a
thread:

    Thread.report_on_exception = true
    t1 = Thread.new do
      puts  "In new thread"
      raise "Exception from thread"
    end
    sleep(1)
    puts "In the main thread"

This will produce:

    In new thread
    #<Thread:...prog.rb:2> terminated with exception (report_on_exception is true):
    Traceback (most recent call last):
    prog.rb:4:in `block in <main>': Exception from thread (RuntimeError)
    In the main thread

See also ::report_on_exception.

There is also an instance level method to set this for a specific thread, see
#report_on_exception=.

;T;0;;;I"report_on_exception=;F;I"Thread;T;[o;;I" untyped report_on_exception;T;I"untyped;To;;I" Basically the same as ::new. However, if class Thread is subclassed, then
calling `start` in that subclass will not invoke the subclass's `initialize`
method.

;T;0;;;I"
start;F;I"Thread;T;[o;;I"*untyped args;T;I"instance;To;;I"Stops execution of the current thread, putting it into a ``sleep'' state, and
schedules execution of another thread.

    a = Thread.new { print "a"; Thread.stop; print "c" }
    sleep 0.1 while a.status!='sleep'
    print "b"
    a.run
    a.join
    #=> "abc"

;T;0;;;I"	stop;F;I"Thread;T;[o;;I" ;F;I"untyped;To; ;I"ÀAn internal representation of the backtrace. The user will never interact with
objects of this class directly, but class methods can be used to get backtrace
settings of the current session.

;T;0;	I"Thread::Backtrace;T;
[ ;[ ;0;[ ;[ ;0;I"Object;To;;I"Õ
Returns maximum backtrace length set by `--backtrace-limit` command-line
option. The defalt is `-1` which means unlimited backtraces. If the value is
zero or positive, the error backtraces, produced by Exception#full_message,
are abbreviated and the extra lines are replaced by `... 3 levels... `

    $ ruby -r net/http -e "p Thread::Backtrace.limit; Net::HTTP.get(URI('http://wrong.address'))"
    - 1
    .../lib/ruby/3.1.0/socket.rb:227:in `getaddrinfo': Failed to open TCP connection to wrong.address:80 (getaddrinfo: Name or service not known) (SocketError)
        from .../lib/ruby/3.1.0/socket.rb:227:in `foreach'
        from .../lib/ruby/3.1.0/socket.rb:632:in `tcp'
        from .../lib/ruby/3.1.0/net/http.rb:998:in `connect'
        from .../lib/ruby/3.1.0/net/http.rb:976:in `do_start'
        from .../lib/ruby/3.1.0/net/http.rb:965:in `start'
        from .../lib/ruby/3.1.0/net/http.rb:627:in `start'
        from .../lib/ruby/3.1.0/net/http.rb:503:in `get_response'
        from .../lib/ruby/3.1.0/net/http.rb:474:in `get'
    .../lib/ruby/3.1.0/socket.rb:227:in `getaddrinfo': getaddrinfo: Name or service not known (SocketError)
        from .../lib/ruby/3.1.0/socket.rb:227:in `foreach'
        from .../lib/ruby/3.1.0/socket.rb:632:in `tcp'
        from .../lib/ruby/3.1.0/net/http.rb:998:in `connect'
        from .../lib/ruby/3.1.0/net/http.rb:976:in `do_start'
        from .../lib/ruby/3.1.0/net/http.rb:965:in `start'
        from .../lib/ruby/3.1.0/net/http.rb:627:in `start'
        from .../lib/ruby/3.1.0/net/http.rb:503:in `get_response'
        from .../lib/ruby/3.1.0/net/http.rb:474:in `get'
        from -e:1:in `<main>'

    $ ruby --backtrace-limit 2 -r net/http -e "p Thread::Backtrace.limit; Net::HTTP.get(URI('http://wrong.address'))"
    2
    .../lib/ruby/3.1.0/socket.rb:227:in `getaddrinfo': Failed to open TCP connection to wrong.address:80 (getaddrinfo: Name or service not known) (SocketError)
        from .../lib/ruby/3.1.0/socket.rb:227:in `foreach'
        from .../lib/ruby/3.1.0/socket.rb:632:in `tcp'
         ... 7 levels...
    .../lib/ruby/3.1.0/socket.rb:227:in `getaddrinfo': getaddrinfo: Name or service not known (SocketError)
        from .../lib/ruby/3.1.0/socket.rb:227:in `foreach'
        from .../lib/ruby/3.1.0/socket.rb:632:in `tcp'
         ... 7 levels...

    $ ruby --backtrace-limit 0 -r net/http -e "p Thread::Backtrace.limit; Net::HTTP.get(URI('http://wrong.address'))"
    0
    .../lib/ruby/3.1.0/socket.rb:227:in `getaddrinfo': Failed to open TCP connection to wrong.address:80 (getaddrinfo: Name or service not known) (SocketError)
         ... 9 levels...
    .../lib/ruby/3.1.0/socket.rb:227:in `getaddrinfo': getaddrinfo: Name or service not known (SocketError)
         ... 9 levels...

;T;0;;;I"
limit;F;I"Thread::Backtrace;T;[o;;I" ;F;I"Integer;To; ;I"]An object representation of a stack frame, initialized by
Kernel#caller_locations.

For example:

    # caller_locations.rb
    def a(skip)
      caller_locations(skip)
    end
    def b(skip)
      a(skip)
    end
    def c(skip)
      b(skip)
    end

    c(0..2).map do |call|
      puts call.to_s
    end

Running `ruby caller_locations.rb` will produce:

    caller_locations.rb:2:in `a'
    caller_locations.rb:5:in `b'
    caller_locations.rb:8:in `c'

Here's another example with a slightly different result:

    # foo.rb
    class Foo
      attr_accessor :locations
      def initialize(skip)
        @locations = caller_locations(skip)
      end
    end

    Foo.new(0..2).locations.map do |call|
      puts call.to_s
    end

Now run `ruby foo.rb` and you should see:

    init.rb:4:in `initialize'
    init.rb:8:in `new'
    init.rb:8:in `<main>'

;T;0;	I" Thread::Backtrace::Location;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"Returns the full file path of this frame.

Same as #path, except that it will return absolute path even if the frame is
in the main script.

;T;0;;;I"absolute_path;F;I" Thread::Backtrace::Location;T;[o;;I" ;F;I"String?;To;;I"YReturns the base label of this frame.

Usually same as #label, without decoration.

;T;0;;;I"base_label;F;I" Thread::Backtrace::Location;T;[o;;I" ;F;I"String?;To;;I"ÔReturns the label of this frame.

Usually consists of method, class, module, etc names with decoration.

Consider the following example:

    def foo
      puts caller_locations(0).first.label

      1.times do
        puts caller_locations(0).first.label

        1.times do
          puts caller_locations(0).first.label
        end

      end
    end

The result of calling `foo` is this:

    label: foo
    label: block in foo
    label: block (2 levels) in foo

;T;0;;;I"
label;F;I" Thread::Backtrace::Location;T;[o;;I" ;F;I"String?;To;;I"¡Returns the line number of this frame.

For example, using `caller_locations.rb` from Thread::Backtrace::Location

    loc = c(0..1).first
    loc.lineno #=> 2

;T;0;;;I"lineno;F;I" Thread::Backtrace::Location;T;[o;;I" ;F;I"Integer;To;;I"IReturns the file name of this frame. This will generally be an absolute path,
unless the frame is in the main script, in which case it will be the script
location passed on the command line.

For example, using `caller_locations.rb` from Thread::Backtrace::Location

    loc = c(0..1).first
    loc.path #=> caller_locations.rb

;T;0;;;I"	path;F;I" Thread::Backtrace::Location;T;[o;;I" ;F;I"String?;To; ;I"LConditionVariable objects augment class Mutex. Using condition variables, it
is possible to suspend while in the middle of a critical section until a
resource becomes available.

Example:

    mutex = Thread::Mutex.new
    resource = Thread::ConditionVariable.new

    a = Thread.new {
       mutex.synchronize {
         # Thread 'a' now needs the resource
         resource.wait(mutex)
         # 'a' can now have the resource
       }
    }

    b = Thread.new {
       mutex.synchronize {
         # Thread 'b' has finished using the resource
         resource.signal
       }
    }

;T;0;	I"Thread::ConditionVariable;T;
[ ;[ ;0;[ ;[ ;0;I"Object;To;;I"2Wakes up all threads waiting for this lock.

;T;0;;;I"broadcast;F;I"Thread::ConditionVariable;T;[o;;I" ;F;I"	self;To;;I"?Wakes up the first thread in line waiting for this lock.

;T;0;;;I"signal;F;I"Thread::ConditionVariable;T;[o;;I" ;F;I"	self;To;;I"çReleases the lock held in `mutex` and waits; reacquires the lock on wakeup.

If `timeout` is given, this method returns after `timeout` seconds passed,
even if no other thread doesn't signal.

Returns the slept result on `mutex`.

;T;0;;;I"	wait;F;I"Thread::ConditionVariable;T;[o;;I".::Thread::Mutex mutex, ?::Integer timeout;T;I"	self;To; ;I"wThread::Mutex implements a simple semaphore that can be used to coordinate
access to shared data from multiple concurrent threads.

Example:

    semaphore = Thread::Mutex.new

    a = Thread.new {
      semaphore.synchronize {
        # access shared resource
      }
    }

    b = Thread.new {
      semaphore.synchronize {
        # access shared resource
      }
    }

;T;0;	I"Thread::Mutex;T;
[ ;[ ;0;[ ;[ ;0;I"Object;To;;I"~Attempts to grab the lock and waits if it isn't available. Raises
`ThreadError` if `mutex` was locked by the current thread.

;T;0;;;I"	lock;F;I"Thread::Mutex;T;[o;;I" ;F;I"	self;To;;I"DReturns `true` if this lock is currently held by some thread.

;T;0;;;I"locked?;F;I"Thread::Mutex;T;[o;;I" ;F;I"	bool;To;;I"GReturns `true` if this lock is currently held by current thread.

;T;0;;;I"owned?;F;I"Thread::Mutex;T;[o;;I" ;F;I"	bool;To;;I"|Obtains a lock, runs the block, and releases the lock when the block
completes.  See the example under Thread::Mutex.

;T;0;;;I"synchronize;F;I"Thread::Mutex;T;[o;;I" ;F;I"X;Fo;;I"cAttempts to obtain the lock and returns immediately. Returns `true` if the
lock was granted.

;T;0;;;I"try_lock;F;I"Thread::Mutex;T;[o;;I" ;F;I"	bool;To;;I"^Releases the lock. Raises `ThreadError` if `mutex` wasn't locked by the
current thread.

;T;0;;;I"unlock;F;I"Thread::Mutex;T;[o;;I" ;F;I"	self;To; ;I"üThe Thread::Queue class implements multi-producer, multi-consumer queues.  It
is especially useful in threaded programming when information must be
exchanged safely between multiple threads. The Thread::Queue class implements
all the required locking semantics.

The class implements FIFO type of queue. In a FIFO queue, the first tasks
added are the first retrieved.

Example:

    queue = Thread::Queue.new

    producer = Thread.new do
      5.times do |i|
         sleep rand(i) # simulate expense
         queue << i
         puts "#{i} produced"
      end
    end

    consumer = Thread.new do
      5.times do |i|
         value = queue.pop
         sleep rand(i/2) # simulate expense
         puts "consumed #{value}"
      end
    end

    consumer.join

;T;0;	I"Thread::Queue;T;
[ ;[ ;0;[ ;[ ;0;I"Object;To;;I"*Removes all objects from the queue.

;T;0;;;I"
clear;F;I"Thread::Queue;T;[o;;I" ;F;I"	void;To;;I"ºCloses the queue. A closed queue cannot be re-opened.

After the call to close completes, the following are true:

*   `closed?` will return true

*   `close` will be ignored.

*   calling enq/push/<< will raise a `ClosedQueueError`.

*   when `empty?` is false, calling deq/pop/shift will return an object from
    the queue as usual.
*   when `empty?` is true, deq(false) will not suspend the thread and will
    return nil. deq(true) will raise a `ThreadError`.


ClosedQueueError is inherited from StopIteration, so that you can break loop
block.

Example:

    q = Thread::Queue.new
    Thread.new{
      while e = q.deq # wait for nil to break loop
        # ...
      end
    }
    q.close

;T;0;;;I"
close;F;I"Thread::Queue;T;[o;;I" ;F;I"	self;To;;I"-Returns `true` if the queue is closed.

;T;0;;;I"closed?;F;I"Thread::Queue;T;[o;;I" ;F;I"	bool;To;;I",Returns `true` if the queue is empty.

;T;0;;;I"empty?;F;I"Thread::Queue;T;[o;;I" ;F;I"	bool;To;;I"'Returns the length of the queue.

;T;0;;;I"length;F;I"Thread::Queue;T;[o;;I" ;F;I"Integer;To;;I":Returns the number of threads waiting on the queue.

;T;0;;;I"num_waiting;F;I"Thread::Queue;T;[o;;I" ;F;I"Integer;To;;I"ÎRetrieves data from the queue.

If the queue is empty, the calling thread is suspended until data is pushed
onto the queue. If `non_block` is true, the thread isn't suspended, and
`ThreadError` is raised.

;T;0;;;I"pop;F;I"Thread::Queue;T;[o;;I"?::boolish non_block;T;I"untyped;To;;I".Pushes the given `object` to the queue.

;T;0;;;I"	push;F;I"Thread::Queue;T;[o;;I"untyped obj;T;I"	void;To; ;I"»This class represents queues of specified size capacity.  The push operation
may be blocked if the capacity is full.

See Thread::Queue for an example of how a Thread::SizedQueue works.

;T;0;	I"Thread::SizedQueue;T;
[ ;[ ;0;[ ;[ ;0;I"Thread::Queue;To;;I"ACreates a fixed-length queue with a maximum size of `max`.

;T;0;;;I"initialize;F;I"Thread::SizedQueue;T;[o;;I"::Integer max;T;I"	void;To;;I"-Returns the maximum size of the queue.

;T;0;;;I"max;F;I"Thread::SizedQueue;T;[o;;I" ;F;I"Integer;To;;I"@Sets the maximum size of the queue to the given `number`.

;T;0;;;I"	max=;F;I"Thread::SizedQueue;T;[o;;I"::Integer max;T;I"	void;To;;I"ÛPushes `object` to the queue.

If there is no space left in the queue, waits until space becomes available,
unless `non_block` is true.  If `non_block` is true, the thread isn't
suspended, and `ThreadError` is raised.

;T;0;;;I"	push;F;I"Thread::SizedQueue;T;[o;;I"&untyped obj, ?::boolish non_block;T;I"	void;To; ;I":ThreadGroup provides a means of keeping track of a number of threads as a
group.

A given Thread object can only belong to one ThreadGroup at a time; adding a
thread to a new group will remove it from any previous group.

Newly created threads belong to the same group as the thread from which they
were created.

;T;0;	I"ThreadGroup;T;
[ ;[ ;0;[ ;[ ;0;I"Object;To;;I"ƒAdds the given `thread` to this group, removing it from any other group to
which it may have previously been a member.

    puts "Initial group is #{ThreadGroup::Default.list}"
    tg = ThreadGroup.new
    t1 = Thread.new { sleep }
    t2 = Thread.new { sleep }
    puts "t1 is #{t1}"
    puts "t2 is #{t2}"
    tg.add(t1)
    puts "Initial group now #{ThreadGroup::Default.list}"
    puts "tg group now #{tg.list}"

This will produce:

    Initial group is #<Thread:0x401bdf4c>
    t1 is #<Thread:0x401b3c90>
    t2 is #<Thread:0x401b3c18>
    Initial group now #<Thread:0x401b3c18>#<Thread:0x401bdf4c>
    tg group now #<Thread:0x401b3c90>

;T;0;;;I"add;F;I"ThreadGroup;T;[o;;I"::Thread thread;T;I"ThreadGroup;To;;I"±Prevents threads from being added to or removed from the receiving
ThreadGroup.

New threads can still be started in an enclosed ThreadGroup.

    ThreadGroup::Default.enclose        #=> #<ThreadGroup:0x4029d914>
    thr = Thread.new { Thread.stop }    #=> #<Thread:0x402a7210 sleep>
    tg = ThreadGroup.new                #=> #<ThreadGroup:0x402752d4>
    tg.add thr
    #=> ThreadError: can't move from the enclosed thread group

;T;0;;;I"enclose;F;I"ThreadGroup;T;[o;;I" ;F;I"	self;To;;I"OReturns `true` if the `thgrp` is enclosed. See also ThreadGroup#enclose.

;T;0;;;I"enclosed?;F;I"ThreadGroup;T;[o;;I" ;F;I"	bool;To;;I"ŒReturns an array of all existing Thread objects that belong to this group.

    ThreadGroup::Default.list   #=> [#<Thread:0x401bdf4c run>]

;T;0;;;I"	list;F;I"ThreadGroup;T;[o;;I" ;F;I"Array[::Thread];To; ;I"Ð Time is an abstraction of dates and times. Time is stored internally as the
number of seconds with subsecond since the *Epoch*, 1970-01-01 00:00:00 UTC.

The Time class treats GMT (Greenwich Mean Time) and UTC (Coordinated Universal
Time) as equivalent. GMT is the older way of referring to these baseline times
but persists in the names of calls on POSIX systems.

Note: A Time object uses the resolution available on your system clock.

All times may have subsecond. Be aware of this fact when comparing times with
each other -- times that are apparently equal when displayed may be different
when compared. (Since Ruby 2.7.0, Time#inspect shows subsecond but Time#to_s
still doesn't show subsecond.)

## Examples

All of these examples were done using the EST timezone which is GMT-5.

### Creating a New Time Instance

You can create a new instance of Time with Time.new. This will use the current
system time. Time.now is an alias for this. You can also pass parts of the
time to Time.new such as year, month, minute, etc. When you want to construct
a time this way you must pass at least a year. If you pass the year with
nothing else time will default to January 1 of that year at 00:00:00 with the
current system timezone. Here are some examples:

    Time.new(2002)         #=> 2002-01-01 00:00:00 -0500
    Time.new(2002, 10)     #=> 2002-10-01 00:00:00 -0500
    Time.new(2002, 10, 31) #=> 2002-10-31 00:00:00 -0500

You can pass a UTC offset:

    Time.new(2002, 10, 31, 2, 2, 2, "+02:00") #=> 2002-10-31 02:02:02 +0200

Or a timezone object:

    zone = timezone("Europe/Athens")      # Eastern European Time, UTC+2
    Time.new(2002, 10, 31, 2, 2, 2, zone) #=> 2002-10-31 02:02:02 +0200

You can also use Time.local and Time.utc to infer local and UTC timezones
instead of using the current system setting.

You can also create a new time using Time.at which takes the number of seconds
(with subsecond) since the [Unix
Epoch](https://en.wikipedia.org/wiki/Unix_time).

    Time.at(628232400) #=> 1989-11-28 00:00:00 -0500

### Working with an Instance of Time

Once you have an instance of Time there is a multitude of things you can do
with it. Below are some examples. For all of the following examples, we will
work on the assumption that you have done the following:

    t = Time.new(1993, 02, 24, 12, 0, 0, "+09:00")

Was that a monday?

    t.monday? #=> false

What year was that again?

    t.year #=> 1993

Was it daylight savings at the time?

    t.dst? #=> false

What's the day a year later?

    t + (60*60*24*365) #=> 1994-02-24 12:00:00 +0900

How many seconds was that since the Unix Epoch?

    t.to_i #=> 730522800

You can also do standard functions like compare two times.

    t1 = Time.new(2010)
    t2 = Time.new(2011)

    t1 == t2 #=> false
    t1 == t1 #=> true
    t1 <  t2 #=> true
    t1 >  t2 #=> false

    Time.new(2010,10,31).between?(t1, t2) #=> true

## What's Here

First, what's elsewhere. Class Time:

*   Inherits from [class
    Object](Object.html#class-Object-label-What-27s+Here).
*   Includes [module
    Comparable](Comparable.html#module-Comparable-label-What-27s+Here).


Here, class Time provides methods that are useful for:

*   [Creating \Time objects](#class-Time-label-Methods+for+Creating).
*   [Fetching \Time values](#class-Time-label-Methods+for+Fetching).
*   [Querying a \Time object](#class-Time-label-Methods+for+Querying).
*   [Comparing \Time objects](#class-Time-label-Methods+for+Comparing).
*   [Converting a \Time object](#class-Time-label-Methods+for+Converting).
*   [Rounding a \Time](#class-Time-label-Methods+for+Rounding).


### Methods for Creating

*   ::new: Returns a new time from specified arguments (year, month, etc.),
    including an optional timezone value.
*   ::local (aliased as ::mktime): Same as ::new, except the timezone is the
    local timezone.
*   ::utc (aliased as ::gm): Same as ::new, except the timezone is UTC.
*   ::at: Returns a new time based on seconds since epoch.
*   ::now: Returns a new time based on the current system time.
*   #+ (plus): Returns a new time increased by the given number of seconds.
*   [-](#method-i-2D) (minus): Returns a new time
        decreased by the given number of seconds.


### Methods for Fetching

*   #year: Returns the year of the time.
*   #month (aliased as #mon): Returns the month of the time.
*   #mday (aliased as #day): Returns the day of the month.
*   #hour: Returns the hours value for the time.
*   #min: Returns the minutes value for the time.
*   #sec: Returns the seconds value for the time.
*   #usec (aliased as #tv_usec): Returns the number of microseconds in the
    subseconds value of the time.
*   #nsec (aliased as #tv_nsec: Returns the number of nanoseconds in the
    subsecond part of the time.
*   #subsec: Returns the subseconds value for the time.
*   #wday: Returns the integer weekday value of the time (0 == Sunday).
*   #yday: Returns the integer yearday value of the time (1 == January 1).
*   #hash: Returns the integer hash value for the time.
*   #utc_offset (aliased as #gmt_offset and #gmtoff): Returns the offset in
    seconds between time and UTC.
*   #to_f: Returns the float number of seconds since epoch for the time.
*   #to_i (aliased as #tv_sec): Returns the integer number of seconds since
    epoch for the time.
*   #to_r: Returns the Rational number of seconds since epoch for the time.
*   #zone: Returns a string representation of the timezone of the time.


### Methods for Querying

*   #utc? (aliased as #gmt?): Returns whether the time is UTC.
*   #dst? (aliased as #isdst): Returns whether the time is DST (daylight
    saving time).
*   #sunday?: Returns whether the time is a Sunday.
*   #monday?: Returns whether the time is a Monday.
*   #tuesday?: Returns whether the time is a Tuesday.
*   #wednesday?: Returns whether the time is a Wednesday.
*   #thursday?: Returns whether the time is a Thursday.
*   #friday?: Returns whether time is a Friday.
*   #saturday?: Returns whether the time is a Saturday.


### Methods for Comparing

*   [#<=>](#method-i-3C-3D-3E): Compares `self` to another time.
*   #eql?: Returns whether the time is equal to another time.


### Methods for Converting

*   #asctime (aliased as #ctime): Returns the time as a string.
*   #inspect: Returns the time in detail as a string.
*   #strftime: Returns the time as a string, according to a given format.
*   #to_a: Returns a 10-element array of values from the time.
*   #to_s: Returns a string representation of the time.
*   #getutc (aliased as #getgm): Returns a new time converted to UTC.
*   #getlocal: Returns a new time converted to local time.
*   #utc (aliased as #gmtime): Converts time to UTC in place.
*   #localtime: Converts time to local time in place.


### Methods for Rounding

*   #round:Returns a new time with subseconds rounded.
*   #ceil: Returns a new time with subseconds raised to a ceiling.
*   #floor: Returns a new time with subseconds lowered to a floor.


## Timezone Argument

A timezone argument must have `local_to_utc` and `utc_to_local` methods, and
may have `name`, `abbr`, and `dst?` methods.

The `local_to_utc` method should convert a Time-like object from the timezone
to UTC, and `utc_to_local` is the opposite.  The result also should be a Time
or Time-like object (not necessary to be the same class).  The #zone of the
result is just ignored. Time-like argument to these methods is similar to a
Time object in UTC without subsecond; it has attribute readers for the parts,
e.g. #year, #month, and so on, and epoch time readers, #to_i.  The subsecond
attributes are fixed as 0, and #utc_offset, #zone, #isdst, and their aliases
are same as a Time object in UTC. Also #to_time, #+, and #- methods are
defined.

The `name` method is used for marshaling. If this method is not defined on a
timezone object, Time objects using that timezone object can not be dumped by
Marshal.

The `abbr` method is used by '%Z' in #strftime.

The `dst?` method is called with a `Time` value and should return whether the
`Time` value is in daylight savings time in the zone.

### Auto Conversion to Timezone

At loading marshaled data, a timezone name will be converted to a timezone
object by `find_timezone` class method, if the method is defined.

Similarly, that class method will be called when a timezone argument does not
have the necessary methods mentioned above.

;T;0;	I"	Time;T;
[ ;[I"Comparable;T;0;[ ;[ ;0;I"Object;To;;I"
*Time*

This form accepts a Time object `time` and optional keyword argument `in`:

    Time.at(Time.new)               # => 2021-04-26 08:52:31.6023486 -0500
    Time.at(Time.new, in: '+09:00') # => 2021-04-26 22:52:31.6023486 +0900

*Seconds*

This form accepts a numeric number of seconds `sec` and optional keyword
argument `in`:

    Time.at(946702800)               # => 1999-12-31 23:00:00 -0600
    Time.at(946702800, in: '+09:00') # => 2000-01-01 14:00:00 +0900

*Seconds with Subseconds and Units*

This form accepts an integer number of seconds `sec_i`, a numeric number of
milliseconds `msec`, a symbol argument for the subsecond unit type (defaulting
to :usec), and an optional keyword argument `in`:

    Time.at(946702800, 500, :millisecond)               # => 1999-12-31 23:00:00.5 -0600
    Time.at(946702800, 500, :millisecond, in: '+09:00') # => 2000-01-01 14:00:00.5 +0900
    Time.at(946702800, 500000)                             # => 1999-12-31 23:00:00.5 -0600
    Time.at(946702800, 500000, :usec)                      # => 1999-12-31 23:00:00.5 -0600
    Time.at(946702800, 500000, :microsecond)               # => 1999-12-31 23:00:00.5 -0600
    Time.at(946702800, 500000, in: '+09:00')               # => 2000-01-01 14:00:00.5 +0900
    Time.at(946702800, 500000, :usec, in: '+09:00')        # => 2000-01-01 14:00:00.5 +0900
    Time.at(946702800, 500000, :microsecond, in: '+09:00') # => 2000-01-01 14:00:00.5 +0900
    Time.at(946702800, 500000000, :nsec)                     # => 1999-12-31 23:00:00.5 -0600
    Time.at(946702800, 500000000, :nanosecond)               # => 1999-12-31 23:00:00.5 -0600
    Time.at(946702800, 500000000, :nsec, in: '+09:00')       # => 2000-01-01 14:00:00.5 +0900
    Time.at(946702800, 500000000, :nanosecond, in: '+09:00') # => 2000-01-01 14:00:00.5 +0900

Parameters:
*   `isec_i` is the integer number of seconds in the range `0..60`.
*   `msec` is the number of milliseconds (Integer, Float, or Rational) in the
    range `0..1000`.
*   `usec` is the number of microseconds (Integer, Float, or Rational) in the
    range `0..1000000`.
*   `nsec` is the number of nanoseconds (Integer, Float, or Rational) in the
    range `0..1000000000`.
*   `in: zone`: a timezone *zone*, which may be:
    *   A string offset from UTC.
    *   A single letter offset from UTC, in the range `'A'..'Z'`, `'J'` (the
        so-called military timezone) excluded.
    *   An integer number of seconds.
    *   A timezone object; see [Timezone
        Argument](#class-Time-label-Timezone+Argument) for details.

;T;0;;;I"at;F;I"	Time;T;[o;;I",::Time, ?in: ::String | ::Integer | nil;T;I"	Time;To;;I"/::Numeric, ?in: ::String | ::Integer | nil;T;I"	Time;To;;I"_::Integer sec_i, ::Numeric msec, ::Time::subsec_unit msec, ?in: ::String | ::Integer | nil;T;I"	Time;To;;I"…Creates a Time object based on given values, interpreted as UTC (GMT). The
year must be specified. Other values default to the minimum value for that
field (and may be `nil` or omitted). Months may be specified by numbers from 1
to 12, or by the three-letter English month names. Hours are specified on a
24-hour clock (0..23). Raises an ArgumentError if any values are out of range.
Will also accept ten arguments in the order output by Time#to_a.

`sec_with_frac` and `usec_with_frac` can have a fractional part.

    Time.utc(2000,"jan",1,20,15,1)  #=> 2000-01-01 20:15:01 UTC
    Time.gm(2000,"jan",1,20,15,1)   #=> 2000-01-01 20:15:01 UTC

;T;0;;;I"gm;F;I"	Time;T;[o;;I"‡::Integer year, ?::Integer | ::String month, ?::Integer day, ?::Integer hour, ?::Integer min, ?::Numeric sec, ?::Numeric usec_with_frac;T;I"	Time;To;;I"2Returns a new Time object based the on given arguments; its timezone is the
local timezone.

In the first form (up to seven arguments), argument `year` is required.

    Time.local(2000)                   # => 2000-01-01 00:00:00 -0600
    Time.local(0, 1, 2, 3, 4, 5, 6.5)  # => 0000-01-02 03:04:05.0000065 -0600

In the second form, all ten arguments are required, though the last four are
ignored. This form is useful for creating a time from a 10-element array such
as those returned by #to_a.

    array = Time.now.to_a
    p array # => [57, 26, 13, 24, 4, 2021, 6, 114, true, "Central Daylight Time"]
    array[5] = 2000
    Time.local(*array)  # => 2000-04-24 13:26:57 -0500

Parameters:
*   `year`: an integer year.
*   `month`: a month value, which may be:
    *   An integer month in the range `1..12`.
    *   A 3-character string that matches regular expression
        `/jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec/i`.

*   `day`: an integer day in the range `1..31` (less than 31 for some months).
*   `hour`: an integer hour in the range `0..23`.
*   `min`: an integer minute in the range `0..59`.
*   `isec_i` is the integer number of seconds in the range `0..60`.
*   `usec` is the number of microseconds (Integer, Float, or Rational) in the
    range `0..1000000`.


Alias: Time.mktime.

Related: Time.utc.

;T;0;;;I"
local;F;I"	Time;T;[o;;I"‡::Integer year, ?::Integer | ::String month, ?::Integer day, ?::Integer hour, ?::Integer min, ?::Numeric sec, ?::Numeric usec_with_frac;T;I"	Time;To;;I"LCreates a new Time object from the current system time. This is the same as
Time.new without arguments.

    Time.now               # => 2009-06-24 12:39:54 +0900
    Time.now(in: '+04:00') # => 2009-06-24 07:39:54 +0400

Parameter:
*   `in: zone`: a timezone *zone*, which may be:
    *   A string offset from UTC.
    *   A single letter offset from UTC, in the range `'A'..'Z'`, `'J'` (the
        so-called military timezone) excluded.
    *   An integer number of seconds.
    *   A timezone object; see [Timezone
        Argument](#class-Time-label-Timezone+Argument) for details.

;T;0;;;I"now;F;I"	Time;T;[o;;I"$?in: ::String | ::Integer | nil;T;I"	Time;To;;I"Returns a new Time object based the on given arguments; its timezone is UTC.

In the first form (up to seven arguments), argument `year` is required.

    Time.utc(2000)                  # => 2000-01-01 00:00:00 UTC
    Time.utc(0, 1, 2, 3, 4, 5, 6.5) # => 0000-01-02 03:04:05.0000065 UTC

In the second form, all ten arguments are required, though the last four are
ignored. This form is useful for creating a time from a 10-element array such
as is returned by #to_a.

    array = Time.now.to_a
    p array # => [57, 26, 13, 24, 4, 2021, 6, 114, true, "Central Daylight Time"]
    array[5] = 2000
    Time.utc(*array) # => 2000-04-24 13:26:57 UTC

Parameters:
*   `year`: an integer year.
*   `month`: a month value, which may be:
    *   An integer month in the range `1..12`.
    *   A 3-character string that matches regular expression
        `/jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec/i`.

*   `day`: an integer day in the range `1..31` (less than 31 for some months).
*   `hour`: an integer hour in the range `0..23`.
*   `min`: an integer minute in the range `0..59`.
*   `isec_i` is the integer number of seconds in the range `0..60`.
*   `usec` is the number of microseconds (Integer, Float, or Rational) in the
    range `0..1000000`.


Alias: Time.gm.

Related: Time.local.

;T;0;;;I"utc;F;I"	Time;T;[o;;I"‡::Integer year, ?::Integer | ::String month, ?::Integer day, ?::Integer hour, ?::Integer min, ?::Numeric sec, ?::Numeric usec_with_frac;T;I"	Time;To;;I"öAdds some number of seconds (possibly including subsecond) to *time* and
returns that value as a new Time object.

    t = Time.now         #=> 2020-07-20 22:14:43.170490982 +0900
    t + (60 * 60 * 24)   #=> 2020-07-21 22:14:43.170490982 +0900

;T;0;;;I"+;F;I"	Time;T;[o;;I"::Numeric arg0;T;I"	Time;To;;I"sReturns a difference in seconds as a Float between *time* and `other_time`, or
subtracts the given number of seconds in `numeric` from *time*.

    t = Time.now       #=> 2020-07-20 22:15:49.302766336 +0900
    t2 = t + 2592000   #=> 2020-08-19 22:15:49.302766336 +0900
    t2 - t             #=> 2592000.0
    t2 - 2592000       #=> 2020-07-20 22:15:49.302766336 +0900

;T;0;;;I"-;F;I"	Time;T;[o;;I"::Time arg0;T;I"
Float;To;;I"::Numeric arg0;T;I"	Time;To;;0;0;;;I"<;F;I"	Time;T;[o;;I"::Time arg0;T;I"	bool;To;;0;0;;;I"<=;F;I"	Time;T;[o;;I"::Time arg0;T;I"	bool;To;;I"qCompares `time` with `other_time`.

-1, 0, +1 or nil depending on whether `time` is less than, equal to, or
greater than `other_time`.

`nil` is returned if the two values are incomparable.

    t = Time.now       #=> 2007-11-19 08:12:12 -0600
    t2 = t + 2592000   #=> 2007-12-19 08:12:12 -0600
    t <=> t2           #=> -1
    t2 <=> t           #=> 1

    t = Time.now       #=> 2007-11-19 08:13:38 -0600
    t2 = t + 0.1       #=> 2007-11-19 08:13:38 -0600
    t.nsec             #=> 98222999
    t2.nsec            #=> 198222999
    t <=> t2           #=> -1
    t2 <=> t           #=> 1
    t <=> t            #=> 0

;T;0;;;I"<=>;F;I"	Time;T;[o;;I"::Time other;T;I"Integer;To;;I"untyped other;T;I"Integer?;To;;0;0;;;I">;F;I"	Time;T;[o;;I"::Time arg0;T;I"	bool;To;;0;0;;;I">=;F;I"	Time;T;[o;;I"::Time arg0;T;I"	bool;To;;I"£Returns a canonical string representation of *time*.

    Time.now.asctime   #=> "Wed Apr  9 08:56:03 2003"
    Time.now.ctime     #=> "Wed Apr  9 08:56:03 2003"

;T;0;;;I"asctime;F;I"	Time;T;[o;;I" ;F;I"String;To;;I"£Returns a canonical string representation of *time*.

    Time.now.asctime   #=> "Wed Apr  9 08:56:03 2003"
    Time.now.ctime     #=> "Wed Apr  9 08:56:03 2003"

;T;0;;;I"
ctime;F;I"	Time;T;[o;;I" ;F;I"String;To;;I"˜Returns the day of the month (1..31) for *time*.

    t = Time.now   #=> 2007-11-19 08:27:03 -0600
    t.day          #=> 19
    t.mday         #=> 19

;T;0;;;I"day;F;I"	Time;T;[o;;I" ;F;I"Integer;To;;I"¤Returns `true` if *time* occurs during Daylight Saving Time in its time zone.

    # CST6CDT:
      Time.local(2000, 1, 1).zone    #=> "CST"
      Time.local(2000, 1, 1).isdst   #=> false
      Time.local(2000, 1, 1).dst?    #=> false
      Time.local(2000, 7, 1).zone    #=> "CDT"
      Time.local(2000, 7, 1).isdst   #=> true
      Time.local(2000, 7, 1).dst?    #=> true

    # Asia/Tokyo:
      Time.local(2000, 1, 1).zone    #=> "JST"
      Time.local(2000, 1, 1).isdst   #=> false
      Time.local(2000, 1, 1).dst?    #=> false
      Time.local(2000, 7, 1).zone    #=> "JST"
      Time.local(2000, 7, 1).isdst   #=> false
      Time.local(2000, 7, 1).dst?    #=> false

;T;0;;;I"	dst?;F;I"	Time;T;[o;;I" ;F;I"	bool;To;;I"}Returns `true` if *time* and `other_time` are both Time objects with the same
seconds (including subsecond) from the Epoch.

;T;0;;;I"	eql?;F;I"	Time;T;[o;;I"untyped arg0;T;I"	bool;To;;I"ŸReturns `true` if *time* represents Friday.

    t = Time.local(1987, 12, 18)     #=> 1987-12-18 00:00:00 -0600
    t.friday?                        #=> true

;T;0;;;I"friday?;F;I"	Time;T;[o;;I" ;F;I"	bool;To;;I"QReturns a new Time object representing *time* in UTC.

    t = Time.local(2000,1,1,20,15,1)   #=> 2000-01-01 20:15:01 -0600
    t.gmt?                             #=> false
    y = t.getgm                        #=> 2000-01-02 02:15:01 UTC
    y.gmt?                             #=> true
    t == y                             #=> true

;T;0;;;I"
getgm;F;I"	Time;T;[o;;I" ;F;I"	Time;To;;I"mReturns a new Time object representing *time* in local time (using the local
time zone in effect for this process).

If `utc_offset` is given, it is used instead of the local time. `utc_offset`
can be given as a human-readable string (eg. `"+09:00"`) or as a number of
seconds (eg. `32400`).

    t = Time.utc(2000,1,1,20,15,1)  #=> 2000-01-01 20:15:01 UTC
    t.utc?                          #=> true

    l = t.getlocal                  #=> 2000-01-01 14:15:01 -0600
    l.utc?                          #=> false
    t == l                          #=> true

    j = t.getlocal("+09:00")        #=> 2000-01-02 05:15:01 +0900
    j.utc?                          #=> false
    t == j                          #=> true

    k = t.getlocal(9*60*60)         #=> 2000-01-02 05:15:01 +0900
    k.utc?                          #=> false
    t == k                          #=> true

;T;0;;;I"getlocal;F;I"	Time;T;[o;;I"?::Integer utc_offset;T;I"	Time;To;;I"QReturns a new Time object representing *time* in UTC.

    t = Time.local(2000,1,1,20,15,1)   #=> 2000-01-01 20:15:01 -0600
    t.gmt?                             #=> false
    y = t.getgm                        #=> 2000-01-02 02:15:01 UTC
    y.gmt?                             #=> true
    t == y                             #=> true

;T;0;;;I"getutc;F;I"	Time;T;[o;;I" ;F;I"	Time;To;;I"Returns `true` if *time* represents a time in UTC (GMT).

    t = Time.now                        #=> 2007-11-19 08:15:23 -0600
    t.utc?                              #=> false
    t = Time.gm(2000,"jan",1,20,15,1)   #=> 2000-01-01 20:15:01 UTC
    t.utc?                              #=> true

    t = Time.now                        #=> 2007-11-19 08:16:03 -0600
    t.gmt?                              #=> false
    t = Time.gm(2000,1,1,20,15,1)       #=> 2000-01-01 20:15:01 UTC
    t.gmt?                              #=> true

;T;0;;;I"	gmt?;F;I"	Time;T;[o;;I" ;F;I"	bool;To;;I"#Returns the offset in seconds between the timezone of *time* and UTC.

    t = Time.gm(2000,1,1,20,15,1)   #=> 2000-01-01 20:15:01 UTC
    t.gmt_offset                    #=> 0
    l = t.getlocal                  #=> 2000-01-01 14:15:01 -0600
    l.gmt_offset                    #=> -21600

;T;0;;;I"gmt_offset;F;I"	Time;T;[o;;I" ;F;I"Integer;To;;I"kConverts *time* to UTC (GMT), modifying the receiver.

    t = Time.now   #=> 2007-11-19 08:18:31 -0600
    t.gmt?         #=> false
    t.gmtime       #=> 2007-11-19 14:18:31 UTC
    t.gmt?         #=> true

    t = Time.now   #=> 2007-11-19 08:18:51 -0600
    t.utc?         #=> false
    t.utc          #=> 2007-11-19 14:18:51 UTC
    t.utc?         #=> true

;T;0;;;I"gmtime;F;I"	Time;T;[o;;I" ;F;I"	Time;To;;I"GReturns a hash code for this Time object.

See also Object#hash.

;T;0;;;I"	hash;F;I"	Time;T;[o;;I" ;F;I"Integer;To;;I"|Returns the hour of the day (0..23) for *time*.

    t = Time.now   #=> 2007-11-19 08:26:20 -0600
    t.hour         #=> 8

;T;0;;;I"	hour;F;I"	Time;T;[o;;I" ;F;I"Integer;To;;I"³Returns a new Time object based on the given arguments.

With no positional arguments, returns the value of Time.now:

    Time.new                                       # => 2021-04-24 17:27:46.0512465 -0500

Otherwise, returns a new Time object based on the given parameters:

    Time.new(2000)                                 # => 2000-01-01 00:00:00 -0600
    Time.new(2000, 12, 31, 23, 59, 59.5)           # => 2000-12-31 23:59:59.5 -0600
    Time.new(2000, 12, 31, 23, 59, 59.5, '+09:00') # => 2000-12-31 23:59:59.5 +0900

Parameters:

*   `year`: an integer year.
*   `month`: a month value, which may be:
    *   An integer month in the range `1..12`.
    *   A 3-character string that matches regular expression
        `/jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec/i`.

*   `day`: an integer day in the range `1..31` (less than 31 for some months).
*   `hour`: an integer hour in the range `0..23`.
*   `min`: an integer minute in the range `0..59`.
*   `sec` is the number of seconds (Integer, Float, or Rational) in the range
    `0..60`.
*   `zone`: a timezone, which may be:
    *   A string offset from UTC.
    *   A single letter offset from UTC, in the range `'A'..'Z'`, `'J'` (the
        so-called military timezone) excluded.
    *   An integer number of seconds.
    *   A timezone object; see [Timezone
        Argument](#class-Time-label-Timezone+Argument) for details.

*   `in: zone`: a timezone *zone*, which may be as above.

;T;0;;;I"initialize;F;I"	Time;T;[o;;I"…?::Integer? year, ?::Integer? month, ?::Integer? day, ?::Integer? hour, ?::Integer? min, ?::Numeric? sec, ?::String | ::Integer | nil;T;I"	void;To;;I"ˆ?::Integer? year, ?::Integer? month, ?::Integer? day, ?::Integer? hour, ?::Integer? min, ?::Numeric? sec, in: ::String | ::Integer | nil;T;I"	void;To;;I"ÞReturns a detailed string representing *time*. Unlike to_s, preserves
subsecond in the representation for easier debugging.

    t = Time.now
    t.inspect                             #=> "2012-11-10 18:16:12.261257655 +0100"
    t.strftime "%Y-%m-%d %H:%M:%S.%N %z"  #=> "2012-11-10 18:16:12.261257655 +0100"

    t.utc.inspect                          #=> "2012-11-10 17:16:12.261257655 UTC"
    t.strftime "%Y-%m-%d %H:%M:%S.%N UTC"  #=> "2012-11-10 17:16:12.261257655 UTC"

;T;0;;;I"inspect;F;I"	Time;T;[o;;I" ;F;I"String;To;;I"¤Returns `true` if *time* occurs during Daylight Saving Time in its time zone.

    # CST6CDT:
      Time.local(2000, 1, 1).zone    #=> "CST"
      Time.local(2000, 1, 1).isdst   #=> false
      Time.local(2000, 1, 1).dst?    #=> false
      Time.local(2000, 7, 1).zone    #=> "CDT"
      Time.local(2000, 7, 1).isdst   #=> true
      Time.local(2000, 7, 1).dst?    #=> true

    # Asia/Tokyo:
      Time.local(2000, 1, 1).zone    #=> "JST"
      Time.local(2000, 1, 1).isdst   #=> false
      Time.local(2000, 1, 1).dst?    #=> false
      Time.local(2000, 7, 1).zone    #=> "JST"
      Time.local(2000, 7, 1).isdst   #=> false
      Time.local(2000, 7, 1).dst?    #=> false

;T;0;;;I"
isdst;F;I"	Time;T;[o;;I" ;F;I"	bool;To;;I"Converts *time* to local time (using the local time zone in effect at the
creation time of *time*) modifying the receiver.

If `utc_offset` is given, it is used instead of the local time.

    t = Time.utc(2000, "jan", 1, 20, 15, 1) #=> 2000-01-01 20:15:01 UTC
    t.utc?                                  #=> true

    t.localtime                             #=> 2000-01-01 14:15:01 -0600
    t.utc?                                  #=> false

    t.localtime("+09:00")                   #=> 2000-01-02 05:15:01 +0900
    t.utc?                                  #=> false

If `utc_offset` is not given and *time* is local time, just returns the
receiver.

;T;0;;;I"localtime;F;I"	Time;T;[o;;I"?::String utc_offset;T;I"	Time;To;;I"˜Returns the day of the month (1..31) for *time*.

    t = Time.now   #=> 2007-11-19 08:27:03 -0600
    t.day          #=> 19
    t.mday         #=> 19

;T;0;;;I"	mday;F;I"	Time;T;[o;;I" ;F;I"Integer;To;;I"€Returns the minute of the hour (0..59) for *time*.

    t = Time.now   #=> 2007-11-19 08:25:51 -0600
    t.min          #=> 25

;T;0;;;I"min;F;I"	Time;T;[o;;I" ;F;I"Integer;To;;I"™Returns the month of the year (1..12) for *time*.

    t = Time.now   #=> 2007-11-19 08:27:30 -0600
    t.mon          #=> 11
    t.month        #=> 11

;T;0;;;I"mon;F;I"	Time;T;[o;;I" ;F;I"Integer;To;;I"ŸReturns `true` if *time* represents Monday.

    t = Time.local(2003, 8, 4)       #=> 2003-08-04 00:00:00 -0500
    t.monday?                        #=> true

;T;0;;;I"monday?;F;I"	Time;T;[o;;I" ;F;I"	bool;To;;I"ÈReturns the number of nanoseconds for the subsecond part of *time*. The result
is a non-negative integer less than 10**9.

    t = Time.now        #=> 2020-07-20 22:07:10.963933942 +0900
    t.nsec              #=> 963933942

If *time* has fraction of nanosecond (such as picoseconds), it is truncated.

    t = Time.new(2000,1,1,0,0,0.666_777_888_999r)
    t.nsec              #=> 666777888

Time#subsec can be used to obtain the subsecond part exactly.

;T;0;;;I"	nsec;F;I"	Time;T;[o;;I" ;F;I"Integer;To;;I"{Rounds subsecond to a given precision in decimal digits (0 digits by default).
It returns a new Time object. `ndigits` should be zero or a positive integer.

    t = Time.utc(2010,3,30, 5,43,25.123456789r)
    t                       #=> 2010-03-30 05:43:25.123456789 UTC
    t.round                 #=> 2010-03-30 05:43:25 UTC
    t.round(0)              #=> 2010-03-30 05:43:25 UTC
    t.round(1)              #=> 2010-03-30 05:43:25.1 UTC
    t.round(2)              #=> 2010-03-30 05:43:25.12 UTC
    t.round(3)              #=> 2010-03-30 05:43:25.123 UTC
    t.round(4)              #=> 2010-03-30 05:43:25.1235 UTC

    t = Time.utc(1999,12,31, 23,59,59)
    (t + 0.4).round         #=> 1999-12-31 23:59:59 UTC
    (t + 0.49).round        #=> 1999-12-31 23:59:59 UTC
    (t + 0.5).round         #=> 2000-01-01 00:00:00 UTC
    (t + 1.4).round         #=> 2000-01-01 00:00:00 UTC
    (t + 1.49).round        #=> 2000-01-01 00:00:00 UTC
    (t + 1.5).round         #=> 2000-01-01 00:00:01 UTC

    t = Time.utc(1999,12,31, 23,59,59)     #=> 1999-12-31 23:59:59 UTC
    (t + 0.123456789).round(4).iso8601(6)  #=> 1999-12-31 23:59:59.1235 UTC

;T;0;;;I"
round;F;I"	Time;T;[o;;I"?::Integer arg0;T;I"	Time;To;;I"¡Returns `true` if *time* represents Saturday.

    t = Time.local(2006, 6, 10)      #=> 2006-06-10 00:00:00 -0500
    t.saturday?                      #=> true

;T;0;;;I"saturday?;F;I"	Time;T;[o;;I" ;F;I"	bool;To;;I"Returns the second of the minute (0..60) for *time*.

**Note:** Seconds range from zero to 60 to allow the system to inject leap
seconds. See https://en.wikipedia.org/wiki/Leap_second for further details.

    t = Time.now   #=> 2007-11-19 08:25:02 -0600
    t.sec          #=> 2

;T;0;;;I"sec;F;I"	Time;T;[o;;I" ;F;I"Integer;To;;I"a!Formats *time* according to the directives in the given format string.

The directives begin with a percent (%) character. Any text not listed as a
directive will be passed through to the output string.

The directive consists of a percent (%) character, zero or more flags,
optional minimum field width, optional modifier and a conversion specifier as
follows:

    %<flags><width><modifier><conversion>

Flags:
    -  don't pad a numerical output
    _  use spaces for padding
    0  use zeros for padding
    ^  upcase the result string
    #  change case
    :  use colons for %z

The minimum field width specifies the minimum width.

The modifiers are "E" and "O". They are ignored.

Format directives:

    Date (Year, Month, Day):
      %Y - Year with century if provided, will pad result at least 4 digits.
              -0001, 0000, 1995, 2009, 14292, etc.
      %C - year / 100 (rounded down such as 20 in 2009)
      %y - year % 100 (00..99)

      %m - Month of the year, zero-padded (01..12)
              %_m  blank-padded ( 1..12)
              %-m  no-padded (1..12)
      %B - The full month name (``January'')
              %^B  uppercased (``JANUARY'')
      %b - The abbreviated month name (``Jan'')
              %^b  uppercased (``JAN'')
      %h - Equivalent to %b

      %d - Day of the month, zero-padded (01..31)
              %-d  no-padded (1..31)
      %e - Day of the month, blank-padded ( 1..31)

      %j - Day of the year (001..366)

    Time (Hour, Minute, Second, Subsecond):
      %H - Hour of the day, 24-hour clock, zero-padded (00..23)
      %k - Hour of the day, 24-hour clock, blank-padded ( 0..23)
      %I - Hour of the day, 12-hour clock, zero-padded (01..12)
      %l - Hour of the day, 12-hour clock, blank-padded ( 1..12)
      %P - Meridian indicator, lowercase (``am'' or ``pm'')
      %p - Meridian indicator, uppercase (``AM'' or ``PM'')

      %M - Minute of the hour (00..59)

      %S - Second of the minute (00..60)

      %L - Millisecond of the second (000..999)
           The digits under millisecond are truncated to not produce 1000.
      %N - Fractional seconds digits, default is 9 digits (nanosecond)
              %3N  millisecond (3 digits)
              %6N  microsecond (6 digits)
              %9N  nanosecond (9 digits)
              %12N picosecond (12 digits)
              %15N femtosecond (15 digits)
              %18N attosecond (18 digits)
              %21N zeptosecond (21 digits)
              %24N yoctosecond (24 digits)
           The digits under the specified length are truncated to avoid
           carry up.

    Time zone:
      %z - Time zone as hour and minute offset from UTC (e.g. +0900)
              %:z - hour and minute offset from UTC with a colon (e.g. +09:00)
              %::z - hour, minute and second offset from UTC (e.g. +09:00:00)
      %Z - Abbreviated time zone name or similar information.  (OS dependent)

    Weekday:
      %A - The full weekday name (``Sunday'')
              %^A  uppercased (``SUNDAY'')
      %a - The abbreviated name (``Sun'')
              %^a  uppercased (``SUN'')
      %u - Day of the week (Monday is 1, 1..7)
      %w - Day of the week (Sunday is 0, 0..6)

    ISO 8601 week-based year and week number:
    The first week of YYYY starts with a Monday and includes YYYY-01-04.
    The days in the year before the first week are in the last week of
    the previous year.
      %G - The week-based year
      %g - The last 2 digits of the week-based year (00..99)
      %V - Week number of the week-based year (01..53)

    Week number:
    The first week of YYYY that starts with a Sunday or Monday (according to %U
    or %W). The days in the year before the first week are in week 0.
      %U - Week number of the year. The week starts with Sunday. (00..53)
      %W - Week number of the year. The week starts with Monday. (00..53)

    Seconds since the Epoch:
      %s - Number of seconds since 1970-01-01 00:00:00 UTC.

    Literal string:
      %n - Newline character (\n)
      %t - Tab character (\t)
      %% - Literal ``%'' character

    Combination:
      %c - date and time (%a %b %e %T %Y)
      %D - Date (%m/%d/%y)
      %F - The ISO 8601 date format (%Y-%m-%d)
      %v - VMS date (%e-%^b-%4Y)
      %x - Same as %D
      %X - Same as %T
      %r - 12-hour time (%I:%M:%S %p)
      %R - 24-hour time (%H:%M)
      %T - 24-hour time (%H:%M:%S)

This method is similar to strftime() function defined in ISO C and POSIX.

While all directives are locale independent since Ruby 1.9, %Z is platform
dependent. So, the result may differ even if the same format string is used in
other systems such as C.

%z is recommended over %Z. %Z doesn't identify the timezone. For example,
"CST" is used at America/Chicago (-06:00), America/Havana (-05:00),
Asia/Harbin (+08:00), Australia/Darwin (+09:30) and Australia/Adelaide
(+10:30). Also, %Z is highly dependent on the operating system. For example,
it may generate a non ASCII string on Japanese Windows, i.e. the result can be
different to "JST". So the numeric time zone offset, %z, is recommended.

Examples:

    t = Time.new(2007,11,19,8,37,48,"-06:00") #=> 2007-11-19 08:37:48 -0600
    t.strftime("Printed on %m/%d/%Y")         #=> "Printed on 11/19/2007"
    t.strftime("at %I:%M %p")                 #=> "at 08:37 AM"

Various ISO 8601 formats:
    %Y%m%d           => 20071119                  Calendar date (basic)
    %F               => 2007-11-19                Calendar date (extended)
    %Y-%m            => 2007-11                   Calendar date, reduced accuracy, specific month
    %Y               => 2007                      Calendar date, reduced accuracy, specific year
    %C               => 20                        Calendar date, reduced accuracy, specific century
    %Y%j             => 2007323                   Ordinal date (basic)
    %Y-%j            => 2007-323                  Ordinal date (extended)
    %GW%V%u          => 2007W471                  Week date (basic)
    %G-W%V-%u        => 2007-W47-1                Week date (extended)
    %GW%V            => 2007W47                   Week date, reduced accuracy, specific week (basic)
    %G-W%V           => 2007-W47                  Week date, reduced accuracy, specific week (extended)
    %H%M%S           => 083748                    Local time (basic)
    %T               => 08:37:48                  Local time (extended)
    %H%M             => 0837                      Local time, reduced accuracy, specific minute (basic)
    %H:%M            => 08:37                     Local time, reduced accuracy, specific minute (extended)
    %H               => 08                        Local time, reduced accuracy, specific hour
    %H%M%S,%L        => 083748,000                Local time with decimal fraction, comma as decimal sign (basic)
    %T,%L            => 08:37:48,000              Local time with decimal fraction, comma as decimal sign (extended)
    %H%M%S.%L        => 083748.000                Local time with decimal fraction, full stop as decimal sign (basic)
    %T.%L            => 08:37:48.000              Local time with decimal fraction, full stop as decimal sign (extended)
    %H%M%S%z         => 083748-0600               Local time and the difference from UTC (basic)
    %T%:z            => 08:37:48-06:00            Local time and the difference from UTC (extended)
    %Y%m%dT%H%M%S%z  => 20071119T083748-0600      Date and time of day for calendar date (basic)
    %FT%T%:z         => 2007-11-19T08:37:48-06:00 Date and time of day for calendar date (extended)
    %Y%jT%H%M%S%z    => 2007323T083748-0600       Date and time of day for ordinal date (basic)
    %Y-%jT%T%:z      => 2007-323T08:37:48-06:00   Date and time of day for ordinal date (extended)
    %GW%V%uT%H%M%S%z => 2007W471T083748-0600      Date and time of day for week date (basic)
    %G-W%V-%uT%T%:z  => 2007-W47-1T08:37:48-06:00 Date and time of day for week date (extended)
    %Y%m%dT%H%M      => 20071119T0837             Calendar date and local time (basic)
    %FT%R            => 2007-11-19T08:37          Calendar date and local time (extended)
    %Y%jT%H%MZ       => 2007323T0837Z             Ordinal date and UTC of day (basic)
    %Y-%jT%RZ        => 2007-323T08:37Z           Ordinal date and UTC of day (extended)
    %GW%V%uT%H%M%z   => 2007W471T0837-0600        Week date and local time and difference from UTC (basic)
    %G-W%V-%uT%R%:z  => 2007-W47-1T08:37-06:00    Week date and local time and difference from UTC (extended)

;T;0;;;I"strftime;F;I"	Time;T;[o;;I"::String arg0;T;I"String;To;;I"ÔReturns the subsecond for *time*.

The return value can be a rational number.

    t = Time.now        #=> 2020-07-20 15:40:26.867462289 +0900
    t.subsec            #=> (867462289/1000000000)

    t = Time.now        #=> 2020-07-20 15:40:50.313828595 +0900
    t.subsec            #=> (62765719/200000000)

    t = Time.new(2000,1,1,2,3,4) #=> 2000-01-01 02:03:04 +0900
    t.subsec                     #=> 0

    Time.new(2000,1,1,0,0,1/3r,"UTC").subsec #=> (1/3)

;T;0;;;I"subsec;F;I"	Time;T;[o;;I" ;F;I"0 | ::Rational;Fo;;I"ŸReturns `true` if *time* represents Sunday.

    t = Time.local(1990, 4, 1)       #=> 1990-04-01 00:00:00 -0600
    t.sunday?                        #=> true

;T;0;;;I"sunday?;F;I"	Time;T;[o;;I" ;F;I"	bool;To;;I"¡Returns `true` if *time* represents Thursday.

    t = Time.local(1995, 12, 21)     #=> 1995-12-21 00:00:00 -0600
    t.thursday?                      #=> true

;T;0;;;I"thursday?;F;I"	Time;T;[o;;I" ;F;I"	bool;To;;I"£Returns a ten-element *array* of values for *time*:

    [sec, min, hour, day, month, year, wday, yday, isdst, zone]

See the individual methods for an explanation of the valid ranges of each
value. The ten elements can be passed directly to Time.utc or Time.local to
create a new Time object.

    t = Time.now     #=> 2007-11-19 08:36:01 -0600
    now = t.to_a     #=> [1, 36, 8, 19, 11, 2007, 1, 323, false, "CST"]

;T;0;;;I"	to_a;F;I"	Time;T;[o;;I" ;F;I"o[ ::Integer, ::Integer, ::Integer, ::Integer, ::Integer, ::Integer, ::Integer, ::Integer, bool, ::String ];To;;I";Returns the value of *time* as a floating point number of seconds since the
Epoch. The return value approximate the exact value in the Time object because
floating point numbers cannot represent all rational numbers exactly.

    t = Time.now        #=> 2020-07-20 22:00:29.38740268 +0900
    t.to_f              #=> 1595250029.3874028
    t.to_i              #=> 1595250029

Note that IEEE 754 double is not accurate enough to represent the exact number
of nanoseconds since the Epoch. (IEEE 754 double has 53bit mantissa. So it can
represent exact number of nanoseconds only in `2 ** 53 / 1_000_000_000 / 60 /
60 / 24 = 104.2` days.) When Ruby uses a nanosecond-resolution clock function,
such as `clock_gettime` of POSIX, to obtain the current time, Time#to_f can
lose information of a Time object created with `Time.now`.

;T;0;;;I"	to_f;F;I"	Time;T;[o;;I" ;F;I"
Float;To;;I"éReturns the value of *time* as an integer number of seconds since the Epoch.

If *time* contains subsecond, they are truncated.

    t = Time.now        #=> 2020-07-21 01:41:29.746012609 +0900
    t.to_i              #=> 1595263289

;T;0;;;I"	to_i;F;I"	Time;T;[o;;I" ;F;I"Integer;To;;I"EReturns the value of *time* as a rational number of seconds since the Epoch.

    t = Time.now      #=> 2020-07-20 22:03:45.212167333 +0900
    t.to_r            #=> (1595250225212167333/1000000000)

This method is intended to be used to get an accurate value representing the
seconds (including subsecond) since the Epoch.

;T;0;;;I"	to_r;F;I"	Time;T;[o;;I" ;F;I"Rational;To;;I"šReturns a string representing *time*. Equivalent to calling #strftime with the
appropriate format string.

    t = Time.now
    t.to_s                              #=> "2012-11-10 18:16:12 +0100"
    t.strftime "%Y-%m-%d %H:%M:%S %z"   #=> "2012-11-10 18:16:12 +0100"

    t.utc.to_s                          #=> "2012-11-10 17:16:12 UTC"
    t.strftime "%Y-%m-%d %H:%M:%S UTC"  #=> "2012-11-10 17:16:12 UTC"

;T;0;;;I"	to_s;F;I"	Time;T;[o;;I" ;F;I"String;To;;I" Returns `true` if *time* represents Tuesday.

    t = Time.local(1991, 2, 19)      #=> 1991-02-19 00:00:00 -0600
    t.tuesday?                       #=> true

;T;0;;;I"tuesday?;F;I"	Time;T;[o;;I" ;F;I"	bool;To;;I"ÈReturns the number of nanoseconds for the subsecond part of *time*. The result
is a non-negative integer less than 10**9.

    t = Time.now        #=> 2020-07-20 22:07:10.963933942 +0900
    t.nsec              #=> 963933942

If *time* has fraction of nanosecond (such as picoseconds), it is truncated.

    t = Time.new(2000,1,1,0,0,0.666_777_888_999r)
    t.nsec              #=> 666777888

Time#subsec can be used to obtain the subsecond part exactly.

;T;0;;;I"tv_nsec;F;I"	Time;T;[o;;I" ;F;I"Integer;To;;I"éReturns the value of *time* as an integer number of seconds since the Epoch.

If *time* contains subsecond, they are truncated.

    t = Time.now        #=> 2020-07-21 01:41:29.746012609 +0900
    t.to_i              #=> 1595263289

;T;0;;;I"tv_sec;F;I"	Time;T;[o;;I" ;F;I"Integer;To;;I"ÄReturns the number of microseconds for the subsecond part of *time*. The
result is a non-negative integer less than 10**6.

    t = Time.now        #=> 2020-07-20 22:05:58.459785953 +0900
    t.usec              #=> 459785

If *time* has fraction of microsecond (such as nanoseconds), it is truncated.

    t = Time.new(2000,1,1,0,0,0.666_777_888_999r)
    t.usec              #=> 666777

Time#subsec can be used to obtain the subsecond part exactly.

;T;0;;;I"tv_usec;F;I"	Time;T;[o;;I" ;F;I"Integer;To;;I"ÄReturns the number of microseconds for the subsecond part of *time*. The
result is a non-negative integer less than 10**6.

    t = Time.now        #=> 2020-07-20 22:05:58.459785953 +0900
    t.usec              #=> 459785

If *time* has fraction of microsecond (such as nanoseconds), it is truncated.

    t = Time.new(2000,1,1,0,0,0.666_777_888_999r)
    t.usec              #=> 666777

Time#subsec can be used to obtain the subsecond part exactly.

;T;0;;;I"	usec;F;I"	Time;T;[o;;I" ;F;I"Integer;To;;I"kConverts *time* to UTC (GMT), modifying the receiver.

    t = Time.now   #=> 2007-11-19 08:18:31 -0600
    t.gmt?         #=> false
    t.gmtime       #=> 2007-11-19 14:18:31 UTC
    t.gmt?         #=> true

    t = Time.now   #=> 2007-11-19 08:18:51 -0600
    t.utc?         #=> false
    t.utc          #=> 2007-11-19 14:18:51 UTC
    t.utc?         #=> true

;T;0;;;I"utc;F;I"	Time;T;[o;;I" ;F;I"	Time;To;;I"Returns `true` if *time* represents a time in UTC (GMT).

    t = Time.now                        #=> 2007-11-19 08:15:23 -0600
    t.utc?                              #=> false
    t = Time.gm(2000,"jan",1,20,15,1)   #=> 2000-01-01 20:15:01 UTC
    t.utc?                              #=> true

    t = Time.now                        #=> 2007-11-19 08:16:03 -0600
    t.gmt?                              #=> false
    t = Time.gm(2000,1,1,20,15,1)       #=> 2000-01-01 20:15:01 UTC
    t.gmt?                              #=> true

;T;0;;;I"	utc?;F;I"	Time;T;[o;;I" ;F;I"	bool;To;;I"#Returns the offset in seconds between the timezone of *time* and UTC.

    t = Time.gm(2000,1,1,20,15,1)   #=> 2000-01-01 20:15:01 UTC
    t.gmt_offset                    #=> 0
    l = t.getlocal                  #=> 2000-01-01 14:15:01 -0600
    l.gmt_offset                    #=> -21600

;T;0;;;I"utc_offset;F;I"	Time;T;[o;;I" ;F;I"Integer;To;;I"cReturns an integer representing the day of the week, 0..6, with Sunday == 0.

    t = Time.now   #=> 2007-11-20 02:35:35 -0600
    t.wday         #=> 2
    t.sunday?      #=> false
    t.monday?      #=> false
    t.tuesday?     #=> true
    t.wednesday?   #=> false
    t.thursday?    #=> false
    t.friday?      #=> false
    t.saturday?    #=> false

;T;0;;;I"	wday;F;I"	Time;T;[o;;I" ;F;I"Integer;To;;I"¢Returns `true` if *time* represents Wednesday.

    t = Time.local(1993, 2, 24)      #=> 1993-02-24 00:00:00 -0600
    t.wednesday?                     #=> true

;T;0;;;I"wednesday?;F;I"	Time;T;[o;;I" ;F;I"	bool;To;;I"‹Returns an integer representing the day of the year, 1..366.

    t = Time.now   #=> 2007-11-19 08:32:31 -0600
    t.yday         #=> 323

;T;0;;;I"	yday;F;I"	Time;T;[o;;I" ;F;I"Integer;To;;I"„Returns the year for *time* (including the century).

    t = Time.now   #=> 2007-11-19 08:27:51 -0600
    t.year         #=> 2007

;T;0;;;I"	year;F;I"	Time;T;[o;;I" ;F;I"Integer;To;;I"ÿReturns the name of the time zone used for *time*. As of Ruby 1.8, returns
``UTC'' rather than ``GMT'' for UTC times.

    t = Time.gm(2000, "jan", 1, 20, 15, 1)
    t.zone   #=> "UTC"
    t = Time.local(2000, "jan", 1, 20, 15, 1)
    t.zone   #=> "CST"

;T;0;;;I"	zone;F;I"	Time;T;[o;;I" ;F;I"String;To;;I"‹Same as Time::gm, but interprets the values in the local time zone.

    Time.local(2000,"jan",1,20,15,1)   #=> 2000-01-01 20:15:01 -0600

;T;0;;;I"mktime;F;I"	Time;T;[o;;I"‡::Integer year, ?::Integer | ::String month, ?::Integer day, ?::Integer hour, ?::Integer min, ?::Numeric sec, ?::Numeric usec_with_frac;T;I"	Time;To;;I"#Returns the offset in seconds between the timezone of *time* and UTC.

    t = Time.gm(2000,1,1,20,15,1)   #=> 2000-01-01 20:15:01 UTC
    t.gmt_offset                    #=> 0
    l = t.getlocal                  #=> 2000-01-01 14:15:01 -0600
    l.gmt_offset                    #=> -21600

;T;0;;;I"gmtoff;F;I"	Time;T;[o;;I" ;F;I"Integer;To;;I"™Returns the month of the year (1..12) for *time*.

    t = Time.now   #=> 2007-11-19 08:27:30 -0600
    t.mon          #=> 11
    t.month        #=> 11

;T;0;;;I"
month;F;I"	Time;T;[o;;I" ;F;I"Integer;To;;I"ÌFloors subsecond to a given precision in decimal digits (0 digits by default).
It returns a new Time object. `ndigits` should be zero or a positive integer.

    t = Time.utc(2010,3,30, 5,43,25.123456789r)
    t                       #=> 2010-03-30 05:43:25.123456789 UTC
    t.floor                 #=> 2010-03-30 05:43:25 UTC
    t.floor(0)              #=> 2010-03-30 05:43:25 UTC
    t.floor(1)              #=> 2010-03-30 05:43:25.1 UTC
    t.floor(2)              #=> 2010-03-30 05:43:25.12 UTC
    t.floor(3)              #=> 2010-03-30 05:43:25.123 UTC
    t.floor(4)              #=> 2010-03-30 05:43:25.1234 UTC

    t = Time.utc(1999,12,31, 23,59,59)
    (t + 0.4).floor    #=> 1999-12-31 23:59:59 UTC
    (t + 0.9).floor    #=> 1999-12-31 23:59:59 UTC
    (t + 1.4).floor    #=> 2000-01-01 00:00:00 UTC
    (t + 1.9).floor    #=> 2000-01-01 00:00:00 UTC

    t = Time.utc(1999,12,31, 23,59,59)
    (t + 0.123456789).floor(4)  #=> 1999-12-31 23:59:59.1234 UTC

;T;0;;;I"
floor;F;I"	Time;T;[o;;I"?::Integer ndigits;T;I"	Time;To;;I"àCeils subsecond to a given precision in decimal digits (0 digits by default).
It returns a new Time object. `ndigits` should be zero or a positive integer.

    t = Time.utc(2010,3,30, 5,43,25.0123456789r)
    t                      #=> 2010-03-30 05:43:25 123456789/10000000000 UTC
    t.ceil                 #=> 2010-03-30 05:43:26 UTC
    t.ceil(0)              #=> 2010-03-30 05:43:26 UTC
    t.ceil(1)              #=> 2010-03-30 05:43:25.1 UTC
    t.ceil(2)              #=> 2010-03-30 05:43:25.02 UTC
    t.ceil(3)              #=> 2010-03-30 05:43:25.013 UTC
    t.ceil(4)              #=> 2010-03-30 05:43:25.0124 UTC

    t = Time.utc(1999,12,31, 23,59,59)
    (t + 0.4).ceil         #=> 2000-01-01 00:00:00 UTC
    (t + 0.9).ceil         #=> 2000-01-01 00:00:00 UTC
    (t + 1.4).ceil         #=> 2000-01-01 00:00:01 UTC
    (t + 1.9).ceil         #=> 2000-01-01 00:00:01 UTC

    t = Time.utc(1999,12,31, 23,59,59)
    (t + 0.123456789).ceil(4)  #=> 1999-12-31 23:59:59.1235 UTC

;T;0;;;I"	ceil;F;I"	Time;T;[o;;I"?::Integer ndigits;T;I"	Time;To; ;0;0;	I"	Time;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"Returns self.

;T;0;;;I"to_time;F;I"	Time;T;[o;;I" ;F;I"	Time;To;;I"0Returns a Date object which denotes self.

;T;0;;;I"to_date;F;I"	Time;T;[o;;I" ;F;I"	Date;To;;I"4Returns a DateTime object which denotes self.

;T;0;;;I"to_datetime;F;I"	Time;T;[o;;I" ;F;I"DateTime;To; ;0;0;	I"	Time;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"FDeserializes JSON string by converting time since epoch to Time

;T;0;;;I"json_create;F;I"	Time;T;[o;;I"2::Hash[::String, ::String | ::Integer] object;T;I"instance;To;;I"XReturns a hash, that will be turned into a JSON object and represent this
object.

;T;0;;;I"as_json;F;I"	Time;T;[o;;I"*untyped;T;I")Hash[::String, ::String | ::Integer];To;;I"uStores class name (Time) with number of seconds since epoch and number of
microseconds for Time as JSON string

;T;0;;;I"to_json;F;I"	Time;T;[o;;I"?::JSON::State state;T;I"String;To; ;0;0;	I"	Time;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"ÛReturn the number of seconds the specified time zone differs from UTC.

Numeric time zones that include minutes, such as `-10:00` or `+1330` will
work, as will simpler hour-only time zones like `-10` or `+13`.

Textual time zones listed in ZoneOffset are also supported.

If the time zone does not match any of the above, `zone_offset` will check if
the local time zone (both with and without potential Daylight Saving Time
changes being in effect) matches `zone`. Specifying a value for `year` will
change the year used to find the local time zone.

If `zone_offset` is unable to determine the offset, nil will be returned.

    require 'time'

    Time.zone_offset("EST") #=> -18000

You must require 'time' to use this method.

;T;0;;;I"zone_offset;F;I"	Time;T;[o;;I"#::String zone, ?::Integer year;T;I"Integer;To;;I"hTakes a string representation of a Time and attempts to parse it using a
heuristic.

This method **does not** function as a validator.  If the input string does
not match valid formats strictly, you may get a cryptic result.  Should
consider to use `Time.strptime` instead of this method as possible.

    require 'time'

    Time.parse("2010-10-31") #=> 2010-10-31 00:00:00 -0500

Any missing pieces of the date are inferred based on the current date.

    require 'time'

    # assuming the current date is "2011-10-31"
    Time.parse("12:00") #=> 2011-10-31 12:00:00 -0500

We can change the date used to infer our missing elements by passing a second
object that responds to #mon, #day and #year, such as Date, Time or DateTime.
We can also use our own object.

    require 'time'

    class MyDate
      attr_reader :mon, :day, :year

      def initialize(mon, day, year)
        @mon, @day, @year = mon, day, year
      end
    end

    d  = Date.parse("2010-10-28")
    t  = Time.parse("2010-10-29")
    dt = DateTime.parse("2010-10-30")
    md = MyDate.new(10,31,2010)

    Time.parse("12:00", d)  #=> 2010-10-28 12:00:00 -0500
    Time.parse("12:00", t)  #=> 2010-10-29 12:00:00 -0500
    Time.parse("12:00", dt) #=> 2010-10-30 12:00:00 -0500
    Time.parse("12:00", md) #=> 2010-10-31 12:00:00 -0500

If a block is given, the year described in `date` is converted by the block.
This is specifically designed for handling two digit years. For example, if
you wanted to treat all two digit years prior to 70 as the year 2000+ you
could write this:

    require 'time'

    Time.parse("01-10-31") {|year| year + (year < 70 ? 2000 : 1900)}
    #=> 2001-10-31 00:00:00 -0500
    Time.parse("70-10-31") {|year| year + (year < 70 ? 2000 : 1900)}
    #=> 1970-10-31 00:00:00 -0500

If the upper components of the given time are broken or missing, they are
supplied with those of `now`.  For the lower components, the minimum values (1
or 0) are assumed if broken or missing.  For example:

    require 'time'

    # Suppose it is "Thu Nov 29 14:33:20 2001" now and
    # your time zone is EST which is GMT-5.
    now = Time.parse("Thu Nov 29 14:33:20 2001")
    Time.parse("16:30", now)     #=> 2001-11-29 16:30:00 -0500
    Time.parse("7/23", now)      #=> 2001-07-23 00:00:00 -0500
    Time.parse("Aug 31", now)    #=> 2001-08-31 00:00:00 -0500
    Time.parse("Aug 2000", now)  #=> 2000-08-01 00:00:00 -0500

Since there are numerous conflicts among locally defined time zone
abbreviations all over the world, this method is not intended to understand
all of them.  For example, the abbreviation "CST" is used variously as:

    -06:00 in America/Chicago,
    -05:00 in America/Havana,
    +08:00 in Asia/Harbin,
    +09:30 in Australia/Darwin,
    +10:30 in Australia/Adelaide,
    etc.

Based on this fact, this method only understands the time zone abbreviations
described in RFC 822 and the system time zone, in the order named. (i.e. a
definition in RFC 822 overrides the system time zone definition.)  The system
time zone is taken from `Time.local(year, 1, 1).zone` and `Time.local(year, 7,
1).zone`. If the extracted time zone abbreviation does not match any of them,
it is ignored and the given time is regarded as a local time.

ArgumentError is raised if Date._parse cannot extract information from `date`
or if the Time class cannot represent specified date.

This method can be used as a fail-safe for other parsing methods as:

    Time.rfc2822(date) rescue Time.parse(date)
    Time.httpdate(date) rescue Time.parse(date)
    Time.xmlschema(date) rescue Time.parse(date)

A failure of Time.parse should be checked, though.

You must require 'time' to use this method.

;T;0;;;I"
parse;F;I"	Time;T;[o;;I"*::String date, ?::Time::_TimeLike now;T;I"	Time;To;;I".
Works similar to `parse` except that instead of using a heuristic to detect
the format of the input string, you provide a second argument that describes
the format of the string.

If a block is given, the year described in `date` is converted by the block.
For example:

    Time.strptime(...) {|y| y < 100 ? (y >= 69 ? y + 1900 : y + 2000) : y}

Below is a list of the formatting options:

%a
:   The abbreviated weekday name ("Sun")
%A
:   The  full  weekday  name ("Sunday")
%b
:   The abbreviated month name ("Jan")
%B
:   The  full  month  name ("January")
%c
:   The preferred local date and time representation
%C
:   Century (20 in 2009)
%d
:   Day of the month (01..31)
%D
:   Date (%m/%d/%y)
%e
:   Day of the month, blank-padded ( 1..31)
%F
:   Equivalent to %Y-%m-%d (the ISO 8601 date format)
%g
:   The last two digits of the commercial year
%G
:   The week-based year according to ISO-8601 (week 1 starts on Monday and
    includes January 4)
%h
:   Equivalent to %b
%H
:   Hour of the day, 24-hour clock (00..23)
%I
:   Hour of the day, 12-hour clock (01..12)
%j
:   Day of the year (001..366)
%k
:   hour, 24-hour clock, blank-padded ( 0..23)
%l
:   hour, 12-hour clock, blank-padded ( 0..12)
%L
:   Millisecond of the second (000..999)
%m
:   Month of the year (01..12)
%M
:   Minute of the hour (00..59)
%n
:   Newline (n)
%N
:   Fractional seconds digits
%p
:   Meridian indicator ("AM" or "PM")
%P
:   Meridian indicator ("am" or "pm")
%r
:   time, 12-hour (same as %I:%M:%S %p)
%R
:   time, 24-hour (%H:%M)
%s
:   Number of seconds since 1970-01-01 00:00:00 UTC.
%S
:   Second of the minute (00..60)
%t
:   Tab character (t)
%T
:   time, 24-hour (%H:%M:%S)
%u
:   Day of the week as a decimal, Monday being 1. (1..7)
%U
:   Week number of the current year, starting with the first Sunday as the
    first day of the first week (00..53)
%v
:   VMS date (%e-%b-%Y)
%V
:   Week number of year according to ISO 8601 (01..53)
%W
:   Week  number  of the current year, starting with the first Monday as the
    first day of the first week (00..53)
%w
:   Day of the week (Sunday is 0, 0..6)
%x
:   Preferred representation for the date alone, no time
%X
:   Preferred representation for the time alone, no date
%y
:   Year without a century (00..99)
%Y
:   Year which may include century, if provided
%z
:   Time zone as  hour offset from UTC (e.g. +0900)
%Z
:   Time zone name
%%
:   Literal "%" character
%+
:   date(1) (%a %b %e %H:%M:%S %Z %Y)


    require 'time'

    Time.strptime("2000-10-31", "%Y-%m-%d") #=> 2000-10-31 00:00:00 -0500

You must require 'time' to use this method.

;T;0;;;I"strptime;F;I"	Time;T;[o;;I";::String date, ::String format, ?::Time::_TimeLike now;T;I"	Time;To;;I"íParses `date` as date-time defined by RFC 2822 and converts it to a Time
object.  The format is identical to the date format defined by RFC 822 and
updated by RFC 1123.

ArgumentError is raised if `date` is not compliant with RFC 2822 or if the
Time class cannot represent specified date.

See #rfc2822 for more information on this format.

    require 'time'

    Time.rfc2822("Wed, 05 Oct 2011 22:26:12 -0400")
    #=> 2010-10-05 22:26:12 -0400

You must require 'time' to use this method.

;T;0;;;I"rfc2822;F;I"	Time;T;[o;;I"::String date;T;I"	Time;To;;I"–Parses `date` as an HTTP-date defined by RFC 2616 and converts it to a Time
object.

ArgumentError is raised if `date` is not compliant with RFC 2616 or if the
Time class cannot represent specified date.

See #httpdate for more information on this format.

    require 'time'

    Time.httpdate("Thu, 06 Oct 2011 02:26:12 GMT")
    #=> 2011-10-06 02:26:12 UTC

You must require 'time' to use this method.

;T;0;;;I"httpdate;F;I"	Time;T;[o;;I"::String date;T;I"	Time;To;;I"çParses `time` as a dateTime defined by the XML Schema and converts it to a
Time object.  The format is a restricted version of the format defined by ISO
8601.

ArgumentError is raised if `time` is not compliant with the format or if the
Time class cannot represent the specified time.

See #xmlschema for more information on this format.

    require 'time'

    Time.xmlschema("2011-10-05T22:26:12-04:00")
    #=> 2011-10-05 22:26:12-04:00

You must require 'time' to use this method.

;T;0;;;I"xmlschema;F;I"	Time;T;[o;;I"::String date;T;I"	Time;To;;I"TReturns a string which represents the time as date-time defined by RFC 2822:

    day-of-week, DD month-name CCYY hh:mm:ss zone

where zone is [+-]hhmm.

If `self` is a UTC time, -0000 is used as zone.

    require 'time'

    t = Time.now
    t.rfc2822  # => "Wed, 05 Oct 2011 22:26:12 -0400"

You must require 'time' to use this method.

;T;0;;;I"rfc2822;F;I"	Time;T;[o;;I" ;F;I"String;To;;I"CReturns a string which represents the time as RFC 1123 date of HTTP-date
defined by RFC 2616:

    day-of-week, DD month-name CCYY hh:mm:ss GMT

Note that the result is always UTC (GMT).

    require 'time'

    t = Time.now
    t.httpdate # => "Thu, 06 Oct 2011 02:26:12 GMT"

You must require 'time' to use this method.

;T;0;;;I"httpdate;F;I"	Time;T;[o;;I" ;F;I"String;To;;I"ßReturns a string which represents the time as a dateTime defined by XML
Schema:

    CCYY-MM-DDThh:mm:ssTZD
    CCYY-MM-DDThh:mm:ss.sssTZD

where TZD is Z or [+-]hh:mm.

If self is a UTC time, Z is used as TZD.  [+-]hh:mm is used otherwise.

`fractional_digits` specifies a number of digits to use for fractional
seconds.  Its default value is 0.

    require 'time'

    t = Time.now
    t.iso8601  # => "2011-10-05T22:26:12-04:00"

You must require 'time' to use this method.

;T;0;;;I"xmlschema;F;I"	Time;T;[o;;I"?::Integer fraction_digits;T;I"String;To; ;I"GDocument-class: TracePoint

A class that provides the functionality of Kernel#set_trace_func in a nice
Object-Oriented API.

## Example

We can use TracePoint to gather information specifically for exceptions:

    trace = TracePoint.new(:raise) do |tp|
        p [tp.lineno, tp.event, tp.raised_exception]
    end
    #=> #<TracePoint:disabled>

    trace.enable
    #=> false

    0 / 0
    #=> [5, :raise, #<ZeroDivisionError: divided by 0>]

## Events

If you don't specify the type of events you want to listen for, TracePoint
will include all available events.

**Note** do not depend on current event set, as this list is subject to
change. Instead, it is recommended you specify the type of events you want to
use.

To filter what is traced, you can pass any of the following as `events`:

`:line`
:   execute an expression or statement on a new line
`:class`
:   start a class or module definition
`:end`
:   finish a class or module definition
`:call`
:   call a Ruby method
`:return`
:   return from a Ruby method
`:c_call`
:   call a C-language routine
`:c_return`
:   return from a C-language routine
`:raise`
:   raise an exception
`:b_call`
:   event hook at block entry
`:b_return`
:   event hook at block ending
`:a_call`
:   event hook at all calls (`call`, `b_call`, and `c_call`)
`:a_return`
:   event hook at all returns (`return`, `b_return`, and `c_return`)
`:thread_begin`
:   event hook at thread beginning
`:thread_end`
:   event hook at thread ending
`:fiber_switch`
:   event hook at fiber switch
`:script_compiled`
:   new Ruby code compiled (with `eval`, `load` or `require`)

;T;0;	I"TracePoint;T;
[ ;[ ;0;[ ;[ ;0;I"Object;To;;I"MReturns a new TracePoint object, not enabled by default.

Next, in order to activate the trace, you must use TracePoint#enable

    trace = TracePoint.new(:call) do |tp|
        p [tp.lineno, tp.defined_class, tp.method_id, tp.event]
    end
    #=> #<TracePoint:disabled>

    trace.enable
    #=> false

    puts "Hello, TracePoint!"
    # ...
    # [48, IRB::Notifier::AbstractNotifier, :printf, :call]
    # ...

When you want to deactivate the trace, you must use TracePoint#disable

    trace.disable

See TracePoint@Events for possible events and more information.

A block must be given, otherwise an ArgumentError is raised.

If the trace method isn't included in the given events filter, a RuntimeError
is raised.

    TracePoint.trace(:line) do |tp|
        p tp.raised_exception
    end
    #=> RuntimeError: 'raised_exception' not supported by this event

If the trace method is called outside block, a RuntimeError is raised.

    TracePoint.trace(:line) do |tp|
      $tp = tp
    end
    $tp.lineno #=> access from outside (RuntimeError)

Access from other threads is also forbidden.

;T;0;;;I"initialize;F;I"TracePoint;T;[o;;I"*::Symbol events;T;I"	void;To;;I"oIn general, while a TracePoint callback is running, other registered callbacks
are not called to avoid confusion by reentrance. This method allows the
reentrance in a given block. This method should be used carefully, otherwise
the callback can be easily called infinitely.

If this method is called when the reentrance is already allowed, it raises a
RuntimeError.

;T;0;;;I"allow_reentry;F;I"TracePoint;T;[o;;I" ;F;I"	void;To;;I"ÁReturns internal information of TracePoint.

The contents of the returned value are implementation specific. It may be
changed in future.

This method is only for debugging TracePoint itself.

;T;0;;;I"	stat;F;I"TracePoint;T;[o;;I" ;F;I"untyped;To;;I"ÑA convenience method for TracePoint.new, that activates the trace
automatically.

    trace = TracePoint.trace(:call) { |tp| [tp.lineno, tp.event] }
    #=> #<TracePoint:enabled>

    trace.enabled? #=> true

;T;0;;;I"
trace;F;I"TracePoint;T;[o;;I"*::Symbol events;T;I"TracePoint;To;;I"æReturn the generated binding object from event.

Note that for `c_call` and `c_return` events, the binding returned is the
binding of the nearest Ruby method calling the C method, since C methods
themselves do not have bindings.

;T;0;;;I"binding;F;I"TracePoint;T;[o;;I" ;F;I"Binding;To;;I"8Return the called name of the method being called

;T;0;;;I"callee_id;F;I"TracePoint;T;[o;;I" ;F;I"Symbol;To;;I"5Return class or module of the method being called.

    class C; def foo; end; end
    trace = TracePoint.new(:call) do |tp|
      p tp.defined_class #=> C
    end.enable do
      C.new.foo
    end

If method is defined by a module, then that module is returned.

    module M; def foo; end; end
    class C; include M; end;
    trace = TracePoint.new(:call) do |tp|
      p tp.defined_class #=> M
    end.enable do
      C.new.foo
    end

**Note:** #defined_class returns singleton class.

6th block parameter of Kernel#set_trace_func passes original class of attached
by singleton class.

**This is a difference between Kernel#set_trace_func and TracePoint.**

    class C; def self.foo; end; end
    trace = TracePoint.new(:call) do |tp|
      p tp.defined_class #=> #<Class:C>
    end.enable do
      C.foo
    end

;T;0;;;I"defined_class;F;I"TracePoint;T;[o;;I" ;F;I"Module;To;;I"mDeactivates the trace

Return true if trace was enabled. Return false if trace was disabled.

    trace.enabled?      #=> true
    trace.disable       #=> true (previous status)
    trace.enabled?      #=> false
    trace.disable       #=> false

If a block is given, the trace will only be disable within the scope of the
block.

    trace.enabled?
    #=> true

    trace.disable do
        trace.enabled?
        # only disabled for this block
    end

    trace.enabled?
    #=> true

Note: You cannot access event hooks within the block.

    trace.disable { p tp.lineno }
    #=> RuntimeError: access from outside

;T;0;;;I"disable;F;I"TracePoint;T;[o;;I" ;F;I"	bool;To;;I" ;F;I"	void;To;;I"‘Activates the trace.

Returns `true` if trace was enabled. Returns `false` if trace was disabled.

    trace.enabled?  #=> false
    trace.enable    #=> false (previous state)
                    #   trace is enabled
    trace.enabled?  #=> true
    trace.enable    #=> true (previous state)
                    #   trace is still enabled

If a block is given, the trace will only be enabled within the scope of the
block.

    trace.enabled?
    #=> false

    trace.enable do
      trace.enabled?
      # only enabled for this block
    end

    trace.enabled?
    #=> false

`target`, `target_line` and `target_thread` parameters are used to limit
tracing only to specified code objects. `target` should be a code object for
which RubyVM::InstructionSequence.of will return an instruction sequence.

    t = TracePoint.new(:line) { |tp| p tp }

    def m1
      p 1
    end

    def m2
      p 2
    end

    t.enable(target: method(:m1))

    m1
    # prints #<TracePoint:line test.rb:4 in `m1'>
    m2
    # prints nothing

Note: You cannot access event hooks within the `enable` block.

    trace.enable { p tp.lineno }
    #=> RuntimeError: access from outside

;T;0;;;I"enable;F;I"TracePoint;T;[o;;I"i?target: (::Method | ::UnboundMethod | ::Proc)?, ?target_line: ::Integer?, ?target_thread: ::Thread?;T;I"	bool;To;;I"i?target: (::Method | ::UnboundMethod | ::Proc)?, ?target_line: ::Integer?, ?target_thread: ::Thread?;T;I"R;Fo;;I"&The current status of the trace

;T;0;;;I"enabled?;F;I"TracePoint;T;[o;;I" ;F;I"	bool;To;;I"AType of event

See TracePoint@Events for more information.

;T;0;;;I"
event;F;I"TracePoint;T;[o;;I" ;F;I"Symbol;To;;I"EReturn a string containing a human-readable TracePoint status.

;T;0;;;I"inspect;F;I"TracePoint;T;[o;;I" ;F;I"String;To;;I"Line number of the event

;T;0;;;I"lineno;F;I"TracePoint;T;[o;;I" ;F;I"Integer;To;;I"CReturn the name at the definition of the method being called

;T;0;;;I"method_id;F;I"TracePoint;T;[o;;I" ;F;I"Symbol;To;;I"!Path of the file being run

;T;0;;;I"	path;F;I"TracePoint;T;[o;;I" ;F;I"String;To;;I"‡Return the parameters definition of the method or block that the current hook
belongs to. Format is the same as for Method#parameters

;T;0;;;I"parameters;F;I"TracePoint;T;[o;;I" ;F;I"iArray[[ :req | :opt | :rest | :keyreq | :key | :keyrest | :block, ::Symbol ] | [ :rest | :keyrest ]];To;;I"8Value from exception raised on the `:raise` event

;T;0;;;I"raised_exception;F;I"TracePoint;T;[o;;I" ;F;I"untyped;To;;I"DReturn value from `:return`, `c_return`, and `b_return` event

;T;0;;;I"return_value;F;I"TracePoint;T;[o;;I" ;F;I"untyped;To;;I"½Return the trace object during event

Same as the following, except it returns the correct object (the method
receiver) for `c_call` and `c_return` events:

    trace.binding.eval('self')

;T;0;;;I"	self;F;I"TracePoint;T;[o;;I" ;F;I"untyped;To;;I"|Compiled source code (String) on *eval methods on the `:script_compiled`
event. If loaded from a file, it will return nil.

;T;0;;;I"eval_script;F;I"TracePoint;T;[o;;I" ;F;I"String?;To;;I"žCompiled instruction sequence represented by a RubyVM::InstructionSequence
instance on the `:script_compiled` event.

Note that this method is MRI specific.

;T;0;;;I"instruction_sequence;F;I"TracePoint;T;[o;;I" ;F;I" RubyVM::InstructionSequence;To; ;I"ÏThe global value `true` is the only instance of class TrueClass and represents
a logically true value in boolean expressions. The class provides operators
allowing `true` to be used in logical expressions.

;T;0;	I"TrueClass;T;
[ ;[ ;0;[ ;[ ;0;0o;;0;0;;;I"!;F;I"TrueClass;T;[o;;I" ;F;I"
false;Fo;;I"LAnd---Returns `false` if *obj* is `nil` or `false`, `true` otherwise.

;T;0;;;I"&;F;I"TrueClass;T;[o;;I"nil;T;I"
false;Fo;;I"
false;T;I"
false;Fo;;I"untyped obj;T;I"	true;Fo;;I"©Case Equality -- For class Object, effectively the same as calling `#==`, but
typically overridden by descendants to provide meaningful semantics in `case`
statements.

;T;0;;;I"===;F;I"TrueClass;T;[o;;I"	true;T;I"	true;Fo;;I"untyped obj;T;I"
false;Fo;;I"UExclusive Or---Returns `true` if *obj* is `nil` or `false`, `false` otherwise.

;T;0;;;I"^;F;I"TrueClass;T;[o;;I"nil;T;I"	true;Fo;;I"
false;T;I"	true;Fo;;I"untyped obj;T;I"
false;Fo;;I"5The string representation of `true` is "true".

;T;0;;;I"	to_s;F;I"TrueClass;T;[o;;I" ;F;I""true";To;;I"×Or---Returns `true`. As *obj* is an argument to a method call, it is always
evaluated; there is no short-circuit evaluation in this case.

    true |  puts("or")
    true || puts("logical or")

*produces:*

    or

;T;0;;;I"|;F;I"TrueClass;T;[o;;I"untyped obj;T;I"	true;Fo;;0;0;;;I"
clone;F;I"TrueClass;T;[o;;I"?freeze: true?;T;I"	self;To; ;0;0;	I"TrueClass;T;
[ ;[ ;0;[ ;[ ;0;0o;;I".Returns a JSON string for true: 'true'.

;T;0;;;I"to_json;F;I"TrueClass;T;[o;;I"?::JSON::State state;T;I"String;To; ;I"+Ruby supports two forms of objectified methods. Class Method is used to
represent methods that are associated with a particular object: these method
objects are bound to that object. Bound method objects for an object can be
created using Object#method.

Ruby also supports unbound methods; methods objects that are not associated
with a particular object. These can be created either by calling
Module#instance_method or by calling #unbind on a bound method object. The
result of both of these is an UnboundMethod object.

Unbound methods can only be called after they are bound to an object. That
object must be a kind_of? the method's original class.

    class Square
      def area
        @side * @side
      end
      def initialize(side)
        @side = side
      end
    end

    area_un = Square.instance_method(:area)

    s = Square.new(12)
    area = area_un.bind(s)
    area.call   #=> 144

Unbound methods are a reference to the method at the time it was objectified:
subsequent changes to the underlying class will not affect the unbound method.

    class Test
      def test
        :original
      end
    end
    um = Test.instance_method(:test)
    class Test
      def test
        :modified
      end
    end
    t = Test.new
    t.test            #=> :modified
    um.bind(t).call   #=> :original

;T;0;	I"UnboundMethod;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"µReturns a clone of this method.

    class A
      def foo
        return "bar"
      end
    end

    m = A.new.method(:foo)
    m.call # => "bar"
    n = m.clone.call # => "bar"

;T;0;;;I"
clone;F;I"UnboundMethod;T;[o;;I" ;F;I"	self;To;;I"<Returns an indication of the number of arguments accepted by a method. Returns
a nonnegative integer for methods that take a fixed number of arguments. For
Ruby methods that take a variable number of arguments, returns -n-1, where n
is the number of required arguments. Keyword arguments will be considered as a
single additional argument, that argument being mandatory if any keyword
argument is mandatory. For methods written in C, returns -1 if the call takes
a variable number of arguments.

    class C
      def one;    end
      def two(a); end
      def three(*a);  end
      def four(a, b); end
      def five(a, b, *c);    end
      def six(a, b, *c, &d); end
      def seven(a, b, x:0); end
      def eight(x:, y:); end
      def nine(x:, y:, **z); end
      def ten(*a, x:, y:); end
    end
    c = C.new
    c.method(:one).arity     #=> 0
    c.method(:two).arity     #=> 1
    c.method(:three).arity   #=> -1
    c.method(:four).arity    #=> 2
    c.method(:five).arity    #=> -3
    c.method(:six).arity     #=> -3
    c.method(:seven).arity   #=> -3
    c.method(:eight).arity   #=> 1
    c.method(:nine).arity    #=> 1
    c.method(:ten).arity     #=> -2

    "cat".method(:size).arity      #=> 0
    "cat".method(:replace).arity   #=> 1
    "cat".method(:squeeze).arity   #=> -1
    "cat".method(:count).arity     #=> -1

;T;0;;;I"
arity;F;I"UnboundMethod;T;[o;;I" ;F;I"Integer;To;;I"-Bind *umeth* to *obj*. If Klass was the class from which *umeth* was obtained,
`obj.kind_of?(Klass)` must be true.

    class A
      def test
        puts "In test, class = #{self.class}"
      end
    end
    class B < A
    end
    class C < B
    end

    um = B.instance_method(:test)
    bm = um.bind(C.new)
    bm.call
    bm = um.bind(B.new)
    bm.call
    bm = um.bind(A.new)
    bm.call

*produces:*

    In test, class = C
    In test, class = B
    prog.rb:16:in `bind': bind argument must be an instance of B (TypeError)
     from prog.rb:16

;T;0;;;I"	bind;F;I"UnboundMethod;T;[o;;I"untyped obj;T;I"Method;To;;I"&Returns the name of the method.

;T;0;;;I"	name;F;I"UnboundMethod;T;[o;;I" ;F;I"Symbol;To;;I"~Returns the class or module that defines the method. See also Method#receiver.

    (1..3).method(:map).owner #=> Enumerable

;T;0;;;I"
owner;F;I"UnboundMethod;T;[o;;I" ;F;I"Module;To;;I"ÞReturns the parameter information of this method.

    def foo(bar); end
    method(:foo).parameters #=> [[:req, :bar]]

    def foo(bar, baz, bat, &blk); end
    method(:foo).parameters #=> [[:req, :bar], [:req, :baz], [:req, :bat], [:block, :blk]]

    def foo(bar, *args); end
    method(:foo).parameters #=> [[:req, :bar], [:rest, :args]]

    def foo(bar, baz, *args, &blk); end
    method(:foo).parameters #=> [[:req, :bar], [:req, :baz], [:rest, :args], [:block, :blk]]

;T;0;;;I"parameters;F;I"UnboundMethod;T;[o;;I" ;F;I""Array[[ ::Symbol, ::Symbol ]];To;;I" ;F;I"Array[[ ::Symbol ]];To;;I"-Returns whether the method is private.

;T;0;;;I"private?;F;I"UnboundMethod;T;[o;;I" ;F;I"	bool;To;;I"/Returns whether the method is protected.

;T;0;;;I"protected?;F;I"UnboundMethod;T;[o;;I" ;F;I"	bool;To;;I",Returns whether the method is public.

;T;0;;;I"public?;F;I"UnboundMethod;T;[o;;I" ;F;I"	bool;To;;I"†Returns the Ruby source filename and line number containing this method or nil
if this method was not defined in Ruby (i.e. native).

;T;0;;;I"source_location;F;I"UnboundMethod;T;[o;;I" ;F;I"[ ::String, ::Integer ]?;To;;I"zReturns a Method of superclass which would be called when super is used or nil
if there is no method on superclass.

;T;0;;;I"super_method;F;I"UnboundMethod;T;[o;;I" ;F;I"UnboundMethod?;To;;I"šReturns the original name of the method.

    class C
      def foo; end
      alias bar foo
    end
    C.instance_method(:bar).original_name # => :foo

;T;0;;;I"original_name;F;I"UnboundMethod;T;[o;;I" ;F;I"Symbol;To;;I"™Bind *umeth* to *recv* and then invokes the method with the specified
arguments. This is semantically equivalent to `umeth.bind(recv).call(args,
...)`.

;T;0;;;I"bind_call;F;I"UnboundMethod;T;[o;;I" untyped recv, *untyped args;T;I"untyped;To;;I"5The Warning module contains a single method named #warn, and the module
extends itself, making Warning.warn available. Warning.warn is called for all
warnings issued by Ruby. By default, warnings are printed to $stderr.

Changing the behavior of Warning.warn is useful to customize how warnings are
handled by Ruby, for instance by filtering some warnings, and/or outputting
warnings somewhere other than $stderr.

If you want to change the behavior of Warning.warn you should use
+Warning.extend(MyNewModuleWithWarnMethod)+ and you can use `super` to get the
default behavior of printing the warning to $stderr.

Example:
    module MyWarningFilter
      def warn(message, category: nil, **kwargs)
        if /some warning I want to ignore/.match?(message)
          # ignore
        else
          super
        end
      end
    end
    Warning.extend MyWarningFilter

You should never redefine Warning#warn (the instance method), as that will
then no longer provide a way to use the default behavior.

The `warning` gem provides convenient ways to customize Warning.warn.

;T;0;	I"Warning;T;
[ ;[ ;0;[ ;[ o;;I"ÙWrites warning message `msg` to $stderr. This method is called by Ruby for all
emitted warnings. A `category` may be included with the warning.

See the documentation of the Warning module for how to customize this.

;T;0;;;I"	warn;F;I"Warning;T;[o;;I"::String;T;I"nil;To;;I"[Calculates the set of unambiguous abbreviations for a given set of strings.

    require 'abbrev'
    require 'pp'

    pp Abbrev.abbrev(['ruby'])
    #=>  {"ruby"=>"ruby", "rub"=>"ruby", "ru"=>"ruby", "r"=>"ruby"}

    pp Abbrev.abbrev(%w{ ruby rules })

*Generates:*
    { "ruby"  =>  "ruby",
      "rub"   =>  "ruby",
      "rules" =>  "rules",
      "rule"  =>  "rules",
      "rul"   =>  "rules" }

It also provides an array core extension, Array#abbrev.

    pp %w{ summer winter }.abbrev

*Generates:*
    { "summer"  => "summer",
      "summe"   => "summer",
      "summ"    => "summer",
      "sum"     => "summer",
      "su"      => "summer",
      "s"       => "summer",
      "winter"  => "winter",
      "winte"   => "winter",
      "wint"    => "winter",
      "win"     => "winter",
      "wi"      => "winter",
      "w"       => "winter" }

;T;0;	I"Abbrev;T;
[ ;[ ;0;[ ;[ o;;I"MGiven a set of strings, calculate the set of unambiguous abbreviations for
those strings, and return a hash where the keys are all the possible
abbreviations and the values are the full strings.

Thus, given `words` is "car" and "cone", the keys pointing to "car" would be
"ca" and "car", while those pointing to "cone" would be "co", "con", and
"cone".

    require 'abbrev'

    Abbrev.abbrev(%w{ car cone })
    #=> {"ca"=>"car", "con"=>"cone", "co"=>"cone", "car"=>"car", "cone"=>"cone"}

The optional `pattern` parameter is a pattern or a string. Only input strings
that match the pattern or start with the string are included in the output
hash.

    Abbrev.abbrev(%w{car box cone crab}, /b/)
    #=> {"box"=>"box", "bo"=>"box", "b"=>"box", "crab" => "crab"}

    Abbrev.abbrev(%w{car box cone}, 'ca')
    #=> {"car"=>"car", "ca"=>"car"}

;T;0;;;I"abbrev;F;I"Abbrev;T;[o;;I"2::Array[::String], ?::String | ::Regexp | nil;T;I"Hash[::String, ::String];To;;I"GThe Base64 module provides for the encoding (#encode64, #strict_encode64,
#urlsafe_encode64) and decoding (#decode64, #strict_decode64,
#urlsafe_decode64) of binary data using a Base64 representation.

## Example

A simple encoding and decoding.

    require "base64"

    enc   = Base64.encode64('Send reinforcements')
                        # -> "U2VuZCByZWluZm9yY2VtZW50cw==\n"
    plain = Base64.decode64(enc)
                        # -> "Send reinforcements"

The purpose of using base64 to encode data is that it translates any binary
data into purely printable characters.

;T;0;	I"Base64;T;
[ ;[ ;0;[ ;[ o;;I"œReturns the Base64-decoded version of `str`. This method complies with RFC
2045. Characters outside the base alphabet are ignored.

    require 'base64'
    str = 'VGhpcyBpcyBsaW5lIG9uZQpUaGlzIG' +
          'lzIGxpbmUgdHdvClRoaXMgaXMgbGlu' +
          'ZSB0aHJlZQpBbmQgc28gb24uLi4K'
    puts Base64.decode64(str)

*Generates:*

    This is line one
    This is line two
    This is line three
    And so on...

;T;0;;;I"decode64;F;I"Base64;T;[o;;I"::String str;T;I"String;To;;I"DReturns the Base64-encoded version of `bin`. This method complies with RFC
2045. Line feeds are added to every 60 encoded characters.

    require 'base64'
    Base64.encode64("Now is the time for all good coders\nto learn Ruby")

*Generates:*

    Tm93IGlzIHRoZSB0aW1lIGZvciBhbGwgZ29vZCBjb2RlcnMKdG8gbGVhcm4g
    UnVieQ==

;T;0;;;I"encode64;F;I"Base64;T;[o;;I"::String bin;T;I"String;To;;I"ÕReturns the Base64-decoded version of `str`. This method complies with RFC
4648. ArgumentError is raised if `str` is incorrectly padded or contains
non-alphabet characters.  Note that CR or LF are also rejected.

;T;0;;;I"strict_decode64;F;I"Base64;T;[o;;I"::String str;T;I"String;To;;I"pReturns the Base64-encoded version of `bin`. This method complies with RFC
4648. No line feeds are added.

;T;0;;;I"strict_encode64;F;I"Base64;T;[o;;I"::String bin;T;I"String;To;;I"bReturns the Base64-decoded version of `str`. This method complies with ``Base
64 Encoding with URL and Filename Safe Alphabet'' in RFC 4648. The alphabet
uses '-' instead of '+' and '_' instead of '/'.

The padding character is optional. This method accepts both correctly-padded
and unpadded input. Note that it still rejects incorrectly-padded input.

;T;0;;;I"urlsafe_decode64;F;I"Base64;T;[o;;I"::String str;T;I"String;To;;I"1Returns the Base64-encoded version of `bin`. This method complies with ``Base
64 Encoding with URL and Filename Safe Alphabet'' in RFC 4648. The alphabet
uses '-' instead of '+' and '_' instead of '/'. Note that the result can still
contain '='. You can remove the padding by setting `padding` as false.

;T;0;;;I"urlsafe_encode64;F;I"Base64;T;[o;;I"&::String bin, ?padding: ::boolish;T;I"String;To;;I"ÜThe Benchmark module provides methods to measure and report the time used to
execute Ruby code.

*   Measure the time to construct the string given by the expression
    `"a"*1_000_000_000`:

        require 'benchmark'

        puts Benchmark.measure { "a"*1_000_000_000 }

    On my machine (OSX 10.8.3 on i5 1.7 GHz) this generates:

        0.350000   0.400000   0.750000 (  0.835234)

    This report shows the user CPU time, system CPU time, the sum of the user
    and system CPU times, and the elapsed real time. The unit of time is
    seconds.

*   Do some experiments sequentially using the #bm method:

        require 'benchmark'

        n = 5000000
        Benchmark.bm do |x|
          x.report { for i in 1..n; a = "1"; end }
          x.report { n.times do   ; a = "1"; end }
          x.report { 1.upto(n) do ; a = "1"; end }
        end

    The result:

            user     system      total        real
        1.010000   0.000000   1.010000 (  1.014479)
        1.000000   0.000000   1.000000 (  0.998261)
        0.980000   0.000000   0.980000 (  0.981335)

*   Continuing the previous example, put a label in each report:

        require 'benchmark'

        n = 5000000
        Benchmark.bm(7) do |x|
          x.report("for:")   { for i in 1..n; a = "1"; end }
          x.report("times:") { n.times do   ; a = "1"; end }
          x.report("upto:")  { 1.upto(n) do ; a = "1"; end }
        end


The result:

                  user     system      total        real
    for:      1.010000   0.000000   1.010000 (  1.015688)
    times:    1.000000   0.000000   1.000000 (  1.003611)
    upto:     1.030000   0.000000   1.030000 (  1.028098)

*   The times for some benchmarks depend on the order in which items are run.
    These differences are due to the cost of memory allocation and garbage
    collection. To avoid these discrepancies, the #bmbm method is provided.
    For example, to compare ways to sort an array of floats:

        require 'benchmark'

        array = (1..1000000).map { rand }

        Benchmark.bmbm do |x|
          x.report("sort!") { array.dup.sort! }
          x.report("sort")  { array.dup.sort  }
        end

    The result:

        Rehearsal -----------------------------------------
        sort!   1.490000   0.010000   1.500000 (  1.490520)
        sort    1.460000   0.000000   1.460000 (  1.463025)
        -------------------------------- total: 2.960000sec

                    user     system      total        real
        sort!   1.460000   0.000000   1.460000 (  1.460465)
        sort    1.450000   0.010000   1.460000 (  1.448327)

*   Report statistics of sequential experiments with unique labels, using the
    #benchmark method:

        require 'benchmark'
        include Benchmark         # we need the CAPTION and FORMAT constants

        n = 5000000
        Benchmark.benchmark(CAPTION, 7, FORMAT, ">total:", ">avg:") do |x|
          tf = x.report("for:")   { for i in 1..n; a = "1"; end }
          tt = x.report("times:") { n.times do   ; a = "1"; end }
          tu = x.report("upto:")  { 1.upto(n) do ; a = "1"; end }
          [tf+tt+tu, (tf+tt+tu)/3]
        end

    The result:

                     user     system      total        real
        for:      0.950000   0.000000   0.950000 (  0.952039)
        times:    0.980000   0.000000   0.980000 (  0.984938)
        upto:     0.950000   0.000000   0.950000 (  0.946787)
        >total:   2.880000   0.000000   2.880000 (  2.883764)
        >avg:     0.960000   0.000000   0.960000 (  0.961255)

;T;0;	I"Benchmark;T;
[ ;[ ;0;[ ;[ o;;I"GInvokes the block with a Benchmark::Report object, which may be used to
collect and report on the results of individual benchmark tests. Reserves
`label_width` leading spaces for labels on each line. Prints `caption` at the
top of the report, and uses `format` to format each line. (Note: `caption`
must contain a terminating newline character, see the default
Benchmark::Tms::CAPTION for an example.)

Returns an array of Benchmark::Tms objects.

If the block returns an array of Benchmark::Tms objects, these will be used to
format additional lines of output. If `labels` parameter are given, these are
used to label these extra lines.

*Note*: Other methods provide a simpler interface to this one, and are
suitable for nearly all benchmarking requirements.  See the examples in
Benchmark, and the #bm and #bmbm methods.

Example:

    require 'benchmark'
    include Benchmark          # we need the CAPTION and FORMAT constants

    n = 5000000
    Benchmark.benchmark(CAPTION, 7, FORMAT, ">total:", ">avg:") do |x|
      tf = x.report("for:")   { for i in 1..n; a = "1"; end }
      tt = x.report("times:") { n.times do   ; a = "1"; end }
      tu = x.report("upto:")  { 1.upto(n) do ; a = "1"; end }
      [tf+tt+tu, (tf+tt+tu)/3]
    end

Generates:

                  user     system      total        real
    for:      0.970000   0.000000   0.970000 (  0.970493)
    times:    0.990000   0.000000   0.990000 (  0.989542)
    upto:     0.970000   0.000000   0.970000 (  0.972854)
    >total:   2.930000   0.000000   2.930000 (  2.932889)
    >avg:     0.976667   0.000000   0.976667 (  0.977630)

;T;0;;;I"benchmark;F;I"Benchmark;T;[o;;I"S::String caption, ?::Integer? label_width, ?::String? format, *::String labels;T;I"Array[::Benchmark::Tms];To;;I"—A simple interface to the #benchmark method, #bm generates sequential reports
with labels. `label_width` and `labels` parameters have the same meaning as
for #benchmark.

    require 'benchmark'

    n = 5000000
    Benchmark.bm(7) do |x|
      x.report("for:")   { for i in 1..n; a = "1"; end }
      x.report("times:") { n.times do   ; a = "1"; end }
      x.report("upto:")  { 1.upto(n) do ; a = "1"; end }
    end

Generates:

                  user     system      total        real
    for:      0.960000   0.000000   0.960000 (  0.957966)
    times:    0.960000   0.000000   0.960000 (  0.960423)
    upto:     0.950000   0.000000   0.950000 (  0.954864)

;T;0;;;I"bm;F;I"Benchmark;T;[o;;I"-?::Integer label_width, *::String labels;T;I"Array[::Benchmark::Tms];To;;I"ISometimes benchmark results are skewed because code executed earlier
encounters different garbage collection overheads than that run later. #bmbm
attempts to minimize this effect by running the tests twice, the first time as
a rehearsal in order to get the runtime environment stable, the second time
for real. GC.start is executed before the start of each of the real timings;
the cost of this is not included in the timings. In reality, though, there's
only so much that #bmbm can do, and the results are not guaranteed to be
isolated from garbage collection and other effects.

Because #bmbm takes two passes through the tests, it can calculate the
required label width.

    require 'benchmark'

    array = (1..1000000).map { rand }

    Benchmark.bmbm do |x|
      x.report("sort!") { array.dup.sort! }
      x.report("sort")  { array.dup.sort  }
    end

Generates:

    Rehearsal -----------------------------------------
    sort!   1.440000   0.010000   1.450000 (  1.446833)
    sort    1.440000   0.000000   1.440000 (  1.448257)
    -------------------------------- total: 2.890000sec

                user     system      total        real
    sort!   1.460000   0.000000   1.460000 (  1.458065)
    sort    1.450000   0.000000   1.450000 (  1.455963)

#bmbm yields a Benchmark::Job object and returns an array of Benchmark::Tms
objects.

;T;0;;;I"	bmbm;F;I"Benchmark;T;[o;;I"?::Integer width;T;I"Array[::Benchmark::Tms];To;;I"Returns the time used to execute the given block as a Benchmark::Tms object.
Takes `label` option.

    require 'benchmark'

    n = 1000000

    time = Benchmark.measure do
      n.times { a = "1" }
    end
    puts time

Generates:

    0.220000   0.000000   0.220000 (  0.227313)

;T;0;;;I"measure;F;I"Benchmark;T;[o;;I"?::String label;T;I"Benchmark::Tms;To;;I"EReturns the elapsed real time used to execute the given block.

;T;0;;;I"realtime;F;I"Benchmark;T;[o;;I" ;F;I"
Float;To; ;0;0;	I"Benchmark::Job;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"yPrints the `label` and measured time for the block,
formatted by `format`. See Tms#format for the
formatting rules.
;T;0;;;I"	item;F;I"Benchmark::Job;T;[o;;I"?::String label;T;I"	self;To;;I"HAn array of 2-element arrays, consisting of label and block pairs.
;T;0;;;I"	list;F;I"Benchmark::Job;T;[o;;I" ;F;I"Array[untyped];To;;I".Length of the widest label in the #list.
;T;0;;;I"
width;F;I"Benchmark::Job;T;[o;;I" ;F;I"Integer;To; ;0;0;	I"Benchmark::Report;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"yPrints the `label` and measured time for the block,
formatted by `format`. See Tms#format for the
formatting rules.
;T;0;;;I"	item;F;I"Benchmark::Report;T;[o;;I"%?::String label, *untyped format;T;I"Benchmark::Tms;To;;I"@An array of Benchmark::Tms objects representing each item.
;T;0;;;I"	list;F;I"Benchmark::Report;T;[o;;I" ;F;I"Array[::Benchmark::Tms];To; ;I"UA data object, representing the times associated with a benchmark measurement.

;T;0;	I"Benchmark::Tms;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"yReturns a new Tms object obtained by memberwise multiplication of the
individual times for this Tms object by `x`.

;T;0;;;I"*;F;I"Benchmark::Tms;T;[o;;I"untyped x;T;I"untyped;To;;I"ÄReturns a new Tms object obtained by memberwise summation of the individual
times for this Tms object with those of the `other` Tms object. This method
and #/() are useful for taking statistics.

;T;0;;;I"+;F;I"Benchmark::Tms;T;[o;;I"untyped other;T;I"untyped;To;;I"Returns a new Tms object obtained by memberwise subtraction of the individual
times for the `other` Tms object from those of this Tms object.

;T;0;;;I"-;F;I"Benchmark::Tms;T;[o;;I"untyped other;T;I"untyped;To;;I"¥Returns a new Tms object obtained by memberwise division of the individual
times for this Tms object by `x`. This method and #+() are useful for taking
statistics.

;T;0;;;I"/;F;I"Benchmark::Tms;T;[o;;I"untyped x;T;I"untyped;To;;I"ŽReturns a new Tms object whose times are the sum of the times for this Tms
object, plus the time required to execute the code block (`blk`).

;T;0;;;I"add;F;I"Benchmark::Tms;T;[o;;I" ;F;I"untyped;To;;I"´An in-place version of #add. Changes the times of this Tms object by making it
the sum of the times for this Tms object, plus the time required to execute
the code block (`blk`).

;T;0;;;I"	add!;F;I"Benchmark::Tms;T;[o;;I" ;F;I"untyped;To;;I""System CPU time of children

;T;0;;;I"cstime;F;I"Benchmark::Tms;T;[o;;I" ;F;I"
Float;To;;I" User CPU time of children

;T;0;;;I"cutime;F;I"Benchmark::Tms;T;[o;;I" ;F;I"
Float;To;;I"KReturns the contents of this Tms object as a formatted string, according to a
`format` string like that passed to Kernel.format. In addition, #format
accepts the following extensions:

`%u`
:   Replaced by the user CPU time, as reported by Tms#utime.
`%y`
:   Replaced by the system CPU time, as reported by #stime (Mnemonic: y of
    "s*y*stem")
`%U`
:   Replaced by the children's user CPU time, as reported by Tms#cutime
`%Y`
:   Replaced by the children's system CPU time, as reported by Tms#cstime
`%t`
:   Replaced by the total CPU time, as reported by Tms#total
`%r`
:   Replaced by the elapsed real time, as reported by Tms#real
`%n`
:   Replaced by the label string, as reported by Tms#label (Mnemonic: n of
    "*n*ame")


If `format` is not given, FORMAT is used as default value, detailing the user,
system and real elapsed time.

;T;0;;;I"format;F;I"Benchmark::Tms;T;[o;;I"$?::String format, *untyped args;T;I"String;To;;I"Label

;T;0;;;I"
label;F;I"Benchmark::Tms;T;[o;;I" ;F;I"String;To;;I"Elapsed real time

;T;0;;;I"	real;F;I"Benchmark::Tms;T;[o;;I" ;F;I"
Float;To;;I"System CPU time

;T;0;;;I"
stime;F;I"Benchmark::Tms;T;[o;;I" ;F;I"
Float;To;;I"¥Returns a new 6-element array, consisting of the label, user CPU time, system
CPU time, children's user CPU time, children's system CPU time and elapsed
real time.

;T;0;;;I"	to_a;F;I"Benchmark::Tms;T;[o;;I" ;F;I"untyped;To;;I"Same as #format.

;T;0;;;I"	to_s;F;I"Benchmark::Tms;T;[o;;I" ;F;I"String;To;;I"BTotal time, that is `utime` + `stime` + `cutime` + `cstime`

;T;0;;;I"
total;F;I"Benchmark::Tms;T;[o;;I" ;F;I"
Float;To;;I"User CPU time

;T;0;;;I"
utime;F;I"Benchmark::Tms;T;[o;;I" ;F;I"
Float;To; ;I"ùBigDecimal provides arbitrary-precision floating point decimal arithmetic.

## Introduction

Ruby provides built-in support for arbitrary precision integer arithmetic.

For example:

    42**13  #=>   1265437718438866624512

BigDecimal provides similar support for very large or very accurate floating
point numbers.

Decimal arithmetic is also useful for general calculation, because it provides
the correct answers people expect--whereas normal binary floating point
arithmetic often introduces subtle errors because of the conversion between
base 10 and base 2.

For example, try:

    sum = 0
    10_000.times do
      sum = sum + 0.0001
    end
    print sum #=> 0.9999999999999062

and contrast with the output from:

    require 'bigdecimal'

    sum = BigDecimal("0")
    10_000.times do
      sum = sum + BigDecimal("0.0001")
    end
    print sum #=> 0.1E1

Similarly:

    (BigDecimal("1.2") - BigDecimal("1.0")) == BigDecimal("0.2") #=> true

    (1.2 - 1.0) == 0.2 #=> false

## A Note About Precision

For a calculation using a BigDecimal and another `value`, the precision of the
result depends on the type of `value`:

*   If `value` is a Float, the precision is Float::DIG + 1.
*   If `value` is a Rational, the precision is larger than Float::DIG + 1.
*   If `value` is a BigDecimal, the precision is `value`'s precision in the
    internal representation, which is platform-dependent.
*   If `value` is other object, the precision is determined by the result of
    +BigDecimal(value)+.


## Special features of accurate decimal arithmetic

Because BigDecimal is more accurate than normal binary floating point
arithmetic, it requires some special values.

### Infinity

BigDecimal sometimes needs to return infinity, for example if you divide a
value by zero.

    BigDecimal("1.0") / BigDecimal("0.0")  #=> Infinity
    BigDecimal("-1.0") / BigDecimal("0.0")  #=> -Infinity

You can represent infinite numbers to BigDecimal using the strings
`'Infinity'`, `'+Infinity'` and `'-Infinity'` (case-sensitive)

### Not a Number

When a computation results in an undefined value, the special value `NaN` (for
'not a number') is returned.

Example:

    BigDecimal("0.0") / BigDecimal("0.0") #=> NaN

You can also create undefined values.

NaN is never considered to be the same as any other value, even NaN itself:

    n = BigDecimal('NaN')
    n == 0.0 #=> false
    n == n #=> false

### Positive and negative zero

If a computation results in a value which is too small to be represented as a
BigDecimal within the currently specified limits of precision, zero must be
returned.

If the value which is too small to be represented is negative, a BigDecimal
value of negative zero is returned.

    BigDecimal("1.0") / BigDecimal("-Infinity") #=> -0.0

If the value is positive, a value of positive zero is returned.

    BigDecimal("1.0") / BigDecimal("Infinity") #=> 0.0

(See BigDecimal.mode for how to specify limits of precision.)

Note that `-0.0` and `0.0` are considered to be the same for the purposes of
comparison.

Note also that in mathematics, there is no particular concept of negative or
positive zero; true mathematical zero has no sign.

## bigdecimal/util

When you require `bigdecimal/util`, the #to_d method will be available on
BigDecimal and the native Integer, Float, Rational, and String classes:

    require 'bigdecimal/util'

    42.to_d         # => 0.42e2
    0.5.to_d        # => 0.5e0
    (2/3r).to_d(3)  # => 0.667e0
    "0.5".to_d      # => 0.5e0

## License

Copyright (C) 2002 by Shigeo Kobayashi <shigeo@tinyforest.gr.jp>.

BigDecimal is released under the Ruby and 2-clause BSD licenses. See
LICENSE.txt for details.

Maintained by mrkn <mrkn@mrkn.jp> and ruby-core members.

Documented by zzak <zachary@zacharyscott.net>, mathew <meta@pobox.com>, and
many other contributors.

;T;0;	I"BigDecimal;T;
[ ;[ ;0;[ ;[ ;0;I"Numeric;To;;I"SInternal method used to provide marshalling support. See the Marshal module.

;T;0;;;I"
_load;F;I"BigDecimal;T;[o;;I"::String;T;I"BigDecimal;To;;I"„Returns the number of digits a Float object is allowed to have; the result is
system-dependent:

    BigDecimal.double_fig # => 16

;T;0;;;I"double_fig;F;I"BigDecimal;T;[o;;I" ;F;I"Integer;To;;I" ;T;0;;;I"interpret_loosely;F;I"BigDecimal;T;[o;;I"::string;T;I"BigDecimal;To;;I"iLimit the number of significant digits in newly created BigDecimal numbers to
the specified value. Rounding is performed as necessary, as specified by
BigDecimal.mode.

A limit of 0, the default, means no upper limit.

The limit specified by this method takes less priority over any limit
specified to instance methods such as ceil, floor, truncate, or round.

;T;0;;;I"
limit;F;I"BigDecimal;T;[o;;I"?::Integer? digits;T;I"Integer;To;;I"çReturns an integer representing the mode settings for exception handling and
rounding.

These modes control exception handling:

*   BigDecimal::EXCEPTION_NaN.
*   BigDecimal::EXCEPTION_INFINITY.
*   BigDecimal::EXCEPTION_UNDERFLOW.
*   BigDecimal::EXCEPTION_OVERFLOW.
*   BigDecimal::EXCEPTION_ZERODIVIDE.
*   BigDecimal::EXCEPTION_ALL.


Values for `setting` for exception handling:

*   `true`: sets the given `mode` to `true`.
*   `false`: sets the given `mode` to `false`.
*   `nil`: does not modify the mode settings.


You can use method BigDecimal.save_exception_mode to temporarily change, and
then automatically restore, exception modes.

For clarity, some examples below begin by setting all exception modes to
`false`.

This mode controls the way rounding is to be performed:

*   BigDecimal::ROUND_MODE


You can use method BigDecimal.save_rounding_mode to temporarily change, and
then automatically restore, the rounding mode.

**NaNs**

Mode BigDecimal::EXCEPTION_NaN controls behavior when a BigDecimal NaN is
created.

Settings:

*   `false` (default): Returns `BigDecimal('NaN')`.
*   `true`: Raises FloatDomainError.


Examples:

    BigDecimal.mode(BigDecimal::EXCEPTION_ALL, false) # => 0
    BigDecimal('NaN')                                 # => NaN
    BigDecimal.mode(BigDecimal::EXCEPTION_NaN, true)  # => 2
    BigDecimal('NaN') # Raises FloatDomainError

**Infinities**

Mode BigDecimal::EXCEPTION_INFINITY controls behavior when a BigDecimal
Infinity or -Infinity is created. Settings:

*   `false` (default): Returns `BigDecimal('Infinity')` or
    `BigDecimal('-Infinity')`.
*   `true`: Raises FloatDomainError.


Examples:

    BigDecimal.mode(BigDecimal::EXCEPTION_ALL, false)     # => 0
    BigDecimal('Infinity')                                # => Infinity
    BigDecimal('-Infinity')                               # => -Infinity
    BigDecimal.mode(BigDecimal::EXCEPTION_INFINITY, true) # => 1
    BigDecimal('Infinity')  # Raises FloatDomainError
    BigDecimal('-Infinity') # Raises FloatDomainError

**Underflow**

Mode BigDecimal::EXCEPTION_UNDERFLOW controls behavior when a BigDecimal
underflow occurs. Settings:

*   `false` (default): Returns `BigDecimal('0')` or `BigDecimal('-Infinity')`.
*   `true`: Raises FloatDomainError.


Examples:

    BigDecimal.mode(BigDecimal::EXCEPTION_ALL, false)      # => 0
    def flow_under
      x = BigDecimal('0.1')
      100.times { x *= x }
    end
    flow_under                                             # => 100
    BigDecimal.mode(BigDecimal::EXCEPTION_UNDERFLOW, true) # => 4
    flow_under # Raises FloatDomainError

**Overflow**

Mode BigDecimal::EXCEPTION_OVERFLOW controls behavior when a BigDecimal
overflow occurs. Settings:

*   `false` (default): Returns `BigDecimal('Infinity')` or
    `BigDecimal('-Infinity')`.
*   `true`: Raises FloatDomainError.


Examples:

    BigDecimal.mode(BigDecimal::EXCEPTION_ALL, false)     # => 0
    def flow_over
      x = BigDecimal('10')
      100.times { x *= x }
    end
    flow_over                                             # => 100
    BigDecimal.mode(BigDecimal::EXCEPTION_OVERFLOW, true) # => 1
    flow_over # Raises FloatDomainError

**Zero Division**

Mode BigDecimal::EXCEPTION_ZERODIVIDE controls behavior when a zero-division
occurs. Settings:

*   `false` (default): Returns `BigDecimal('Infinity')` or
    `BigDecimal('-Infinity')`.
*   `true`: Raises FloatDomainError.


Examples:

    BigDecimal.mode(BigDecimal::EXCEPTION_ALL, false)       # => 0
    one = BigDecimal('1')
    zero = BigDecimal('0')
    one / zero                                              # => Infinity
    BigDecimal.mode(BigDecimal::EXCEPTION_ZERODIVIDE, true) # => 16
    one / zero # Raises FloatDomainError

**All Exceptions**

Mode BigDecimal::EXCEPTION_ALL controls all of the above:

    BigDecimal.mode(BigDecimal::EXCEPTION_ALL, false) # => 0
    BigDecimal.mode(BigDecimal::EXCEPTION_ALL, true)  # => 23

**Rounding**

Mode BigDecimal::ROUND_MODE controls the way rounding is to be performed; its
`setting` values are:

*   `ROUND_UP`: Round away from zero. Aliased as `:up`.
*   `ROUND_DOWN`: Round toward zero. Aliased as `:down` and `:truncate`.
*   `ROUND_HALF_UP`: Round toward the nearest neighbor; if the neighbors are
    equidistant, round away from zero. Aliased as `:half_up` and `:default`.
*   `ROUND_HALF_DOWN`: Round toward the nearest neighbor; if the neighbors are
    equidistant, round toward zero. Aliased as `:half_down`.
*   `ROUND_HALF_EVEN` (Banker's rounding): Round toward the nearest neighbor;
    if the neighbors are equidistant, round toward the even neighbor. Aliased
    as `:half_even` and `:banker`.
*   `ROUND_CEILING`: Round toward positive infinity. Aliased as `:ceiling` and
    `:ceil`.
*   `ROUND_FLOOR`: Round toward negative infinity. Aliased as `:floor:`.

;T;0;;;I"	mode;F;I"BigDecimal;T;[o;;I"&::Integer mode, ?::Integer? value;T;I"Integer?;To;;I"˜Execute the provided block, but preserve the exception mode

    BigDecimal.save_exception_mode do
      BigDecimal.mode(BigDecimal::EXCEPTION_OVERFLOW, false)
      BigDecimal.mode(BigDecimal::EXCEPTION_NaN, false)

      BigDecimal(BigDecimal('Infinity'))
      BigDecimal(BigDecimal('-Infinity'))
      BigDecimal(BigDecimal('NaN'))
    end

For use with the BigDecimal::EXCEPTION_*

See BigDecimal.mode

;T;0;;;I"save_exception_mode;F;I"BigDecimal;T;[o;;I" ;F;I"	void;To;;I"îExecute the provided block, but preserve the precision limit

    BigDecimal.limit(100)
    puts BigDecimal.limit
    BigDecimal.save_limit do
        BigDecimal.limit(200)
        puts BigDecimal.limit
    end
    puts BigDecimal.limit

;T;0;;;I"save_limit;F;I"BigDecimal;T;[o;;I" ;F;I"	void;To;;I"Execute the provided block, but preserve the rounding mode

    BigDecimal.save_rounding_mode do
      BigDecimal.mode(BigDecimal::ROUND_MODE, :up)
      puts BigDecimal.mode(BigDecimal::ROUND_MODE)
    end

For use with the BigDecimal::ROUND_*

See BigDecimal.mode

;T;0;;;I"save_rounding_mode;F;I"BigDecimal;T;[o;;I" ;F;I"	void;To;;I"FReturns the modulus from dividing by b.

See BigDecimal#divmod.

;T;0;;;I"%;F;I"BigDecimal;T;[o;;I"::Numeric;T;I"BigDecimal;To;;I" ;T;0;;;I"*;F;I"BigDecimal;T;[o;;I"::Numeric;T;I"BigDecimal;To;;I"îReturns the BigDecimal value of `self` raised to power `other`:

    b = BigDecimal('3.14')
    b ** 2              # => 0.98596e1
    b ** 2.0            # => 0.98596e1
    b ** Rational(2, 1) # => 0.98596e1

Related: BigDecimal#power.

;T;0;;;I"**;F;I"BigDecimal;T;[o;;I"::Numeric;T;I"BigDecimal;To;;I"Returns the BigDecimal sum of `self` and `value`:

    b = BigDecimal('111111.111') # => 0.111111111e6
    b + 2                        # => 0.111113111e6
    b + 2.0                      # => 0.111113111e6
    b + Rational(2, 1)           # => 0.111113111e6
    b + Complex(2, 0)            # => (0.111113111e6+0i)

See the [Note About
Precision](BigDecimal.html#class-BigDecimal-label-A+Note+About+Precision).

;T;0;;;I"+;F;I"BigDecimal;T;[o;;I"::Numeric;T;I"BigDecimal;To;;I"VReturns `self`:

    +BigDecimal(5)  # => 0.5e1
    +BigDecimal(-5) # => -0.5e1

;T;0;;;I"+@;F;I"BigDecimal;T;[o;;I" ;F;I"BigDecimal;To;;I"¤Returns the BigDecimal difference of `self` and `value`:

    b = BigDecimal('333333.333') # => 0.333333333e6
    b - 2                        # => 0.333331333e6
    b - 2.0                      # => 0.333331333e6
    b - Rational(2, 1)           # => 0.333331333e6
    b - Complex(2, 0)            # => (0.333331333e6+0i)

See the [Note About
Precision](BigDecimal.html#class-BigDecimal-label-A+Note+About+Precision).

;T;0;;;I"-;F;I"BigDecimal;T;[o;;I"::Numeric;T;I"BigDecimal;To;;I"~Returns the BigDecimal negation of self:

    b0 = BigDecimal('1.5')
    b1 = -b0 # => -0.15e1
    b2 = -b1 # => 0.15e1

;T;0;;;I"-@;F;I"BigDecimal;T;[o;;I" ;F;I"BigDecimal;To;;I"­Divide by the specified value.

The result precision will be the precision of the larger operand, but its
minimum is 2*Float::DIG.

See BigDecimal#div. See BigDecimal#quo.

;T;0;;;I"/;F;I"BigDecimal;T;[o;;I"::Numeric;T;I"BigDecimal;To;;I"2Returns `true` if `self` is less than `other`, `false` otherwise:

    b = BigDecimal('1.5') # => 0.15e1
    b < 2                 # => true
    b < 2.0               # => true
    b < Rational(2, 1)    # => true
    b < 1.5               # => false

Raises an exception if the comparison cannot be made.

;T;0;;;I"<;F;I"BigDecimal;T;[o;;I"::Numeric;T;I"	bool;To;;I"bReturns `true` if `self` is less or equal to than `other`, `false` otherwise:

    b = BigDecimal('1.5') # => 0.15e1
    b <= 2                # => true
    b <= 2.0              # => true
    b <= Rational(2, 1)   # => true
    b <= 1.5              # => true
    b < 1                 # => false

Raises an exception if the comparison cannot be made.

;T;0;;;I"<=;F;I"BigDecimal;T;[o;;I"::Numeric;T;I"	bool;To;;I"PThe comparison operator. a <=> b is 0 if a == b, 1 if a > b, -1 if a < b.

;T;0;;;I"<=>;F;I"BigDecimal;T;[o;;I"untyped;T;I"Integer?;To;;I"öTests for value equality; returns true if the values are equal.

The == and === operators and the eql? method have the same implementation for
BigDecimal.

Values may be coerced to perform the comparison:

    BigDecimal('1.0') == 1.0  #=> true

;T;0;;;I"==;F;I"BigDecimal;T;[o;;I"untyped;T;I"	bool;To;;I"öTests for value equality; returns true if the values are equal.

The == and === operators and the eql? method have the same implementation for
BigDecimal.

Values may be coerced to perform the comparison:

    BigDecimal('1.0') == 1.0  #=> true

;T;0;;;I"===;F;I"BigDecimal;T;[o;;I"untyped;T;I"	bool;To;;I"Returns `true` if `self` is greater than `other`, `false` otherwise:

    b = BigDecimal('1.5')
    b > 1              # => true
    b > 1.0            # => true
    b > Rational(1, 1) # => true
    b > 2              # => false

Raises an exception if the comparison cannot be made.

;T;0;;;I">;F;I"BigDecimal;T;[o;;I"::Numeric;T;I"	bool;To;;I"OReturns `true` if `self` is greater than or equal to `other`, `false`
otherwise:

    b = BigDecimal('1.5')
    b >= 1              # => true
    b >= 1.0            # => true
    b >= Rational(1, 1) # => true
    b >= 1.5            # => true
    b > 2               # => false

Raises an exception if the comparison cannot be made.

;T;0;;;I">=;F;I"BigDecimal;T;[o;;I"::Numeric;T;I"	bool;To;;I"àReturns a string representing the marshalling of `self`. See module Marshal.

    inf = BigDecimal('Infinity') # => Infinity
    dumped = inf._dump           # => "9:Infinity"
    BigDecimal._load(dumped)     # => Infinity

;T;0;;;I"
_dump;F;I"BigDecimal;T;[o;;I"?untyped;T;I"String;To;;I"{Returns the BigDecimal absolute value of `self`:

    BigDecimal('5').abs  # => 0.5e1
    BigDecimal('-3').abs # => 0.3e1

;T;0;;;I"abs;F;I"BigDecimal;T;[o;;I" ;F;I"BigDecimal;To;;I"±Returns the BigDecimal sum of `self` and `value` with a precision of `ndigits`
decimal digits.

When `ndigits` is less than the number of significant digits in the sum, the
sum is rounded to that number of digits, according to the current rounding
mode; see BigDecimal.mode.

Examples:

    # Set the rounding mode.
    BigDecimal.mode(BigDecimal::ROUND_MODE, :half_up)
    b = BigDecimal('111111.111')
    b.add(1, 0)               # => 0.111112111e6
    b.add(1, 3)               # => 0.111e6
    b.add(1, 6)               # => 0.111112e6
    b.add(1, 15)              # => 0.111112111e6
    b.add(1.0, 15)            # => 0.111112111e6
    b.add(Rational(1, 1), 15) # => 0.111112111e6

;T;0;;;I"add;F;I"BigDecimal;T;[o;;I"&::Numeric value, ::Integer digits;T;I"BigDecimal;To;;I"ÔReturn the smallest integer greater than or equal to the value, as a
BigDecimal.

    BigDecimal('3.14159').ceil #=> 4
    BigDecimal('-9.1').ceil #=> -9

If n is specified and positive, the fractional part of the result has no more
than that many digits.

If n is specified and negative, at least that many digits to the left of the
decimal point will be 0 in the result.

    BigDecimal('3.14159').ceil(3) #=> 3.142
    BigDecimal('13345.234').ceil(-2) #=> 13400.0

;T;0;;;I"	ceil;F;I"BigDecimal;T;[o;;I" ;F;I"Integer;To;;I"::int n;T;I"BigDecimal;To;;I" ;T;0;;;I"
clone;F;I"BigDecimal;T;[o;;I" ;F;I"	self;To;;I"ÏThe coerce method provides support for Ruby type coercion. It is not enabled
by default.

This means that binary operations like + * / or - can often be performed on a
BigDecimal and an object of another type, if the other object can be coerced
into a BigDecimal value.

e.g.
    a = BigDecimal("1.0")
    b = a / 2.0 #=> 0.5

Note that coercing a String to a BigDecimal is not supported by default; it
requires a special compile-time option when building Ruby.

;T;0;;;I"coerce;F;I"BigDecimal;T;[o;;I"::Numeric;T;I"#[ ::BigDecimal, ::BigDecimal ];To;;I"µDivide by the specified value.

digits
:   If specified and less than the number of significant digits of the result,
    the result is rounded to that number of digits, according to
    BigDecimal.mode.

    If digits is 0, the result is the same as for the / operator or #quo.

    If digits is not specified, the result is an integer, by analogy with
    Float#div; see also BigDecimal#divmod.


See BigDecimal#/. See BigDecimal#quo.

Examples:

    a = BigDecimal("4")
    b = BigDecimal("3")

    a.div(b, 3)  # => 0.133e1

    a.div(b, 0)  # => 0.1333333333333333333e1
    a / b        # => 0.1333333333333333333e1
    a.quo(b)     # => 0.1333333333333333333e1

    a.div(b)     # => 1

;T;0;;;I"div;F;I"BigDecimal;T;[o;;I"::Numeric value;T;I"Integer;To;;I""::Numeric value, ::int digits;T;I"BigDecimal;To;;I"Divides by the specified value, and returns the quotient and modulus as
BigDecimal numbers. The quotient is rounded towards negative infinity.

For example:

    require 'bigdecimal'

    a = BigDecimal("42")
    b = BigDecimal("9")

    q, m = a.divmod(b)

    c = q * b + m

    a == c  #=> true

The quotient q is (a/b).floor, and the modulus is the amount that must be
added to q * b to get a.

;T;0;;;I"divmod;F;I"BigDecimal;T;[o;;I"::Numeric;T;I"#[ ::BigDecimal, ::BigDecimal ];To;;I" ;T;0;;;I"dup;F;I"BigDecimal;T;[o;;I" ;F;I"	self;To;;I"öTests for value equality; returns true if the values are equal.

The == and === operators and the eql? method have the same implementation for
BigDecimal.

Values may be coerced to perform the comparison:

    BigDecimal('1.0') == 1.0  #=> true

;T;0;;;I"	eql?;F;I"BigDecimal;T;[o;;I"untyped;T;I"	bool;To;;I"ÅReturns the exponent of the BigDecimal number, as an Integer.

If the number can be represented as 0.xxxxxx*10**n where xxxxxx is a string of
digits with no leading zeros, then n is the exponent.

;T;0;;;I"exponent;F;I"BigDecimal;T;[o;;I" ;F;I"Integer;To;;I"AReturns True if the value is finite (not NaN or infinite).

;T;0;;;I"finite?;F;I"BigDecimal;T;[o;;I" ;F;I"	bool;To;;I">Return the integer part of the number, as a BigDecimal.

;T;0;;;I"fix;F;I"BigDecimal;T;[o;;I" ;F;I"BigDecimal;To;;I"ÕReturn the largest integer less than or equal to the value, as a BigDecimal.

    BigDecimal('3.14159').floor #=> 3
    BigDecimal('-9.1').floor #=> -10

If n is specified and positive, the fractional part of the result has no more
than that many digits.

If n is specified and negative, at least that many digits to the left of the
decimal point will be 0 in the result.

    BigDecimal('3.14159').floor(3) #=> 3.141
    BigDecimal('13345.234').floor(-2) #=> 13300.0

;T;0;;;I"
floor;F;I"BigDecimal;T;[o;;I" ;F;I"Integer;To;;I"::int n;T;I"BigDecimal;To;;I"AReturn the fractional part of the number, as a BigDecimal.

;T;0;;;I"	frac;F;I"BigDecimal;T;[o;;I" ;F;I"BigDecimal;To;;I"°Returns the integer hash value for `self`.

Two instances of BigDecimal have the same hash value if and only if they have
equal:

*   Sign.
*   Fractional part.
*   Exponent.

;T;0;;;I"	hash;F;I"BigDecimal;T;[o;;I" ;F;I"Integer;To;;I"`Returns nil, -1, or +1 depending on whether the value is finite, -Infinity, or
+Infinity.

;T;0;;;I"infinite?;F;I"BigDecimal;T;[o;;I" ;F;I"Integer?;To;;I"mReturns a string representation of self.

    BigDecimal("1234.5678").inspect
      #=> "0.12345678e4"

;T;0;;;I"inspect;F;I"BigDecimal;T;[o;;I" ;F;I"String;To;;I"FReturns the modulus from dividing by b.

See BigDecimal#divmod.

;T;0;;;I"modulo;F;I"BigDecimal;T;[o;;I"::Numeric b;T;I"BigDecimal;To;;I"òReturns the BigDecimal product of `self` and `value` with a precision of
`ndigits` decimal digits.

When `ndigits` is less than the number of significant digits in the sum, the
sum is rounded to that number of digits, according to the current rounding
mode; see BigDecimal.mode.

Examples:

    # Set the rounding mode.
    BigDecimal.mode(BigDecimal::ROUND_MODE, :half_up)
    b = BigDecimal('555555.555')
    b.mult(3, 0)              # => 0.1666666665e7
    b.mult(3, 3)              # => 0.167e7
    b.mult(3, 6)              # => 0.166667e7
    b.mult(3, 15)             # => 0.1666666665e7
    b.mult(3.0, 0)            # => 0.1666666665e7
    b.mult(Rational(3, 1), 0) # => 0.1666666665e7
    b.mult(Complex(3, 0), 0)  # => (0.1666666665e7+0.0i)

;T;0;;;I"	mult;F;I"BigDecimal;T;[o;;I""::Numeric value, ::int digits;T;I"BigDecimal;To;;I"1Returns True if the value is Not a Number.

;T;0;;;I"	nan?;F;I"BigDecimal;T;[o;;I" ;F;I"	bool;To;;I"<Returns self if the value is non-zero, nil otherwise.

;T;0;;;I"nonzero?;F;I"BigDecimal;T;[o;;I" ;F;I"
self?;To;;I"wReturns the value raised to the power of n.

Note that n must be an Integer.

Also available as the operator **.

;T;0;;;I"
power;F;I"BigDecimal;T;[o;;I"::Numeric n, ::int prec;T;I"BigDecimal;To;;I"jReturns an Array of two Integer values that represent platform-dependent
internal storage properties.

This method is deprecated and will be removed in the future. Instead, use
BigDecimal#n_significant_digits for obtaining the number of significant digits
in scientific notation, and BigDecimal#precision for obtaining the number of
digits in decimal notation.

;T;0;;;I"
precs;F;I"BigDecimal;T;[o;;I" ;F;I"[ ::Integer, ::Integer ];To;;I"gDivide by the specified value.

digits
:   If specified and less than the number of significant digits of the result,
    the result is rounded to the given number of digits, according to the
    rounding mode indicated by BigDecimal.mode.

    If digits is 0 or omitted, the result is the same as for the / operator.


See BigDecimal#/. See BigDecimal#div.

;T;0;;;I"quo;F;I"BigDecimal;T;[o;;I"::Numeric;T;I"BigDecimal;To;;I"aReturns the remainder from dividing by the value.

x.remainder(y) means x-y*(x/y).truncate

;T;0;;;I"remainder;F;I"BigDecimal;T;[o;;I"::Numeric;T;I"BigDecimal;To;;I"9Round to the nearest integer (by default), returning the result as a
BigDecimal if n is specified, or as an Integer if it isn't.

    BigDecimal('3.14159').round #=> 3
    BigDecimal('8.7').round #=> 9
    BigDecimal('-9.9').round #=> -10

    BigDecimal('3.14159').round(2).class.name #=> "BigDecimal"
    BigDecimal('3.14159').round.class.name #=> "Integer"

If n is specified and positive, the fractional part of the result has no more
than that many digits.

If n is specified and negative, at least that many digits to the left of the
decimal point will be 0 in the result, and return value will be an Integer.

    BigDecimal('3.14159').round(3) #=> 3.142
    BigDecimal('13345.234').round(-2) #=> 13300

The value of the optional mode argument can be used to determine how rounding
is performed; see BigDecimal.mode.

;T;0;;;I"
round;F;I"BigDecimal;T;[o;;I" ;F;I"Integer;To;;I"!::Numeric n, ?::Integer mode;T;I"BigDecimal;To;;I"7Returns the sign of the value.

Returns a positive value if > 0, a negative value if < 0, and a zero if == 0.

The specific value returned indicates the type and sign of the BigDecimal, as
follows:

BigDecimal::SIGN_NaN
:   value is Not a Number
BigDecimal::SIGN_POSITIVE_ZERO
:   value is +0
BigDecimal::SIGN_NEGATIVE_ZERO
:   value is -0
BigDecimal::SIGN_POSITIVE_INFINITE
:   value is +Infinity
BigDecimal::SIGN_NEGATIVE_INFINITE
:   value is -Infinity
BigDecimal::SIGN_POSITIVE_FINITE
:   value is positive
BigDecimal::SIGN_NEGATIVE_FINITE
:   value is negative

;T;0;;;I"	sign;F;I"BigDecimal;T;[o;;I" ;F;I"Integer;To;;I"mSplits a BigDecimal number into four parts, returned as an array of values.

The first value represents the sign of the BigDecimal, and is -1 or 1, or 0 if
the BigDecimal is Not a Number.

The second value is a string representing the significant digits of the
BigDecimal, with no leading zeros.

The third value is the base used for arithmetic (currently always 10) as an
Integer.

The fourth value is an Integer exponent.

If the BigDecimal can be represented as 0.xxxxxx*10**n, then xxxxxx is the
string of significant digits with no leading zeros, and n is the exponent.

From these values, you can translate a BigDecimal to a float as follows:

    sign, significant_digits, base, exponent = a.split
    f = sign * "0.#{significant_digits}".to_f * (base ** exponent)

(Note that the to_f method is provided as a more convenient way to translate a
BigDecimal to a Float.)

;T;0;;;I"
split;F;I"BigDecimal;T;[o;;I" ;F;I"2[ ::Integer, ::String, ::Integer, ::Integer ];To;;I"WReturns the square root of the value.

Result has at least n significant digits.

;T;0;;;I"	sqrt;F;I"BigDecimal;T;[o;;I"::int n;T;I"BigDecimal;To;;I"åSubtract the specified value.

e.g.
    c = a.sub(b,n)

digits
:   If specified and less than the number of significant digits of the result,
    the result is rounded to that number of digits, according to
    BigDecimal.mode.

;T;0;;;I"sub;F;I"BigDecimal;T;[o;;I""::Numeric value, ::int digits;T;I"BigDecimal;To;;I"§Returns a new Float object having approximately the same value as the
BigDecimal number. Normal accuracy limits and built-in errors of binary Float
arithmetic apply.

;T;0;;;I"	to_f;F;I"BigDecimal;T;[o;;I" ;F;I"
Float;To;;I"gReturns the value as an Integer.

If the BigDecimal is infinity or NaN, raises FloatDomainError.

;T;0;;;I"	to_i;F;I"BigDecimal;T;[o;;I" ;F;I"Integer;To;;I"gReturns the value as an Integer.

If the BigDecimal is infinity or NaN, raises FloatDomainError.

;T;0;;;I"to_int;F;I"BigDecimal;T;[o;;I" ;F;I"Integer;To;;I"+Converts a BigDecimal to a Rational.

;T;0;;;I"	to_r;F;I"BigDecimal;T;[o;;I" ;F;I"Rational;To;;I"}Converts the value to a string.

The default format looks like  0.xxxxEnn.

The optional parameter s consists of either an integer; or an optional '+' or
' ', followed by an optional number, followed by an optional 'E' or 'F'.

If there is a '+' at the start of s, positive values are returned with a
leading '+'.

A space at the start of s returns positive values with a leading space.

If s contains a number, a space is inserted after each group of that many
fractional digits.

If s ends with an 'E', engineering notation (0.xxxxEnn) is used.

If s ends with an 'F', conventional floating point notation is used.

Examples:

    BigDecimal('-123.45678901234567890').to_s('5F')
      #=> '-123.45678 90123 45678 9'

    BigDecimal('123.45678901234567890').to_s('+8F')
      #=> '+123.45678901 23456789'

    BigDecimal('123.45678901234567890').to_s(' F')
      #=> ' 123.4567890123456789'

;T;0;;;I"	to_s;F;I"BigDecimal;T;[o;;I"?::String | ::int s;T;I"String;To;;I"Truncate to the nearest integer (by default), returning the result as a
BigDecimal.

    BigDecimal('3.14159').truncate #=> 3
    BigDecimal('8.7').truncate #=> 8
    BigDecimal('-9.9').truncate #=> -9

If n is specified and positive, the fractional part of the result has no more
than that many digits.

If n is specified and negative, at least that many digits to the left of the
decimal point will be 0 in the result.

    BigDecimal('3.14159').truncate(3) #=> 3.141
    BigDecimal('13345.234').truncate(-2) #=> 13300.0

;T;0;;;I"truncate;F;I"BigDecimal;T;[o;;I" ;F;I"Integer;To;;I"::int n;T;I"BigDecimal;To;;I")Returns True if the value is zero.

;T;0;;;I"
zero?;F;I"BigDecimal;T;[o;;I" ;F;I"	bool;To;;I"}Returns self.

    require 'bigdecimal/util'

    d = BigDecimal("3.14")
    d.to_d                       # => 0.314e1

;T;0;;;I"	to_d;F;I"BigDecimal;T;[o;;I" ;F;I"BigDecimal;To;;0;0;;;I"initialize_copy;F;I"BigDecimal;T;[o;;I"	self;T;I"	self;To; ;0;0;	I"BigDecimal;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"RImport a JSON Marshalled object.

method used for JSON marshalling support.

;T;0;;;I"json_create;F;I"BigDecimal;T;[o;;I"&::Hash[::String, ::String] object;T;I"instance;To;;I"MMarshal the object to JSON.

method used for JSON marshalling support.

;T;0;;;I"as_json;F;I"BigDecimal;T;[o;;I"*untyped;T;I"Hash[::String, ::String];To;;I"return the JSON value

;T;0;;;I"to_json;F;I"BigDecimal;T;[o;;I"?::JSON::State state;T;I"String;To;;I"¾Provides mathematical functions.

Example:

    require "bigdecimal/math"

    include BigMath

    a = BigDecimal((PI(100)/2).to_s)
    puts sin(a,100) # => 0.99999999999999999999......e0

;T;0;	I"BigMath;T;
[ ;[ ;0;[ ;[ o;;I"¹Computes e (the base of natural logarithms) to the specified number of digits
of precision, `numeric`.

    BigMath.E(10).to_s
    #=> "0.271828182845904523536028752390026306410273e1"

;T;0;;;I"E;F;I"BigMath;T;[o;;I"::Numeric prec;T;I"BigDecimal;To;;I"¨Computes the value of pi to the specified number of digits of precision,
`numeric`.

    BigMath.PI(10).to_s
    #=> "0.3141592653589793238462643388813853786957412e1"

;T;0;;;I"PI;F;I"BigMath;T;[o;;I"::Numeric prec;T;I"BigDecimal;To;;I"ñComputes the arctangent of `decimal` to the specified number of digits of
precision, `numeric`.

If `decimal` is NaN, returns NaN.

    BigMath.atan(BigDecimal('-1'), 16).to_s
    #=> "-0.785398163397448309615660845819878471907514682065e0"

;T;0;;;I"	atan;F;I"BigMath;T;[o;;I"#::BigDecimal x, ::Numeric prec;T;I"BigDecimal;To;;I"õComputes the cosine of `decimal` to the specified number of digits of
precision, `numeric`.

If `decimal` is Infinity or NaN, returns NaN.

    BigMath.cos(BigMath.PI(4), 16).to_s
    #=> "-0.999999999999999999999999999999856613163740061349e0"

;T;0;;;I"cos;F;I"BigMath;T;[o;;I"#::BigDecimal x, ::Numeric prec;T;I"BigDecimal;To;;I"ÜComputes the value of e (the base of natural logarithms) raised to the power
of `decimal`, to the specified number of digits of precision.

If `decimal` is infinity, returns Infinity.

If `decimal` is NaN, returns NaN.

;T;0;;;I"exp;F;I"BigMath;T;[o;;I"!::BigDecimal, ::Numeric prec;T;I"BigDecimal;To;;I"þComputes the natural logarithm of `decimal` to the specified number of digits
of precision, `numeric`.

If `decimal` is zero or negative, raises Math::DomainError.

If `decimal` is positive infinity, returns Infinity.

If `decimal` is NaN, returns NaN.

;T;0;;;I"log;F;I"BigMath;T;[o;;I"!::BigDecimal, ::Numeric prec;T;I"BigDecimal;To;;I"éComputes the sine of `decimal` to the specified number of digits of precision,
`numeric`.

If `decimal` is Infinity or NaN, returns NaN.

    BigMath.sin(BigMath.PI(5)/4, 5).to_s
    #=> "0.70710678118654752440082036563292800375e0"

;T;0;;;I"sin;F;I"BigMath;T;[o;;I"#::BigDecimal x, ::Numeric prec;T;I"BigDecimal;To;;I"¹Computes the square root of `decimal` to the specified number of digits of
precision, `numeric`.

    BigMath.sqrt(BigDecimal('2'), 16).to_s
    #=> "0.1414213562373095048801688724e1"

;T;0;;;I"	sqrt;F;I"BigMath;T;[o;;I"#::BigDecimal x, ::Numeric prec;T;I"BigDecimal;To; ;I"W#{value}\n"
              end.join("")
            )
          end
        end
      end
    end

    # add HTML generation methods
    CGI.new("html3")    # html3.2
    CGI.new("html4")    # html4.01 (Strict)
    CGI.new("html4Tr")  # html4.01 Transitional
    CGI.new("html4Fr")  # html4.01 Frameset
    CGI.new("html5")    # html5

### Some utility methods

    require 'cgi/util'
    CGI.escapeHTML('Usage: foo "bar" <baz>')

### Some utility methods like a function

    require 'cgi/util'
    include CGI::Util
    escapeHTML('Usage: foo "bar" <baz>')
    h('Usage: foo "bar" <baz>') # alias

;T;0;	I"CGI;T;
[ ;[I"CGI::Util;T;0;[ ;[ ;0;0o;;I"{	Create a new CGI instance.

`tag_maker`
:   This is the same as using the `options_hash` form with the value `{
    :tag_maker => tag_maker }` Note that it is recommended to use the
    `options_hash` form, since it also allows you specify the charset you will
    accept.
`options_hash`
:   A Hash that recognizes three options:

    `:accept_charset`
:       specifies encoding of received query string.  If omitted,
        `@@accept_charset` is used.  If the encoding is not valid, a
        CGI::InvalidEncoding will be raised.

        Example. Suppose `@@accept_charset` is "UTF-8"

        when not specified:

            cgi=CGI.new      # @accept_charset # => "UTF-8"

        when specified as "EUC-JP":

            cgi=CGI.new(:accept_charset => "EUC-JP") # => "EUC-JP"

    `:tag_maker`
:       String that specifies which version of the HTML generation methods to
        use.  If not specified, no HTML generation methods will be loaded.

        The following values are supported:

        "html3"
:           HTML 3.x
        "html4"
:           HTML 4.0
        "html4Tr"
:           HTML 4.0 Transitional
        "html4Fr"
:           HTML 4.0 with Framesets
        "html5"
:           HTML 5


    `:max_multipart_length`
:       Specifies maximum length of multipart data. Can be an Integer scalar
        or a lambda, that will be evaluated when the request is parsed. This
        allows more complex logic to be set when determining whether to accept
        multipart data (e.g. consult a registered users upload allowance)

        Default is 128 * 1024 * 1024 bytes

            cgi=CGI.new(:max_multipart_length => 268435456) # simple scalar

            cgi=CGI.new(:max_multipart_length => -> {check_filesystem}) # lambda


`block`
:   If provided, the block is called when an invalid encoding is encountered.
    For example:

        encoding_errors={}
        cgi=CGI.new(:accept_charset=>"EUC-JP") do |name,value|
          encoding_errors[name] = value
        end


Finally, if the CGI object is not created in a standard CGI call environment
(that is, it can't locate REQUEST_METHOD in its environment), then it will run
in "offline" mode.  In this mode, it reads its parameters from the command
line or (failing that) from standard input.  Otherwise, cookies and other
parameters are parsed automatically from the standard CGI locations, which
varies according to the REQUEST_METHOD.

;T;0;;;I"initialize;F;I"CGI;T;[o;;I"?::String tag_maker;T;I"	void;To;;I"+::Hash[::Symbol, untyped] options_hash;T;I"	void;To;;I"AReturn the accept character set for all new CGI instances.

;T;0;;;I"accept_charset;F;I"CGI;T;[o;;I" ;F;I"String;To;;I">Set the accept character set for all new CGI instances.

;T;0;;;I"accept_charset=;F;I"CGI;T;[o;;I"::String accept_charset;T;I"String;To;;I"ÉParse an HTTP query string into a hash of key=>value pairs.

    params = CGI.parse("query_string")
      # {"name1" => ["value1", "value2", ...],
      #  "name2" => ["value1", "value2", ...], ... }

;T;0;;;I"
parse;F;I"CGI;T;[o;;I"::String query;T;I"&Hash[::String, ::Array[::String]];To;;I"Create an HTTP header block as a string.

Includes the empty line that ends the header block.

`content_type_string`
:   If this form is used, this string is the `Content-Type`
`headers_hash`
:   A Hash of header values. The following header keys are recognized:

    type
:       The Content-Type header.  Defaults to "text/html"
    charset
:       The charset of the body, appended to the Content-Type header.
    nph
:       A boolean value.  If true, prepend protocol string and status code,
        and date; and sets default values for "server" and "connection" if not
        explicitly set.
    status
:       The HTTP status code as a String, returned as the Status header.  The
        values are:

        OK
:           200 OK
        PARTIAL_CONTENT
:           206 Partial Content
        MULTIPLE_CHOICES
:           300 Multiple Choices
        MOVED
:           301 Moved Permanently
        REDIRECT
:           302 Found
        NOT_MODIFIED
:           304 Not Modified
        BAD_REQUEST
:           400 Bad Request
        AUTH_REQUIRED
:           401 Authorization Required
        FORBIDDEN
:           403 Forbidden
        NOT_FOUND
:           404 Not Found
        METHOD_NOT_ALLOWED
:           405 Method Not Allowed
        NOT_ACCEPTABLE
:           406 Not Acceptable
        LENGTH_REQUIRED
:           411 Length Required
        PRECONDITION_FAILED
:           412 Precondition Failed
        SERVER_ERROR
:           500 Internal Server Error
        NOT_IMPLEMENTED
:           501 Method Not Implemented
        BAD_GATEWAY
:           502 Bad Gateway
        VARIANT_ALSO_VARIES
:           506 Variant Also Negotiates


    server
:       The server software, returned as the Server header.
    connection
:       The connection type, returned as the Connection header (for instance,
        "close".
    length
:       The length of the content that will be sent, returned as the
        Content-Length header.
    language
:       The language of the content, returned as the Content-Language header.
    expires
:       The time on which the current content expires, as a `Time` object,
        returned as the Expires header.
    cookie
:       A cookie or cookies, returned as one or more Set-Cookie headers.  The
        value can be the literal string of the cookie; a CGI::Cookie object;
        an Array of literal cookie strings or Cookie objects; or a hash all of
        whose values are literal cookie strings or Cookie objects.

        These cookies are in addition to the cookies held in the
        @output_cookies field.


    Other headers can also be set; they are appended as key: value.


Examples:

    http_header
      # Content-Type: text/html

    http_header("text/plain")
      # Content-Type: text/plain

    http_header("nph"        => true,
                "status"     => "OK",  # == "200 OK"
                  # "status"     => "200 GOOD",
                "server"     => ENV['SERVER_SOFTWARE'],
                "connection" => "close",
                "type"       => "text/html",
                "charset"    => "iso-2022-jp",
                  # Content-Type: text/html; charset=iso-2022-jp
                "length"     => 103,
                "language"   => "ja",
                "expires"    => Time.now + 30,
                "cookie"     => [cookie1, cookie2],
                "my_header1" => "my_value",
                "my_header2" => "my_value")

This method does not perform charset conversion.

;T;0;;;I"http_header;F;I"CGI;T;[o;;I"?::String options;T;I"String;To;;I"6?::Hash[::String | ::Symbol, untyped] header_hash;T;I"String;To;;0;0;;;I"	nph?;F;I"CGI;T;[o;;I" ;F;I"untyped;To;;I"uPrint an HTTP header and body to $DEFAULT_OUTPUT ($>)

`content_type_string`
:   If a string is passed, it is assumed to be the content type.
`headers_hash`
:   This is a Hash of headers, similar to that used by #http_header.
`block`
:   A block is required and should evaluate to the body of the response.


`Content-Length` is automatically calculated from the size of the String
returned by the content block.

If `ENV['REQUEST_METHOD'] == "HEAD"`, then only the header is output (the
content block is still required, but it is ignored).

If the charset is "iso-2022-jp" or "euc-jp" or "shift_jis" then the content is
converted to this charset, and the language is set to "ja".

Example:

    cgi = CGI.new
    cgi.out{ "string" }
      # Content-Type: text/html
      # Content-Length: 6
      #
      # string

    cgi.out("text/plain") { "string" }
      # Content-Type: text/plain
      # Content-Length: 6
      #
      # string

    cgi.out("nph"        => true,
            "status"     => "OK",  # == "200 OK"
            "server"     => ENV['SERVER_SOFTWARE'],
            "connection" => "close",
            "type"       => "text/html",
            "charset"    => "iso-2022-jp",
              # Content-Type: text/html; charset=iso-2022-jp
            "language"   => "ja",
            "expires"    => Time.now + (3600 * 24 * 30),
            "cookie"     => [cookie1, cookie2],
            "my_header1" => "my_value",
            "my_header2" => "my_value") { "string" }
       # HTTP/1.1 200 OK
       # Date: Sun, 15 May 2011 17:35:54 GMT
       # Server: Apache 2.2.0
       # Connection: close
       # Content-Type: text/html; charset=iso-2022-jp
       # Content-Length: 6
       # Content-Language: ja
       # Expires: Tue, 14 Jun 2011 17:35:54 GMT
       # Set-Cookie: foo
       # Set-Cookie: bar
       # my_header1: my_value
       # my_header2: my_value
       #
       # string

;T;0;;;I"out;F;I"CGI;T;[o;;I""?::String content_type_string;T;I"	void;To;;I"6::Hash[::String | ::Symbol, untyped] headers_hash;T;I"	void;To;;I"˜Print an argument or list of arguments to the default output stream

    cgi = CGI.new
    cgi.print    # default:  cgi.print == $DEFAULT_OUTPUT.print

;T;0;;;I"
print;F;I"CGI;T;[o;;I"*::String options;T;I"	void;To;;I"Synonym for $stdin.

;T;0;;;I"stdinput;F;I"CGI;T;[o;;I" ;F;I"IO;To;;I"Synonym for $stdout.

;T;0;;;I"stdoutput;F;I"CGI;T;[o;;I" ;F;I"IO;To; ;I"Class representing an HTTP cookie.

In addition to its specific fields and methods, a Cookie instance is a
delegator to the array of its values.

See RFC 2965.

## Examples of use
    cookie1 = CGI::Cookie.new("name", "value1", "value2", ...)
    cookie1 = CGI::Cookie.new("name" => "name", "value" => "value")
    cookie1 = CGI::Cookie.new('name'     => 'name',
                              'value'    => ['value1', 'value2', ...],
                              'path'     => 'path',   # optional
                              'domain'   => 'domain', # optional
                              'expires'  => Time.now, # optional
                              'secure'   => true,     # optional
                              'httponly' => true      # optional
                              )

    cgi.out("cookie" => [cookie1, cookie2]) { "string" }

    name     = cookie1.name
    values   = cookie1.value
    path     = cookie1.path
    domain   = cookie1.domain
    expires  = cookie1.expires
    secure   = cookie1.secure
    httponly = cookie1.httponly

    cookie1.name     = 'name'
    cookie1.value    = ['value1', 'value2', ...]
    cookie1.path     = 'path'
    cookie1.domain   = 'domain'
    cookie1.expires  = Time.now + 30
    cookie1.secure   = true
    cookie1.httponly = true

;T;0;	I"CGI::Cookie;T;
[ ;[ ;0;[ ;[ ;0;I"
Array;To;;I"³Parse a raw cookie string into a hash of cookie-name=>Cookie pairs.

    cookies = CGI::Cookie.parse("raw_cookie_string")
      # { "name1" => cookie1, "name2" => cookie2, ... }

;T;0;;;I"
parse;F;I"CGI::Cookie;T;[o;;I"::String raw_cookie;T;I"Hash[::String, instance];To;;I":Domain for which this cookie applies, as a `String`

;T;0;;;I"domain;F;I"CGI::Cookie;T;[o;;I" ;F;I"String?;To;;I":Domain for which this cookie applies, as a `String`

;T;0;;;I"domain=;F;I"CGI::Cookie;T;[o;;I"::String domain;T;I"String;To;;I"5Time at which this cookie expires, as a `Time`

;T;0;;;I"expires;F;I"CGI::Cookie;T;[o;;I" ;F;I"
Time?;To;;I"5Time at which this cookie expires, as a `Time`

;T;0;;;I"expires=;F;I"CGI::Cookie;T;[o;;I"::Time time;T;I"	Time;To;;I"7True if this cookie is httponly; false otherwise

;T;0;;;I"httponly;F;I"CGI::Cookie;T;[o;;I" ;F;I"	bool;To;;I"TSet whether the Cookie is a httponly cookie or not.

`val` must be a boolean.

;T;0;;;I"httponly=;F;I"CGI::Cookie;T;[o;;I"::boolish val;T;I"	bool;To;;I""A summary of cookie string.

;T;0;;;I"inspect;F;I"CGI::Cookie;T;[o;;I" ;F;I"String;To;;I")Name of this cookie, as a `String`

;T;0;;;I"	name;F;I"CGI::Cookie;T;[o;;I" ;F;I"String;To;;I")Name of this cookie, as a `String`

;T;0;;;I"
name=;F;I"CGI::Cookie;T;[o;;I"::String name;T;I"String;To;;I"8Path for which this cookie applies, as a `String`

;T;0;;;I"	path;F;I"CGI::Cookie;T;[o;;I" ;F;I"String?;To;;I"8Path for which this cookie applies, as a `String`

;T;0;;;I"
path=;F;I"CGI::Cookie;T;[o;;I"::String path;T;I"String;To;;I"5True if this cookie is secure; false otherwise

;T;0;;;I"secure;F;I"CGI::Cookie;T;[o;;I" ;F;I"	bool;To;;I"RSet whether the Cookie is a secure cookie or not.

`val` must be a boolean.

;T;0;;;I"secure=;F;I"CGI::Cookie;T;[o;;I"::boolish val;T;I"A;Fo;;I"7Convert the Cookie to its string representation.

;T;0;;;I"	to_s;F;I"CGI::Cookie;T;[o;;I" ;F;I"String;To;;I";Returns the value or list of values for this cookie.

;T;0;;;I"
value;F;I"CGI::Cookie;T;[o;;I" ;F;I"Array[::String];To;;I"LReplaces the value of this cookie with a new value or list of values.

;T;0;;;I"value=;F;I"CGI::Cookie;T;[o;;I"::String val;T;I"String;To;;I"::Array[::String] val;T;I"Array[::String];To;;I"PCreate a new CGI::Cookie object.

`name_string`
:   The name of the cookie; in this form, there is no #domain or #expiration.
    The #path is gleaned from the `SCRIPT_NAME` environment variable, and
    #secure is false.
`*value`
:   value or list of values of the cookie
`options_hash`
:   A Hash of options to initialize this Cookie.  Possible options are:

    name
:       the name of the cookie.  Required.
    value
:       the cookie's value or list of values.
    path
:       the path for which this cookie applies.  Defaults to the value of the
        `SCRIPT_NAME` environment variable.
    domain
:       the domain for which this cookie applies.
    expires
:       the time at which this cookie expires, as a `Time` object.
    secure
:       whether this cookie is a secure cookie or not (default to false).
        Secure cookies are only transmitted to HTTPS servers.
    httponly
:       whether this cookie is a HttpOnly cookie or not (default to

        false).  HttpOnly cookies are not available to javascript.

    These keywords correspond to attributes of the cookie object.

;T;0;;;I"initialize;F;I"CGI::Cookie;T;[o;;I"*::String name_string, *::String value;T;I"	void;To;;I"+::Hash[::String, untyped] options_hash;T;I"	void;To;;0;0;	I"CGI::Escape;T;
[ ;[ ;0;[ ;[ o;;I""Returns URL-escaped string.

;T;0;;;I"escape;F;I"CGI::Escape;T;[o;;I"::string str;T;I"String;To;;I"#Returns HTML-escaped string.

;T;0;;;I"escapeHTML;F;I"CGI::Escape;T;[o;;I"::string str;T;I"String;To;;I"$Returns URL-unescaped string.

;T;0;;;I"unescape;F;I"CGI::Escape;T;[o;;I"'::string str, ?::encoding encoding;T;I"String;To;;I"%Returns HTML-unescaped string.

;T;0;;;I"unescapeHTML;F;I"CGI::Escape;T;[o;;I"::string str;T;I"String;To; ;I"BException raised when there is an invalid encoding detected

;T;0;	I"CGI::InvalidEncoding;T;
[ ;[ ;0;[ ;[ ;0;I"Exception;To;;I"ðMixin module that provides the following:

1.  Access to the CGI environment variables as methods.  See documentation to
    the CGI class for a list of these variables.  The methods are exposed by
    removing the leading `HTTP_` (if it exists) and downcasing the name.  For
    example, `auth_type` will return the environment variable `AUTH_TYPE`, and
    `accept` will return the value for `HTTP_ACCEPT`.

2.  Access to cookies, including the cookies attribute.

3.  Access to parameters, including the params attribute, and overloading #[]
    to perform parameter value lookup by key.

4.  The initialize_query method, for initializing the above mechanisms,
    handling multipart forms, and allowing the class to be used in "offline"
    mode.

;T;0;	I"CGI::QueryExtension;T;
[ ;[ ;0;[ ;[ o;;I"¤Get the value for the parameter with a given key.

If the parameter has multiple values, only the first will be retrieved; use
#params to get the array of values.

;T;0;;;I"[];F;I"CGI::QueryExtension;T;[o;;I"::String key;T;I"String?;To;;0;0;;;I"accept;F;I"CGI::QueryExtension;T;[o;;I" ;F;I"String?;To;;0;0;;;I"accept_charset;F;I"CGI::QueryExtension;T;[o;;I" ;F;I"String?;To;;0;0;;;I"accept_encoding;F;I"CGI::QueryExtension;T;[o;;I" ;F;I"String?;To;;0;0;;;I"accept_language;F;I"CGI::QueryExtension;T;[o;;I" ;F;I"String?;To;;0;0;;;I"auth_type;F;I"CGI::QueryExtension;T;[o;;I" ;F;I"String?;To;;0;0;;;I"cache_control;F;I"CGI::QueryExtension;T;[o;;I" ;F;I"String?;To;;0;0;;;I"content_length;F;I"CGI::QueryExtension;T;[o;;I" ;F;I"String?;To;;0;0;;;I"content_type;F;I"CGI::QueryExtension;T;[o;;I" ;F;I"String?;To;;I">Get the cookies as a hash of cookie-name=>Cookie pairs.

;T;0;;;I"cookies;F;I"CGI::QueryExtension;T;[o;;I" ;F;I""Hash[::String, ::CGI::Cookie];To;;I">Get the cookies as a hash of cookie-name=>Cookie pairs.

;T;0;;;I"cookies=;F;I"CGI::QueryExtension;T;[o;;I",::Hash[::String, ::CGI::Cookie] cookies;T;I""Hash[::String, ::CGI::Cookie];To;;0;0;;;I"create_body;F;I"CGI::QueryExtension;T;[o;;I"::boolish is_large;T;I"Tempfile | ::StringIO;To;;I"=Get the uploaded files as a hash of name=>values pairs

;T;0;;;I"
files;F;I"CGI::QueryExtension;T;[o;;I" ;F;I",Hash[::String, ::Tempfile | ::StringIO];To;;0;0;;;I"	from;F;I"CGI::QueryExtension;T;[o;;I" ;F;I"String?;To;;0;0;;;I"gateway_interface;F;I"CGI::QueryExtension;T;[o;;I" ;F;I"String?;To;;I"=Returns true if a given query string parameter exists.

;T;0;;;I"has_key?;F;I"CGI::QueryExtension;T;[o;;I"::String key;T;I"	bool;To;;0;0;;;I"	host;F;I"CGI::QueryExtension;T;[o;;I" ;F;I"String?;To;;I">Return all query parameter names as an array of String.

;T;0;;;I"	keys;F;I"CGI::QueryExtension;T;[o;;I" ;F;I"Array[::String];To;;I"=Returns whether the form contained multipart/form-data

;T;0;;;I"multipart?;F;I"CGI::QueryExtension;T;[o;;I" ;F;I"	bool;To;;0;0;;;I"negotiate;F;I"CGI::QueryExtension;T;[o;;I" ;F;I"String?;To;;I"TGet the parameters as a hash of name=>values pairs, where values is an Array.

;T;0;;;I"params;F;I"CGI::QueryExtension;T;[o;;I" ;F;I"@Hash[::String, ::Array[::String] | ::Tempfile | ::StringIO];To;;I"Set all the parameters.

;T;0;;;I"params=;F;I"CGI::QueryExtension;T;[o;;I"G::Hash[::String, ::Array[::String] | ::Tempfile | ::StringIO] hash;T;I"@Hash[::String, ::Array[::String] | ::Tempfile | ::StringIO];To;;0;0;;;I"path_info;F;I"CGI::QueryExtension;T;[o;;I" ;F;I"String?;To;;0;0;;;I"path_translated;F;I"CGI::QueryExtension;T;[o;;I" ;F;I"String?;To;;0;0;;;I"pragma;F;I"CGI::QueryExtension;T;[o;;I" ;F;I"String?;To;;0;0;;;I"query_string;F;I"CGI::QueryExtension;T;[o;;I" ;F;I"String?;To;;I"'Get the raw cookies as a string.

;T;0;;;I"raw_cookie;F;I"CGI::QueryExtension;T;[o;;I" ;F;I"String?;To;;I"/Get the raw RFC2965 cookies as a string.

;T;0;;;I"raw_cookie2;F;I"CGI::QueryExtension;T;[o;;I" ;F;I"String?;To;;0;0;;;I"referer;F;I"CGI::QueryExtension;T;[o;;I" ;F;I"String?;To;;0;0;;;I"remote_addr;F;I"CGI::QueryExtension;T;[o;;I" ;F;I"String?;To;;0;0;;;I"remote_host;F;I"CGI::QueryExtension;T;[o;;I" ;F;I"String?;To;;0;0;;;I"remote_ident;F;I"CGI::QueryExtension;T;[o;;I" ;F;I"String?;To;;0;0;;;I"remote_user;F;I"CGI::QueryExtension;T;[o;;I" ;F;I"String?;To;;0;0;;;I"request_method;F;I"CGI::QueryExtension;T;[o;;I" ;F;I"String?;To;;0;0;;;I"script_name;F;I"CGI::QueryExtension;T;[o;;I" ;F;I"String?;To;;0;0;;;I"server_name;F;I"CGI::QueryExtension;T;[o;;I" ;F;I"String?;To;;0;0;;;I"server_port;F;I"CGI::QueryExtension;T;[o;;I" ;F;I"String?;To;;0;0;;;I"server_protocol;F;I"CGI::QueryExtension;T;[o;;I" ;F;I"String?;To;;0;0;;;I"server_software;F;I"CGI::QueryExtension;T;[o;;I" ;F;I"String?;To;;0;0;;;I"unescape_filename?;F;I"CGI::QueryExtension;T;[o;;I" ;F;I"	bool;To;;0;0;;;I"user_agent;F;I"CGI::QueryExtension;T;[o;;I" ;F;I"String?;To;;I"+A wrapper class to use a StringIO object as the body and switch to a TempFile
when the passed threshold is passed. Initialize the data from the query.

Handles multipart forms (in particular, forms that involve file uploads).
Reads query parameters in the @params field, and cookies into @cookies.

;T;0;;;I"initialize_query;F;I"CGI::QueryExtension;T;[o;;I" ;F;I"	void;To;;I"=offline mode. read name=value pairs on standard input.

;T;0;;;I"read_from_cmdline;F;I"CGI::QueryExtension;T;[o;;I" ;F;I"String;To;;I"Parses multipart form elements according to
    http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.2

Returns a hash of multipart form parameters with bodies of type StringIO or
Tempfile depending on whether the multipart form element exceeds 10 KB

    params[name => body]

;T;0;;;I"read_multipart;F;I"CGI::QueryExtension;T;[o;;I"0::String boundary, ::Integer content_length;T;I"Tempfile | ::StringIO;To;;0;0;	I"CGI::Util;T;
[ ;[ ;0;[ ;[ o;;I"hEscape only the tags of certain HTML elements in `string`.

Takes an element or elements or array of elements.  Each element is specified
by the name of the element, without angle brackets. This matches both the
start and the end tag of that element. The attribute list of the open tag will
also be escaped (for instance, the double-quotes surrounding attribute
values).

    print CGI.escapeElement('<BR><A HREF="url"></A>', "A", "IMG")
      # "<BR>&lt;A HREF=&quot;url&quot;&gt;&lt;/A&gt"

    print CGI.escapeElement('<BR><A HREF="url"></A>', ["A", "IMG"])
      # "<BR>&lt;A HREF=&quot;url&quot;&gt;&lt;/A&gt"

;T;0;;;I"escapeElement;F;I"CGI::Util;T;[o;;I"<::string string, *::String | ::Array[::String] elements;T;I"String;To;;I"Prettify (indent) an HTML string.

`string` is the HTML string to indent.  `shift` is the indentation unit to
use; it defaults to two spaces.

    print CGI.pretty("<HTML><BODY></BODY></HTML>")
      # <HTML>
      #   <BODY>
      #   </BODY>
      # </HTML>

    print CGI.pretty("<HTML><BODY></BODY></HTML>", "\t")
      # <HTML>
      #         <BODY>
      #         </BODY>
      # </HTML>

;T;0;;;I"pretty;F;I"CGI::Util;T;[o;;I"%::string string, ?::String shift;T;I"String;To;;I"’Format a `Time` object as a String using the format specified by RFC 1123.

    CGI.rfc1123_date(Time.now)
      # Sat, 01 Jan 2000 00:00:00 GMT

;T;0;;;I"rfc1123_date;F;I"CGI::Util;T;[o;;I"::Time time;T;I"String;To;;I"LUndo escaping such as that done by CGI.escapeElement()

    print CGI.unescapeElement(
            CGI.escapeHTML('<BR><A HREF="url"></A>'), "A", "IMG")
      # "&lt;BR&gt;<A HREF="url"></A>"

    print CGI.unescapeElement(
            CGI.escapeHTML('<BR><A HREF="url"></A>'), ["A", "IMG"])
      # "&lt;BR&gt;<A HREF="url"></A>"

;T;0;;;I"unescapeElement;F;I"CGI::Util;T;[o;;I"<::string string, *::String | ::Array[::String] elements;T;I"String;To;;I"ŸCoverage provides coverage measurement feature for Ruby. This feature is
experimental, so these APIs may be changed in future.

Caveat: Currently, only process-global coverage measurement is supported. You
cannot measure per-thread covearge.

# Usage

1.  require "coverage"
2.  do Coverage.start
3.  require or load Ruby source file
4.  Coverage.result will return a hash that contains filename as key and
    coverage array as value. A coverage array gives, for each line, the number
    of line execution by the interpreter. A `nil` value means coverage is
    disabled for this line (lines like `else` and `end`).


# Examples

    [foo.rb]
    s = 0
    10.times do |x|
      s += x
    end

    if s == 45
      p :ok
    else
      p :ng
    end
    [EOF]

    require "coverage"
    Coverage.start
    require "foo.rb"
    p Coverage.result  #=> {"foo.rb"=>[1, 1, 10, nil, nil, 1, 1, nil, 0, nil]}

## Lines Coverage

If a coverage mode is not explicitly specified when starting coverage, lines
coverage is what will run. It reports the number of line executions for each
line.

    require "coverage"
    Coverage.start(lines: true)
    require "foo.rb"
    p Coverage.result #=> {"foo.rb"=>{:lines=>[1, 1, 10, nil, nil, 1, 1, nil, 0, nil]}}

The value of the lines coverage result is an array containing how many times
each line was executed. Order in this array is important. For example, the
first item in this array, at index 0, reports how many times line 1 of this
file was executed while coverage was run (which, in this example, is one
time).

A `nil` value means coverage is disabled for this line (lines like `else` and
`end`).

## Oneshot Lines Coverage

Oneshot lines coverage tracks and reports on the executed lines while coverage
is running. It will not report how many times a line was executed, only that
it was executed.

    require "coverage"
    Coverage.start(oneshot_lines: true)
    require "foo.rb"
    p Coverage.result #=> {"foo.rb"=>{:oneshot_lines=>[1, 2, 3, 6, 7]}}

The value of the oneshot lines coverage result is an array containing the line
numbers that were executed.

## Branches Coverage

Branches coverage reports how many times each branch within each conditional
was executed.

    require "coverage"
    Coverage.start(branches: true)
    require "foo.rb"
    p Coverage.result #=> {"foo.rb"=>{:branches=>{[:if, 0, 6, 0, 10, 3]=>{[:then, 1, 7, 2, 7, 7]=>1, [:else, 2, 9, 2, 9, 7]=>0}}}}

Each entry within the branches hash is a conditional, the value of which is
another hash where each entry is a branch in that conditional. The values are
the number of times the method was executed, and the keys are identifying
information about the branch.

The information that makes up each key identifying branches or conditionals is
the following, from left to right:

1.  A label for the type of branch or conditional.
2.  A unique identifier.
3.  The starting line number it appears on in the file.
4.  The starting column number it appears on in the file.
5.  The ending line number it appears on in the file.
6.  The ending column number it appears on in the file.


## Methods Coverage

Methods coverage reports how many times each method was executed.

    [foo_method.rb]
    class Greeter
      def greet
        "welcome!"
      end
    end

    def hello
      "Hi"
    end

    hello()
    Greeter.new.greet()
    [EOF]

    require "coverage"
    Coverage.start(methods: true)
    require "foo_method.rb"
    p Coverage.result #=> {"foo_method.rb"=>{:methods=>{[Object, :hello, 7, 0, 9, 3]=>1, [Greeter, :greet, 2, 2, 4, 5]=>1}}}

Each entry within the methods hash represents a method. The values in this
hash are the number of times the method was executed, and the keys are
identifying information about the method.

The information that makes up each key identifying a method is the following,
from left to right:

1.  The class.
2.  The method name.
3.  The starting line number the method appears on in the file.
4.  The starting column number the method appears on in the file.
5.  The ending line number the method appears on in the file.
6.  The ending column number the method appears on in the file.


## All Coverage Modes

You can also run all modes of coverage simultaneously with this shortcut. Note
that running all coverage modes does not run both lines and oneshot lines.
Those modes cannot be run simultaneously. Lines coverage is run in this case,
because you can still use it to determine whether or not a line was executed.

    require "coverage"
    Coverage.start(:all)
    require "foo.rb"
    p Coverage.result #=> {"foo.rb"=>{:lines=>[1, 1, 10, nil, nil, 1, 1, nil, 0, nil], :branches=>{[:if, 0, 6, 0, 10, 3]=>{[:then, 1, 7, 2, 7, 7]=>1, [:else, 2, 9, 2, 9, 7]=>0}}, :methods=>{}}}

;T;0;	I"Coverage;T;
[ ;[ ;0;[ ;[ o;;I" ;T;0;;;I"line_stub;F;I"Coverage;T;[o;;I" ;F;I"Array[::Integer?];To;;I"ÄReturns a hash that contains filename as key and coverage array as value. This
is the same as `Coverage.result(stop: false, clear: false)`.

    {
      "file.rb" => [1, 2, nil],
      ...
    }

;T;0;;;I"peek_result;F;I"Coverage;T;[o;;I" ;F;I"Hash[::String, untyped];To;;I"´Returns a hash that contains filename as key and coverage array as value. If
`clear` is true, it clears the counters to zero. If `stop` is true, it
disables coverage measurement.

;T;0;;;I"result;F;I"Coverage;T;[o;;I"(?stop: ::boolish, ?clear: ::boolish;T;I"Hash[::String, untyped];To;;I"{Returns true if coverage stats are currently being collected (after
Coverage.start call, but before Coverage.result call)

;T;0;;;I"running?;F;I"Coverage;T;[o;;I" ;F;I"	bool;To;;I"Enables the coverage measurement. See the documentation of Coverage class in
detail. This is equivalent to Coverage.setup and Coverage.resume.

;T;0;;;I"
start;F;I"Coverage;T;[o;;I"\?lines: ::boolish, ?branches: ::boolish, ?methods: ::boolish, ?oneshot_lines: ::boolish;T;I"nil;To;;I">Start/resume the coverage measurement.

Caveat: Currently, only process-global coverage measurement is supported. You
cannot measure per-thread covearge. If your process has multiple thread, using
Coverage.resume/suspend to capture code coverage executed from only a limited
code block, may yield misleading results.

;T;0;;;I"resume;F;I"Coverage;T;[o;;I" ;F;I"nil;To;;I"`Suspend the coverage measurement. You can use Coverage.resume to restart the
measurement.

;T;0;;;I"suspend;F;I"Coverage;T;[o;;I" ;F;I"nil;To; ;I"ÊÍ## CSV
CSV (comma-separated variables) data is a text representation of a table:
*   A *row* *separator* delimits table rows. A common row separator is the
    newline character `"\n"`.
*   A *column* *separator* delimits fields in a row. A common column separator
    is the comma character `","`.


This CSV String, with row separator `"\n"` and column separator `","`, has
three rows and two columns:
    "foo,0\nbar,1\nbaz,2\n"

Despite the name CSV, a CSV representation can use different separators.

For more about tables, see the Wikipedia article "[Table
(information)](https://en.wikipedia.org/wiki/Table_(information))", especially
its section "[Simple
table](https://en.wikipedia.org/wiki/Table_(information)#Simple_table)"

## Class CSV

Class CSV provides methods for:
*   Parsing CSV data from a String object, a File (via its file path), or an
    IO object.
*   Generating CSV data to a String object.


To make CSV available:
    require 'csv'

All examples here assume that this has been done.

## Keeping It Simple

A CSV object has dozens of instance methods that offer fine-grained control of
parsing and generating CSV data. For many needs, though, simpler approaches
will do.

This section summarizes the singleton methods in CSV that allow you to parse
and generate without explicitly creating CSV objects. For details, follow the
links.

### Simple Parsing

Parsing methods commonly return either of:
*   An Array of Arrays of Strings:
    *   The outer Array is the entire "table".
    *   Each inner Array is a row.
    *   Each String is a field.

*   A CSV::Table object.  For details, see [\CSV with
    Headers](#class-CSV-label-CSV+with+Headers).


#### Parsing a String

The input to be parsed can be a string:
    string = "foo,0\nbar,1\nbaz,2\n"

Method CSV.parse returns the entire CSV data:
    CSV.parse(string) # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]

Method CSV.parse_line returns only the first row:
    CSV.parse_line(string) # => ["foo", "0"]

CSV extends class String with instance method String#parse_csv, which also
returns only the first row:
    string.parse_csv # => ["foo", "0"]

#### Parsing Via a File Path

The input to be parsed can be in a file:
    string = "foo,0\nbar,1\nbaz,2\n"
    path = 't.csv'
    File.write(path, string)

Method CSV.read returns the entire CSV data:
    CSV.read(path) # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]

Method CSV.foreach iterates, passing each row to the given block:
    CSV.foreach(path) do |row|
      p row
    end

Output:
    ["foo", "0"]
    ["bar", "1"]
    ["baz", "2"]

Method CSV.table returns the entire CSV data as a CSV::Table object:
    CSV.table(path) # => #<CSV::Table mode:col_or_row row_count:3>

#### Parsing from an Open IO Stream

The input to be parsed can be in an open IO stream:

Method CSV.read returns the entire CSV data:
    File.open(path) do |file|
      CSV.read(file)
    end # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]

As does method CSV.parse:
    File.open(path) do |file|
      CSV.parse(file)
    end # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]

Method CSV.parse_line returns only the first row:
    File.open(path) do |file|
     CSV.parse_line(file)
    end # => ["foo", "0"]

Method CSV.foreach iterates, passing each row to the given block:
    File.open(path) do |file|
      CSV.foreach(file) do |row|
        p row
      end
    end

Output:
    ["foo", "0"]
    ["bar", "1"]
    ["baz", "2"]

Method CSV.table returns the entire CSV data as a CSV::Table object:
    File.open(path) do |file|
      CSV.table(file)
    end # => #<CSV::Table mode:col_or_row row_count:3>

### Simple Generating

Method CSV.generate returns a String; this example uses method CSV#<< to
append the rows that are to be generated:
    output_string = CSV.generate do |csv|
      csv << ['foo', 0]
      csv << ['bar', 1]
      csv << ['baz', 2]
    end
    output_string # => "foo,0\nbar,1\nbaz,2\n"

Method CSV.generate_line returns a String containing the single row
constructed from an Array:
    CSV.generate_line(['foo', '0']) # => "foo,0\n"

CSV extends class Array with instance method `Array#to_csv`, which forms an
Array into a String:
    ['foo', '0'].to_csv # => "foo,0\n"

### "Filtering" CSV

Method CSV.filter provides a Unix-style filter for CSV data. The input data is
processed to form the output data:
    in_string = "foo,0\nbar,1\nbaz,2\n"
    out_string = ''
    CSV.filter(in_string, out_string) do |row|
      row[0] = row[0].upcase
      row[1] *= 4
    end
    out_string # => "FOO,0000\nBAR,1111\nBAZ,2222\n"

## CSV Objects

There are three ways to create a CSV object:
*   Method CSV.new returns a new CSV object.
*   Method CSV.instance returns a new or cached CSV object.
*   Method CSV() also returns a new or cached CSV object.


### Instance Methods

CSV has three groups of instance methods:
*   Its own internally defined instance methods.
*   Methods included by module Enumerable.
*   Methods delegated to class IO. See below.


#### Delegated Methods

For convenience, a CSV object will delegate to many methods in class IO. (A
few have wrapper "guard code" in CSV.) You may call:
*   IO#binmode
*   #binmode?
*   IO#close
*   IO#close_read
*   IO#close_write
*   IO#closed?
*   #eof
*   #eof?
*   IO#external_encoding
*   IO#fcntl
*   IO#fileno
*   #flock
*   IO#flush
*   IO#fsync
*   IO#internal_encoding
*   #ioctl
*   IO#isatty
*   #path
*   IO#pid
*   IO#pos
*   IO#pos=
*   IO#reopen
*   #rewind
*   IO#seek
*   #stat
*   IO#string
*   IO#sync
*   IO#sync=
*   IO#tell
*   #to_i
*   #to_io
*   IO#truncate
*   IO#tty?


### Options

The default values for options are:
    DEFAULT_OPTIONS = {
      # For both parsing and generating.
      col_sep:            ",",
      row_sep:            :auto,
      quote_char:         '"',
      # For parsing.
      field_size_limit:   nil,
      converters:         nil,
      unconverted_fields: nil,
      headers:            false,
      return_headers:     false,
      header_converters:  nil,
      skip_blanks:        false,
      skip_lines:         nil,
      liberal_parsing:    false,
      nil_value:          nil,
      empty_value:        "",
      strip:              false,
      # For generating.
      write_headers:      nil,
      quote_empty:        true,
      force_quotes:       false,
      write_converters:   nil,
      write_nil_value:    nil,
      write_empty_value:  "",
    }

#### Options for Parsing

Options for parsing, described in detail below, include:
*   `row_sep`: Specifies the row separator; used to delimit rows.
*   `col_sep`: Specifies the column separator; used to delimit fields.
*   `quote_char`: Specifies the quote character; used to quote fields.
*   `field_size_limit`: Specifies the maximum field size allowed.
*   `converters`: Specifies the field converters to be used.
*   `unconverted_fields`: Specifies whether unconverted fields are to be
    available.
*   `headers`: Specifies whether data contains headers, or specifies the
    headers themselves.
*   `return_headers`: Specifies whether headers are to be returned.
*   `header_converters`: Specifies the header converters to be used.
*   `skip_blanks`: Specifies whether blanks lines are to be ignored.
*   `skip_lines`: Specifies how comments lines are to be recognized.
*   `strip`: Specifies whether leading and trailing whitespace are to be
    stripped from fields. This must be compatible with `col_sep`; if it is
    not, then an `ArgumentError` exception will be raised.
*   `liberal_parsing`: Specifies whether CSV should attempt to parse
    non-compliant data.
*   `nil_value`: Specifies the object that is to be substituted for each null
    (no-text) field.
*   `empty_value`: Specifies the object that is to be substituted for each
    empty field.


###### Option `row_sep`

Specifies the row separator, a String or the Symbol `:auto` (see below), to be
used for both parsing and generating.

Default value:
    CSV::DEFAULT_OPTIONS.fetch(:row_sep) # => :auto

---

When `row_sep` is a String, that String becomes the row separator. The String
will be transcoded into the data's Encoding before use.

Using `"\n"`:
    row_sep = "\n"
    str = CSV.generate(row_sep: row_sep) do |csv|
      csv << [:foo, 0]
      csv << [:bar, 1]
      csv << [:baz, 2]
    end
    str # => "foo,0\nbar,1\nbaz,2\n"
    ary = CSV.parse(str)
    ary # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]

Using `|` (pipe):
    row_sep = '|'
    str = CSV.generate(row_sep: row_sep) do |csv|
      csv << [:foo, 0]
      csv << [:bar, 1]
      csv << [:baz, 2]
    end
    str # => "foo,0|bar,1|baz,2|"
    ary = CSV.parse(str, row_sep: row_sep)
    ary # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]

Using `--` (two hyphens):
    row_sep = '--'
    str = CSV.generate(row_sep: row_sep) do |csv|
      csv << [:foo, 0]
      csv << [:bar, 1]
      csv << [:baz, 2]
    end
    str # => "foo,0--bar,1--baz,2--"
    ary = CSV.parse(str, row_sep: row_sep)
    ary # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]

Using `''` (empty string):
    row_sep = ''
    str = CSV.generate(row_sep: row_sep) do |csv|
      csv << [:foo, 0]
      csv << [:bar, 1]
      csv << [:baz, 2]
    end
    str # => "foo,0bar,1baz,2"
    ary = CSV.parse(str, row_sep: row_sep)
    ary # => [["foo", "0bar", "1baz", "2"]]

---

When `row_sep` is the Symbol `:auto` (the default), generating uses `"\n"` as
the row separator:
    str = CSV.generate do |csv|
      csv << [:foo, 0]
      csv << [:bar, 1]
      csv << [:baz, 2]
    end
    str # => "foo,0\nbar,1\nbaz,2\n"

Parsing, on the other hand, invokes auto-discovery of the row separator.

Auto-discovery reads ahead in the data looking for the next `\r\n`, `\n`, or
`\r` sequence. The sequence will be selected even if it occurs in a quoted
field, assuming that you would have the same line endings there.

Example:
    str = CSV.generate do |csv|
      csv << [:foo, 0]
      csv << [:bar, 1]
      csv << [:baz, 2]
    end
    str # => "foo,0\nbar,1\nbaz,2\n"
    ary = CSV.parse(str)
    ary # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]

The default `$INPUT_RECORD_SEPARATOR` (`$/`) is used if any of the following
is true:
*   None of those sequences is found.
*   Data is `ARGF`, `STDIN`, `STDOUT`, or `STDERR`.
*   The stream is only available for output.


Obviously, discovery takes a little time. Set manually if speed is important.
Also note that IO objects should be opened in binary mode on Windows if this
feature will be used as the line-ending translation can cause problems with
resetting the document position to where it was before the read ahead.

---

Raises an exception if the given value is not String-convertible:
    row_sep = BasicObject.new
    # Raises NoMethodError (undefined method `to_s' for #<BasicObject:>)
    CSV.generate(ary, row_sep: row_sep)
    # Raises NoMethodError (undefined method `to_s' for #<BasicObject:>)
    CSV.parse(str, row_sep: row_sep)

###### Option `col_sep`

Specifies the String field separator to be used for both parsing and
generating. The String will be transcoded into the data's Encoding before use.

Default value:
    CSV::DEFAULT_OPTIONS.fetch(:col_sep) # => "," (comma)

Using the default (comma):
    str = CSV.generate do |csv|
      csv << [:foo, 0]
      csv << [:bar, 1]
      csv << [:baz, 2]
    end
    str # => "foo,0\nbar,1\nbaz,2\n"
    ary = CSV.parse(str)
    ary # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]

Using `:` (colon):
    col_sep = ':'
    str = CSV.generate(col_sep: col_sep) do |csv|
      csv << [:foo, 0]
      csv << [:bar, 1]
      csv << [:baz, 2]
    end
    str # => "foo:0\nbar:1\nbaz:2\n"
    ary = CSV.parse(str, col_sep: col_sep)
    ary # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]

Using `::` (two colons):
    col_sep = '::'
    str = CSV.generate(col_sep: col_sep) do |csv|
      csv << [:foo, 0]
      csv << [:bar, 1]
      csv << [:baz, 2]
    end
    str # => "foo::0\nbar::1\nbaz::2\n"
    ary = CSV.parse(str, col_sep: col_sep)
    ary # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]

Using `''` (empty string):
    col_sep = ''
    str = CSV.generate(col_sep: col_sep) do |csv|
      csv << [:foo, 0]
      csv << [:bar, 1]
      csv << [:baz, 2]
    end
    str # => "foo0\nbar1\nbaz2\n"

---

Raises an exception if parsing with the empty String:
    col_sep = ''
    # Raises ArgumentError (:col_sep must be 1 or more characters: "")
    CSV.parse("foo0\nbar1\nbaz2\n", col_sep: col_sep)

Raises an exception if the given value is not String-convertible:
    col_sep = BasicObject.new
    # Raises NoMethodError (undefined method `to_s' for #<BasicObject:>)
    CSV.generate(line, col_sep: col_sep)
    # Raises NoMethodError (undefined method `to_s' for #<BasicObject:>)
    CSV.parse(str, col_sep: col_sep)

###### Option `quote_char`

Specifies the character (String of length 1) used used to quote fields in both
parsing and generating. This String will be transcoded into the data's
Encoding before use.

Default value:
    CSV::DEFAULT_OPTIONS.fetch(:quote_char) # => "\"" (double quote)

This is useful for an application that incorrectly uses `'` (single-quote) to
quote fields, instead of the correct `"` (double-quote).

Using the default (double quote):
    str = CSV.generate do |csv|
      csv << ['foo', 0]
      csv << ["'bar'", 1]
      csv << ['"baz"', 2]
    end
    str # => "foo,0\n'bar',1\n\"\"\"baz\"\"\",2\n"
    ary = CSV.parse(str)
    ary # => [["foo", "0"], ["'bar'", "1"], ["\"baz\"", "2"]]

Using `'` (single-quote):
    quote_char = "'"
    str = CSV.generate(quote_char: quote_char) do |csv|
      csv << ['foo', 0]
      csv << ["'bar'", 1]
      csv << ['"baz"', 2]
    end
    str # => "foo,0\n'''bar''',1\n\"baz\",2\n"
    ary = CSV.parse(str, quote_char: quote_char)
    ary # => [["foo", "0"], ["'bar'", "1"], ["\"baz\"", "2"]]

---

Raises an exception if the String length is greater than 1:
    # Raises ArgumentError (:quote_char has to be nil or a single character String)
    CSV.new('', quote_char: 'xx')

Raises an exception if the value is not a String:
    # Raises ArgumentError (:quote_char has to be nil or a single character String)
    CSV.new('', quote_char: :foo)

###### Option `field_size_limit`

Specifies the Integer field size limit.

Default value:
    CSV::DEFAULT_OPTIONS.fetch(:field_size_limit) # => nil

This is a maximum size CSV will read ahead looking for the closing quote for a
field. (In truth, it reads to the first line ending beyond this size.) If a
quote cannot be found within the limit CSV will raise a MalformedCSVError,
assuming the data is faulty. You can use this limit to prevent what are
effectively DoS attacks on the parser. However, this limit can cause a
legitimate parse to fail; therefore the default value is `nil` (no limit).

For the examples in this section:
    str = <<~EOT
      "a","b"
      "
      2345
      ",""
    EOT
    str # => "\"a\",\"b\"\n\"\n2345\n\",\"\"\n"

Using the default `nil`:
    ary = CSV.parse(str)
    ary # => [["a", "b"], ["\n2345\n", ""]]

Using `50`:
    field_size_limit = 50
    ary = CSV.parse(str, field_size_limit: field_size_limit)
    ary # => [["a", "b"], ["\n2345\n", ""]]

---

Raises an exception if a field is too long:
    big_str = "123456789\n" * 1024
    # Raises CSV::MalformedCSVError (Field size exceeded in line 1.)
    CSV.parse('valid,fields,"' + big_str + '"', field_size_limit: 2048)

###### Option `converters`

Specifies converters to be used in parsing fields. See [Field
Converters](#class-CSV-label-Field+Converters)

Default value:
    CSV::DEFAULT_OPTIONS.fetch(:converters) # => nil

The value may be a field converter name (see [Stored
Converters](#class-CSV-label-Stored+Converters)):
    str = '1,2,3'
    # Without a converter
    array = CSV.parse_line(str)
    array # => ["1", "2", "3"]
    # With built-in converter :integer
    array = CSV.parse_line(str, converters: :integer)
    array # => [1, 2, 3]

The value may be a converter list (see [Converter
Lists](#class-CSV-label-Converter+Lists)):
    str = '1,3.14159'
    # Without converters
    array = CSV.parse_line(str)
    array # => ["1", "3.14159"]
    # With built-in converters
    array = CSV.parse_line(str, converters: [:integer, :float])
    array # => [1, 3.14159]

The value may be a Proc custom converter: (see [Custom Field
Converters](#class-CSV-label-Custom+Field+Converters)):
    str = ' foo  ,  bar  ,  baz  '
    # Without a converter
    array = CSV.parse_line(str)
    array # => [" foo  ", "  bar  ", "  baz  "]
    # With a custom converter
    array = CSV.parse_line(str, converters: proc {|field| field.strip })
    array # => ["foo", "bar", "baz"]

See also [Custom Field Converters](#class-CSV-label-Custom+Field+Converters)

---

Raises an exception if the converter is not a converter name or a Proc:
    str = 'foo,0'
    # Raises NoMethodError (undefined method `arity' for nil:NilClass)
    CSV.parse(str, converters: :foo)

###### Option `unconverted_fields`

Specifies the boolean that determines whether unconverted field values are to
be available.

Default value:
    CSV::DEFAULT_OPTIONS.fetch(:unconverted_fields) # => nil

The unconverted field values are those found in the source data, prior to any
conversions performed via option `converters`.

When option `unconverted_fields` is `true`, each returned row (Array or
CSV::Row) has an added method, `unconverted_fields`, that returns the
unconverted field values:
    str = <<-EOT
    foo,0
    bar,1
    baz,2
    EOT
    # Without unconverted_fields
    csv = CSV.parse(str, converters: :integer)
    csv # => [["foo", 0], ["bar", 1], ["baz", 2]]
    csv.first.respond_to?(:unconverted_fields) # => false
    # With unconverted_fields
    csv = CSV.parse(str, converters: :integer, unconverted_fields: true)
    csv # => [["foo", 0], ["bar", 1], ["baz", 2]]
    csv.first.respond_to?(:unconverted_fields) # => true
    csv.first.unconverted_fields # => ["foo", "0"]

###### Option `headers`

Specifies a boolean, Symbol, Array, or String to be used to define column
headers.

Default value:
    CSV::DEFAULT_OPTIONS.fetch(:headers) # => false

---

Without `headers`:
    str = <<-EOT
    Name,Count
    foo,0
    bar,1
    bax,2
    EOT
    csv = CSV.new(str)
    csv # => #<CSV io_type:StringIO encoding:UTF-8 lineno:0 col_sep:"," row_sep:"\n" quote_char:"\"">
    csv.headers # => nil
    csv.shift # => ["Name", "Count"]

---

If set to `true` or the Symbol `:first_row`, the first row of the data is
treated as a row of headers:
    str = <<-EOT
    Name,Count
    foo,0
    bar,1
    bax,2
    EOT
    csv = CSV.new(str, headers: true)
    csv # => #<CSV io_type:StringIO encoding:UTF-8 lineno:2 col_sep:"," row_sep:"\n" quote_char:"\"" headers:["Name", "Count"]>
    csv.headers # => ["Name", "Count"]
    csv.shift # => #<CSV::Row "Name":"bar" "Count":"1">

---

If set to an Array, the Array elements are treated as headers:
    str = <<-EOT
    foo,0
    bar,1
    bax,2
    EOT
    csv = CSV.new(str, headers: ['Name', 'Count'])
    csv
    csv.headers # => ["Name", "Count"]
    csv.shift # => #<CSV::Row "Name":"bar" "Count":"1">

---

If set to a String `str`, method `CSV::parse_line(str, options)` is called
with the current `options`, and the returned Array is treated as headers:
    str = <<-EOT
    foo,0
    bar,1
    bax,2
    EOT
    csv = CSV.new(str, headers: 'Name,Count')
    csv
    csv.headers # => ["Name", "Count"]
    csv.shift # => #<CSV::Row "Name":"bar" "Count":"1">

###### Option `return_headers`

Specifies the boolean that determines whether method #shift returns or ignores
the header row.

Default value:
    CSV::DEFAULT_OPTIONS.fetch(:return_headers) # => false

Examples:
    str = <<-EOT
    Name,Count
    foo,0
    bar,1
    bax,2
    EOT
    # Without return_headers first row is str.
    csv = CSV.new(str, headers: true)
    csv.shift # => #<CSV::Row "Name":"foo" "Count":"0">
    # With return_headers first row is headers.
    csv = CSV.new(str, headers: true, return_headers: true)
    csv.shift # => #<CSV::Row "Name":"Name" "Count":"Count">

###### Option `header_converters`

Specifies converters to be used in parsing headers. See [Header
Converters](#class-CSV-label-Header+Converters)

Default value:
    CSV::DEFAULT_OPTIONS.fetch(:header_converters) # => nil

Identical in functionality to option
[converters](#class-CSV-label-Option+converters) except that:
*   The converters apply only to the header row.
*   The built-in header converters are `:downcase` and `:symbol`.


This section assumes prior execution of:
    str = <<-EOT
    Name,Value
    foo,0
    bar,1
    baz,2
    EOT
    # With no header converter
    table = CSV.parse(str, headers: true)
    table.headers # => ["Name", "Value"]

The value may be a header converter name (see [Stored
Converters](#class-CSV-label-Stored+Converters)):
    table = CSV.parse(str, headers: true, header_converters: :downcase)
    table.headers # => ["name", "value"]

The value may be a converter list (see [Converter
Lists](#class-CSV-label-Converter+Lists)):
    header_converters = [:downcase, :symbol]
    table = CSV.parse(str, headers: true, header_converters: header_converters)
    table.headers # => [:name, :value]

The value may be a Proc custom converter (see [Custom Header
Converters](#class-CSV-label-Custom+Header+Converters)):
    upcase_converter = proc {|field| field.upcase }
    table = CSV.parse(str, headers: true, header_converters: upcase_converter)
    table.headers # => ["NAME", "VALUE"]

See also [Custom Header Converters](#class-CSV-label-Custom+Header+Converters)

###### Option `skip_blanks`

Specifies a boolean that determines whether blank lines in the input will be
ignored; a line that contains a column separator is not considered to be
blank.

Default value:
    CSV::DEFAULT_OPTIONS.fetch(:skip_blanks) # => false

See also option [skiplines](#class-CSV-label-Option+skip_lines).

For examples in this section:
    str = <<-EOT
    foo,0

    bar,1
    baz,2

    ,
    EOT

Using the default, `false`:
    ary = CSV.parse(str)
    ary # => [["foo", "0"], [], ["bar", "1"], ["baz", "2"], [], [nil, nil]]

Using `true`:
    ary = CSV.parse(str, skip_blanks: true)
    ary # => [["foo", "0"], ["bar", "1"], ["baz", "2"], [nil, nil]]

Using a truthy value:
    ary = CSV.parse(str, skip_blanks: :foo)
    ary # => [["foo", "0"], ["bar", "1"], ["baz", "2"], [nil, nil]]

###### Option `skip_lines`

Specifies an object to use in identifying comment lines in the input that are
to be ignored:
*   If a Regexp, ignores lines that match it.
*   If a String, converts it to a Regexp, ignores lines that match it.
*   If `nil`, no lines are considered to be comments.


Default value:
    CSV::DEFAULT_OPTIONS.fetch(:skip_lines) # => nil

For examples in this section:
    str = <<-EOT
    # Comment
    foo,0
    bar,1
    baz,2
    # Another comment
    EOT
    str # => "# Comment\nfoo,0\nbar,1\nbaz,2\n# Another comment\n"

Using the default, `nil`:
    ary = CSV.parse(str)
    ary # => [["# Comment"], ["foo", "0"], ["bar", "1"], ["baz", "2"], ["# Another comment"]]

Using a Regexp:
    ary = CSV.parse(str, skip_lines: /^#/)
    ary # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]

Using a String:
    ary = CSV.parse(str, skip_lines: '#')
    ary # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]

---

Raises an exception if given an object that is not a Regexp, a String, or
`nil`:
    # Raises ArgumentError (:skip_lines has to respond to #match: 0)
    CSV.parse(str, skip_lines: 0)

###### Option `strip`

Specifies the boolean value that determines whether whitespace is stripped
from each input field.

Default value:
    CSV::DEFAULT_OPTIONS.fetch(:strip) # => false

With default value `false`:
    ary = CSV.parse_line(' a , b ')
    ary # => [" a ", " b "]

With value `true`:
    ary = CSV.parse_line(' a , b ', strip: true)
    ary # => ["a", "b"]

###### Option `liberal_parsing`

Specifies the boolean value that determines whether CSV will attempt to parse
input not conformant with RFC 4180, such as double quotes in unquoted fields.

Default value:
    CSV::DEFAULT_OPTIONS.fetch(:liberal_parsing) # => false

For examples in this section:
    str = 'is,this "three, or four",fields'

Without `liberal_parsing`:
    # Raises CSV::MalformedCSVError (Illegal quoting in str 1.)
    CSV.parse_line(str)

With `liberal_parsing`:
    ary = CSV.parse_line(str, liberal_parsing: true)
    ary # => ["is", "this \"three", " or four\"", "fields"]

###### Option `nil_value`

Specifies the object that is to be substituted for each null (no-text) field.

Default value:
    CSV::DEFAULT_OPTIONS.fetch(:nil_value) # => nil

With the default, `nil`:
    CSV.parse_line('a,,b,,c') # => ["a", nil, "b", nil, "c"]

With a different object:
    CSV.parse_line('a,,b,,c', nil_value: 0) # => ["a", 0, "b", 0, "c"]

###### Option `empty_value`

Specifies the object that is to be substituted for each field that has an
empty String.

Default value:
    CSV::DEFAULT_OPTIONS.fetch(:empty_value) # => "" (empty string)

With the default, `""`:
    CSV.parse_line('a,"",b,"",c') # => ["a", "", "b", "", "c"]

With a different object:
    CSV.parse_line('a,"",b,"",c', empty_value: 'x') # => ["a", "x", "b", "x", "c"]

#### Options for Generating

Options for generating, described in detail below, include:
*   `row_sep`: Specifies the row separator; used to delimit rows.
*   `col_sep`: Specifies the column separator; used to delimit fields.
*   `quote_char`: Specifies the quote character; used to quote fields.
*   `write_headers`: Specifies whether headers are to be written.
*   `force_quotes`: Specifies whether each output field is to be quoted.
*   `quote_empty`: Specifies whether each empty output field is to be quoted.
*   `write_converters`: Specifies the field converters to be used in writing.
*   `write_nil_value`: Specifies the object that is to be substituted for each
    `nil`-valued field.
*   `write_empty_value`: Specifies the object that is to be substituted for
    each empty field.


###### Option `row_sep`

Specifies the row separator, a String or the Symbol `:auto` (see below), to be
used for both parsing and generating.

Default value:
    CSV::DEFAULT_OPTIONS.fetch(:row_sep) # => :auto

---

When `row_sep` is a String, that String becomes the row separator. The String
will be transcoded into the data's Encoding before use.

Using `"\n"`:
    row_sep = "\n"
    str = CSV.generate(row_sep: row_sep) do |csv|
      csv << [:foo, 0]
      csv << [:bar, 1]
      csv << [:baz, 2]
    end
    str # => "foo,0\nbar,1\nbaz,2\n"
    ary = CSV.parse(str)
    ary # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]

Using `|` (pipe):
    row_sep = '|'
    str = CSV.generate(row_sep: row_sep) do |csv|
      csv << [:foo, 0]
      csv << [:bar, 1]
      csv << [:baz, 2]
    end
    str # => "foo,0|bar,1|baz,2|"
    ary = CSV.parse(str, row_sep: row_sep)
    ary # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]

Using `--` (two hyphens):
    row_sep = '--'
    str = CSV.generate(row_sep: row_sep) do |csv|
      csv << [:foo, 0]
      csv << [:bar, 1]
      csv << [:baz, 2]
    end
    str # => "foo,0--bar,1--baz,2--"
    ary = CSV.parse(str, row_sep: row_sep)
    ary # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]

Using `''` (empty string):
    row_sep = ''
    str = CSV.generate(row_sep: row_sep) do |csv|
      csv << [:foo, 0]
      csv << [:bar, 1]
      csv << [:baz, 2]
    end
    str # => "foo,0bar,1baz,2"
    ary = CSV.parse(str, row_sep: row_sep)
    ary # => [["foo", "0bar", "1baz", "2"]]

---

When `row_sep` is the Symbol `:auto` (the default), generating uses `"\n"` as
the row separator:
    str = CSV.generate do |csv|
      csv << [:foo, 0]
      csv << [:bar, 1]
      csv << [:baz, 2]
    end
    str # => "foo,0\nbar,1\nbaz,2\n"

Parsing, on the other hand, invokes auto-discovery of the row separator.

Auto-discovery reads ahead in the data looking for the next `\r\n`, `\n`, or
`\r` sequence. The sequence will be selected even if it occurs in a quoted
field, assuming that you would have the same line endings there.

Example:
    str = CSV.generate do |csv|
      csv << [:foo, 0]
      csv << [:bar, 1]
      csv << [:baz, 2]
    end
    str # => "foo,0\nbar,1\nbaz,2\n"
    ary = CSV.parse(str)
    ary # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]

The default `$INPUT_RECORD_SEPARATOR` (`$/`) is used if any of the following
is true:
*   None of those sequences is found.
*   Data is `ARGF`, `STDIN`, `STDOUT`, or `STDERR`.
*   The stream is only available for output.


Obviously, discovery takes a little time. Set manually if speed is important.
Also note that IO objects should be opened in binary mode on Windows if this
feature will be used as the line-ending translation can cause problems with
resetting the document position to where it was before the read ahead.

---

Raises an exception if the given value is not String-convertible:
    row_sep = BasicObject.new
    # Raises NoMethodError (undefined method `to_s' for #<BasicObject:>)
    CSV.generate(ary, row_sep: row_sep)
    # Raises NoMethodError (undefined method `to_s' for #<BasicObject:>)
    CSV.parse(str, row_sep: row_sep)

###### Option `col_sep`

Specifies the String field separator to be used for both parsing and
generating. The String will be transcoded into the data's Encoding before use.

Default value:
    CSV::DEFAULT_OPTIONS.fetch(:col_sep) # => "," (comma)

Using the default (comma):
    str = CSV.generate do |csv|
      csv << [:foo, 0]
      csv << [:bar, 1]
      csv << [:baz, 2]
    end
    str # => "foo,0\nbar,1\nbaz,2\n"
    ary = CSV.parse(str)
    ary # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]

Using `:` (colon):
    col_sep = ':'
    str = CSV.generate(col_sep: col_sep) do |csv|
      csv << [:foo, 0]
      csv << [:bar, 1]
      csv << [:baz, 2]
    end
    str # => "foo:0\nbar:1\nbaz:2\n"
    ary = CSV.parse(str, col_sep: col_sep)
    ary # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]

Using `::` (two colons):
    col_sep = '::'
    str = CSV.generate(col_sep: col_sep) do |csv|
      csv << [:foo, 0]
      csv << [:bar, 1]
      csv << [:baz, 2]
    end
    str # => "foo::0\nbar::1\nbaz::2\n"
    ary = CSV.parse(str, col_sep: col_sep)
    ary # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]

Using `''` (empty string):
    col_sep = ''
    str = CSV.generate(col_sep: col_sep) do |csv|
      csv << [:foo, 0]
      csv << [:bar, 1]
      csv << [:baz, 2]
    end
    str # => "foo0\nbar1\nbaz2\n"

---

Raises an exception if parsing with the empty String:
    col_sep = ''
    # Raises ArgumentError (:col_sep must be 1 or more characters: "")
    CSV.parse("foo0\nbar1\nbaz2\n", col_sep: col_sep)

Raises an exception if the given value is not String-convertible:
    col_sep = BasicObject.new
    # Raises NoMethodError (undefined method `to_s' for #<BasicObject:>)
    CSV.generate(line, col_sep: col_sep)
    # Raises NoMethodError (undefined method `to_s' for #<BasicObject:>)
    CSV.parse(str, col_sep: col_sep)

###### Option `quote_char`

Specifies the character (String of length 1) used used to quote fields in both
parsing and generating. This String will be transcoded into the data's
Encoding before use.

Default value:
    CSV::DEFAULT_OPTIONS.fetch(:quote_char) # => "\"" (double quote)

This is useful for an application that incorrectly uses `'` (single-quote) to
quote fields, instead of the correct `"` (double-quote).

Using the default (double quote):
    str = CSV.generate do |csv|
      csv << ['foo', 0]
      csv << ["'bar'", 1]
      csv << ['"baz"', 2]
    end
    str # => "foo,0\n'bar',1\n\"\"\"baz\"\"\",2\n"
    ary = CSV.parse(str)
    ary # => [["foo", "0"], ["'bar'", "1"], ["\"baz\"", "2"]]

Using `'` (single-quote):
    quote_char = "'"
    str = CSV.generate(quote_char: quote_char) do |csv|
      csv << ['foo', 0]
      csv << ["'bar'", 1]
      csv << ['"baz"', 2]
    end
    str # => "foo,0\n'''bar''',1\n\"baz\",2\n"
    ary = CSV.parse(str, quote_char: quote_char)
    ary # => [["foo", "0"], ["'bar'", "1"], ["\"baz\"", "2"]]

---

Raises an exception if the String length is greater than 1:
    # Raises ArgumentError (:quote_char has to be nil or a single character String)
    CSV.new('', quote_char: 'xx')

Raises an exception if the value is not a String:
    # Raises ArgumentError (:quote_char has to be nil or a single character String)
    CSV.new('', quote_char: :foo)

###### Option `write_headers`

Specifies the boolean that determines whether a header row is included in the
output; ignored if there are no headers.

Default value:
    CSV::DEFAULT_OPTIONS.fetch(:write_headers) # => nil

Without `write_headers`:
    file_path = 't.csv'
    CSV.open(file_path,'w',
        :headers => ['Name','Value']
      ) do |csv|
        csv << ['foo', '0']
    end
    CSV.open(file_path) do |csv|
      csv.shift
    end # => ["foo", "0"]

With `write_headers`":
    CSV.open(file_path,'w',
        :write_headers=> true,
        :headers => ['Name','Value']
      ) do |csv|
        csv << ['foo', '0']
    end
    CSV.open(file_path) do |csv|
      csv.shift
    end # => ["Name", "Value"]

###### Option `force_quotes`

Specifies the boolean that determines whether each output field is to be
double-quoted.

Default value:
    CSV::DEFAULT_OPTIONS.fetch(:force_quotes) # => false

For examples in this section:
    ary = ['foo', 0, nil]

Using the default, `false`:
    str = CSV.generate_line(ary)
    str # => "foo,0,\n"

Using `true`:
    str = CSV.generate_line(ary, force_quotes: true)
    str # => "\"foo\",\"0\",\"\"\n"

###### Option `quote_empty`

Specifies the boolean that determines whether an empty value is to be
double-quoted.

Default value:
    CSV::DEFAULT_OPTIONS.fetch(:quote_empty) # => true

With the default `true`:
    CSV.generate_line(['"', ""]) # => "\"\"\"\",\"\"\n"

With `false`:
    CSV.generate_line(['"', ""], quote_empty: false) # => "\"\"\"\",\n"

###### Option `write_converters`

Specifies converters to be used in generating fields. See [Write
Converters](#class-CSV-label-Write+Converters)

Default value:
    CSV::DEFAULT_OPTIONS.fetch(:write_converters) # => nil

With no write converter:
    str = CSV.generate_line(["\na\n", "\tb\t", " c "])
    str # => "\"\na\n\",\tb\t, c \n"

With a write converter:
    strip_converter = proc {|field| field.strip }
    str = CSV.generate_line(["\na\n", "\tb\t", " c "], write_converters: strip_converter)
    str # => "a,b,c\n"

With two write converters (called in order):
    upcase_converter = proc {|field| field.upcase }
    downcase_converter = proc {|field| field.downcase }
    write_converters = [upcase_converter, downcase_converter]
    str = CSV.generate_line(['a', 'b', 'c'], write_converters: write_converters)
    str # => "a,b,c\n"

See also [Write Converters](#class-CSV-label-Write+Converters)

---

Raises an exception if the converter returns a value that is neither `nil` nor
String-convertible:
    bad_converter = proc {|field| BasicObject.new }
    # Raises NoMethodError (undefined method `is_a?' for #<BasicObject:>)
    CSV.generate_line(['a', 'b', 'c'], write_converters: bad_converter)#

###### Option `write_nil_value`

Specifies the object that is to be substituted for each `nil`-valued field.

Default value:
    CSV::DEFAULT_OPTIONS.fetch(:write_nil_value) # => nil

Without the option:
    str = CSV.generate_line(['a', nil, 'c', nil])
    str # => "a,,c,\n"

With the option:
    str = CSV.generate_line(['a', nil, 'c', nil], write_nil_value: "x")
    str # => "a,x,c,x\n"

###### Option `write_empty_value`

Specifies the object that is to be substituted for each field that has an
empty String.

Default value:
    CSV::DEFAULT_OPTIONS.fetch(:write_empty_value) # => ""

Without the option:
    str = CSV.generate_line(['a', '', 'c', ''])
    str # => "a,\"\",c,\"\"\n"

With the option:
    str = CSV.generate_line(['a', '', 'c', ''], write_empty_value: "x")
    str # => "a,x,c,x\n"

### CSV with Headers

CSV allows to specify column names of CSV file, whether they are in data, or
provided separately. If headers are specified, reading methods return an
instance of CSV::Table, consisting of CSV::Row.

    # Headers are part of data
    data = CSV.parse(<<~ROWS, headers: true)
      Name,Department,Salary
      Bob,Engineering,1000
      Jane,Sales,2000
      John,Management,5000
    ROWS

    data.class      #=> CSV::Table
    data.first      #=> #<CSV::Row "Name":"Bob" "Department":"Engineering" "Salary":"1000">
    data.first.to_h #=> {"Name"=>"Bob", "Department"=>"Engineering", "Salary"=>"1000"}

    # Headers provided by developer
    data = CSV.parse('Bob,Engineering,1000', headers: %i[name department salary])
    data.first      #=> #<CSV::Row name:"Bob" department:"Engineering" salary:"1000">

### Converters

By default, each value (field or header) parsed by CSV is formed into a
String. You can use a *field* *converter* or  *header* *converter* to
intercept and modify the parsed values:
*   See [Field Converters](#class-CSV-label-Field+Converters).
*   See [Header Converters](#class-CSV-label-Header+Converters).


Also by default, each value to be written during generation is written
'as-is'. You can use a *write* *converter* to modify values before writing.
*   See [Write Converters](#class-CSV-label-Write+Converters).


#### Specifying Converters

You can specify converters for parsing or generating in the `options` argument
to various CSV methods:
*   Option `converters` for converting parsed field values.
*   Option `header_converters` for converting parsed header values.
*   Option `write_converters` for converting values to be written (generated).


There are three forms for specifying converters:
*   A converter proc: executable code to be used for conversion.
*   A converter name: the name of a stored converter.
*   A converter list: an array of converter procs, converter names, and
    converter lists.


##### Converter Procs

This converter proc, `strip_converter`, accepts a value `field` and returns
`field.strip`:
    strip_converter = proc {|field| field.strip }

In this call to `CSV.parse`, the keyword argument `converters:
string_converter` specifies that:
*   Proc `string_converter` is to be called for each parsed field.
*   The converter's return value is to replace the `field` value.

Example:
    string = " foo , 0 \n bar , 1 \n baz , 2 \n"
    array = CSV.parse(string, converters: strip_converter)
    array # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]

A converter proc can receive a second argument, `field_info`, that contains
details about the field. This modified `strip_converter` displays its
arguments:
    strip_converter = proc do |field, field_info|
      p [field, field_info]
      field.strip
    end
    string = " foo , 0 \n bar , 1 \n baz , 2 \n"
    array = CSV.parse(string, converters: strip_converter)
    array # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]

Output:
    [" foo ", #<struct CSV::FieldInfo index=0, line=1, header=nil>]
    [" 0 ", #<struct CSV::FieldInfo index=1, line=1, header=nil>]
    [" bar ", #<struct CSV::FieldInfo index=0, line=2, header=nil>]
    [" 1 ", #<struct CSV::FieldInfo index=1, line=2, header=nil>]
    [" baz ", #<struct CSV::FieldInfo index=0, line=3, header=nil>]
    [" 2 ", #<struct CSV::FieldInfo index=1, line=3, header=nil>]

Each CSV::FieldInfo object shows:
*   The 0-based field index.
*   The 1-based line index.
*   The field header, if any.


##### Stored Converters

A converter may be given a name and stored in a structure where the parsing
methods can find it by name.

The storage structure for field converters is the Hash CSV::Converters. It has
several built-in converter procs:
*   `:integer`: converts each String-embedded integer into a true Integer.
*   `:float`: converts each String-embedded float into a true Float.
*   `:date`: converts each String-embedded date into a true Date.
*   `:date_time`: converts each String-embedded date-time into a true DateTime

. This example creates a converter proc, then stores it:
    strip_converter = proc {|field| field.strip }
    CSV::Converters[:strip] = strip_converter

Then the parsing method call can refer to the converter by its name, `:strip`:
    string = " foo , 0 \n bar , 1 \n baz , 2 \n"
    array = CSV.parse(string, converters: :strip)
    array # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]

The storage structure for header converters is the Hash CSV::HeaderConverters,
which works in the same way. It also has built-in converter procs:
*   `:downcase`: Downcases each header.
*   `:symbol`: Converts each header to a Symbol.


There is no such storage structure for write headers.

In order for the parsing methods to access stored converters in
non-main-Ractors, the storage structure must be made shareable first.
Therefore, `Ractor.make_shareable(CSV::Converters)` and
`Ractor.make_shareable(CSV::HeaderConverters)` must be called before the
creation of Ractors that use the converters stored in these structures. (Since
making the storage structures shareable involves freezing them, any custom
converters that are to be used must be added first.)

##### Converter Lists

A *converter* *list* is an Array that may include any assortment of:
*   Converter procs.
*   Names of stored converters.
*   Nested converter lists.


Examples:
    numeric_converters = [:integer, :float]
    date_converters = [:date, :date_time]
    [numeric_converters, strip_converter]
    [strip_converter, date_converters, :float]

Like a converter proc, a converter list may be named and stored in either
CSV::Converters or CSV::HeaderConverters:
    CSV::Converters[:custom] = [strip_converter, date_converters, :float]
    CSV::HeaderConverters[:custom] = [:downcase, :symbol]

There are two built-in converter lists:
    CSV::Converters[:numeric] # => [:integer, :float]
    CSV::Converters[:all] # => [:date_time, :numeric]

#### Field Converters

With no conversion, all parsed fields in all rows become Strings:
    string = "foo,0\nbar,1\nbaz,2\n"
    ary = CSV.parse(string)
    ary # => # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]

When you specify a field converter, each parsed field is passed to the
converter; its return value becomes the stored value for the field. A
converter might, for example, convert an integer embedded in a String into a
true Integer. (In fact, that's what built-in field converter `:integer` does.)

There are three ways to use field converters.

*   Using option [converters](#class-CSV-label-Option+converters) with a
    parsing method:
        ary = CSV.parse(string, converters: :integer)
        ary # => [0, 1, 2] # => [["foo", 0], ["bar", 1], ["baz", 2]]

*   Using option [converters](#class-CSV-label-Option+converters) with a new
    CSV instance:
        csv = CSV.new(string, converters: :integer)
        # Field converters in effect:
        csv.converters # => [:integer]
        csv.read # => [["foo", 0], ["bar", 1], ["baz", 2]]

*   Using method #convert to add a field converter to a CSV instance:
        csv = CSV.new(string)
        # Add a converter.
        csv.convert(:integer)
        csv.converters # => [:integer]
        csv.read # => [["foo", 0], ["bar", 1], ["baz", 2]]


Installing a field converter does not affect already-read rows:
    csv = CSV.new(string)
    csv.shift # => ["foo", "0"]
    # Add a converter.
    csv.convert(:integer)
    csv.converters # => [:integer]
    csv.read # => [["bar", 1], ["baz", 2]]

There are additional built-in converters, and custom converters are also
supported.

##### Built-In Field Converters

The built-in field converters are in Hash CSV::Converters:
*   Each key is a field converter name.
*   Each value is one of:
    *   A Proc field converter.
    *   An Array of field converter names.



Display:
    CSV::Converters.each_pair do |name, value|
      if value.kind_of?(Proc)
        p [name, value.class]
      else
        p [name, value]
      end
    end

Output:
    [:integer, Proc]
    [:float, Proc]
    [:numeric, [:integer, :float]]
    [:date, Proc]
    [:date_time, Proc]
    [:all, [:date_time, :numeric]]

Each of these converters transcodes values to UTF-8 before attempting
conversion. If a value cannot be transcoded to UTF-8 the conversion will fail
and the value will remain unconverted.

Converter `:integer` converts each field that Integer() accepts:
    data = '0,1,2,x'
    # Without the converter
    csv = CSV.parse_line(data)
    csv # => ["0", "1", "2", "x"]
    # With the converter
    csv = CSV.parse_line(data, converters: :integer)
    csv # => [0, 1, 2, "x"]

Converter `:float` converts each field that Float() accepts:
    data = '1.0,3.14159,x'
    # Without the converter
    csv = CSV.parse_line(data)
    csv # => ["1.0", "3.14159", "x"]
    # With the converter
    csv = CSV.parse_line(data, converters: :float)
    csv # => [1.0, 3.14159, "x"]

Converter `:numeric` converts with both `:integer` and `:float`..

Converter `:date` converts each field that Date::parse accepts:
    data = '2001-02-03,x'
    # Without the converter
    csv = CSV.parse_line(data)
    csv # => ["2001-02-03", "x"]
    # With the converter
    csv = CSV.parse_line(data, converters: :date)
    csv # => [#<Date: 2001-02-03 ((2451944j,0s,0n),+0s,2299161j)>, "x"]

Converter `:date_time` converts each field that DateTime::parse accepts:
    data = '2020-05-07T14:59:00-05:00,x'
    # Without the converter
    csv = CSV.parse_line(data)
    csv # => ["2020-05-07T14:59:00-05:00", "x"]
    # With the converter
    csv = CSV.parse_line(data, converters: :date_time)
    csv # => [#<DateTime: 2020-05-07T14:59:00-05:00 ((2458977j,71940s,0n),-18000s,2299161j)>, "x"]

Converter `:numeric` converts with both `:date_time` and `:numeric`..

As seen above, method #convert adds converters to a CSV instance, and method
#converters returns an Array of the converters in effect:
    csv = CSV.new('0,1,2')
    csv.converters # => []
    csv.convert(:integer)
    csv.converters # => [:integer]
    csv.convert(:date)
    csv.converters # => [:integer, :date]

##### Custom Field Converters

You can define a custom field converter:
    strip_converter = proc {|field| field.strip }
    string = " foo , 0 \n bar , 1 \n baz , 2 \n"
    array = CSV.parse(string, converters: strip_converter)
    array # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]

You can register the converter in Converters Hash, which allows you to refer
to it by name:
    CSV::Converters[:strip] = strip_converter
    string = " foo , 0 \n bar , 1 \n baz , 2 \n"
    array = CSV.parse(string, converters: :strip)
    array # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]

#### Header Converters

Header converters operate only on headers (and not on other rows).

There are three ways to use header converters; these examples use built-in
header converter `:dowhcase`, which downcases each parsed header.

*   Option `header_converters` with a singleton parsing method:
        string = "Name,Count\nFoo,0\n,Bar,1\nBaz,2"
        tbl = CSV.parse(string, headers: true, header_converters: :downcase)
        tbl.class # => CSV::Table
        tbl.headers # => ["name", "count"]

*   Option `header_converters` with a new CSV instance:
        csv = CSV.new(string, header_converters: :downcase)
        # Header converters in effect:
        csv.header_converters # => [:downcase]
        tbl = CSV.parse(string, headers: true)
        tbl.headers # => ["Name", "Count"]

*   Method #header_convert adds a header converter to a CSV instance:
        csv = CSV.new(string)
        # Add a header converter.
        csv.header_convert(:downcase)
        csv.header_converters # => [:downcase]
        tbl = CSV.parse(string, headers: true)
        tbl.headers # => ["Name", "Count"]


##### Built-In Header Converters

The built-in header converters are in Hash CSV::HeaderConverters. The keys
there are the names of the converters:
    CSV::HeaderConverters.keys # => [:downcase, :symbol]

Converter `:downcase` converts each header by downcasing it:
    string = "Name,Count\nFoo,0\n,Bar,1\nBaz,2"
    tbl = CSV.parse(string, headers: true, header_converters: :downcase)
    tbl.class # => CSV::Table
    tbl.headers # => ["name", "count"]

Converter `:symbol` converts each header by making it into a Symbol:
    string = "Name,Count\nFoo,0\n,Bar,1\nBaz,2"
    tbl = CSV.parse(string, headers: true, header_converters: :symbol)
    tbl.headers # => [:name, :count]

Details:
*   Strips leading and trailing whitespace.
*   Downcases the header.
*   Replaces embedded spaces with underscores.
*   Removes non-word characters.
*   Makes the string into a Symbol.


##### Custom Header Converters

You can define a custom header converter:
    upcase_converter = proc {|header| header.upcase }
    string = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
    table = CSV.parse(string, headers: true, header_converters: upcase_converter)
    table # => #<CSV::Table mode:col_or_row row_count:4>
    table.headers # => ["NAME", "VALUE"]

You can register the converter in HeaderConverters Hash, which allows you to
refer to it by name:
    CSV::HeaderConverters[:upcase] = upcase_converter
    table = CSV.parse(string, headers: true, header_converters: :upcase)
    table # => #<CSV::Table mode:col_or_row row_count:4>
    table.headers # => ["NAME", "VALUE"]

##### Write Converters

When you specify a write converter for generating CSV, each field to be
written is passed to the converter; its return value becomes the new value for
the field. A converter might, for example, strip whitespace from a field.

Using no write converter (all fields unmodified):
    output_string = CSV.generate do |csv|
      csv << [' foo ', 0]
      csv << [' bar ', 1]
      csv << [' baz ', 2]
    end
    output_string # => " foo ,0\n bar ,1\n baz ,2\n"

Using option `write_converters` with two custom write converters:
    strip_converter = proc {|field| field.respond_to?(:strip) ? field.strip : field }
    upcase_converter = proc {|field| field.respond_to?(:upcase) ? field.upcase : field }
    write_converters = [strip_converter, upcase_converter]
    output_string = CSV.generate(write_converters: write_converters) do |csv|
      csv << [' foo ', 0]
      csv << [' bar ', 1]
      csv << [' baz ', 2]
    end
    output_string # => "FOO,0\nBAR,1\nBAZ,2\n"

### Character Encodings (M17n or Multilingualization)

This new CSV parser is m17n savvy.  The parser works in the Encoding of the IO
or String object being read from or written to. Your data is never transcoded
(unless you ask Ruby to transcode it for you) and will literally be parsed in
the Encoding it is in. Thus CSV will return Arrays or Rows of Strings in the
Encoding of your data. This is accomplished by transcoding the parser itself
into your Encoding.

Some transcoding must take place, of course, to accomplish this multiencoding
support. For example, `:col_sep`, `:row_sep`, and `:quote_char` must be
transcoded to match your data.  Hopefully this makes the entire process feel
transparent, since CSV's defaults should just magically work for your data.
However, you can set these values manually in the target Encoding to avoid the
translation.

It's also important to note that while all of CSV's core parser is now
Encoding agnostic, some features are not. For example, the built-in converters
will try to transcode data to UTF-8 before making conversions. Again, you can
provide custom converters that are aware of your Encodings to avoid this
translation. It's just too hard for me to support native conversions in all of
Ruby's Encodings.

Anyway, the practical side of this is simple: make sure IO and String objects
passed into CSV have the proper Encoding set and everything should just work.
CSV methods that allow you to open IO objects (CSV::foreach(), CSV::open(),
CSV::read(), and CSV::readlines()) do allow you to specify the Encoding.

One minor exception comes when generating CSV into a String with an Encoding
that is not ASCII compatible. There's no existing data for CSV to use to
prepare itself and thus you will probably need to manually specify the desired
Encoding for most of those cases. It will try to guess using the fields in a
row of output though, when using CSV::generate_line() or Array#to_csv().

I try to point out any other Encoding issues in the documentation of methods
as they come up.

This has been tested to the best of my ability with all non-"dummy" Encodings
Ruby ships with. However, it is brave new code and may have some bugs. Please
feel free to [report](mailto:james@grayproductions.net) any issues you find
with it.

;T;0;	I"CSV;T;
[ ;[I"Enumerable;T;0;[ ;[ ;0;I"Object;To;;I"eCalls the block with each row read from source `path` or `io`.

*   Argument `path`, if given, must be the path to a file.
*   Argument `io` should be an IO object that is:
    *   Open for reading; on return, the IO object will be closed.
    *   Positioned at the beginning. To position at the end, for appending,
        use method CSV.generate. For any other positioning, pass a preset
        StringIO object instead.

*   Argument `mode`, if given, must be a File mode See [Open
    Mode](IO.html#method-c-new-label-Open+Mode).
*   Arguments `**options` must be keyword options. See [Options for
    Parsing](#class-CSV-label-Options+for+Parsing).
*   This method optionally accepts an additional `:encoding` option that you
    can use to specify the Encoding of the data read from `path` or `io`. You
    must provide this unless your data is in the encoding given by
    `Encoding::default_external`. Parsing will use this to determine how to
    parse the data. You may provide a second Encoding to have the data
    transcoded as it is read. For example,
        encoding: 'UTF-32BE:UTF-8'

    would read `UTF-32BE` data from the file but transcode it to `UTF-8`
    before parsing.


###### Without Option `headers`

Without option `headers`, returns each row as an Array object.

These examples assume prior execution of:
    string = "foo,0\nbar,1\nbaz,2\n"
    path = 't.csv'
    File.write(path, string)

Read rows from a file at `path`:
    CSV.foreach(path) {|row| p row }

Output:
    ["foo", "0"]
    ["bar", "1"]
    ["baz", "2"]

Read rows from an IO object:
    File.open(path) do |file|
      CSV.foreach(file) {|row| p row }
    end

Output:
    ["foo", "0"]
    ["bar", "1"]
    ["baz", "2"]

Returns a new Enumerator if no block given:
    CSV.foreach(path) # => #<Enumerator: CSV:foreach("t.csv", "r")>
    CSV.foreach(File.open(path)) # => #<Enumerator: CSV:foreach(#<File:t.csv>, "r")>

Issues a warning if an encoding is unsupported:
    CSV.foreach(File.open(path), encoding: 'foo:bar') {|row| }

Output:
    warning: Unsupported encoding foo ignored
    warning: Unsupported encoding bar ignored

###### With Option `headers`

With {option `headers`[}](#class-CSV-label-Option+headers), returns each row
as a CSV::Row object.

These examples assume prior execution of:
    string = "Name,Count\nfoo,0\nbar,1\nbaz,2\n"
    path = 't.csv'
    File.write(path, string)

Read rows from a file at `path`:
    CSV.foreach(path, headers: true) {|row| p row }

Output:
    #<CSV::Row "Name":"foo" "Count":"0">
    #<CSV::Row "Name":"bar" "Count":"1">
    #<CSV::Row "Name":"baz" "Count":"2">

Read rows from an IO object:
    File.open(path) do |file|
      CSV.foreach(file, headers: true) {|row| p row }
    end

Output:
    #<CSV::Row "Name":"foo" "Count":"0">
    #<CSV::Row "Name":"bar" "Count":"1">
    #<CSV::Row "Name":"baz" "Count":"2">

---

Raises an exception if `path` is a String, but not the path to a readable
file:
    # Raises Errno::ENOENT (No such file or directory @ rb_sysopen - nosuch.csv):
    CSV.foreach('nosuch.csv') {|row| }

Raises an exception if `io` is an IO object, but not open for reading:
    io = File.open(path, 'w') {|row| }
    # Raises TypeError (no implicit conversion of nil into String):
    CSV.foreach(io) {|row| }

Raises an exception if `mode` is invalid:
    # Raises ArgumentError (invalid access mode nosuch):
    CSV.foreach(path, 'nosuch') {|row| }

;T;0;;;I"foreach;F;I"CSV;T;[o;;I"D::String | ::IO | ::StringIO path, ?::Hash[::Symbol, U] options;T;I"	void;To;;I"¾Returns the new CSV object created using `string` or `io` and the specified
`options`.

*   Argument `string` should be a String object; it will be put into a new
    StringIO object positioned at the beginning.
*   Argument `io` should be an IO object that is:
    *   Open for reading; on return, the IO object will be closed.
    *   Positioned at the beginning. To position at the end, for appending,
        use method CSV.generate. For any other positioning, pass a preset
        StringIO object instead.

*   Argument `options`: See:
    *   [Options for Parsing](#class-CSV-label-Options+for+Parsing)
    *   [Options for Generating](#class-CSV-label-Options+for+Generating)

    For performance reasons, the options cannot be overridden in a CSV object,
    so those specified here will endure.


In addition to the CSV instance methods, several IO methods are delegated. See
[Delegated Methods](#class-CSV-label-Delegated+Methods).

---

Create a CSV object from a String object:
    csv = CSV.new('foo,0')
    csv # => #<CSV io_type:StringIO encoding:UTF-8 lineno:0 col_sep:"," row_sep:"\n" quote_char:"\"">

Create a CSV object from a File object:
    File.write('t.csv', 'foo,0')
    csv = CSV.new(File.open('t.csv'))
    csv # => #<CSV io_type:File io_path:"t.csv" encoding:UTF-8 lineno:0 col_sep:"," row_sep:"\n" quote_char:"\"">

---

Raises an exception if the argument is `nil`:
    # Raises ArgumentError (Cannot parse nil as CSV):
    CSV.new(nil)

;T;0;;;I"initialize;F;I"CSV;T;[o;;I"I?::String | ::IO | ::StringIO io, ?::Hash[::Symbol, untyped] options;T;I"	void;To;;I"1Parses `string` or `io` using the specified `options`.

*   Argument `string` should be a String object; it will be put into a new
    StringIO object positioned at the beginning.
*   Argument `io` should be an IO object that is:
    *   Open for reading; on return, the IO object will be closed.
    *   Positioned at the beginning. To position at the end, for appending,
        use method CSV.generate. For any other positioning, pass a preset
        StringIO object instead.

*   Argument `options`: see [Options for
    Parsing](#class-CSV-label-Options+for+Parsing)


###### Without Option `headers`

Without {option `headers`[}](#class-CSV-label-Option+headers) case.

These examples assume prior execution of:
    string = "foo,0\nbar,1\nbaz,2\n"
    path = 't.csv'
    File.write(path, string)

---

With no block given, returns an Array of Arrays formed from the source.

Parse a String:
    a_of_a = CSV.parse(string)
    a_of_a # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]

Parse an open File:
    a_of_a = File.open(path) do |file|
      CSV.parse(file)
    end
    a_of_a # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]

---

With a block given, calls the block with each parsed row:

Parse a String:
    CSV.parse(string) {|row| p row }

Output:
    ["foo", "0"]
    ["bar", "1"]
    ["baz", "2"]

Parse an open File:
    File.open(path) do |file|
      CSV.parse(file) {|row| p row }
    end

Output:
    ["foo", "0"]
    ["bar", "1"]
    ["baz", "2"]

###### With Option `headers`

With {option `headers`[}](#class-CSV-label-Option+headers) case.

These examples assume prior execution of:
    string = "Name,Count\nfoo,0\nbar,1\nbaz,2\n"
    path = 't.csv'
    File.write(path, string)

---

With no block given, returns a CSV::Table object formed from the source.

Parse a String:
    csv_table = CSV.parse(string, headers: ['Name', 'Count'])
    csv_table # => #<CSV::Table mode:col_or_row row_count:5>

Parse an open File:
    csv_table = File.open(path) do |file|
      CSV.parse(file, headers: ['Name', 'Count'])
    end
    csv_table # => #<CSV::Table mode:col_or_row row_count:4>

---

With a block given, calls the block with each parsed row, which has been
formed into a CSV::Row object:

Parse a String:
    CSV.parse(string, headers: ['Name', 'Count']) {|row| p row }

Output:
    # <CSV::Row "Name":"foo" "Count":"0">
    # <CSV::Row "Name":"bar" "Count":"1">
    # <CSV::Row "Name":"baz" "Count":"2">

Parse an open File:
    File.open(path) do |file|
      CSV.parse(file, headers: ['Name', 'Count']) {|row| p row }
    end

Output:
    # <CSV::Row "Name":"foo" "Count":"0">
    # <CSV::Row "Name":"bar" "Count":"1">
    # <CSV::Row "Name":"baz" "Count":"2">

---

Raises an exception if the argument is not a String object or IO object:
    # Raises NoMethodError (undefined method `close' for :foo:Symbol)
    CSV.parse(:foo)

;T;0;;;I"
parse;F;I"CSV;T;[o;;I"5::String str, ?::Hash[::Symbol, untyped] options;T;I"Array[::Array[::String?]]?;To;;I"DReturns the data created by parsing the first line of `string` or `io` using
the specified `options`.

*   Argument `string` should be a String object; it will be put into a new
    StringIO object positioned at the beginning.
*   Argument `io` should be an IO object that is:
    *   Open for reading; on return, the IO object will be closed.
    *   Positioned at the beginning. To position at the end, for appending,
        use method CSV.generate. For any other positioning, pass a preset
        StringIO object instead.

*   Argument `options`: see [Options for
    Parsing](#class-CSV-label-Options+for+Parsing)


###### Without Option `headers`

Without option `headers`, returns the first row as a new Array.

These examples assume prior execution of:
    string = "foo,0\nbar,1\nbaz,2\n"
    path = 't.csv'
    File.write(path, string)

Parse the first line from a String object:
    CSV.parse_line(string) # => ["foo", "0"]

Parse the first line from a File object:
    File.open(path) do |file|
      CSV.parse_line(file) # => ["foo", "0"]
    end # => ["foo", "0"]

Returns `nil` if the argument is an empty String:
    CSV.parse_line('') # => nil

###### With Option `headers`

With {option `headers`[}](#class-CSV-label-Option+headers), returns the first
row as a CSV::Row object.

These examples assume prior execution of:
    string = "Name,Count\nfoo,0\nbar,1\nbaz,2\n"
    path = 't.csv'
    File.write(path, string)

Parse the first line from a String object:
    CSV.parse_line(string, headers: true) # => #<CSV::Row "Name":"foo" "Count":"0">

Parse the first line from a File object:
    File.open(path) do |file|
      CSV.parse_line(file, headers: true)
    end # => #<CSV::Row "Name":"foo" "Count":"0">

---

Raises an exception if the argument is `nil`:
    # Raises ArgumentError (Cannot parse nil as CSV):
    CSV.parse_line(nil)

;T;0;;;I"parse_line;F;I"CSV;T;[o;;I"5::String str, ?::Hash[::Symbol, untyped] options;T;I"Array[::String?]?;To;;I"	Forms the remaining rows from `self` into:
*   A CSV::Table object, if headers are in use.
*   An Array of Arrays, otherwise.


The data source must be opened for reading.

Without headers:
    string = "foo,0\nbar,1\nbaz,2\n"
    path = 't.csv'
    File.write(path, string)
    csv = CSV.open(path)
    csv.read # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]

With headers:
    string = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
    path = 't.csv'
    File.write(path, string)
    csv = CSV.open(path, headers: true)
    csv.read # => #<CSV::Table mode:col_or_row row_count:4>

---

Raises an exception if the source is not opened for reading:
    string = "foo,0\nbar,1\nbaz,2\n"
    csv = CSV.new(string)
    csv.close
    # Raises IOError (not opened for reading)
    csv.read

;T;0;;;I"	read;F;I"CSV;T;[o;;I" ;F;I"Array[::Array[::String?]];To;;I" ;T;0;;;I"readline;F;I"CSV;T;[o;;I" ;F;I"Array[::String?]?;To;;I" Opens the given `source` with the given `options` (see CSV.open), reads the
source (see CSV#read), and returns the result, which will be either an Array
of Arrays or a CSV::Table.

Without headers:
    string = "foo,0\nbar,1\nbaz,2\n"
    path = 't.csv'
    File.write(path, string)
    CSV.read(path) # => [["foo", "0"], ["bar", "1"], ["baz", "2"]]

With headers:
    string = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
    path = 't.csv'
    File.write(path, string)
    CSV.read(path, headers: true) # => #<CSV::Table mode:col_or_row row_count:4>

;T;0;;;I"	read;F;I"CSV;T;[o;;I"6::String path, ?::Hash[::Symbol, untyped] options;T;I"Array[::Array[::String?]];To;;I"ýAppends a row to `self`.

*   Argument `row` must be an Array object or a CSV::Row object.
*   The output stream must be open for writing.


---

Append Arrays:
    CSV.generate do |csv|
      csv << ['foo', 0]
      csv << ['bar', 1]
      csv << ['baz', 2]
    end # => "foo,0\nbar,1\nbaz,2\n"

Append CSV::Rows:
    headers = []
    CSV.generate do |csv|
      csv << CSV::Row.new(headers, ['foo', 0])
      csv << CSV::Row.new(headers, ['bar', 1])
      csv << CSV::Row.new(headers, ['baz', 2])
    end # => "foo,0\nbar,1\nbaz,2\n"

Headers in CSV::Row objects are not appended:
    headers = ['Name', 'Count']
    CSV.generate do |csv|
      csv << CSV::Row.new(headers, ['foo', 0])
      csv << CSV::Row.new(headers, ['bar', 1])
      csv << CSV::Row.new(headers, ['baz', 2])
    end # => "foo,0\nbar,1\nbaz,2\n"

---

Raises an exception if `row` is not an Array or CSV::Row:
    CSV.generate do |csv|
      # Raises NoMethodError (undefined method `collect' for :foo:Symbol)
      csv << :foo
    end

Raises an exception if the output stream is not opened for writing:
    path = 't.csv'
    File.write(path, '')
    File.open(path) do |file|
      CSV.open(file) do |csv|
        # Raises IOError (not opened for writing)
        csv << ['foo', 0]
      end
    end

;T;0;;;I"<<;F;I"CSV;T;[o;;I"&::Array[untyped] | ::CSV::Row row;T;I"	void;To;;I"0*   Argument `csv_string`, if given, must be a String object; defaults to a
    new empty String.
*   Arguments `options`, if given, should be generating options. See [Options
    for Generating](#class-CSV-label-Options+for+Generating).


---

Creates a new CSV object via `CSV.new(csv_string, **options)`; calls the block
with the CSV object, which the block may modify; returns the String generated
from the CSV object.

Note that a passed String **is** modified by this method. Pass
`csv_string`.dup if the String must be preserved.

This method has one additional option: `:encoding`, which sets the base
Encoding for the output if no no `str` is specified. CSV needs this hint if
you plan to output non-ASCII compatible data.

---

Add lines:
    input_string = "foo,0\nbar,1\nbaz,2\n"
    output_string = CSV.generate(input_string) do |csv|
      csv << ['bat', 3]
      csv << ['bam', 4]
    end
    output_string # => "foo,0\nbar,1\nbaz,2\nbat,3\nbam,4\n"
    input_string # => "foo,0\nbar,1\nbaz,2\nbat,3\nbam,4\n"
    output_string.equal?(input_string) # => true # Same string, modified

Add lines into new string, preserving old string:
    input_string = "foo,0\nbar,1\nbaz,2\n"
    output_string = CSV.generate(input_string.dup) do |csv|
      csv << ['bat', 3]
      csv << ['bam', 4]
    end
    output_string # => "foo,0\nbar,1\nbaz,2\nbat,3\nbam,4\n"
    input_string # => "foo,0\nbar,1\nbaz,2\n"
    output_string.equal?(input_string) # => false # Different strings

Create lines from nothing:
    output_string = CSV.generate do |csv|
      csv << ['foo', 0]
      csv << ['bar', 1]
      csv << ['baz', 2]
    end
    output_string # => "foo,0\nbar,1\nbaz,2\n"

---

Raises an exception if `csv_string` is not a String object:
    # Raises TypeError (no implicit conversion of Integer into String)
    CSV.generate(0)

;T;0;;;I"generate;F;I"CSV;T;[o;;I"%?::String str, **untyped options;T;I"String;To;;I"
Calls the block with each successive row. The data source must be opened for
reading.

Without headers:
    string = "foo,0\nbar,1\nbaz,2\n"
    csv = CSV.new(string)
    csv.each do |row|
      p row
    end

Output:
    ["foo", "0"]
    ["bar", "1"]
    ["baz", "2"]

With headers:
    string = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
    csv = CSV.new(string, headers: true)
    csv.each do |row|
      p row
    end

Output:
    <CSV::Row "Name":"foo" "Value":"0">
    <CSV::Row "Name":"bar" "Value":"1">
    <CSV::Row "Name":"baz" "Value":"2">

---

Raises an exception if the source is not opened for reading:
    string = "foo,0\nbar,1\nbaz,2\n"
    csv = CSV.new(string)
    csv.close
    # Raises IOError (not opened for reading)
    csv.each do |row|
      p row
    end

;T;0;;;I"	each;F;I"CSV;T;[o;;I" ;F;I"#Enumerator[untyped, ::Integer];To;;I" ;F;I"Integer;To; ;I"7A CSV::Row is part Array and part Hash. It retains an order for the fields and
allows duplicates just as an Array would, but also allows you to access fields
by name just as you could if they were in a Hash.

All rows returned by CSV will be constructed from this class, if header row
processing is activated.

;T;0;	I"CSV::Row;T;
[ ;[I"Enumerable;T;0;[ ;[ ;0;I"Object;To;;I"ËAdds a field to `self`; returns `self`:

If the argument is a 2-element Array `[header, value]`, a field is added with
the given `header` and `value`:
    source = "Name,Name,Name\nFoo,Bar,Baz\n"
    table = CSV.parse(source, headers: true)
    row = table[0]
    row << ['NAME', 'Bat']
    row # => #<CSV::Row "Name":"Foo" "Name":"Bar" "Name":"Baz" "NAME":"Bat">

If the argument is a Hash, each `key-value` pair is added as a field with
header `key` and value `value`.
    source = "Name,Name,Name\nFoo,Bar,Baz\n"
    table = CSV.parse(source, headers: true)
    row = table[0]
    row << {NAME: 'Bat', name: 'Bam'}
    row # => #<CSV::Row "Name":"Foo" "Name":"Bar" "Name":"Baz" NAME:"Bat" name:"Bam">

Otherwise, the given `value` is added as a field with no header.
    source = "Name,Name,Name\nFoo,Bar,Baz\n"
    table = CSV.parse(source, headers: true)
    row = table[0]
    row << 'Bag'
    row # => #<CSV::Row "Name":"Foo" "Name":"Bar" "Name":"Baz" nil:"Bag">

;T;0;;;I"<<;F;I"CSV::Row;T;[o;;I"untyped arg;T;I"untyped;To;;I"dReturns `true` if this row contains the same headers and fields in the same
order as `other`.

;T;0;;;I"==;F;I"CSV::Row;T;[o;;I"untyped other;T;I"	bool;To;;I"ŠAssigns the field value for the given `index` or `header`; returns `value`.

---

Assign field value by Integer index:
    source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
    table = CSV.parse(source, headers: true)
    row = table[0]
    row[0] = 'Bat'
    row[1] = 3
    row # => #<CSV::Row "Name":"Bat" "Value":3>

Counts backward from the last column if `index` is negative:
    row[-1] = 4
    row[-2] = 'Bam'
    row # => #<CSV::Row "Name":"Bam" "Value":4>

Extends the row with `nil:nil` if positive `index` is not in the row:
    row[4] = 5
    row # => #<CSV::Row "Name":"bad" "Value":4 nil:nil nil:nil nil:5>

Raises IndexError if negative `index` is too small (too far from zero).

---

Assign field value by header (first found):
    source = "Name,Name,Name\nFoo,Bar,Baz\n"
    table = CSV.parse(source, headers: true)
    row = table[0]
    row['Name'] = 'Bat'
    row # => #<CSV::Row "Name":"Bat" "Name":"Bar" "Name":"Baz">

Assign field value by header, ignoring `offset` leading fields:
    source = "Name,Name,Name\nFoo,Bar,Baz\n"
    table = CSV.parse(source, headers: true)
    row = table[0]
    row['Name', 2] = 4
    row # => #<CSV::Row "Name":"Foo" "Name":"Bar" "Name":4>

Append new field by (new) header:
    source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
    table = CSV.parse(source, headers: true)
    row = table[0]
    row['New'] = 6
    row# => #<CSV::Row "Name":"foo" "Value":"0" "New":6>

;T;0;;;I"[]=;F;I"CSV::Row;T;[o;;I"*untyped args;T;I"untyped;To;;I"zRemoves a specified field from `self`; returns the 2-element Array `[header,
value]` if the field exists.

If an Integer argument `index` is given, removes and returns the field at
offset `index`, or returns `nil` if the field does not exist:
    source = "Name,Name,Name\nFoo,Bar,Baz\n"
    table = CSV.parse(source, headers: true)
    row = table[0]
    row.delete(1) # => ["Name", "Bar"]
    row.delete(50) # => nil

Otherwise, if the single argument `header` is given, removes and returns the
first-found field with the given header, of returns a new empty Array if the
field does not exist:
    source = "Name,Name,Name\nFoo,Bar,Baz\n"
    table = CSV.parse(source, headers: true)
    row = table[0]
    row.delete('Name') # => ["Name", "Foo"]
    row.delete('NAME') # => []

If argument `header` and Integer argument `offset` are given, removes and
returns the first-found field with the given header whose `index` is at least
as large as `offset`:
    source = "Name,Name,Name\nFoo,Bar,Baz\n"
    table = CSV.parse(source, headers: true)
    row = table[0]
    row.delete('Name', 1) # => ["Name", "Bar"]
    row.delete('NAME', 1) # => []

;T;0;;;I"delete;F;I"CSV::Row;T;[o;;I"4untyped header_or_index, ?untyped minimum_index;T;I"untyped;To;;I"!Removes fields from `self` as selected by the block; returns `self`.

Removes each field for which the block returns a truthy value:
    source = "Name,Name,Name\nFoo,Bar,Baz\n"
    table = CSV.parse(source, headers: true)
    row = table[0]
    row.delete_if {|header, value| value.start_with?('B') } # => true
    row # => #<CSV::Row "Name":"Foo">
    row.delete_if {|header, value| header.start_with?('B') } # => false

If no block is given, returns a new Enumerator:
    row.delete_if # => #<Enumerator: #<CSV::Row "Name":"Foo">:delete_if>

;T;0;;;I"delete_if;F;I"CSV::Row;T;[o;;I" ;F;I"untyped;To;;I"¾Finds and returns the object in nested object that is specified by
`index_or_header` and `specifiers`.

The nested objects may be instances of various classes. See [Dig
Methods](https://docs.ruby-lang.org/en/master/doc/dig_methods_rdoc.html).

Examples:
    source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
    table = CSV.parse(source, headers: true)
    row = table[0]
    row.dig(1) # => "0"
    row.dig('Value') # => "0"
    row.dig(5) # => nil

;T;0;;;I"dig;F;I"CSV::Row;T;[o;;I".untyped index_or_header, *untyped indexes;T;I"untyped;To;;I"ÐYields each pair of the row as header and field tuples (much like iterating
over a Hash). This method returns the row for chaining.

If no block is given, an Enumerator is returned.

Support for Enumerable.

;T;0;;;I"	each;F;I"CSV::Row;T;[o;;I" ;F;I"(Enumerator[::Array[::String], self];To;;I" ;F;I"	self;To;;0;0;;;I"empty?;F;I"CSV::Row;T;[o;;I"*untyped args;T;I"	bool;To;;I"qReturns the field value as specified by `header`.

---

With the single argument `header`, returns the field value for that header
(first found):
    source = "Name,Name,Name\nFoo,Bar,Baz\n"
    table = CSV.parse(source, headers: true)
    row = table[0]
    row.fetch('Name') # => "Foo"

Raises exception `KeyError` if the header does not exist.

---

With arguments `header` and `default` given, returns the field value for the
header (first found) if the header exists, otherwise returns `default`:
    source = "Name,Name,Name\nFoo,Bar,Baz\n"
    table = CSV.parse(source, headers: true)
    row = table[0]
    row.fetch('Name', '') # => "Foo"
    row.fetch(:nosuch, '') # => ""

---

With argument `header` and a block given, returns the field value for the
header (first found) if the header exists; otherwise calls the block and
returns its return value:
    source = "Name,Name,Name\nFoo,Bar,Baz\n"
    table = CSV.parse(source, headers: true)
    row = table[0]
    row.fetch('Name') {|header| fail 'Cannot happen' } # => "Foo"
    row.fetch(:nosuch) {|header| "Header '#{header} not found'" } # => "Header 'nosuch not found'"

;T;0;;;I"
fetch;F;I"CSV::Row;T;[o;;I"%untyped header, *untyped varargs;T;I"untyped;To;;I"¢Returns the field value for the given `index` or `header`.

---

Fetch field value by Integer index:
    source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
    table = CSV.parse(source, headers: true)
    row = table[0]
    row.field(0) # => "foo"
    row.field(1) # => "bar"

Counts backward from the last column if `index` is negative:
    row.field(-1) # => "0"
    row.field(-2) # => "foo"

Returns `nil` if `index` is out of range:
    row.field(2) # => nil
    row.field(-3) # => nil

---

Fetch field value by header (first found):
    source = "Name,Name,Name\nFoo,Bar,Baz\n"
    table = CSV.parse(source, headers: true)
    row = table[0]
    row.field('Name') # => "Foo"

Fetch field value by header, ignoring `offset` leading fields:
    source = "Name,Name,Name\nFoo,Bar,Baz\n"
    table = CSV.parse(source, headers: true)
    row = table[0]
    row.field('Name', 2) # => "Baz"

Returns `nil` if the header does not exist.

;T;0;;;I"
field;F;I"CSV::Row;T;[o;;I"4untyped header_or_index, ?untyped minimum_index;T;I"untyped;To;;I"SReturns `true` if `data` matches a field in this row, and `false` otherwise.

;T;0;;;I"field?;F;I"CSV::Row;T;[o;;I"untyped data;T;I"	bool;To;;I"@Returns `true` if this is a field row, `false` otherwise.

;T;0;;;I"field_row?;F;I"CSV::Row;T;[o;;I" ;F;I"	bool;To;;I"‚Returns field values per the given `specifiers`, which may be any mixture of:
*   Integer index.
*   Range of Integer indexes.
*   2-element Array containing a header and offset.
*   Header.
*   Range of headers.


For `specifier` in one of the first four cases above, returns the result of
`self.field(specifier)`;  see #field.

Although there may be any number of `specifiers`, the examples here will
illustrate one at a time.

When the specifier is an Integer `index`, returns `self.field(index)`L
    source = "Name,Name,Name\nFoo,Bar,Baz\n"
    table = CSV.parse(source, headers: true)
    row = table[0]
    row.fields(1) # => ["Bar"]

When the specifier is a Range of Integers `range`, returns
`self.field(range)`:
    row.fields(1..2) # => ["Bar", "Baz"]

When the specifier is a 2-element Array `array`, returns `self.field(array)`L
    row.fields('Name', 1) # => ["Foo", "Bar"]

When the specifier is a header `header`, returns `self.field(header)`L
    row.fields('Name') # => ["Foo"]

When the specifier is a Range of headers `range`, forms a new Range
`new_range` from the indexes of `range.start` and `range.end`, and returns
`self.field(new_range)`:
    source = "Name,NAME,name\nFoo,Bar,Baz\n"
    table = CSV.parse(source, headers: true)
    row = table[0]
    row.fields('Name'..'NAME') # => ["Foo", "Bar"]

Returns all fields if no argument given:
    row.fields # => ["Foo", "Bar", "Baz"]

;T;0;;;I"fields;F;I"CSV::Row;T;[o;;I"$*untyped headers_and_or_indices;T;I"untyped;To;;I"UReturns `true` if there is a field with the given `header`, `false` otherwise.

;T;0;;;I"has_key?;F;I"CSV::Row;T;[o;;I"untyped header;T;I"	bool;To;;I"AReturns `true` if this is a header row, `false` otherwise.

;T;0;;;I"header_row?;F;I"CSV::Row;T;[o;;I" ;F;I"	bool;To;;I"¾Returns the headers for this row:
    source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
    table = CSV.parse(source, headers: true)
    row = table.first
    row.headers # => ["Name", "Value"]

;T;0;;;I"headers;F;I"CSV::Row;T;[o;;I" ;F;I"untyped;To;;I"§This method will return the index of a field with the provided `header`. The
`offset` can be used to locate duplicate header names, as described in
CSV::Row.field().

;T;0;;;I"
index;F;I"CSV::Row;T;[o;;I"+untyped header, ?untyped minimum_index;T;I"untyped;To;;I"Returns an ASCII-compatible String showing:
*   Class CSV::Row.
*   Header-value pairs.

Example:
    source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
    table = CSV.parse(source, headers: true)
    row = table[0]
    row.inspect # => "#<CSV::Row \"Name\":\"foo\" \"Value\":\"0\">"

;T;0;;;I"inspect;F;I"CSV::Row;T;[o;;I" ;F;I"String;To;;0;0;;;I"length;F;I"CSV::Row;T;[o;;I"*untyped args;T;I"untyped;To;;I"&Appends each of the given `values` to `self` as a field; returns `self`:
    source = "Name,Name,Name\nFoo,Bar,Baz\n"
    table = CSV.parse(source, headers: true)
    row = table[0]
    row.push('Bat', 'Bam')
    row # => #<CSV::Row "Name":"Foo" "Name":"Bar" "Name":"Baz" nil:"Bat" nil:"Bam">

;T;0;;;I"	push;F;I"CSV::Row;T;[o;;I"*untyped args;T;I"untyped;To;;0;0;;;I"	size;F;I"CSV::Row;T;[o;;I"*untyped args;T;I"untyped;To;;I"ËReturns the row as a CSV String. Headers are not included:
    source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
    table = CSV.parse(source, headers: true)
    row = table[0]
    row.to_csv # => "foo,0\n"

;T;0;;;I"to_csv;F;I"CSV::Row;T;[o;;I"**untyped;T;I"untyped;To;;I"×Returns the new Hash formed by adding each header-value pair in `self` as a
key-value pair in the Hash.
    source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
    table = CSV.parse(source, headers: true)
    row = table[0]
    row.to_h # => {"Name"=>"foo", "Value"=>"0"}

Header order is preserved, but repeated headers are ignored:
    source = "Name,Name,Name\nFoo,Bar,Baz\n"
    table = CSV.parse(source, headers: true)
    row = table[0]
    row.to_h # => {"Name"=>"Foo"}

;T;0;;;I"	to_h;F;I"CSV::Row;T;[o;;I" ;F;I"untyped;To; ;0;0;	I"CSV::FieldInfo;T;
[ ;[ ;0;[ ;[ ;0;I"Struct;To; ;I"JThe error thrown when the parser encounters illegal CSV formatting.

;T;0;	I"CSV::MalformedCSVError;T;
[ ;[ ;0;[ ;[ ;0;I"RuntimeError;To; ;I"=A CSV::Table is a two-dimensional data structure for representing CSV
documents. Tables allow you to work with the data by row or column, manipulate
the data, and even convert the results back to CSV, if needed.

All tables returned by CSV will be constructed from this class, if header row
processing is activated.

;T;0;	I"CSV::Table;T;
[ ;[I"Enumerable;T;0;[ ;[ ;0;I"Object;To;;I"ÔConstructs a new CSV::Table from `array_of_rows`, which are expected to be
CSV::Row objects. All rows are assumed to have the same headers.

The optional `headers` parameter can be set to Array of headers. If headers
aren't set, headers are fetched from CSV::Row objects. Otherwise, headers()
method will return headers being set in headers argument.

A CSV::Table object supports the following Array methods through delegation:

*   empty?()
*   length()
*   size()

;T;0;;;I"initialize;F;I"CSV::Table;T;[o;;I"-untyped array_of_rows, ?headers: untyped;T;I"untyped;To;;I"ËIf `row_or_array` is a CSV::Row object, it is appended to the table:
    source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
    table = CSV.parse(source, headers: true)
    table << CSV::Row.new(table.headers, ['bat', 3])
    table[3] # => #<CSV::Row "Name":"bat" "Value":3>

If `row_or_array` is an Array, it is used to create a new CSV::Row object
which is then appended to the table:
    table << ['bam', 4]
    table[4] # => #<CSV::Row "Name":"bam" "Value":4>

;T;0;;;I"<<;F;I"CSV::Table;T;[o;;I"untyped row_or_array;T;I"untyped;To;;I"Returns `true` if all each row of `self` `==` the corresponding row of
`other_table`, otherwise, `false`.

The access mode does no affect the result.

Equal tables:
    source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
    table = CSV.parse(source, headers: true)
    other_table = CSV.parse(source, headers: true)
    table == other_table # => true

Different row count:
    other_table.delete(2)
    table == other_table # => false

Different last row:
    other_table << ['bat', 3]
    table == other_table # => false

;T;0;;;I"==;F;I"CSV::Table;T;[o;;I"untyped other;T;I"	bool;To;;I"gReturns data from the table;  does not modify the table.

---

The expression `table[n]`, where `n` is a non-negative Integer, returns the
+n+th row of the table, if that row exists, and if the access mode is `:row`
or `:col_or_row`:
    source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
    table = CSV.parse(source, headers: true)
    table.by_row! # => #<CSV::Table mode:row row_count:4>
    table[1] # => #<CSV::Row "Name":"bar" "Value":"1">
    table.by_col_or_row! # => #<CSV::Table mode:col_or_row row_count:4>
    table[1] # => #<CSV::Row "Name":"bar" "Value":"1">

Counts backward from the last row if `n` is negative:
    table[-1] # => #<CSV::Row "Name":"baz" "Value":"2">

Returns `nil` if `n` is too large or too small:
    table[4] # => nil
    table[-4] => nil

Raises an exception if the access mode is `:row` and `n` is not an
[Integer-convertible
object](https://docs.ruby-lang.org/en/master/implicit_conversion_rdoc.html#lab
el-Integer-Convertible+Objects).
    table.by_row! # => #<CSV::Table mode:row row_count:4>
    # Raises TypeError (no implicit conversion of String into Integer):
    table['Name']

---

The expression `table[range]`, where `range` is a Range object, returns rows
from the table, beginning at row `range.first`, if those rows exist, and if
the access mode is `:row` or `:col_or_row`:
    source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
    table = CSV.parse(source, headers: true)
    table.by_row! # => #<CSV::Table mode:row row_count:4>
    rows = table[1..2] # => #<CSV::Row "Name":"bar" "Value":"1">
    rows # => [#<CSV::Row "Name":"bar" "Value":"1">, #<CSV::Row "Name":"baz" "Value":"2">]
    table.by_col_or_row! # => #<CSV::Table mode:col_or_row row_count:4>
    rows = table[1..2] # => #<CSV::Row "Name":"bar" "Value":"1">
    rows # => [#<CSV::Row "Name":"bar" "Value":"1">, #<CSV::Row "Name":"baz" "Value":"2">]

If there are too few rows, returns all from `range.first` to the end:
    rows = table[1..50] # => #<CSV::Row "Name":"bar" "Value":"1">
    rows # => [#<CSV::Row "Name":"bar" "Value":"1">, #<CSV::Row "Name":"baz" "Value":"2">]

Special case:  if `range.start == table.size`, returns an empty Array:
    table[table.size..50] # => []

If `range.end` is negative, calculates the ending index from the end:
    rows = table[0..-1]
    rows # => [#<CSV::Row "Name":"foo" "Value":"0">, #<CSV::Row "Name":"bar" "Value":"1">, #<CSV::Row "Name":"baz" "Value":"2">]

If `range.start` is negative, calculates the starting index from the end:
    rows = table[-1..2]
    rows # => [#<CSV::Row "Name":"baz" "Value":"2">]

If `range.start` is larger than `table.size`, returns `nil`:
    table[4..4] # => nil

---

The expression `table[header]`, where `header` is a String, returns column
values (Array of Strings) if the column exists and if the access mode is
`:col` or `:col_or_row`:
    source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
    table = CSV.parse(source, headers: true)
    table.by_col! # => #<CSV::Table mode:col row_count:4>
    table['Name'] # => ["foo", "bar", "baz"]
    table.by_col_or_row! # => #<CSV::Table mode:col_or_row row_count:4>
    col = table['Name']
    col # => ["foo", "bar", "baz"]

Modifying the returned column values does not modify the table:
    col[0] = 'bat'
    col # => ["bat", "bar", "baz"]
    table['Name'] # => ["foo", "bar", "baz"]

Returns an Array of `nil` values if there is no such column:
    table['Nosuch'] # => [nil, nil, nil]

;T;0;;;I"[];F;I"CSV::Table;T;[o;;I"untyped index_or_header;T;I"untyped;To;;I"·In the default mixed mode, this method assigns rows for index access and
columns for header access. You can force the index association by first
calling by_col!() or by_row!().

Rows may be set to an Array of values (which will inherit the table's
headers()) or a CSV::Row.

Columns may be set to a single value, which is copied to each row of the
column, or an Array of values. Arrays of values are assigned to rows top to
bottom in row major order. Excess values are ignored and if the Array does not
have a value for each row the extra rows will receive a `nil`.

Assigning to an existing column or row clobbers the data. Assigning to new
columns creates them at the right end of the table.

;T;0;;;I"[]=;F;I"CSV::Table;T;[o;;I"+untyped index_or_header, untyped value;T;I"untyped;To;;I"uReturns a duplicate table object, in column mode. This is handy for chaining
in a single call without changing the table mode, but be aware that this
method can consume a fair amount of memory for bigger data sets.

This method returns the duplicate table for chaining. Don't chain destructive
methods (like []=()) this way though, since you are working with a duplicate.

;T;0;;;I"by_col;F;I"CSV::Table;T;[o;;I" ;F;I"untyped;To;;I"ÊSwitches the mode of this table to column mode. All calls to indexing and
iteration methods will work with columns until the mode is changed again.

This method returns the table and is safe to chain.

;T;0;;;I"by_col!;F;I"CSV::Table;T;[o;;I" ;F;I"untyped;To;;I"uReturns a duplicate table object, in mixed mode. This is handy for chaining in
a single call without changing the table mode, but be aware that this method
can consume a fair amount of memory for bigger data sets.

This method returns the duplicate table for chaining.  Don't chain destructive
methods (like []=()) this way though, since you are working with a duplicate.

;T;0;;;I"by_col_or_row;F;I"CSV::Table;T;[o;;I" ;F;I"untyped;To;;I"ZSwitches the mode of this table to mixed mode. All calls to indexing and
iteration methods will use the default intelligent indexing system until the
mode is changed again. In mixed mode an index is assumed to be a row reference
while anything else is assumed to be column access by headers.

This method returns the table and is safe to chain.

;T;0;;;I"by_col_or_row!;F;I"CSV::Table;T;[o;;I" ;F;I"untyped;To;;I"tReturns a duplicate table object, in row mode.  This is handy for chaining in
a single call without changing the table mode, but be aware that this method
can consume a fair amount of memory for bigger data sets.

This method returns the duplicate table for chaining.  Don't chain destructive
methods (like []=()) this way though, since you are working with a duplicate.

;T;0;;;I"by_row;F;I"CSV::Table;T;[o;;I" ;F;I"untyped;To;;I"ÄSwitches the mode of this table to row mode. All calls to indexing and
iteration methods will work with rows until the mode is changed again.

This method returns the table and is safe to chain.

;T;0;;;I"by_row!;F;I"CSV::Table;T;[o;;I" ;F;I"untyped;To;;I"HIf the access mode is `:row` or `:col_or_row`, and each argument is either an
Integer or a Range, returns deleted rows. Otherwise, returns deleted columns
data.

In either case, the returned values are in the order specified by the
arguments.  Arguments may be repeated.

---

Returns rows as an Array of CSV::Row objects.

One index:
    source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
    table = CSV.parse(source, headers: true)
    deleted_values = table.delete(0)
    deleted_values # => [#<CSV::Row "Name":"foo" "Value":"0">]

Two indexes:
    table = CSV.parse(source, headers: true)
    deleted_values = table.delete(2, 0)
    deleted_values # => [#<CSV::Row "Name":"baz" "Value":"2">, #<CSV::Row "Name":"foo" "Value":"0">]

---

Returns columns data as column Arrays.

One header:
    table = CSV.parse(source, headers: true)
    deleted_values = table.delete('Name')
    deleted_values # => ["foo", "bar", "baz"]

Two headers:
    table = CSV.parse(source, headers: true)
    deleted_values = table.delete('Value', 'Name')
    deleted_values # => [["0", "1", "2"], ["foo", "bar", "baz"]]

;T;0;;;I"delete;F;I"CSV::Table;T;[o;;I" *untyped indexes_or_headers;T;I"untyped;To;;I"YRemoves rows or columns for which the block returns a truthy value; returns
`self`.

Removes rows when the access mode is `:row` or `:col_or_row`; calls the block
with each CSV::Row object:
    source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
    table = CSV.parse(source, headers: true)
    table.by_row! # => #<CSV::Table mode:row row_count:4>
    table.size # => 3
    table.delete_if {|row| row['Name'].start_with?('b') }
    table.size # => 1

Removes columns when the access mode is `:col`; calls the block with each
column as a 2-element array containing the header and an Array of column
fields:
    source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
    table = CSV.parse(source, headers: true)
    table.by_col! # => #<CSV::Table mode:col row_count:4>
    table.headers.size # => 2
    table.delete_if {|column_data| column_data[1].include?('2') }
    table.headers.size # => 1

Returns a new Enumerator if no block is given:
    source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
    table = CSV.parse(source, headers: true)
    table.delete_if # => #<Enumerator: #<CSV::Table mode:col_or_row row_count:4>:delete_if>

;T;0;;;I"delete_if;F;I"CSV::Table;T;[o;;I" ;F;I"untyped;To;;I" Extracts the nested value specified by the sequence of `index` or `header`
objects by calling dig at each step, returning nil if any intermediate step is
nil.

;T;0;;;I"dig;F;I"CSV::Table;T;[o;;I"7untyped index_or_header, *untyped index_or_headers;T;I"untyped;To;;I"ŒCalls the block with each row or column; returns `self`.

When the access mode is `:row` or `:col_or_row`, calls the block with each
CSV::Row object:
    source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
    table = CSV.parse(source, headers: true)
    table.by_row! # => #<CSV::Table mode:row row_count:4>
    table.each {|row| p row }

Output:
    #<CSV::Row "Name":"foo" "Value":"0">
    #<CSV::Row "Name":"bar" "Value":"1">
    #<CSV::Row "Name":"baz" "Value":"2">

When the access mode is `:col`, calls the block with each column as a
2-element array containing the header and an Array of column fields:
    table.by_col! # => #<CSV::Table mode:col row_count:4>
    table.each {|column_data| p column_data }

Output:
    ["Name", ["foo", "bar", "baz"]]
    ["Value", ["0", "1", "2"]]

Returns a new Enumerator if no block is given:
    table.each # => #<Enumerator: #<CSV::Table mode:col row_count:4>:each>

;T;0;;;I"	each;F;I"CSV::Table;T;[o;;I" ;F;I"Enumerator[untyped, self];To;;I" ;F;I"	self;To;;I" ;F;I"	self;To;;0;0;;;I"empty?;F;I"CSV::Table;T;[o;;I"*untyped args;T;I"untyped;To;;I"¡Returns the headers for the first row of this table (assumed to match all
other rows). The headers Array passed to CSV::Table.new is returned for empty
tables.

;T;0;;;I"headers;F;I"CSV::Table;T;[o;;I" ;F;I"untyped;To;;I"BShows the mode and size of this table in a US-ASCII String.

;T;0;;;I"inspect;F;I"CSV::Table;T;[o;;I" ;F;I"String;To;;0;0;;;I"length;F;I"CSV::Table;T;[o;;I"*untyped args;T;I"untyped;To;;I":The current access mode for indexing and iteration.

;T;0;;;I"	mode;F;I"CSV::Table;T;[o;;I" ;F;I"untyped;To;;I"¼A shortcut for appending multiple rows. Equivalent to:
    rows.each {|row| self << row }

Each argument may be either a CSV::Row object or an Array:
    source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
    table = CSV.parse(source, headers: true)
    rows = [
      CSV::Row.new(table.headers, ['bat', 3]),
      ['bam', 4]
    ]
    table.push(*rows)
    table[3..4] # => [#<CSV::Row "Name":"bat" "Value":3>, #<CSV::Row "Name":"bam" "Value":4>]

;T;0;;;I"	push;F;I"CSV::Table;T;[o;;I"*untyped rows;T;I"untyped;To;;0;0;;;I"	size;F;I"CSV::Table;T;[o;;I"*untyped args;T;I"untyped;To;;I"vReturns the table as an Array of Arrays. Headers will be the first row, then
all of the field rows will follow.

;T;0;;;I"	to_a;F;I"CSV::Table;T;[o;;I" ;F;I"untyped;To;;I"ÐReturns the table as a complete CSV String. Headers will be listed first, then
all of the field rows.

This method assumes you want the Table.headers(), unless you explicitly pass
`:write_headers => false`.

;T;0;;;I"to_csv;F;I"CSV::Table;T;[o;;I")?write_headers: ::boolish, **untyped;T;I"untyped;To;;I"¶If the access mode is `:row` or `:col_or_row`, and each argument is either an
Integer or a Range, returns rows. Otherwise, returns columns data.

In either case, the returned values are in the order specified by the
arguments.  Arguments may be repeated.

---

Returns rows as an Array of CSV::Row objects.

No argument:
    source = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
    table = CSV.parse(source, headers: true)
    table.values_at # => []

One index:
    values = table.values_at(0)
    values # => [#<CSV::Row "Name":"foo" "Value":"0">]

Two indexes:
    values = table.values_at(2, 0)
    values # => [#<CSV::Row "Name":"baz" "Value":"2">, #<CSV::Row "Name":"foo" "Value":"0">]

One Range:
    values = table.values_at(1..2)
    values # => [#<CSV::Row "Name":"bar" "Value":"1">, #<CSV::Row "Name":"baz" "Value":"2">]

Ranges and indexes:
    values = table.values_at(0..1, 1..2, 0, 2)
    pp values

Output:
    [#<CSV::Row "Name":"foo" "Value":"0">,
     #<CSV::Row "Name":"bar" "Value":"1">,
     #<CSV::Row "Name":"bar" "Value":"1">,
     #<CSV::Row "Name":"baz" "Value":"2">,
     #<CSV::Row "Name":"foo" "Value":"0">,
     #<CSV::Row "Name":"baz" "Value":"2">]

---

Returns columns data as row Arrays, each consisting of the specified columns
data for that row:
    values = table.values_at('Name')
    values # => [["foo"], ["bar"], ["baz"]]
    values = table.values_at('Value', 'Name')
    values # => [["0", "foo"], ["1", "bar"], ["2", "baz"]]

;T;0;;;I"values_at;F;I"CSV::Table;T;[o;;I" *untyped indices_or_headers;T;I"untyped;To; ;I"Edate and datetime class - Tadayoshi Funaba 1998-2011

'date' provides two classes: Date and DateTime.

## Terms and Definitions

Some terms and definitions are based on ISO 8601 and JIS X 0301.

### Calendar Date

The calendar date is a particular day of a calendar year, identified by its
ordinal number within a calendar month within that year.

In those classes, this is so-called "civil".

### Ordinal Date

The ordinal date is a particular day of a calendar year identified by its
ordinal number within the year.

In those classes, this is so-called "ordinal".

### Week Date

The week date is a date identified by calendar week and day numbers.

The calendar week is a seven day period within a calendar year, starting on a
Monday and identified by its ordinal number within the year; the first
calendar week of the year is the one that includes the first Thursday of that
year. In the Gregorian calendar, this is equivalent to the week which includes
January 4.

In those classes, this is so-called "commercial".

### Julian Day Number

The Julian day number is in elapsed days since noon (Greenwich Mean Time) on
January 1, 4713 BCE (in the Julian calendar).

In this document, the astronomical Julian day number is the same as the
original Julian day number. And the chronological Julian day number is a
variation of the Julian day number. Its days begin at midnight on local time.

In this document, when the term "Julian day number" simply appears, it just
refers to "chronological Julian day number", not the original.

In those classes, those are so-called "ajd" and "jd".

### Modified Julian Day Number

The modified Julian day number is in elapsed days since midnight (Coordinated
Universal Time) on November 17, 1858 CE (in the Gregorian calendar).

In this document, the astronomical modified Julian day number is the same as
the original modified Julian day number. And the chronological modified Julian
day number is a variation of the modified Julian day number. Its days begin at
midnight on local time.

In this document, when the term "modified Julian day number" simply appears,
it just refers to "chronological modified Julian day number", not the
original.

In those classes, those are so-called "amjd" and "mjd".

## Date

A subclass of Object that includes the Comparable module and easily handles
date.

A Date object is created with Date::new, Date::jd, Date::ordinal,
Date::commercial, Date::parse, Date::strptime, Date::today, Time#to_date, etc.

    require 'date'

    Date.new(2001,2,3)
     #=> #<Date: 2001-02-03 ...>
    Date.jd(2451944)
     #=> #<Date: 2001-02-03 ...>
    Date.ordinal(2001,34)
     #=> #<Date: 2001-02-03 ...>
    Date.commercial(2001,5,6)
     #=> #<Date: 2001-02-03 ...>
    Date.parse('2001-02-03')
     #=> #<Date: 2001-02-03 ...>
    Date.strptime('03-02-2001', '%d-%m-%Y')
     #=> #<Date: 2001-02-03 ...>
    Time.new(2001,2,3).to_date
     #=> #<Date: 2001-02-03 ...>

All date objects are immutable; hence cannot modify themselves.

The concept of a date object can be represented as a tuple of the day count,
the offset and the day of calendar reform.

The day count denotes the absolute position of a temporal dimension. The
offset is relative adjustment, which determines decoded local time with the
day count. The day of calendar reform denotes the start day of the new style.
The old style of the West is the Julian calendar which was adopted by Caesar.
The new style is the Gregorian calendar, which is the current civil calendar
of many countries.

The day count is virtually the astronomical Julian day number. The offset in
this class is usually zero, and cannot be specified directly.

A Date object can be created with an optional argument, the day of calendar
reform as a Julian day number, which should be 2298874 to 2426355 or
negative/positive infinity. The default value is `Date::ITALY`
(2299161=1582-10-15). See also sample/cal.rb.

    $ ruby sample/cal.rb -c it 10 1582
        October 1582
     S  M Tu  W Th  F  S
        1  2  3  4 15 16
    17 18 19 20 21 22 23
    24 25 26 27 28 29 30
    31

    $ ruby sample/cal.rb -c gb  9 1752
       September 1752
     S  M Tu  W Th  F  S
           1  2 14 15 16
    17 18 19 20 21 22 23
    24 25 26 27 28 29 30

A Date object has various methods. See each reference.

    d = Date.parse('3rd Feb 2001')
                                 #=> #<Date: 2001-02-03 ...>
    d.year                       #=> 2001
    d.mon                        #=> 2
    d.mday                       #=> 3
    d.wday                       #=> 6
    d += 1                       #=> #<Date: 2001-02-04 ...>
    d.strftime('%a %d %b %Y')    #=> "Sun 04 Feb 2001"

;T;0;	I"	Date;T;
[ ;[I"Comparable;T;0;[ ;[ ;0;0o;;I" ;T;0;;;I"initialize;F;I"	Date;T;[o;;I"I?::Integer year, ?::Integer month, ?::Integer mday, ?::Integer start;T;I"	void;To;;I"ÌReturns a hash of parsed elements.

Raise an ArgumentError when the string length is longer than *limit*. You can
stop this check by passing `limit: nil`, but note that it may take a long time
to parse.

;T;0;;;I"_httpdate;F;I"	Date;T;[o;;I"::String str;T;I"Hash[::Symbol, ::Integer];To;;I"ÌReturns a hash of parsed elements.

Raise an ArgumentError when the string length is longer than *limit*. You can
stop this check by passing `limit: nil`, but note that it may take a long time
to parse.

;T;0;;;I"_iso8601;F;I"	Date;T;[o;;I"::String str;T;I"Hash[::Symbol, ::Integer];To;;I"ÌReturns a hash of parsed elements.

Raise an ArgumentError when the string length is longer than *limit*. You can
stop this check by passing `limit: nil`, but note that it may take a long time
to parse.

;T;0;;;I"_jisx0301;F;I"	Date;T;[o;;I"::String str;T;I"Hash[::Symbol, ::Integer];To;;I"ÈParses the given representation of date and time, and returns a hash of parsed
elements.

This method *does not* function as a validator.  If the input string does not
match valid formats strictly, you may get a cryptic result.  Should consider
to use `Date._strptime` or `DateTime._strptime` instead of this method as
possible.

If the optional second argument is true and the detected year is in the range
"00" to "99", considers the year a 2-digit form and makes it full.

    Date._parse('2001-02-03') #=> {:year=>2001, :mon=>2, :mday=>3}

Raise an ArgumentError when the string length is longer than *limit*. You can
stop this check by passing `limit: nil`, but note that it may take a long time
to parse.

;T;0;;;I"_parse;F;I"	Date;T;[o;;I"&::String str, ?::boolish complete;T;I"Hash[::Symbol, ::Integer];To;;I"ÌReturns a hash of parsed elements.

Raise an ArgumentError when the string length is longer than *limit*. You can
stop this check by passing `limit: nil`, but note that it may take a long time
to parse.

;T;0;;;I"_rfc2822;F;I"	Date;T;[o;;I"::String str;T;I")Hash[::Symbol, ::Integer | ::String];To;;I"ÌReturns a hash of parsed elements.

Raise an ArgumentError when the string length is longer than *limit*. You can
stop this check by passing `limit: nil`, but note that it may take a long time
to parse.

;T;0;;;I"_rfc3339;F;I"	Date;T;[o;;I"::String str;T;I")Hash[::Symbol, ::Integer | ::String];To;;I"ÌReturns a hash of parsed elements.

Raise an ArgumentError when the string length is longer than *limit*. You can
stop this check by passing `limit: nil`, but note that it may take a long time
to parse.

;T;0;;;I"_rfc822;F;I"	Date;T;[o;;I"::String str;T;I")Hash[::Symbol, ::Integer | ::String];To;;I"VParses the given representation of date and time with the given template, and
returns a hash of parsed elements.  _strptime does not support specification
of flags and width unlike strftime.

    Date._strptime('2001-02-03', '%Y-%m-%d')
                              #=> {:year=>2001, :mon=>2, :mday=>3}

See also strptime(3) and #strftime.

;T;0;;;I"_strptime;F;I"	Date;T;[o;;I"#::String str, ?::String format;T;I"Hash[::Symbol, ::Integer];To;;I"ÌReturns a hash of parsed elements.

Raise an ArgumentError when the string length is longer than *limit*. You can
stop this check by passing `limit: nil`, but note that it may take a long time
to parse.

;T;0;;;I"_xmlschema;F;I"	Date;T;[o;;I"::String str;T;I"Hash[::Symbol, ::Integer];To;;I"sCreates a date object denoting the given calendar date.

In this class, BCE years are counted astronomically.  Thus, the year before
the year 1 is the year zero, and the year preceding the year zero is the year
-1.  The month and the day of month should be a negative or a positive number
(as a relative month/day from the end of year/month when negative).  They
should not be zero.

The last argument should be a Julian day number which denotes the day of
calendar reform.  Date::ITALY (2299161=1582-10-15), Date::ENGLAND
(2361222=1752-09-14), Date::GREGORIAN (the proleptic Gregorian calendar) and
Date::JULIAN (the proleptic Julian calendar) can be specified as a day of
calendar reform.

    Date.new(2001)            #=> #<Date: 2001-01-01 ...>
    Date.new(2001,2,3)        #=> #<Date: 2001-02-03 ...>
    Date.new(2001,2,-1)       #=> #<Date: 2001-02-28 ...>

See also ::jd.

;T;0;;;I"
civil;F;I"	Date;T;[o;;I"I?::Integer year, ?::Integer month, ?::Integer mday, ?::Integer start;T;I"	Date;To;;I"¢Creates a date object denoting the given week date.

The week and the day of week should be a negative or a positive number (as a
relative week/day from the end of year/week when negative).  They should not
be zero.

    Date.commercial(2001)     #=> #<Date: 2001-01-01 ...>
    Date.commercial(2002)     #=> #<Date: 2001-12-31 ...>
    Date.commercial(2001,5,6) #=> #<Date: 2001-02-03 ...>

See also ::jd and ::new.

;T;0;;;I"commercial;F;I"	Date;T;[o;;I"L?::Integer cwyear, ?::Integer cweek, ?::Integer cwday, ?::Integer start;T;I"	Date;To;;I"´Returns true if the given year is a leap year of the proleptic Gregorian
calendar.

    Date.gregorian_leap?(1900)        #=> false
    Date.gregorian_leap?(2000)        #=> true

;T;0;;;I"gregorian_leap?;F;I"	Date;T;[o;;I"::Integer year;T;I"	bool;To;;I"}Creates a new Date object by parsing from a string according to some RFC 2616
format.

    Date.httpdate('Sat, 03 Feb 2001 00:00:00 GMT')
                                              #=> #<Date: 2001-02-03 ...>

Raise an ArgumentError when the string length is longer than *limit*. You can
stop this check by passing `limit: nil`, but note that it may take a long time
to parse.

;T;0;;;I"httpdate;F;I"	Date;T;[o;;I"#::String str, ?::Integer start;T;I"	Date;To;;I"ÏCreates a new Date object by parsing from a string according to some typical
ISO 8601 formats.

    Date.iso8601('2001-02-03')        #=> #<Date: 2001-02-03 ...>
    Date.iso8601('20010203')          #=> #<Date: 2001-02-03 ...>
    Date.iso8601('2001-W05-6')        #=> #<Date: 2001-02-03 ...>

Raise an ArgumentError when the string length is longer than *limit*. You can
stop this check by passing `limit: nil`, but note that it may take a long time
to parse.

;T;0;;;I"iso8601;F;I"	Date;T;[o;;I"#::String str, ?::Integer start;T;I"	Date;To;;I"Creates a date object denoting the given chronological Julian day number.

    Date.jd(2451944)          #=> #<Date: 2001-02-03 ...>
    Date.jd(2451945)          #=> #<Date: 2001-02-04 ...>
    Date.jd(0)                #=> #<Date: -4712-01-01 ...>

See also ::new.

;T;0;;;I"jd;F;I"	Date;T;[o;;I"#::Integer jd, ?::Integer start;T;I"	Date;To;;I"ÔCreates a new Date object by parsing from a string according to some typical
JIS X 0301 formats.

    Date.jisx0301('H13.02.03')                #=> #<Date: 2001-02-03 ...>

For no-era year, legacy format, Heisei is assumed.

    Date.jisx0301('13.02.03')                 #=> #<Date: 2001-02-03 ...>

Raise an ArgumentError when the string length is longer than *limit*. You can
stop this check by passing `limit: nil`, but note that it may take a long time
to parse.

;T;0;;;I"jisx0301;F;I"	Date;T;[o;;I"#::String str, ?::Integer start;T;I"	Date;To;;I"±Returns true if the given year is a leap year of the proleptic Julian
calendar.

    Date.julian_leap?(1900)           #=> true
    Date.julian_leap?(1901)           #=> false

;T;0;;;I"julian_leap?;F;I"	Date;T;[o;;I"::Integer year;T;I"	bool;To;;I"´Returns true if the given year is a leap year of the proleptic Gregorian
calendar.

    Date.gregorian_leap?(1900)        #=> false
    Date.gregorian_leap?(2000)        #=> true

;T;0;;;I"
leap?;F;I"	Date;T;[o;;I"::Integer year;T;I"	bool;To;;I"ŒCreates a date object denoting the given ordinal date.

The day of year should be a negative or a positive number (as a relative day
from the end of year when negative).  It should not be zero.

    Date.ordinal(2001)        #=> #<Date: 2001-01-01 ...>
    Date.ordinal(2001,34)     #=> #<Date: 2001-02-03 ...>
    Date.ordinal(2001,-1)     #=> #<Date: 2001-12-31 ...>

See also ::jd and ::new.

;T;0;;;I"ordinal;F;I"	Date;T;[o;;I"7?::Integer year, ?::Integer yday, ?::Integer start;T;I"	Date;To;;I"&Parses the given representation of date and time, and creates a date object.

This method *does not* function as a validator.  If the input string does not
match valid formats strictly, you may get a cryptic result.  Should consider
to use `Date.strptime` instead of this method as possible.

If the optional second argument is true and the detected year is in the range
"00" to "99", considers the year a 2-digit form and makes it full.

    Date.parse('2001-02-03')          #=> #<Date: 2001-02-03 ...>
    Date.parse('20010203')            #=> #<Date: 2001-02-03 ...>
    Date.parse('3rd Feb 2001')        #=> #<Date: 2001-02-03 ...>

Raise an ArgumentError when the string length is longer than *limit*. You can
stop this check by passing `limit: nil`, but note that it may take a long time
to parse.

;T;0;;;I"
parse;F;I"	Date;T;[o;;I"8::String str, ?::boolish complete, ?::Integer start;T;I"	Date;To;;I"†Creates a new Date object by parsing from a string according to some typical
RFC 2822 formats.

    Date.rfc2822('Sat, 3 Feb 2001 00:00:00 +0000')
                                              #=> #<Date: 2001-02-03 ...>

Raise an ArgumentError when the string length is longer than *limit*. You can
stop this check by passing `limit: nil`, but note that it may take a long time
to parse.

;T;0;;;I"rfc2822;F;I"	Date;T;[o;;I"#::String str, ?::Integer start;T;I"	Date;To;;I"SCreates a new Date object by parsing from a string according to some typical
RFC 3339 formats.

    Date.rfc3339('2001-02-03T04:05:06+07:00') #=> #<Date: 2001-02-03 ...>

Raise an ArgumentError when the string length is longer than *limit*. You can
stop this check by passing `limit: nil`, but note that it may take a long time
to parse.

;T;0;;;I"rfc3339;F;I"	Date;T;[o;;I"#::String str, ?::Integer start;T;I"	Date;To;;I"†Creates a new Date object by parsing from a string according to some typical
RFC 2822 formats.

    Date.rfc2822('Sat, 3 Feb 2001 00:00:00 +0000')
                                              #=> #<Date: 2001-02-03 ...>

Raise an ArgumentError when the string length is longer than *limit*. You can
stop this check by passing `limit: nil`, but note that it may take a long time
to parse.

;T;0;;;I"rfc822;F;I"	Date;T;[o;;I"#::String str, ?::Integer start;T;I"	Date;To;;I"ßParses the given representation of date and time with the given template, and
creates a date object.  strptime does not support specification of flags and
width unlike strftime.

    Date.strptime('2001-02-03', '%Y-%m-%d')   #=> #<Date: 2001-02-03 ...>
    Date.strptime('03-02-2001', '%d-%m-%Y')   #=> #<Date: 2001-02-03 ...>
    Date.strptime('2001-034', '%Y-%j')        #=> #<Date: 2001-02-03 ...>
    Date.strptime('2001-W05-6', '%G-W%V-%u')  #=> #<Date: 2001-02-03 ...>
    Date.strptime('2001 04 6', '%Y %U %w')    #=> #<Date: 2001-02-03 ...>
    Date.strptime('2001 05 6', '%Y %W %u')    #=> #<Date: 2001-02-03 ...>
    Date.strptime('sat3feb01', '%a%d%b%y')    #=> #<Date: 2001-02-03 ...>

See also strptime(3) and #strftime.

;T;0;;;I"strptime;F;I"	Date;T;[o;;I"5::String str, ?::String format, ?::Integer start;T;I"	Date;To;;I"dCreates a date object denoting the present day.

    Date.today   #=> #<Date: 2011-06-11 ...>

;T;0;;;I"
today;F;I"	Date;T;[o;;I"?::Integer start;T;I"	Date;To;;I"QReturns true if the given calendar date is valid, and false if not. Valid in
this context is whether the arguments passed to this method would be accepted
by ::new.

    Date.valid_date?(2001,2,3)        #=> true
    Date.valid_date?(2001,2,29)       #=> false
    Date.valid_date?(2001,2,-1)       #=> true

See also ::jd and ::civil.

;T;0;;;I"valid_civil?;F;I"	Date;T;[o;;I"F::Integer year, ::Integer month, ::Integer mday, ?::Integer start;T;I"	bool;To;;I"ÂReturns true if the given week date is valid, and false if not.

    Date.valid_commercial?(2001,5,6)  #=> true
    Date.valid_commercial?(2001,5,8)  #=> false

See also ::jd and ::commercial.

;T;0;;;I"valid_commercial?;F;I"	Date;T;[o;;I"I::Integer cwyear, ::Integer cweek, ::Integer cwday, ?::Integer start;T;I"	bool;To;;I"QReturns true if the given calendar date is valid, and false if not. Valid in
this context is whether the arguments passed to this method would be accepted
by ::new.

    Date.valid_date?(2001,2,3)        #=> true
    Date.valid_date?(2001,2,29)       #=> false
    Date.valid_date?(2001,2,-1)       #=> true

See also ::jd and ::civil.

;T;0;;;I"valid_date?;F;I"	Date;T;[o;;I"F::Integer year, ::Integer month, ::Integer mday, ?::Integer start;T;I"	bool;To;;I"~Just returns true.  It's nonsense, but is for symmetry.

    Date.valid_jd?(2451944)           #=> true

See also ::jd.

;T;0;;;I"valid_jd?;F;I"	Date;T;[o;;I"#::Integer jd, ?::Integer start;T;I"	bool;To;;I"ÂReturns true if the given ordinal date is valid, and false if not.

    Date.valid_ordinal?(2001,34)      #=> true
    Date.valid_ordinal?(2001,366)     #=> false

See also ::jd and ::ordinal.

;T;0;;;I"valid_ordinal?;F;I"	Date;T;[o;;I"5::Integer year, ::Integer yday, ?::Integer start;T;I"	bool;To;;I"MCreates a new Date object by parsing from a string according to some typical
XML Schema formats.

    Date.xmlschema('2001-02-03')      #=> #<Date: 2001-02-03 ...>

Raise an ArgumentError when the string length is longer than *limit*. You can
stop this check by passing `limit: nil`, but note that it may take a long time
to parse.

;T;0;;;I"xmlschema;F;I"	Date;T;[o;;I"#::String str, ?::Integer start;T;I"	Date;To;;I"^Returns a date object pointing `other` days after self.  The other should be a
numeric value.  If the other is a fractional number, assumes its precision is
at most nanosecond.

    Date.new(2001,2,3) + 1    #=> #<Date: 2001-02-04 ...>
    DateTime.new(2001,2,3) + Rational(1,2)
                              #=> #<DateTime: 2001-02-03T12:00:00+00:00 ...>
    DateTime.new(2001,2,3) + Rational(-1,2)
                              #=> #<DateTime: 2001-02-02T12:00:00+00:00 ...>
    DateTime.jd(0,12) + DateTime.new(2001,2,3).ajd
                              #=> #<DateTime: 2001-02-03T00:00:00+00:00 ...>

;T;0;;;I"+;F;I"	Date;T;[o;;I"::Numeric & ::_ToR other;T;I"	Date;To;;I"YReturns the difference between the two dates if the other is a date object.
If the other is a numeric value, returns a date object pointing `other` days
before self.  If the other is a fractional number, assumes its precision is at
most nanosecond.

    Date.new(2001,2,3) - 1   #=> #<Date: 2001-02-02 ...>
    DateTime.new(2001,2,3) - Rational(1,2)
                             #=> #<DateTime: 2001-02-02T12:00:00+00:00 ...>
    Date.new(2001,2,3) - Date.new(2001)
                             #=> (33/1)
    DateTime.new(2001,2,3) - DateTime.new(2001,2,2,12)
                             #=> (1/2)

;T;0;;;I"-;F;I"	Date;T;[o;;I"::Numeric & ::_ToR other;T;I"	Date;To;;I"::Date other;T;I"Rational;To;;I"ÇReturns a date object pointing `n` months before self. The argument `n` should
be a numeric value.

    Date.new(2001,2,3)  <<  1   #=> #<Date: 2001-01-03 ...>
    Date.new(2001,2,3)  << -2   #=> #<Date: 2001-04-03 ...>

When the same day does not exist for the corresponding month, the last day of
the month is used instead:

    Date.new(2001,3,28) << 1   #=> #<Date: 2001-02-28 ...>
    Date.new(2001,3,31) << 1   #=> #<Date: 2001-02-28 ...>

This also results in the following, possibly unexpected, behavior:

    Date.new(2001,3,31) << 2         #=> #<Date: 2001-01-31 ...>
    Date.new(2001,3,31) << 1 << 1    #=> #<Date: 2001-01-28 ...>

    Date.new(2001,3,31) << 1 << -1   #=> #<Date: 2001-03-28 ...>

;T;0;;;I"<<;F;I"	Date;T;[o;;I"::Integer month;T;I"	Date;To;;I"¼Compares the two dates and returns -1, zero, 1 or nil.  The other should be a
date object or a numeric value as an astronomical Julian day number.

    Date.new(2001,2,3) <=> Date.new(2001,2,4)   #=> -1
    Date.new(2001,2,3) <=> Date.new(2001,2,3)   #=> 0
    Date.new(2001,2,3) <=> Date.new(2001,2,2)   #=> 1
    Date.new(2001,2,3) <=> Object.new           #=> nil
    Date.new(2001,2,3) <=> Rational(4903887,2)  #=> 0

See also Comparable.

;T;0;;;I"<=>;F;I"	Date;T;[o;;I"untyped other;T;I"Integer?;To;;I"5Returns true if they are the same day.

    Date.new(2001,2,3) === Date.new(2001,2,3)
                                      #=> true
    Date.new(2001,2,3) === Date.new(2001,2,4)
                                      #=> false
    DateTime.new(2001,2,3) === DateTime.new(2001,2,3,12)
                                      #=> true
    DateTime.new(2001,2,3) === DateTime.new(2001,2,3,0,0,0,'+24:00')
                                      #=> true
    DateTime.new(2001,2,3) === DateTime.new(2001,2,4,0,0,0,'+24:00')
                                      #=> false

;T;0;;;I"===;F;I"	Date;T;[o;;I"::Date other;T;I"	bool;To;;I"ÆReturns a date object pointing `n` months after self. The argument `n` should
be a numeric value.

    Date.new(2001,2,3)  >>  1   #=> #<Date: 2001-03-03 ...>
    Date.new(2001,2,3)  >> -2   #=> #<Date: 2000-12-03 ...>

When the same day does not exist for the corresponding month, the last day of
the month is used instead:

    Date.new(2001,1,28) >> 1   #=> #<Date: 2001-02-28 ...>
    Date.new(2001,1,31) >> 1   #=> #<Date: 2001-02-28 ...>

This also results in the following, possibly unexpected, behavior:

    Date.new(2001,1,31) >> 2         #=> #<Date: 2001-03-31 ...>
    Date.new(2001,1,31) >> 1 >> 1    #=> #<Date: 2001-03-28 ...>

    Date.new(2001,1,31) >> 1 >> -1   #=> #<Date: 2001-01-28 ...>

;T;0;;;I">>;F;I"	Date;T;[o;;I"::Integer month;T;I"	Date;To;;I"ûReturns the astronomical Julian day number.  This is a fractional number,
which is not adjusted by the offset.

    DateTime.new(2001,2,3,4,5,6,'+7').ajd     #=> (11769328217/4800)
    DateTime.new(2001,2,2,14,5,6,'-7').ajd    #=> (11769328217/4800)

;T;0;;;I"ajd;F;I"	Date;T;[o;;I" ;F;I"Rational;To;;I" Returns the astronomical modified Julian day number.  This is a fractional
number, which is not adjusted by the offset.

    DateTime.new(2001,2,3,4,5,6,'+7').amjd    #=> (249325817/4800)
    DateTime.new(2001,2,2,14,5,6,'-7').amjd   #=> (249325817/4800)

;T;0;;;I"	amjd;F;I"	Date;T;[o;;I" ;F;I"Rational;To;;I"—Returns a string in asctime(3) format (but without "n\0" at the end).  This
method is equivalent to strftime('%c').

See also asctime(3) or ctime(3).

;T;0;;;I"asctime;F;I"	Date;T;[o;;I" ;F;I"String;To;;I"—Returns a string in asctime(3) format (but without "n\0" at the end).  This
method is equivalent to strftime('%c').

See also asctime(3) or ctime(3).

;T;0;;;I"
ctime;F;I"	Date;T;[o;;I" ;F;I"String;To;;I"hReturns the day of calendar week (1-7, Monday is 1).

    Date.new(2001,2,3).cwday          #=> 6

;T;0;;;I"
cwday;F;I"	Date;T;[o;;I" ;F;I"Integer;To;;I"\Returns the calendar week number (1-53).

    Date.new(2001,2,3).cweek          #=> 5

;T;0;;;I"
cweek;F;I"	Date;T;[o;;I" ;F;I"Integer;To;;I"†Returns the calendar week based year.

    Date.new(2001,2,3).cwyear         #=> 2001
    Date.new(2000,1,1).cwyear         #=> 1999

;T;0;;;I"cwyear;F;I"	Date;T;[o;;I" ;F;I"Integer;To;;I"XReturns the day of the month (1-31).

    Date.new(2001,2,3).mday           #=> 3

;T;0;;;I"day;F;I"	Date;T;[o;;I" ;F;I"Integer;To;;I">This method is equivalent to step(min, -1){|date| ...}.

;T;0;;;I"downto;F;I"	Date;T;[o;;I"::Date min;T;I"	Date;To;;I"::Date min;T;I"Enumerator[::Date, ::Date];To;;I"=This method is equivalent to new_start(Date::ENGLAND).

;T;0;;;I"england;F;I"	Date;T;[o;;I" ;F;I"	Date;To;;I"*Returns true if the date is Friday.

;T;0;;;I"friday?;F;I"	Date;T;[o;;I" ;F;I"	bool;To;;I"?This method is equivalent to new_start(Date::GREGORIAN).

;T;0;;;I"gregorian;F;I"	Date;T;[o;;I" ;F;I"	Date;To;;I"³Returns true if the date is on or after the day of calendar reform.

    Date.new(1582,10,15).gregorian?          #=> true
    (Date.new(1582,10,15) - 1).gregorian?    #=> false

;T;0;;;I"gregorian?;F;I"	Date;T;[o;;I" ;F;I"	bool;To;;I"WThis method is equivalent to strftime('%a, %d %b %Y %T GMT'). See also RFC
2616.

;T;0;;;I"httpdate;F;I"	Date;T;[o;;I" ;F;I"String;To;;I"àReturns the value as a string for inspection.

    Date.new(2001,2,3).inspect
              #=> "#<Date: 2001-02-03>"
    DateTime.new(2001,2,3,4,5,6,'-7').inspect
              #=> "#<DateTime: 2001-02-03T04:05:06-07:00>"

;T;0;;;I"inspect;F;I"	Date;T;[o;;I" ;F;I"String;To;;I"3This method is equivalent to strftime('%F').

;T;0;;;I"iso8601;F;I"	Date;T;[o;;I" ;F;I"String;To;;I";This method is equivalent to new_start(Date::ITALY).

;T;0;;;I"
italy;F;I"	Date;T;[o;;I" ;F;I"	Date;To;;I"áReturns the Julian day number.  This is a whole number, which is adjusted by
the offset as the local time.

    DateTime.new(2001,2,3,4,5,6,'+7').jd      #=> 2451944
    DateTime.new(2001,2,3,4,5,6,'-7').jd      #=> 2451944

;T;0;;;I"jd;F;I"	Date;T;[o;;I" ;F;I"Integer;To;;I"fReturns a string in a JIS X 0301 format.

    Date.new(2001,2,3).jisx0301       #=> "H13.02.03"

;T;0;;;I"jisx0301;F;I"	Date;T;[o;;I" ;F;I"String;To;;I"<This method is equivalent to new_start(Date::JULIAN).

;T;0;;;I"julian;F;I"	Date;T;[o;;I" ;F;I"	Date;To;;I"®Returns true if the date is before the day of calendar reform.

    Date.new(1582,10,15).julian?             #=> false
    (Date.new(1582,10,15) - 1).julian?       #=> true

;T;0;;;I"julian?;F;I"	Date;T;[o;;I" ;F;I"	bool;To;;I"Returns the Lilian day number.  This is a whole number, which is adjusted by
the offset as the local time.

    Date.new(2001,2,3).ld            #=> 152784

;T;0;;;I"ld;F;I"	Date;T;[o;;I" ;F;I"Integer;To;;I"Returns true if the year is a leap year.

    Date.new(2000).leap?      #=> true
    Date.new(2001).leap?      #=> false

;T;0;;;I"
leap?;F;I"	Date;T;[o;;I" ;F;I"	bool;To;;I"XReturns the day of the month (1-31).

    Date.new(2001,2,3).mday           #=> 3

;T;0;;;I"	mday;F;I"	Date;T;[o;;I" ;F;I"Integer;To;;I"æReturns the modified Julian day number.  This is a whole number, which is
adjusted by the offset as the local time.

    DateTime.new(2001,2,3,4,5,6,'+7').mjd     #=> 51943
    DateTime.new(2001,2,3,4,5,6,'-7').mjd     #=> 51943

;T;0;;;I"mjd;F;I"	Date;T;[o;;I" ;F;I"Integer;To;;I"MReturns the month (1-12).

    Date.new(2001,2,3).mon            #=> 2

;T;0;;;I"mon;F;I"	Date;T;[o;;I" ;F;I"Integer;To;;I"*Returns true if the date is Monday.

;T;0;;;I"monday?;F;I"	Date;T;[o;;I" ;F;I"	bool;To;;I"MReturns the month (1-12).

    Date.new(2001,2,3).mon            #=> 2

;T;0;;;I"
month;F;I"	Date;T;[o;;I" ;F;I"Integer;To;;I"˜Duplicates self and resets its day of calendar reform.

    d = Date.new(1582,10,15)
    d.new_start(Date::JULIAN)         #=> #<Date: 1582-10-05 ...>

;T;0;;;I"new_start;F;I"	Date;T;[o;;I"?::Integer start;T;I"	Date;To;;I"8Returns a date object denoting the following day.

;T;0;;;I"	next;F;I"	Date;T;[o;;I" ;F;I"	Date;To;;I"*This method is equivalent to d + n.

;T;0;;;I"next_day;F;I"	Date;T;[o;;I"?::Integer day;T;I"	Date;To;;I"FThis method is equivalent to d >> n.

See Date#>> for examples.

;T;0;;;I"next_month;F;I"	Date;T;[o;;I"?::Integer month;T;I"	Date;To;;I"This method is equivalent to d >> (n * 12).

    Date.new(2001,2,3).next_year      #=> #<Date: 2002-02-03 ...>
    Date.new(2008,2,29).next_year     #=> #<Date: 2009-02-28 ...>
    Date.new(2008,2,29).next_year(4)  #=> #<Date: 2012-02-29 ...>

See also Date#>>.

;T;0;;;I"next_year;F;I"	Date;T;[o;;I"?::Integer year;T;I"	Date;To;;I"*This method is equivalent to d - n.

;T;0;;;I"prev_day;F;I"	Date;T;[o;;I"?::Integer day;T;I"	Date;To;;I"FThis method is equivalent to d << n.

See Date#<< for examples.

;T;0;;;I"prev_month;F;I"	Date;T;[o;;I"?::Integer month;T;I"	Date;To;;I"This method is equivalent to d << (n * 12).

    Date.new(2001,2,3).prev_year      #=> #<Date: 2000-02-03 ...>
    Date.new(2008,2,29).prev_year     #=> #<Date: 2007-02-28 ...>
    Date.new(2008,2,29).prev_year(4)  #=> #<Date: 2004-02-29 ...>

See also Date#<<.

;T;0;;;I"prev_year;F;I"	Date;T;[o;;I"?::Integer year;T;I"	Date;To;;I"DThis method is equivalent to strftime('%a, %-d %b %Y %T %z').

;T;0;;;I"rfc2822;F;I"	Date;T;[o;;I" ;F;I"String;To;;I"9This method is equivalent to strftime('%FT%T%:z').

;T;0;;;I"rfc3339;F;I"	Date;T;[o;;I" ;F;I"String;To;;I"†Creates a new Date object by parsing from a string according to some typical
RFC 2822 formats.

    Date.rfc2822('Sat, 3 Feb 2001 00:00:00 +0000')
                                              #=> #<Date: 2001-02-03 ...>

Raise an ArgumentError when the string length is longer than *limit*. You can
stop this check by passing `limit: nil`, but note that it may take a long time
to parse.

;T;0;;;I"rfc822;F;I"	Date;T;[o;;I" ;F;I"String;To;;I",Returns true if the date is Saturday.

;T;0;;;I"saturday?;F;I"	Date;T;[o;;I" ;F;I"	bool;To;;I"½Returns the Julian day number denoting the day of calendar reform.

    Date.new(2001,2,3).start                  #=> 2299161.0
    Date.new(2001,2,3,Date::GREGORIAN).start  #=> -Infinity

;T;0;;;I"
start;F;I"	Date;T;[o;;I" ;F;I"
Float;To;;I"ÖIterates evaluation of the given block, which takes a date object. The limit
should be a date object.

    Date.new(2001).step(Date.new(2001,-1,-1)).select{|d| d.sunday?}.size
                              #=> 52

;T;0;;;I"	step;F;I"	Date;T;[o;;I""::Date limit, ?::Integer step;T;I"	Date;To;;I""::Date limit, ?::Integer step;T;I"Enumerator[::Date, ::Date];To;;I"À Formats date according to the directives in the given format string. The
directives begin with a percent (%) character. Any text not listed as a
directive will be passed through to the output string.

A directive consists of a percent (%) character, zero or more flags, an
optional minimum field width, an optional modifier, and a conversion specifier
as follows.

    %<flags><width><modifier><conversion>

Flags:
    -  don't pad a numerical output.
    _  use spaces for padding.
    0  use zeros for padding.
    ^  upcase the result string.
    #  change case.

The minimum field width specifies the minimum width.

The modifiers are "E", "O", ":", "::" and ":::". "E" and "O" are ignored.  No
effect to result currently.

Format directives:

    Date (Year, Month, Day):
      %Y - Year with century (can be negative, 4 digits at least)
              -0001, 0000, 1995, 2009, 14292, etc.
      %C - year / 100 (round down.  20 in 2009)
      %y - year % 100 (00..99)

      %m - Month of the year, zero-padded (01..12)
              %_m  blank-padded ( 1..12)
              %-m  no-padded (1..12)
      %B - The full month name (``January'')
              %^B  uppercased (``JANUARY'')
      %b - The abbreviated month name (``Jan'')
              %^b  uppercased (``JAN'')
      %h - Equivalent to %b

      %d - Day of the month, zero-padded (01..31)
              %-d  no-padded (1..31)
      %e - Day of the month, blank-padded ( 1..31)

      %j - Day of the year (001..366)

    Time (Hour, Minute, Second, Subsecond):
      %H - Hour of the day, 24-hour clock, zero-padded (00..23)
      %k - Hour of the day, 24-hour clock, blank-padded ( 0..23)
      %I - Hour of the day, 12-hour clock, zero-padded (01..12)
      %l - Hour of the day, 12-hour clock, blank-padded ( 1..12)
      %P - Meridian indicator, lowercase (``am'' or ``pm'')
      %p - Meridian indicator, uppercase (``AM'' or ``PM'')

      %M - Minute of the hour (00..59)

      %S - Second of the minute (00..60)

      %L - Millisecond of the second (000..999)
      %N - Fractional seconds digits, default is 9 digits (nanosecond)
              %3N  millisecond (3 digits)   %15N femtosecond (15 digits)
              %6N  microsecond (6 digits)   %18N attosecond  (18 digits)
              %9N  nanosecond  (9 digits)   %21N zeptosecond (21 digits)
              %12N picosecond (12 digits)   %24N yoctosecond (24 digits)

    Time zone:
      %z - Time zone as hour and minute offset from UTC (e.g. +0900)
              %:z - hour and minute offset from UTC with a colon (e.g. +09:00)
              %::z - hour, minute and second offset from UTC (e.g. +09:00:00)
              %:::z - hour, minute and second offset from UTC
                                                (e.g. +09, +09:30, +09:30:30)
      %Z - Equivalent to %:z (e.g. +09:00)

    Weekday:
      %A - The full weekday name (``Sunday'')
              %^A  uppercased (``SUNDAY'')
      %a - The abbreviated name (``Sun'')
              %^a  uppercased (``SUN'')
      %u - Day of the week (Monday is 1, 1..7)
      %w - Day of the week (Sunday is 0, 0..6)

    ISO 8601 week-based year and week number:
    The week 1 of YYYY starts with a Monday and includes YYYY-01-04.
    The days in the year before the first week are in the last week of
    the previous year.
      %G - The week-based year
      %g - The last 2 digits of the week-based year (00..99)
      %V - Week number of the week-based year (01..53)

    Week number:
    The week 1 of YYYY starts with a Sunday or Monday (according to %U
    or %W).  The days in the year before the first week are in week 0.
      %U - Week number of the year.  The week starts with Sunday.  (00..53)
      %W - Week number of the year.  The week starts with Monday.  (00..53)

    Seconds since the Unix Epoch:
      %s - Number of seconds since 1970-01-01 00:00:00 UTC.
      %Q - Number of milliseconds since 1970-01-01 00:00:00 UTC.

    Literal string:
      %n - Newline character (\n)
      %t - Tab character (\t)
      %% - Literal ``%'' character

    Combination:
      %c - date and time (%a %b %e %T %Y)
      %D - Date (%m/%d/%y)
      %F - The ISO 8601 date format (%Y-%m-%d)
      %v - VMS date (%e-%^b-%Y)
      %x - Same as %D
      %X - Same as %T
      %r - 12-hour time (%I:%M:%S %p)
      %R - 24-hour time (%H:%M)
      %T - 24-hour time (%H:%M:%S)
      %+ - date(1) (%a %b %e %H:%M:%S %Z %Y)

This method is similar to the strftime() function defined in ISO C and POSIX.
Several directives (%a, %A, %b, %B, %c, %p, %r, %x, %X, %E*, %O* and %Z) are
locale dependent in the function. However, this method is locale independent.
So, the result may differ even if the same format string is used in other
systems such as C. It is good practice to avoid %x and %X because there are
corresponding locale independent representations, %D and %T.

Examples:

    d = DateTime.new(2007,11,19,8,37,48,"-06:00")
                              #=> #<DateTime: 2007-11-19T08:37:48-0600 ...>
    d.strftime("Printed on %m/%d/%Y")   #=> "Printed on 11/19/2007"
    d.strftime("at %I:%M%p")            #=> "at 08:37AM"

Various ISO 8601 formats:
    %Y%m%d           => 20071119                  Calendar date (basic)
    %F               => 2007-11-19                Calendar date (extended)
    %Y-%m            => 2007-11                   Calendar date, reduced accuracy, specific month
    %Y               => 2007                      Calendar date, reduced accuracy, specific year
    %C               => 20                        Calendar date, reduced accuracy, specific century
    %Y%j             => 2007323                   Ordinal date (basic)
    %Y-%j            => 2007-323                  Ordinal date (extended)
    %GW%V%u          => 2007W471                  Week date (basic)
    %G-W%V-%u        => 2007-W47-1                Week date (extended)
    %GW%V            => 2007W47                   Week date, reduced accuracy, specific week (basic)
    %G-W%V           => 2007-W47                  Week date, reduced accuracy, specific week (extended)
    %H%M%S           => 083748                    Local time (basic)
    %T               => 08:37:48                  Local time (extended)
    %H%M             => 0837                      Local time, reduced accuracy, specific minute (basic)
    %H:%M            => 08:37                     Local time, reduced accuracy, specific minute (extended)
    %H               => 08                        Local time, reduced accuracy, specific hour
    %H%M%S,%L        => 083748,000                Local time with decimal fraction, comma as decimal sign (basic)
    %T,%L            => 08:37:48,000              Local time with decimal fraction, comma as decimal sign (extended)
    %H%M%S.%L        => 083748.000                Local time with decimal fraction, full stop as decimal sign (basic)
    %T.%L            => 08:37:48.000              Local time with decimal fraction, full stop as decimal sign (extended)
    %H%M%S%z         => 083748-0600               Local time and the difference from UTC (basic)
    %T%:z            => 08:37:48-06:00            Local time and the difference from UTC (extended)
    %Y%m%dT%H%M%S%z  => 20071119T083748-0600      Date and time of day for calendar date (basic)
    %FT%T%:z         => 2007-11-19T08:37:48-06:00 Date and time of day for calendar date (extended)
    %Y%jT%H%M%S%z    => 2007323T083748-0600       Date and time of day for ordinal date (basic)
    %Y-%jT%T%:z      => 2007-323T08:37:48-06:00   Date and time of day for ordinal date (extended)
    %GW%V%uT%H%M%S%z => 2007W471T083748-0600      Date and time of day for week date (basic)
    %G-W%V-%uT%T%:z  => 2007-W47-1T08:37:48-06:00 Date and time of day for week date (extended)
    %Y%m%dT%H%M      => 20071119T0837             Calendar date and local time (basic)
    %FT%R            => 2007-11-19T08:37          Calendar date and local time (extended)
    %Y%jT%H%MZ       => 2007323T0837Z             Ordinal date and UTC of day (basic)
    %Y-%jT%RZ        => 2007-323T08:37Z           Ordinal date and UTC of day (extended)
    %GW%V%uT%H%M%z   => 2007W471T0837-0600        Week date and local time and difference from UTC (basic)
    %G-W%V-%uT%R%:z  => 2007-W47-1T08:37-06:00    Week date and local time and difference from UTC (extended)

See also strftime(3) and ::strptime.

;T;0;;;I"strftime;F;I"	Date;T;[o;;I"?::String format;T;I"String;To;;I"8Returns a date object denoting the following day.

;T;0;;;I"	succ;F;I"	Date;T;[o;;I" ;F;I"	Date;To;;I"*Returns true if the date is Sunday.

;T;0;;;I"sunday?;F;I"	Date;T;[o;;I" ;F;I"	bool;To;;I",Returns true if the date is Thursday.

;T;0;;;I"thursday?;F;I"	Date;T;[o;;I" ;F;I"	bool;To;;I"Returns self.

;T;0;;;I"to_date;F;I"	Date;T;[o;;I" ;F;I"	Date;To;;I"4Returns a DateTime object which denotes self.

;T;0;;;I"to_datetime;F;I"	Date;T;[o;;I" ;F;I"DateTime;To;;I"Returns a string in an ISO 8601 format. (This method doesn't use the expanded
representations.)

    Date.new(2001,2,3).to_s  #=> "2001-02-03"

;T;0;;;I"	to_s;F;I"	Date;T;[o;;I" ;F;I"String;To;;I"‚Returns a Time object which denotes self. If self is a julian date, convert it
to a gregorian date before converting it to Time.

;T;0;;;I"to_time;F;I"	Date;T;[o;;I" ;F;I"	Time;To;;I"+Returns true if the date is Tuesday.

;T;0;;;I"tuesday?;F;I"	Date;T;[o;;I" ;F;I"	bool;To;;I"=This method is equivalent to step(max, 1){|date| ...}.

;T;0;;;I"	upto;F;I"	Date;T;[o;;I"::Date max;T;I"	Date;To;;I"::Date max;T;I"Enumerator[::Date, ::Date];To;;I"bReturns the day of week (0-6, Sunday is zero).

    Date.new(2001,2,3).wday           #=> 6

;T;0;;;I"	wday;F;I"	Date;T;[o;;I" ;F;I"Integer;To;;I"-Returns true if the date is Wednesday.

;T;0;;;I"wednesday?;F;I"	Date;T;[o;;I" ;F;I"	bool;To;;I"3This method is equivalent to strftime('%F').

;T;0;;;I"xmlschema;F;I"	Date;T;[o;;I" ;F;I"String;To;;I"YReturns the day of the year (1-366).

    Date.new(2001,2,3).yday           #=> 34

;T;0;;;I"	yday;F;I"	Date;T;[o;;I" ;F;I"Integer;To;;I"tReturns the year.

    Date.new(2001,2,3).year           #=> 2001
    (Date.new(1,1,1) - 1).year        #=> 0

;T;0;;;I"	year;F;I"	Date;T;[o;;I" ;F;I"Integer;To; ;0;0;	I"	Date;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"zDeserializes JSON string by converting Julian year `y`, month `m`, day `d` and
Day of Calendar Reform `sg` to Date.

;T;0;;;I"json_create;F;I"	Date;T;[o;;I"<::Hash[::String, ::String | ::Integer | ::Float] object;T;I"instance;To;;I"XReturns a hash, that will be turned into a JSON object and represent this
object.

;T;0;;;I"as_json;F;I"	Date;T;[o;;I"*untyped;T;I"3Hash[::String, ::String | ::Integer | ::Float];To;;I"wStores class name (Date) with Julian year `y`, month `m`, day `d` and Day of
Calendar Reform `sg` as JSON string

;T;0;;;I"to_json;F;I"	Date;T;[o;;I"?::JSON::State state;T;I"String;To; ;I"§## DateTime

A subclass of Date that easily handles date, hour, minute, second, and offset.

DateTime class is considered deprecated. Use Time class.

DateTime does not consider any leap seconds, does not track any summer time
rules.

A DateTime object is created with DateTime::new, DateTime::jd,
DateTime::ordinal, DateTime::commercial, DateTime::parse, DateTime::strptime,
DateTime::now, Time#to_datetime, etc.

    require 'date'

    DateTime.new(2001,2,3,4,5,6)
                        #=> #<DateTime: 2001-02-03T04:05:06+00:00 ...>

The last element of day, hour, minute, or second can be a fractional number.
The fractional number's precision is assumed at most nanosecond.

    DateTime.new(2001,2,3.5)
                        #=> #<DateTime: 2001-02-03T12:00:00+00:00 ...>

An optional argument, the offset, indicates the difference between the local
time and UTC. For example, `Rational(3,24)` represents ahead of 3 hours of
UTC, `Rational(-5,24)` represents behind of 5 hours of UTC. The offset should
be -1 to +1, and its precision is assumed at most second. The default value is
zero (equals to UTC).

    DateTime.new(2001,2,3,4,5,6,Rational(3,24))
                        #=> #<DateTime: 2001-02-03T04:05:06+03:00 ...>

The offset also accepts string form:

    DateTime.new(2001,2,3,4,5,6,'+03:00')
                        #=> #<DateTime: 2001-02-03T04:05:06+03:00 ...>

An optional argument, the day of calendar reform (`start`), denotes a Julian
day number, which should be 2298874 to 2426355 or negative/positive infinity.
The default value is `Date::ITALY` (2299161=1582-10-15).

A DateTime object has various methods. See each reference.

    d = DateTime.parse('3rd Feb 2001 04:05:06+03:30')
                        #=> #<DateTime: 2001-02-03T04:05:06+03:30 ...>
    d.hour              #=> 4
    d.min               #=> 5
    d.sec               #=> 6
    d.offset            #=> (7/48)
    d.zone              #=> "+03:30"
    d += Rational('1.5')
                        #=> #<DateTime: 2001-02-04%16:05:06+03:30 ...>
    d = d.new_offset('+09:00')
                        #=> #<DateTime: 2001-02-04%21:35:06+09:00 ...>
    d.strftime('%I:%M:%S %p')
                        #=> "09:35:06 PM"
    d > DateTime.new(1999)
                        #=> true

### When should you use DateTime and when should you use Time?

It's a common misconception that [William
Shakespeare](https://en.wikipedia.org/wiki/William_Shakespeare) and [Miguel de
Cervantes](https://en.wikipedia.org/wiki/Miguel_de_Cervantes) died on the same
day in history - so much so that UNESCO named April 23 as [World Book Day
because of this fact](https://en.wikipedia.org/wiki/World_Book_Day). However,
because England hadn't yet adopted the [Gregorian Calendar
Reform](https://en.wikipedia.org/wiki/Gregorian_calendar#Gregorian_reform)
(and wouldn't until
[1752](https://en.wikipedia.org/wiki/Calendar_(New_Style)_Act_1750)) their
deaths are actually 10 days apart. Since Ruby's Time class implements a
[proleptic Gregorian
calendar](https://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar) and has
no concept of calendar reform there's no way to express this with Time
objects. This is where DateTime steps in:

    shakespeare = DateTime.iso8601('1616-04-23', Date::ENGLAND)
     #=> Tue, 23 Apr 1616 00:00:00 +0000
    cervantes = DateTime.iso8601('1616-04-23', Date::ITALY)
     #=> Sat, 23 Apr 1616 00:00:00 +0000

Already you can see something is weird - the days of the week are different.
Taking this further:

    cervantes == shakespeare
     #=> false
    (shakespeare - cervantes).to_i
     #=> 10

This shows that in fact they died 10 days apart (in reality 11 days since
Cervantes died a day earlier but was buried on the 23rd). We can see the
actual date of Shakespeare's death by using the #gregorian method to convert
it:

    shakespeare.gregorian
     #=> Tue, 03 May 1616 00:00:00 +0000

So there's an argument that all the celebrations that take place on the 23rd
April in Stratford-upon-Avon are actually the wrong date since England is now
using the Gregorian calendar. You can see why when we transition across the
reform date boundary:

    # start off with the anniversary of Shakespeare's birth in 1751
    shakespeare = DateTime.iso8601('1751-04-23', Date::ENGLAND)
     #=> Tue, 23 Apr 1751 00:00:00 +0000

    # add 366 days since 1752 is a leap year and April 23 is after February 29
    shakespeare + 366
     #=> Thu, 23 Apr 1752 00:00:00 +0000

    # add another 365 days to take us to the anniversary in 1753
    shakespeare + 366 + 365
     #=> Fri, 04 May 1753 00:00:00 +0000

As you can see, if we're accurately tracking the number of [solar
years](https://en.wikipedia.org/wiki/Tropical_year) since Shakespeare's
birthday then the correct anniversary date would be the 4th May and not the
23rd April.

So when should you use DateTime in Ruby and when should you use Time? Almost
certainly you'll want to use Time since your app is probably dealing with
current dates and times. However, if you need to deal with dates and times in
a historical context you'll want to use DateTime to avoid making the same
mistakes as UNESCO. If you also have to deal with timezones then best of luck
- just bear in mind that you'll probably be dealing with [local solar
times](https://en.wikipedia.org/wiki/Solar_time), since it wasn't until the
19th century that the introduction of the railways necessitated the need for
[Standard Time](https://en.wikipedia.org/wiki/Standard_time#Great_Britain) and
eventually timezones.

;T;0;	I"DateTime;T;
[ ;[ ;0;[ ;[ ;0;I"	Date;To;;I"{Creates a DateTime object denoting the given calendar date.

    DateTime.new(2001,2,3)    #=> #<DateTime: 2001-02-03T00:00:00+00:00 ...>
    DateTime.new(2001,2,3,4,5,6,'+7')
                              #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>
    DateTime.new(2001,-11,-26,-20,-55,-54,'+7')
                              #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>

;T;0;;;I"initialize;F;I"DateTime;T;[o;;I"Ž?::Integer year, ?::Integer month, ?::Integer mday, ?::Integer hour, ?::Integer minute, ?::Integer second, ?::Integer offset, ?::Integer start;T;I"	void;To;;I"åParses the given representation of date and time with the given template, and
returns a hash of parsed elements.  _strptime does not support specification
of flags and width unlike strftime.

See also strptime(3) and #strftime.

;T;0;;;I"_strptime;F;I"DateTime;T;[o;;I"#::String str, ?::String format;T;I")Hash[::Symbol, ::Integer | ::String];To;;I"{Creates a DateTime object denoting the given calendar date.

    DateTime.new(2001,2,3)    #=> #<DateTime: 2001-02-03T00:00:00+00:00 ...>
    DateTime.new(2001,2,3,4,5,6,'+7')
                              #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>
    DateTime.new(2001,-11,-26,-20,-55,-54,'+7')
                              #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>

;T;0;;;I"
civil;F;I"DateTime;T;[o;;I"Ž?::Integer year, ?::Integer month, ?::Integer mday, ?::Integer hour, ?::Integer minute, ?::Integer second, ?::Integer offset, ?::Integer start;T;I"DateTime;To;;I"NCreates a DateTime object denoting the given week date.

    DateTime.commercial(2001) #=> #<DateTime: 2001-01-01T00:00:00+00:00 ...>
    DateTime.commercial(2002) #=> #<DateTime: 2001-12-31T00:00:00+00:00 ...>
    DateTime.commercial(2001,5,6,4,5,6,'+7')
                              #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>

;T;0;;;I"commercial;F;I"DateTime;T;[o;;I"‘?::Integer cwyear, ?::Integer cweek, ?::Integer cwday, ?::Integer hour, ?::Integer minute, ?::Integer second, ?::Integer offset, ?::Integer start;T;I"DateTime;To;;I"ˆCreates a new DateTime object by parsing from a string according to some RFC
2616 format.

    DateTime.httpdate('Sat, 03 Feb 2001 04:05:06 GMT')
                              #=> #<DateTime: 2001-02-03T04:05:06+00:00 ...>

Raise an ArgumentError when the string length is longer than *limit*. You can
stop this check by passing `limit: nil`, but note that it may take a long time
to parse.

;T;0;;;I"httpdate;F;I"DateTime;T;[o;;I"#::String str, ?::Integer start;T;I"DateTime;To;;I"…Creates a new DateTime object by parsing from a string according to some
typical ISO 8601 formats.

    DateTime.iso8601('2001-02-03T04:05:06+07:00')
                              #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>
    DateTime.iso8601('20010203T040506+0700')
                              #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>
    DateTime.iso8601('2001-W05-6T04:05:06+07:00')
                              #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>

Raise an ArgumentError when the string length is longer than *limit*. You can
stop this check by passing `limit: nil`, but note that it may take a long time
to parse.

;T;0;;;I"iso8601;F;I"DateTime;T;[o;;I"#::String str, ?::Integer start;T;I"DateTime;To;;I"YCreates a DateTime object denoting the given chronological Julian day number.

    DateTime.jd(2451944)      #=> #<DateTime: 2001-02-03T00:00:00+00:00 ...>
    DateTime.jd(2451945)      #=> #<DateTime: 2001-02-04T00:00:00+00:00 ...>
    DateTime.jd(Rational('0.5'))
                              #=> #<DateTime: -4712-01-01T12:00:00+00:00 ...>

;T;0;;;I"jd;F;I"DateTime;T;[o;;I"n?::Integer jd, ?::Integer hour, ?::Integer minute, ?::Integer second, ?::Integer offset, ?::Integer start;T;I"DateTime;To;;I"ACreates a new DateTime object by parsing from a string according to some
typical JIS X 0301 formats.

    DateTime.jisx0301('H13.02.03T04:05:06+07:00')
                              #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>

For no-era year, legacy format, Heisei is assumed.

    DateTime.jisx0301('13.02.03T04:05:06+07:00')
                              #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>

Raise an ArgumentError when the string length is longer than *limit*. You can
stop this check by passing `limit: nil`, but note that it may take a long time
to parse.

;T;0;;;I"jisx0301;F;I"DateTime;T;[o;;I"#::String str, ?::Integer start;T;I"DateTime;To;;I"„Creates a DateTime object denoting the present time.

    DateTime.now              #=> #<DateTime: 2011-06-11T21:20:44+09:00 ...>

;T;0;;;I"now;F;I"DateTime;T;[o;;I"?::Integer start;T;I"DateTime;To;;I"~Creates a DateTime object denoting the given ordinal date.

    DateTime.ordinal(2001,34) #=> #<DateTime: 2001-02-03T00:00:00+00:00 ...>
    DateTime.ordinal(2001,34,4,5,6,'+7')
                              #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>
    DateTime.ordinal(2001,-332,-20,-55,-54,'+7')
                              #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>

;T;0;;;I"ordinal;F;I"DateTime;T;[o;;I"|?::Integer year, ?::Integer yday, ?::Integer hour, ?::Integer minute, ?::Integer second, ?::Integer offset, ?::Integer start;T;I"DateTime;To;;I"³Parses the given representation of date and time, and creates a DateTime
object.

This method *does not* function as a validator.  If the input string does not
match valid formats strictly, you may get a cryptic result.  Should consider
to use `DateTime.strptime` instead of this method as possible.

If the optional second argument is true and the detected year is in the range
"00" to "99", makes it full.

    DateTime.parse('2001-02-03T04:05:06+07:00')
                              #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>
    DateTime.parse('20010203T040506+0700')
                              #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>
    DateTime.parse('3rd Feb 2001 04:05:06 PM')
                              #=> #<DateTime: 2001-02-03T16:05:06+00:00 ...>

Raise an ArgumentError when the string length is longer than *limit*. You can
stop this check by passing `limit: nil`, but note that it may take a long time
to parse.

;T;0;;;I"
parse;F;I"DateTime;T;[o;;I"8::String str, ?::boolish complete, ?::Integer start;T;I"DateTime;To;;I"Creates a new DateTime object by parsing from a string according to some
typical RFC 2822 formats.

    DateTime.rfc2822('Sat, 3 Feb 2001 04:05:06 +0700')
                             #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>

Raise an ArgumentError when the string length is longer than *limit*. You can
stop this check by passing `limit: nil`, but note that it may take a long time
to parse.

;T;0;;;I"rfc2822;F;I"DateTime;T;[o;;I"#::String str, ?::Integer start;T;I"DateTime;To;;I"ŒCreates a new DateTime object by parsing from a string according to some
typical RFC 3339 formats.

    DateTime.rfc3339('2001-02-03T04:05:06+07:00')
                              #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>

Raise an ArgumentError when the string length is longer than *limit*. You can
stop this check by passing `limit: nil`, but note that it may take a long time
to parse.

;T;0;;;I"rfc3339;F;I"DateTime;T;[o;;I"#::String str, ?::Integer start;T;I"DateTime;To;;I"Creates a new DateTime object by parsing from a string according to some
typical RFC 2822 formats.

    DateTime.rfc2822('Sat, 3 Feb 2001 04:05:06 +0700')
                             #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>

Raise an ArgumentError when the string length is longer than *limit*. You can
stop this check by passing `limit: nil`, but note that it may take a long time
to parse.

;T;0;;;I"rfc822;F;I"DateTime;T;[o;;I"#::String str, ?::Integer start;T;I"DateTime;To;;I"1Parses the given representation of date and time with the given template, and
creates a DateTime object.  strptime does not support specification of flags
and width unlike strftime.

    DateTime.strptime('2001-02-03T04:05:06+07:00', '%Y-%m-%dT%H:%M:%S%z')
                              #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>
    DateTime.strptime('03-02-2001 04:05:06 PM', '%d-%m-%Y %I:%M:%S %p')
                              #=> #<DateTime: 2001-02-03T16:05:06+00:00 ...>
    DateTime.strptime('2001-W05-6T04:05:06+07:00', '%G-W%V-%uT%H:%M:%S%z')
                              #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>
    DateTime.strptime('2001 04 6 04 05 06 +7', '%Y %U %w %H %M %S %z')
                              #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>
    DateTime.strptime('2001 05 6 04 05 06 +7', '%Y %W %u %H %M %S %z')
                              #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>
    DateTime.strptime('-1', '%s')
                              #=> #<DateTime: 1969-12-31T23:59:59+00:00 ...>
    DateTime.strptime('-1000', '%Q')
                              #=> #<DateTime: 1969-12-31T23:59:59+00:00 ...>
    DateTime.strptime('sat3feb014pm+7', '%a%d%b%y%H%p%z')
                              #=> #<DateTime: 2001-02-03T16:00:00+07:00 ...>

See also strptime(3) and #strftime.

;T;0;;;I"strptime;F;I"DateTime;T;[o;;I"5::String str, ?::String format, ?::Integer start;T;I"DateTime;To;;I"Creates a new DateTime object by parsing from a string according to some
typical XML Schema formats.

    DateTime.xmlschema('2001-02-03T04:05:06+07:00')
                              #=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>

Raise an ArgumentError when the string length is longer than *limit*. You can
stop this check by passing `limit: nil`, but note that it may take a long time
to parse.

;T;0;;;I"xmlschema;F;I"DateTime;T;[o;;I"#::String str, ?::Integer start;T;I"DateTime;To;;I"TReturns the hour (0-23).

    DateTime.new(2001,2,3,4,5,6).hour         #=> 4

;T;0;;;I"	hour;F;I"DateTime;T;[o;;I" ;F;I"Integer;To;;I"This method is equivalent to strftime('%FT%T%:z'). The optional argument `n`
is the number of digits for fractional seconds.

    DateTime.parse('2001-02-03T04:05:06.123456789+07:00').iso8601(9)
                              #=> "2001-02-03T04:05:06.123456789+07:00"

;T;0;;;I"iso8601;F;I"DateTime;T;[o;;I"?::Integer n;T;I"String;To;;I"Returns a string in a JIS X 0301 format. The optional argument `n` is the
number of digits for fractional seconds.

    DateTime.parse('2001-02-03T04:05:06.123456789+07:00').jisx0301(9)
                              #=> "H13.02.03T04:05:06.123456789+07:00"

;T;0;;;I"jisx0301;F;I"DateTime;T;[o;;I"?::Integer n;T;I"String;To;;I"VReturns the minute (0-59).

    DateTime.new(2001,2,3,4,5,6).min          #=> 5

;T;0;;;I"min;F;I"DateTime;T;[o;;I" ;F;I"Integer;To;;I"VReturns the minute (0-59).

    DateTime.new(2001,2,3,4,5,6).min          #=> 5

;T;0;;;I"minute;F;I"DateTime;T;[o;;I" ;F;I"Integer;To;;I"ñDuplicates self and resets its offset.

    d = DateTime.new(2001,2,3,4,5,6,'-02:00')
                              #=> #<DateTime: 2001-02-03T04:05:06-02:00 ...>
    d.new_offset('+09:00')    #=> #<DateTime: 2001-02-03T15:05:06+09:00 ...>

;T;0;;;I"new_offset;F;I"DateTime;T;[o;;I"?::String offset;T;I"DateTime;To;;I"TReturns the offset.

    DateTime.parse('04pm+0730').offset        #=> (5/16)

;T;0;;;I"offset;F;I"DateTime;T;[o;;I" ;F;I"Rational;To;;I"This method is equivalent to strftime('%FT%T%:z'). The optional argument `n`
is the number of digits for fractional seconds.

    DateTime.parse('2001-02-03T04:05:06.123456789+07:00').rfc3339(9)
                              #=> "2001-02-03T04:05:06.123456789+07:00"

;T;0;;;I"rfc3339;F;I"DateTime;T;[o;;I"?::Integer n;T;I"String;To;;I"VReturns the second (0-59).

    DateTime.new(2001,2,3,4,5,6).sec          #=> 6

;T;0;;;I"sec;F;I"DateTime;T;[o;;I" ;F;I"Integer;To;;I"rReturns the fractional part of the second.

    DateTime.new(2001,2,3,4,5,6.5).sec_fraction       #=> (1/2)

;T;0;;;I"sec_fraction;F;I"DateTime;T;[o;;I" ;F;I"Rational;To;;I"VReturns the second (0-59).

    DateTime.new(2001,2,3,4,5,6).sec          #=> 6

;T;0;;;I"second;F;I"DateTime;T;[o;;I" ;F;I"Integer;To;;I"rReturns the fractional part of the second.

    DateTime.new(2001,2,3,4,5,6.5).sec_fraction       #=> (1/2)

;T;0;;;I"second_fraction;F;I"DateTime;T;[o;;I" ;F;I"Rational;To;;I"¡ Formats date according to the directives in the given format string. The
directives begin with a percent (%) character. Any text not listed as a
directive will be passed through to the output string.

A directive consists of a percent (%) character, zero or more flags, an
optional minimum field width, an optional modifier, and a conversion specifier
as follows.

    %<flags><width><modifier><conversion>

Flags:
    -  don't pad a numerical output.
    _  use spaces for padding.
    0  use zeros for padding.
    ^  upcase the result string.
    #  change case.
    :  use colons for %z.

The minimum field width specifies the minimum width.

The modifiers are "E" and "O". They are ignored.

Format directives:

    Date (Year, Month, Day):
      %Y - Year with century (can be negative, 4 digits at least)
              -0001, 0000, 1995, 2009, 14292, etc.
      %C - year / 100 (round down.  20 in 2009)
      %y - year % 100 (00..99)

      %m - Month of the year, zero-padded (01..12)
              %_m  blank-padded ( 1..12)
              %-m  no-padded (1..12)
      %B - The full month name (``January'')
              %^B  uppercased (``JANUARY'')
      %b - The abbreviated month name (``Jan'')
              %^b  uppercased (``JAN'')
      %h - Equivalent to %b

      %d - Day of the month, zero-padded (01..31)
              %-d  no-padded (1..31)
      %e - Day of the month, blank-padded ( 1..31)

      %j - Day of the year (001..366)

    Time (Hour, Minute, Second, Subsecond):
      %H - Hour of the day, 24-hour clock, zero-padded (00..23)
      %k - Hour of the day, 24-hour clock, blank-padded ( 0..23)
      %I - Hour of the day, 12-hour clock, zero-padded (01..12)
      %l - Hour of the day, 12-hour clock, blank-padded ( 1..12)
      %P - Meridian indicator, lowercase (``am'' or ``pm'')
      %p - Meridian indicator, uppercase (``AM'' or ``PM'')

      %M - Minute of the hour (00..59)

      %S - Second of the minute (00..60)

      %L - Millisecond of the second (000..999)
      %N - Fractional seconds digits, default is 9 digits (nanosecond)
              %3N  millisecond (3 digits)   %15N femtosecond (15 digits)
              %6N  microsecond (6 digits)   %18N attosecond  (18 digits)
              %9N  nanosecond  (9 digits)   %21N zeptosecond (21 digits)
              %12N picosecond (12 digits)   %24N yoctosecond (24 digits)

    Time zone:
      %z - Time zone as hour and minute offset from UTC (e.g. +0900)
              %:z - hour and minute offset from UTC with a colon (e.g. +09:00)
              %::z - hour, minute and second offset from UTC (e.g. +09:00:00)
              %:::z - hour, minute and second offset from UTC
                                                (e.g. +09, +09:30, +09:30:30)
      %Z - Equivalent to %:z (e.g. +09:00)

    Weekday:
      %A - The full weekday name (``Sunday'')
              %^A  uppercased (``SUNDAY'')
      %a - The abbreviated name (``Sun'')
              %^a  uppercased (``SUN'')
      %u - Day of the week (Monday is 1, 1..7)
      %w - Day of the week (Sunday is 0, 0..6)

    ISO 8601 week-based year and week number:
    The week 1 of YYYY starts with a Monday and includes YYYY-01-04.
    The days in the year before the first week are in the last week of
    the previous year.
      %G - The week-based year
      %g - The last 2 digits of the week-based year (00..99)
      %V - Week number of the week-based year (01..53)

    Week number:
    The week 1 of YYYY starts with a Sunday or Monday (according to %U
    or %W).  The days in the year before the first week are in week 0.
      %U - Week number of the year.  The week starts with Sunday.  (00..53)
      %W - Week number of the year.  The week starts with Monday.  (00..53)

    Seconds since the Unix Epoch:
      %s - Number of seconds since 1970-01-01 00:00:00 UTC.
      %Q - Number of milliseconds since 1970-01-01 00:00:00 UTC.

    Literal string:
      %n - Newline character (\n)
      %t - Tab character (\t)
      %% - Literal ``%'' character

    Combination:
      %c - date and time (%a %b %e %T %Y)
      %D - Date (%m/%d/%y)
      %F - The ISO 8601 date format (%Y-%m-%d)
      %v - VMS date (%e-%^b-%Y)
      %x - Same as %D
      %X - Same as %T
      %r - 12-hour time (%I:%M:%S %p)
      %R - 24-hour time (%H:%M)
      %T - 24-hour time (%H:%M:%S)
      %+ - date(1) (%a %b %e %H:%M:%S %Z %Y)

This method is similar to the strftime() function defined in ISO C and POSIX.
Several directives (%a, %A, %b, %B, %c, %p, %r, %x, %X, %E*, %O* and %Z) are
locale dependent in the function. However, this method is locale independent.
So, the result may differ even if the same format string is used in other
systems such as C. It is good practice to avoid %x and %X because there are
corresponding locale independent representations, %D and %T.

Examples:

    d = DateTime.new(2007,11,19,8,37,48,"-06:00")
                              #=> #<DateTime: 2007-11-19T08:37:48-0600 ...>
    d.strftime("Printed on %m/%d/%Y")   #=> "Printed on 11/19/2007"
    d.strftime("at %I:%M%p")            #=> "at 08:37AM"

Various ISO 8601 formats:
    %Y%m%d           => 20071119                  Calendar date (basic)
    %F               => 2007-11-19                Calendar date (extended)
    %Y-%m            => 2007-11                   Calendar date, reduced accuracy, specific month
    %Y               => 2007                      Calendar date, reduced accuracy, specific year
    %C               => 20                        Calendar date, reduced accuracy, specific century
    %Y%j             => 2007323                   Ordinal date (basic)
    %Y-%j            => 2007-323                  Ordinal date (extended)
    %GW%V%u          => 2007W471                  Week date (basic)
    %G-W%V-%u        => 2007-W47-1                Week date (extended)
    %GW%V            => 2007W47                   Week date, reduced accuracy, specific week (basic)
    %G-W%V           => 2007-W47                  Week date, reduced accuracy, specific week (extended)
    %H%M%S           => 083748                    Local time (basic)
    %T               => 08:37:48                  Local time (extended)
    %H%M             => 0837                      Local time, reduced accuracy, specific minute (basic)
    %H:%M            => 08:37                     Local time, reduced accuracy, specific minute (extended)
    %H               => 08                        Local time, reduced accuracy, specific hour
    %H%M%S,%L        => 083748,000                Local time with decimal fraction, comma as decimal sign (basic)
    %T,%L            => 08:37:48,000              Local time with decimal fraction, comma as decimal sign (extended)
    %H%M%S.%L        => 083748.000                Local time with decimal fraction, full stop as decimal sign (basic)
    %T.%L            => 08:37:48.000              Local time with decimal fraction, full stop as decimal sign (extended)
    %H%M%S%z         => 083748-0600               Local time and the difference from UTC (basic)
    %T%:z            => 08:37:48-06:00            Local time and the difference from UTC (extended)
    %Y%m%dT%H%M%S%z  => 20071119T083748-0600      Date and time of day for calendar date (basic)
    %FT%T%:z         => 2007-11-19T08:37:48-06:00 Date and time of day for calendar date (extended)
    %Y%jT%H%M%S%z    => 2007323T083748-0600       Date and time of day for ordinal date (basic)
    %Y-%jT%T%:z      => 2007-323T08:37:48-06:00   Date and time of day for ordinal date (extended)
    %GW%V%uT%H%M%S%z => 2007W471T083748-0600      Date and time of day for week date (basic)
    %G-W%V-%uT%T%:z  => 2007-W47-1T08:37:48-06:00 Date and time of day for week date (extended)
    %Y%m%dT%H%M      => 20071119T0837             Calendar date and local time (basic)
    %FT%R            => 2007-11-19T08:37          Calendar date and local time (extended)
    %Y%jT%H%MZ       => 2007323T0837Z             Ordinal date and UTC of day (basic)
    %Y-%jT%RZ        => 2007-323T08:37Z           Ordinal date and UTC of day (extended)
    %GW%V%uT%H%M%z   => 2007W471T0837-0600        Week date and local time and difference from UTC (basic)
    %G-W%V-%uT%R%:z  => 2007-W47-1T08:37-06:00    Week date and local time and difference from UTC (extended)

See also strftime(3) and ::strptime.

;T;0;;;I"strftime;F;I"DateTime;T;[o;;I"?::String format;T;I"String;To;;I"0Returns a Date object which denotes self.

;T;0;;;I"to_date;F;I"DateTime;T;[o;;I" ;F;I"	Date;To;;I"Returns self.

;T;0;;;I"to_datetime;F;I"DateTime;T;[o;;I" ;F;I"DateTime;To;;I"ÊReturns a string in an ISO 8601 format. (This method doesn't use the expanded
representations.)

    DateTime.new(2001,2,3,4,5,6,'-7').to_s
                             #=> "2001-02-03T04:05:06-07:00"

;T;0;;;I"	to_s;F;I"DateTime;T;[o;;I" ;F;I"String;To;;I"0Returns a Time object which denotes self.

;T;0;;;I"to_time;F;I"DateTime;T;[o;;I" ;F;I"	Time;To;;I"This method is equivalent to strftime('%FT%T%:z'). The optional argument `n`
is the number of digits for fractional seconds.

    DateTime.parse('2001-02-03T04:05:06.123456789+07:00').iso8601(9)
                              #=> "2001-02-03T04:05:06.123456789+07:00"

;T;0;;;I"xmlschema;F;I"DateTime;T;[o;;I"?::Integer n;T;I"String;To;;I"XReturns the timezone.

    DateTime.parse('04pm+0730').zone          #=> "+07:30"

;T;0;;;I"	zone;F;I"DateTime;T;[o;;I" ;F;I"String;To; ;0;0;	I"DateTime;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"¡Deserializes JSON string by converting year `y`, month `m`, day `d`, hour `H`,
minute `M`, second `S`, offset `of` and Day of Calendar Reform `sg` to
DateTime.

;T;0;;;I"json_create;F;I"DateTime;T;[o;;I"<::Hash[::String, ::String | ::Integer | ::Float] object;T;I"instance;To;;I"XReturns a hash, that will be turned into a JSON object and represent this
object.

;T;0;;;I"as_json;F;I"DateTime;T;[o;;I"*untyped;T;I"3Hash[::String, ::String | ::Integer | ::Float];To;;I"¥Stores class name (DateTime) with Julian year `y`, month `m`, day `d`, hour
`H`, minute `M`, second `S`, offset `of` and Day of Calendar Reform `sg` as
JSON string

;T;0;;;I"to_json;F;I"DateTime;T;[o;;I"?::JSON::State state;T;I"String;To; ;I"-
## Introduction

The DBM class provides a wrapper to a Unix-style
[dbm](https://en.wikipedia.org/wiki/Dbm) or Database Manager library.

Dbm databases do not have tables or columns; they are simple key-value data
stores, like a Ruby Hash except not resident in RAM. Keys and values must be
strings.

The exact library used depends on how Ruby was compiled. It could be any of
the following:

*   The original ndbm library is released in 4.3BSD. It is based on dbm
    library in Unix Version 7 but has different API to support multiple
    databases in a process.
*   [Berkeley DB](https://en.wikipedia.org/wiki/Berkeley_DB) versions 1 thru
    6, also known as BDB and Sleepycat DB, now owned by Oracle Corporation.
*   Berkeley DB 1.x, still found in 4.4BSD derivatives (FreeBSD, OpenBSD,
    etc).
*   [gdbm](http://www.gnu.org/software/gdbm/), the GNU implementation of dbm.
*   [qdbm](http://fallabs.com/qdbm/index.html), another open source
    reimplementation of dbm.


All of these dbm implementations have their own Ruby interfaces available,
which provide richer (but varying) APIs.

## Cautions

Before you decide to use DBM, there are some issues you should consider:

*   Each implementation of dbm has its own file format. Generally, dbm
    libraries will not read each other's files. This makes dbm files a bad
    choice for data exchange.

*   Even running the same OS and the same dbm implementation, the database
    file format may depend on the CPU architecture. For example, files may not
    be portable between PowerPC and 386, or between 32 and 64 bit Linux.

*   Different versions of Berkeley DB use different file formats. A change to
    the OS may therefore break DBM access to existing files.

*   Data size limits vary between implementations. Original Berkeley DB was
    limited to 2GB of data. Dbm libraries also sometimes limit the total size
    of a key/value pair, and the total size of all the keys that hash to the
    same value. These limits can be as little as 512 bytes. That said, gdbm
    and recent versions of Berkeley DB do away with these limits.


Given the above cautions, DBM is not a good choice for long term storage of
important data. It is probably best used as a fast and easy alternative to a
Hash for processing large amounts of data.

## Example

    require 'dbm'
    db = DBM.open('rfcs', 0666, DBM::WRCREAT)
    db['822'] = 'Standard for the Format of ARPA Internet Text Messages'
    db['1123'] = 'Requirements for Internet Hosts - Application and Support'
    db['3068'] = 'An Anycast Prefix for 6to4 Relay Routers'
    puts db['822']

;T;0;	I"DBM;T;
[ ;[I"Enumerable;T;0;[ ;[ ;0;0o;;I"QOpen a dbm database and yields it if a block is given. See also `DBM.new`.

;T;0;;;I"	open;F;I"DBM;T;[o;;I"9::String filename, ?::Integer mode, ?::Integer flags;T;I"DBM;To;;I"9::String filename, ?::Integer mode, ?::Integer flags;T;I"T;Fo;;I"sReturn a value from the database by locating the key string provided.  If the
key is not found, returns nil.

;T;0;;;I"[];F;I"DBM;T;[o;;I"::String;T;I"String?;To;;I"^Stores the specified string value in the database, indexed via the string key
provided.

;T;0;;;I"[]=;F;I"DBM;T;[o;;I"::String, ::String;T;I"String;To;;I"*Deletes all data from the database.

;T;0;;;I"
clear;F;I"DBM;T;[o;;I" ;F;I"	self;To;;I"Closes the database.

;T;0;;;I"
close;F;I"DBM;T;[o;;I" ;F;I"	void;To;;I"?Returns true if the database is closed, false otherwise.

;T;0;;;I"closed?;F;I"DBM;T;[o;;I" ;F;I"	bool;To;;I"*Deletes an entry from the database.

;T;0;;;I"delete;F;I"DBM;T;[o;;I"::String;T;I"	void;To;;I"ODeletes all entries for which the code block returns true. Returns self.

;T;0;;;I"delete_if;F;I"DBM;T;[o;;I" ;F;I"	self;To;;I"UCalls the block once for each [key, value] pair in the database. Returns self.

;T;0;;;I"	each;F;I"DBM;T;[o;;I" ;F;I"	self;To;;I" ;F;I"-Enumerator[[ ::String, ::String ], self];To;;I"NCalls the block once for each key string in the database. Returns self.

;T;0;;;I"each_key;F;I"DBM;T;[o;;I" ;F;I"	self;To;;I" ;F;I"Enumerator[::String, self];To;;I"UCalls the block once for each [key, value] pair in the database. Returns self.

;T;0;;;I"each_pair;F;I"DBM;T;[o;;I" ;F;I"	self;To;;I" ;F;I"-Enumerator[[ ::String, ::String ], self];To;;I"PCalls the block once for each value string in the database. Returns self.

;T;0;;;I"each_value;F;I"DBM;T;[o;;I" ;F;I"	self;To;;I" ;F;I"Enumerator[::String, self];To;;I">Returns true if the database is empty, false otherwise.

;T;0;;;I"empty?;F;I"DBM;T;[o;;I" ;F;I"	bool;To;;I" Return a value from the database by locating the key string provided.  If the
key is not found, returns `ifnone`. If `ifnone` is not given, raises
IndexError.

;T;0;;;I"
fetch;F;I"DBM;T;[o;;I"#::String key, ?::String ifnone;T;I"String;To;;I"PReturns true if the database contains the specified key, false otherwise.

;T;0;;;I"has_key?;F;I"DBM;T;[o;;I"::String;T;I"	bool;To;;I"YReturns true if the database contains the specified string value, false
otherwise.

;T;0;;;I"has_value?;F;I"DBM;T;[o;;I" ;F;I"	bool;To;;I"PReturns true if the database contains the specified key, false otherwise.

;T;0;;;I"include?;F;I"DBM;T;[o;;I"::String;T;I"	bool;To;;I"„Returns a Hash (not a DBM database) created by using each value in the
database as a key, with the corresponding key as its value.

;T;0;;;I"invert;F;I"DBM;T;[o;;I" ;F;I"Hash[::String, ::String];To;;I"/Returns the key for the specified value.

;T;0;;;I"key;F;I"DBM;T;[o;;I"::String;T;I"String?;To;;I"PReturns true if the database contains the specified key, false otherwise.

;T;0;;;I"	key?;F;I"DBM;T;[o;;I"::String;T;I"	bool;To;;I"?Returns an array of all the string keys in the database.

;T;0;;;I"	keys;F;I"DBM;T;[o;;I" ;F;I"Array[::String];To;;I"5Returns the number of entries in the database.

;T;0;;;I"length;F;I"DBM;T;[o;;I" ;F;I"Integer;To;;I"PReturns true if the database contains the specified key, false otherwise.

;T;0;;;I"member?;F;I"DBM;T;[o;;I"::String;T;I"	bool;To;;I"‰Converts the contents of the database to an in-memory Hash, then calls
Hash#reject with the specified code block, returning a new Hash.

;T;0;;;I"reject;F;I"DBM;T;[o;;I" ;F;I"Hash[::String, ::String];To;;I"ODeletes all entries for which the code block returns true. Returns self.

;T;0;;;I"reject!;F;I"DBM;T;[o;;I" ;F;I"	self;To;;I"ªReplaces the contents of the database with the contents of the specified
object. Takes any object which implements the each_pair method, including Hash
and DBM objects.

;T;0;;;I"replace;F;I"DBM;T;[o;;I"::DBM::_ReplaceSource;T;I"DBM;To;;I"fReturns a new array consisting of the [key, value] pairs for which the code
block returns true.

;T;0;;;I"select;F;I"DBM;T;[o;;I" ;F;I""Array[[ ::String, ::String ]];To;;I"©Removes a [key, value] pair from the database, and returns it. If the database
is empty, returns nil. The order in which values are removed/returned is not
guaranteed.

;T;0;;;I"
shift;F;I"DBM;T;[o;;I" ;F;I"[ ::String, ::String ]?;To;;I"5Returns the number of entries in the database.

;T;0;;;I"	size;F;I"DBM;T;[o;;I" ;F;I"Integer;To;;I"^Stores the specified string value in the database, indexed via the string key
provided.

;T;0;;;I"
store;F;I"DBM;T;[o;;I"::String, ::String;T;I"String;To;;I"`Converts the contents of the database to an array of [key, value] arrays, and
returns it.

;T;0;;;I"	to_a;F;I"DBM;T;[o;;I" ;F;I""Array[[ ::String, ::String ]];To;;I"YConverts the contents of the database to an in-memory Hash object, and returns
it.

;T;0;;;I"to_hash;F;I"DBM;T;[o;;I" ;F;I"Hash[::String, ::String];To;;I"žUpdates the database with multiple values from the specified object. Takes any
object which implements the each_pair method, including Hash and DBM objects.

;T;0;;;I"update;F;I"DBM;T;[o;;I"::DBM::_UpdateSource;T;I"DBM;To;;I"YReturns true if the database contains the specified string value, false
otherwise.

;T;0;;;I"value?;F;I"DBM;T;[o;;I"::String;T;I"	bool;To;;I"AReturns an array of all the string values in the database.

;T;0;;;I"values;F;I"DBM;T;[o;;I" ;F;I"Array[::String];To;;I"MReturns an array containing the values associated with the given keys.

;T;0;;;I"values_at;F;I"DBM;T;[o;;I"*::String;T;I"Array[::String];To;;I"}Open a dbm database with the specified name, which can include a directory
path. Any file extensions needed will be supplied automatically by the dbm
library. For example, Berkeley DB appends '.db', and GNU gdbm uses two
physical files with extensions '.dir' and '.pag'.

The mode should be an integer, as for Unix chmod.

Flags should be one of READER, WRITER, WRCREAT or NEWDB.

;T;0;;;I"initialize;F;I"DBM;T;[o;;I"9::String filename, ?::Integer mode, ?::Integer flags;T;I"	void;To;;I"{	The `DidYouMean` gem adds functionality to suggest possible method/class names
upon errors such as `NameError` and `NoMethodError`. In Ruby 2.3 or later, it
is automatically activated during startup.

@example

    methosd
    # => NameError: undefined local variable or method `methosd' for main:Object
    #   Did you mean?  methods
    #                  method

    OBject
    # => NameError: uninitialized constant OBject
    #    Did you mean?  Object

    @full_name = "Yuki Nishijima"
    first_name, last_name = full_name.split(" ")
    # => NameError: undefined local variable or method `full_name' for main:Object
    #    Did you mean?  @full_name

    @@full_name = "Yuki Nishijima"
    @@full_anme
    # => NameError: uninitialized class variable @@full_anme in Object
    #    Did you mean?  @@full_name

    full_name = "Yuki Nishijima"
    full_name.starts_with?("Y")
    # => NoMethodError: undefined method `starts_with?' for "Yuki Nishijima":String
    #    Did you mean?  start_with?

    hash = {foo: 1, bar: 2, baz: 3}
    hash.fetch(:fooo)
    # => KeyError: key not found: :fooo
    #    Did you mean?  :foo

## Disabling `did_you_mean`

Occasionally, you may want to disable the `did_you_mean` gem for e.g.
debugging issues in the error object itself. You can disable it entirely by
specifying `--disable-did_you_mean` option to the `ruby` command:

    $ ruby --disable-did_you_mean -e "1.zeor?"
    -e:1:in `<main>': undefined method `zeor?' for 1:Integer (NameError)

When you do not have direct access to the `ruby` command (e.g. +rails
console+, `irb`), you could applyoptions using the `RUBYOPT` environment
variable:

    $ RUBYOPT='--disable-did_you_mean' irb
    irb:0> 1.zeor?
    # => NoMethodError (undefined method `zeor?' for 1:Integer)

## Getting the original error message

Sometimes, you do not want to disable the gem entirely, but need to get the
original error message without suggestions (e.g. testing). In this case, you
could use the `#original_message` method on the error object:

    no_method_error = begin
                        1.zeor?
                      rescue NoMethodError => error
                        error
                      end

    no_method_error.message
    # => NoMethodError (undefined method `zeor?' for 1:Integer)
    #    Did you mean?  zero?

    no_method_error.original_message
    # => NoMethodError (undefined method `zeor?' for 1:Integer)

;T;0;	I"DidYouMean;T;
[ ;[ ;0;[ ;[ o; ;0;0;	I"!DidYouMean::ClassNameChecker;T;
[ ;[ ;0;[ ;[ ;0;0o; ;0;0;	I",DidYouMean::ClassNameChecker::ClassName;T;
[ ;[ ;0;[ ;[ ;0;I"String;To;;0;0;	I"DidYouMean::Correctable;T;
[ ;[ ;0;[ ;[ o;;I" ;T;0;;;I"corrections;F;I"DidYouMean::Correctable;T;[o;;I" ;F;I"Array[::String];To; ;I"¥The `DidYouMean::Formatter` is the basic, default formatter for the gem. The
formatter responds to the `message_for` method and it returns a human readable
string.

;T;0;	I"DidYouMean::Formatter;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"ùReturns a human readable string that contains `corrections`. This formatter is
designed to be less verbose to not take too much screen space while being
helpful enough to the user.

@example

    formatter = DidYouMean::Formatter.new

    # displays suggestions in two lines with the leading empty line
    puts formatter.message_for(["methods", "method"])

    Did you mean?  methods
                    method
    # => nil

    # displays an empty line
    puts formatter.message_for([])

    # => nil

;T;0;;;I"message_for;F;I"DidYouMean::Formatter;T;[o;;I""::Array[::String] corrections;T;I"String;To;;0;0;	I"DidYouMean::JaroWinkler;T;
[ ;[ ;0;[ ;[ o;;I" ;T;0;;;I"distance;F;I"DidYouMean::JaroWinkler;T;[o;;I"::String, ::String;T;I"Integer;To;;0;0;	I"DidYouMean::Jaro;T;
[ ;[ ;0;[ ;[ o;;I" ;T;0;;;I"distance;F;I"DidYouMean::Jaro;T;[o;;I"::String, ::String;T;I"Integer;To; ;0;0;	I" DidYouMean::KeyErrorChecker;T;
[ ;[ ;0;[ ;[ ;0;0o;;I" ;T;0;;;I"initialize;F;I" DidYouMean::KeyErrorChecker;T;[o;;I"0::KeyError[::_ToS, ::Hash[::_ToS, untyped]];T;I"	void;To;;I" ;T;0;;;I"corrections;F;I" DidYouMean::KeyErrorChecker;T;[o;;I" ;F;I"Array[::String];To;;0;0;	I"DidYouMean::Levenshtein;T;
[ ;[ ;0;[ ;[ o;;0;0;;;I"distance;F;I"DidYouMean::Levenshtein;T;[o;;I"::String, ::String;T;I"Integer?;To; ;0;0;	I""DidYouMean::MethodNameChecker;T;
[ ;[ ;0;[ ;[ ;0;0o;;I" ;T;0;;;I"initialize;F;I""DidYouMean::MethodNameChecker;T;[o;;I"'::NoMethodError[untyped] exception;T;I"	void;To;;I" ;T;0;;;I"corrections;F;I""DidYouMean::MethodNameChecker;T;[o;;I" ;F;I"Array[::Symbol];To; ;0;0;	I"DidYouMean::NullChecker;T;
[ ;[ ;0;[ ;[ ;0;0o;;I" ;T;0;;;I"initialize;F;I"DidYouMean::NullChecker;T;[o;;I"*untyped;T;I"	void;To;;I" ;T;0;;;I"corrections;F;I"DidYouMean::NullChecker;T;[o;;I" ;F;I"Array[untyped];To; ;0;0;	I"&DidYouMean::PatternKeyNameChecker;T;
[ ;[ ;0;[ ;[ ;0;0o;;I" ;T;0;;;I"initialize;F;I"&DidYouMean::PatternKeyNameChecker;T;[o;;I"untyped;T;I"	void;To;;I" ;T;0;;;I"corrections;F;I"&DidYouMean::PatternKeyNameChecker;T;[o;;I" ;F;I"Array[::String];To; ;0;0;	I"#DidYouMean::RequirePathChecker;T;
[ ;[ ;0;[ ;[ ;0;0o;;I" ;T;0;;;I"requireables;F;I"#DidYouMean::RequirePathChecker;T;[o;;I" ;F;I"Array[::String];To;;I" ;T;0;;;I"initialize;F;I"#DidYouMean::RequirePathChecker;T;[o;;I"untyped exception;T;I"	void;To;;I" ;T;0;;;I"corrections;F;I"#DidYouMean::RequirePathChecker;T;[o;;I" ;F;I"Array[::String];To; ;0;0;	I"DidYouMean::SpellChecker;T;
[ ;[ ;0;[ ;[ ;0;0o;;I" ;T;0;;;I"initialize;F;I"DidYouMean::SpellChecker;T;[o;;I"-dictionary: ::Array[::String | ::Symbol];T;I"	void;To;;I" ;T;0;;;I"correct;F;I"DidYouMean::SpellChecker;T;[o;;I"::String | ::Symbol input;T;I"Array[::String];To; ;I"bspell checker for a dictionary that has a tree structure, see
doc/tree_spell_checker_api.md

;T;0;	I"!DidYouMean::TreeSpellChecker;T;
[ ;[ ;0;[ ;[ ;0;0o;;I" ;T;0;;;I"initialize;F;I"!DidYouMean::TreeSpellChecker;T;[o;;I"Idictionary: ::Array[::String], ?separator: ::String, ?augment: bool?;T;I"	void;To;;I" ;T;0;;;I"correct;F;I"!DidYouMean::TreeSpellChecker;T;[o;;I"::String input;T;I"Array[::String];To; ;0;0;	I"$DidYouMean::VariableNameChecker;T;
[ ;[ ;0;[ ;[ ;0;0o;;I" ;T;0;;;I"initialize;F;I"$DidYouMean::VariableNameChecker;T;[o;;I"::NameError[untyped];T;I"	void;To;;I" ;T;0;;;I"corrections;F;I"$DidYouMean::VariableNameChecker;T;[o;;I" ;F;I"Array[::Symbol];To;;I"This module provides a framework for message digest libraries.

You may want to look at OpenSSL::Digest as it supports more algorithms.

A cryptographic hash function is a procedure that takes data and returns a
fixed bit string: the hash value, also known as *digest*. Hash functions are
also called one-way functions, it is easy to compute a digest from a message,
but it is infeasible to generate a message from a digest.

## Examples

    require 'digest'

    # Compute a complete digest
    Digest::SHA256.digest 'message'       #=> "\xABS\n\x13\xE4Y..."

    sha256 = Digest::SHA256.new
    sha256.digest 'message'               #=> "\xABS\n\x13\xE4Y..."

    # Other encoding formats
    Digest::SHA256.hexdigest 'message'    #=> "ab530a13e459..."
    Digest::SHA256.base64digest 'message' #=> "q1MKE+RZFJgr..."

    # Compute digest by chunks
    md5 = Digest::MD5.new
    md5.update 'message1'
    md5 << 'message2'                     # << is an alias for update

    md5.hexdigest                         #=> "94af09c09bb9..."

    # Compute digest for a file
    sha256 = Digest::SHA256.file 'testfile'
    sha256.hexdigest

Additionally digests can be encoded in "bubble babble" format as a sequence of
consonants and vowels which is more recognizable and comparable than a
hexadecimal digest.

    require 'digest/bubblebabble'

    Digest::SHA256.bubblebabble 'message' #=> "xopoh-fedac-fenyh-..."

See the bubble babble specification at
http://web.mit.edu/kenta/www/one/bubblebabble/spec/jrtrjwzi/draft-huima-01.txt
.

## Digest algorithms

Different digest algorithms (or hash functions) are available:

MD5
:   See RFC 1321 The MD5 Message-Digest Algorithm
RIPEMD-160
:   As Digest::RMD160. See
    http://homes.esat.kuleuven.be/~bosselae/ripemd160.html.
SHA1
:   See FIPS 180 Secure Hash Standard.
SHA2 family
:   See FIPS 180 Secure Hash Standard which defines the following algorithms:
    *   SHA512
    *   SHA384
    *   SHA256



The latest versions of the FIPS publications can be found here:
http://csrc.nist.gov/publications/PubsFIPS.html.

;T;0;	I"Digest;T;
[ ;[ ;0;[ ;[ o;;I"BReturns a BubbleBabble encoded version of a given *string*.

;T;0;;;I"bubblebabble;F;I"Digest;T;[o;;I"::String;T;I"String;To;;0;0;;;I"const_missing;F;I"Digest;T;[o;;I"::Symbol name;T;I"singleton(::Digest::Base);To;;I";Generates a hex-encoded version of a given *string*.

;T;0;;;I"hexencode;F;I"Digest;T;[o;;I"::String;T;I"String;To;;0;0;;;I"bubblebabble;F;I"Digest;T;[o;;I"::String;T;I"String;To;;0;0;;;I"hexencode;F;I"Digest;T;[o;;I"::String;T;I"String;To;;I"sThis module provides instance methods for a digest implementation object to
calculate message digest values.

;T;0;	I"Digest::Instance;T;
[ ;[ ;0;[ ;[ o;;I"ÅUpdates the digest using a given *string* and returns self.

The update() method and the left-shift operator are overridden by each
implementation subclass. (One should be an alias for the other)

;T;0;;;I"<<;F;I"Digest::Instance;T;[o;;I"::String;T;I"	self;To;;I"ÔIf a string is given, checks whether it is equal to the hex-encoded hash value
of the digest object.  If another digest instance is given, checks whether
they have the same hash value.  Otherwise returns false.

;T;0;;;I"==;F;I"Digest::Instance;T;[o;;I""::Digest::Instance | ::String;T;I"	bool;To;;I"{If none is given, returns the resulting hash value of the digest in a base64
encoded form, keeping the digest's state.

If a `string` is given, returns the hash value for the given `string` in a
base64 encoded form, resetting the digest to the initial state before and
after the process.

In either case, the return value is properly padded with '=' and contains no
line feeds.

;T;0;;;I"base64digest;F;I"Digest::Instance;T;[o;;I"?::String? str;T;I"String;To;;I"SReturns the resulting hash value and resets the digest to the initial state.

;T;0;;;I"base64digest!;F;I"Digest::Instance;T;[o;;I" ;F;I"String;To;;I"jReturns the block length of the digest.

This method is overridden by each implementation subclass.

;T;0;;;I"block_length;F;I"Digest::Instance;T;[o;;I" ;F;I"Integer;To;;I"GReturns the resulting hash value in a Bubblebabble encoded form.

;T;0;;;I"bubblebabble;F;I"Digest::Instance;T;[o;;I" ;F;I"String;To;;I"ïIf none is given, returns the resulting hash value of the digest, keeping the
digest's state.

If a *string* is given, returns the hash value for the given *string*,
resetting the digest to the initial state before and after the process.

;T;0;;;I"digest;F;I"Digest::Instance;T;[o;;I"?::String;T;I"String;To;;I"SReturns the resulting hash value and resets the digest to the initial state.

;T;0;;;I"digest!;F;I"Digest::Instance;T;[o;;I" ;F;I"String;To;;I"ªReturns the length of the hash value of the digest.

This method should be overridden by each implementation subclass. If not,
digest_obj.digest().length() is returned.

;T;0;;;I"digest_length;F;I"Digest::Instance;T;[o;;I" ;F;I"Integer;To;;I"TUpdates the digest with the contents of a given file *name* and returns self.

;T;0;;;I"	file;F;I"Digest::Instance;T;[o;;I"::String name;T;I"	self;To;;I"If none is given, returns the resulting hash value of the digest in a
hex-encoded form, keeping the digest's state.

If a *string* is given, returns the hash value for the given *string* in a
hex-encoded form, resetting the digest to the initial state before and after
the process.

;T;0;;;I"hexdigest;F;I"Digest::Instance;T;[o;;I"?::String;T;I"String;To;;I"iReturns the resulting hash value in a hex-encoded form and resets the digest
to the initial state.

;T;0;;;I"hexdigest!;F;I"Digest::Instance;T;[o;;I" ;F;I"String;To;;I"8Creates a printable version of the digest object.

;T;0;;;I"inspect;F;I"Digest::Instance;T;[o;;I" ;F;I"String;To;;I"*Returns digest_obj.digest_length().

;T;0;;;I"length;F;I"Digest::Instance;T;[o;;I" ;F;I"Integer;To;;I"gReturns a new, initialized copy of the digest object.  Equivalent to
digest_obj.clone().reset().

;T;0;;;I"new;F;I"Digest::Instance;T;[o;;I" ;F;I"Digest::Base;To;;I"{Resets the digest to the initial state and returns self.

This method is overridden by each implementation subclass.

;T;0;;;I"
reset;F;I"Digest::Instance;T;[o;;I" ;F;I"	self;To;;I"*Returns digest_obj.digest_length().

;T;0;;;I"	size;F;I"Digest::Instance;T;[o;;I" ;F;I"Integer;To;;I"&Returns digest_obj.hexdigest().

;T;0;;;I"	to_s;F;I"Digest::Instance;T;[o;;I" ;F;I"String;To;;I"ÅUpdates the digest using a given *string* and returns self.

The update() method and the left-shift operator are overridden by each
implementation subclass. (One should be an alias for the other)

;T;0;;;I"update;F;I"Digest::Instance;T;[o;;I"::String;T;I"	self;To;;I"VFinishes the digest and returns the resulting hash value.

This method is overridden by each implementation subclass and often made
private, because some of those subclasses may leave internal data
uninitialized.  Do not call this method from outside.  Use #digest!() instead,
which ensures that internal data be reset for security reasons.

;T;0;;;I"finish;F;I"Digest::Instance;T;[o;;I" ;F;I"	self;To; ;I"LThis module stands as a base class for digest implementation classes.

;T;0;	I"Digest::Class;T;
[ ;[I"Digest::Instance;T;0;[ ;[ ;0;0o;;I"†Returns the base64 encoded hash value of a given *string*.  The return value
is properly padded with '=' and contains no line feeds.

;T;0;;;I"base64digest;F;I"Digest::Class;T;[o;;I"::String str, *untyped;T;I"String;To;;I"GReturns the BubbleBabble encoded hash value of a given *string*.

;T;0;;;I"bubblebabble;F;I"Digest::Class;T;[o;;I"::String, *untyped;T;I"String;To;;I"äReturns the hash value of a given *string*.  This is equivalent to
Digest::Class.new(*parameters).digest(string), where extra *parameters*, if
any, are passed through to the constructor and the *string* is passed to
#digest().

;T;0;;;I"digest;F;I"Digest::Class;T;[o;;I"::String, *untyped;T;I"String;To;;I"	Creates a digest object and reads a given file, *name*. Optional arguments are
passed to the constructor of the digest class.

    p Digest::SHA256.file("X11R6.8.2-src.tar.bz2").hexdigest
    # => "f02e3c85572dc9ad7cb77c2a638e3be24cc1b5bea9fdbb0b0299c9668475c534"

;T;0;;;I"	file;F;I"Digest::Class;T;[o;;I"::String name, *untyped;T;I"Digest::Class;To;;I"˜Returns the hex-encoded hash value of a given *string*.  This is almost
equivalent to Digest.hexencode(Digest::Class.new(*parameters).digest(string)).

;T;0;;;I"hexdigest;F;I"Digest::Class;T;[o;;I"::String, *untyped;T;I"String;To;;0;0;;;I"initialize;F;I"Digest::Class;T;[o;;I" ;F;I"	self;To; ;I"5This abstract class provides a common interface to message digest
implementation classes written in C.

## Write a Digest subclass in C
Digest::Base provides a common interface to message digest classes written in
C. These classes must provide a struct of type rb_digest_metadata_t:
    typedef int (*rb_digest_hash_init_func_t)(void *);
    typedef void (*rb_digest_hash_update_func_t)(void *, unsigned char *, size_t);
    typedef int (*rb_digest_hash_finish_func_t)(void *, unsigned char *);

    typedef struct {
      int api_version;
      size_t digest_len;
      size_t block_len;
      size_t ctx_size;
      rb_digest_hash_init_func_t init_func;
      rb_digest_hash_update_func_t update_func;
      rb_digest_hash_finish_func_t finish_func;
    } rb_digest_metadata_t;

This structure must be set as an instance variable named `metadata` (without
the +@+ in front of the name). By example:
     static const rb_digest_metadata_t sha1 = {
        RUBY_DIGEST_API_VERSION,
        SHA1_DIGEST_LENGTH,
        SHA1_BLOCK_LENGTH,
        sizeof(SHA1_CTX),
        (rb_digest_hash_init_func_t)SHA1_Init,
        (rb_digest_hash_update_func_t)SHA1_Update,
        (rb_digest_hash_finish_func_t)SHA1_Finish,
    };

    rb_ivar_set(cDigest_SHA1, rb_intern("metadata"),
                Data_Wrap_Struct(0, 0, 0, (void *)&sha1));

;T;0;	I"Digest::Base;T;
[ ;[ ;0;[ ;[ ;0;I"Digest::Class;To;;I"@Update the digest using given *string* and return `self`.

;T;0;;;I"<<;F;I"Digest::Base;T;[o;;I"::String;T;I"	self;To;;I"6Return the block length of the digest in bytes.

;T;0;;;I"block_length;F;I"Digest::Base;T;[o;;I" ;F;I"Integer;To;;I"4Return the length of the hash value in bytes.

;T;0;;;I"digest_length;F;I"Digest::Base;T;[o;;I" ;F;I"Integer;To;;I"?Reset the digest to its initial state and return `self`.

;T;0;;;I"
reset;F;I"Digest::Base;T;[o;;I" ;F;I"	self;To;;I"@Update the digest using given *string* and return `self`.

;T;0;;;I"update;F;I"Digest::Base;T;[o;;I"::String;T;I"	self;To;;0;0;;;I"finish;F;I"Digest::Base;T;[o;;I" ;F;I"String;To;;0;0;;;I"initialize_copy;F;I"Digest::Base;T;[o;;I"::Digest::Base;T;I"	self;To; ;I"A class for calculating message digests using the SHA-1 Secure Hash Algorithm
by NIST (the US' National Institute of Standards and Technology), described in
FIPS PUB 180-1.

See Digest::Instance for digest API.

SHA-1 calculates a digest of 160 bits (20 bytes).

## Examples
    require 'digest'

    # Compute a complete digest
    Digest::SHA1.hexdigest 'abc'      #=> "a9993e36..."

    # Compute digest by chunks
    sha1 = Digest::SHA1.new               # =>#<Digest::SHA1>
    sha1.update "ab"
    sha1 << "c"                           # alias for #update
    sha1.hexdigest                        # => "a9993e36..."

    # Use the same object to compute another digest
    sha1.reset
    sha1 << "message"
    sha1.hexdigest                        # => "6f9b9af3..."

;T;0;	I"Digest::SHA1;T;
[ ;[ ;0;[ ;[ ;0;I"Digest::Base;To; ;I"©A class for calculating message digests using the MD5 Message-Digest Algorithm
by RSA Data Security, Inc., described in RFC1321.

MD5 calculates a digest of 128 bits (16 bytes).

## Examples
    require 'digest'

    # Compute a complete digest
    Digest::MD5.hexdigest 'abc'      #=> "90015098..."

    # Compute digest by chunks
    md5 = Digest::MD5.new               # =>#<Digest::MD5>
    md5.update "ab"
    md5 << "c"                           # alias for #update
    md5.hexdigest                        # => "90015098..."

    # Use the same object to compute another digest
    md5.reset
    md5 << "message"
    md5.hexdigest                        # => "78e73102..."

;T;0;	I"Digest::MD5;T;
[ ;[ ;0;[ ;[ ;0;I"Digest::Base;To; ;I"àA class for calculating message digests using RIPEMD-160 cryptographic hash
function, designed by Hans Dobbertin, Antoon Bosselaers, and Bart Preneel.

RMD160 calculates a digest of 160 bits (20 bytes).

## Examples
    require 'digest'

    # Compute a complete digest
    Digest::RMD160.hexdigest 'abc'      #=> "8eb208f7..."

    # Compute digest by chunks
    rmd160 = Digest::RMD160.new               # =>#<Digest::RMD160>
    rmd160.update "ab"
    rmd160 << "c"                           # alias for #update
    rmd160.hexdigest                        # => "8eb208f7..."

    # Use the same object to compute another digest
    rmd160.reset
    rmd160 << "message"
    rmd160.hexdigest                        # => "1dddbe1b..."

;T;0;	I"Digest::RMD160;T;
[ ;[ ;0;[ ;[ ;0;I"Digest::Base;To; ;0;0;	I"Digest::SHA256;T;
[ ;[ ;0;[ ;[ ;0;I"Digest::Base;To; ;0;0;	I"Digest::SHA384;T;
[ ;[ ;0;[ ;[ ;0;I"Digest::Base;To; ;0;0;	I"Digest::SHA512;T;
[ ;[ ;0;[ ;[ ;0;I"Digest::Base;To; ;I"º# ERB -- Ruby Templating

## Introduction

ERB provides an easy to use but powerful templating system for Ruby.  Using
ERB, actual Ruby code can be added to any plain text document for the purposes
of generating document information details and/or flow control.

A very simple example is this:

    require 'erb'

    x = 42
    template = ERB.new <<-EOF
      The value of x is: <%= x %>
    EOF
    puts template.result(binding)

*Prints:* The value of x is: 42

More complex examples are given below.

## Recognized Tags

ERB recognizes certain tags in the provided template and converts them based
on the rules below:

    <% Ruby code -- inline with output %>
    <%= Ruby expression -- replace with result %>
    <%# comment -- ignored -- useful in testing %> (`<% #` doesn't work. Don't use Ruby comments.)
    % a line of Ruby code -- treated as <% line %> (optional -- see ERB.new)
    %% replaced with % if first thing on a line and % processing is used
    <%% or %%> -- replace with <% or %> respectively

All other text is passed through ERB filtering unchanged.

## Options

There are several settings you can change when you use ERB:
*   the nature of the tags that are recognized;
*   the binding used to resolve local variables in the template.


See the ERB.new and ERB#result methods for more detail.

## Character encodings

ERB (or Ruby code generated by ERB) returns a string in the same character
encoding as the input string.  When the input string has a magic comment,
however, it returns a string in the encoding specified by the magic comment.

    # -*- coding: utf-8 -*-
    require 'erb'

    template = ERB.new <<EOF
    <%#-*- coding: Big5 -*-%>
      \_\_ENCODING\_\_ is <%= \_\_ENCODING\_\_ %>.
    EOF
    puts template.result

*Prints:* _*ENCODING*_ is Big5.

## Examples

### Plain Text

ERB is useful for any generic templating situation.  Note that in this
example, we use the convenient "% at start of line" tag, and we quote the
template literally with `%q{...}` to avoid trouble with the backslash.

    require "erb"

    # Create template.
    template = %q{
      From:  James Edward Gray II <james@grayproductions.net>
      To:  <%= to %>
      Subject:  Addressing Needs

      <%= to[/\w+/] %>:

      Just wanted to send a quick note assuring that your needs are being
      addressed.

      I want you to know that my team will keep working on the issues,
      especially:

      <%# ignore numerous minor requests -- focus on priorities %>
      % priorities.each do |priority|
        * <%= priority %>
      % end

      Thanks for your patience.

      James Edward Gray II
    }.gsub(/^  /, '')

    message = ERB.new(template, trim_mode: "%<>")

    # Set up template data.
    to = "Community Spokesman <spokesman@ruby_community.org>"
    priorities = [ "Run Ruby Quiz",
                   "Document Modules",
                   "Answer Questions on Ruby Talk" ]

    # Produce result.
    email = message.result
    puts email

*Generates:*

    From:  James Edward Gray II <james@grayproductions.net>
    To:  Community Spokesman <spokesman@ruby_community.org>
    Subject:  Addressing Needs

    Community:

    Just wanted to send a quick note assuring that your needs are being addressed.

    I want you to know that my team will keep working on the issues, especially:

        * Run Ruby Quiz
        * Document Modules
        * Answer Questions on Ruby Talk

    Thanks for your patience.

    James Edward Gray II

### Ruby in HTML

ERB is often used in `.rhtml` files (HTML with embedded Ruby).  Notice the
need in this example to provide a special binding when the template is run, so
that the instance variables in the Product object can be resolved.

    require "erb"

    # Build template data class.
    class Product
      def initialize( code, name, desc, cost )
        @code = code
        @name = name
        @desc = desc
        @cost = cost

        @features = [ ]
      end

      def add_feature( feature )
        @features << feature
      end

      # Support templating of member data.
      def get_binding
        binding
      end

      # ...
    end

    # Create template.
    template = %{
      <html>
        <head><title>Ruby Toys -- <%= @name %></title></head>
        <body>

          <h1><%= @name %> (<%= @code %>)</h1>
          <p><%= @desc %></p>

          <ul>
            <% @features.each do |f| %>
              <li><b><%= f %></b></li>
            <% end %>
          </ul>

          <p>
            <% if @cost < 10 %>
              <b>Only <%= @cost %>!!!</b>
            <% else %>
               Call for a price, today!
            <% end %>
          </p>

        </body>
      </html>
    }.gsub(/^  /, '')

    rhtml = ERB.new(template)

    # Set up template data.
    toy = Product.new( "TZ-1002",
                       "Rubysapien",
                       "Geek's Best Friend!  Responds to Ruby commands...",
                       999.95 )
    toy.add_feature("Listens for verbal commands in the Ruby language!")
    toy.add_feature("Ignores Perl, Java, and all C variants.")
    toy.add_feature("Karate-Chop Action!!!")
    toy.add_feature("Matz signature on left leg.")
    toy.add_feature("Gem studded eyes... Rubies, of course!")

    # Produce result.
    rhtml.run(toy.get_binding)

*Generates (some blank lines removed):*

    <html>
      <head><title>Ruby Toys -- Rubysapien</title></head>
      <body>

        <h1>Rubysapien (TZ-1002)</h1>
        <p>Geek's Best Friend!  Responds to Ruby commands...</p>

        <ul>
            <li><b>Listens for verbal commands in the Ruby language!</b></li>
            <li><b>Ignores Perl, Java, and all C variants.</b></li>
            <li><b>Karate-Chop Action!!!</b></li>
            <li><b>Matz signature on left leg.</b></li>
            <li><b>Gem studded eyes... Rubies, of course!</b></li>
        </ul>

        <p>
             Call for a price, today!
        </p>

      </body>
    </html>

## Notes

There are a variety of templating solutions available in various Ruby
projects. For example, RDoc, distributed with Ruby, uses its own template
engine, which can be reused elsewhere.

Other popular engines could be found in the corresponding
[Category](https://www.ruby-toolbox.com/categories/template_engines) of The
Ruby Toolbox.

;T;0;	I"ERB;T;
[ ;[ ;0;[ ;[ ;0;0o;;I":Returns revision information for the erb.rb module.

;T;0;;;I"version;F;I"ERB;T;[o;;I" ;F;I"String;To;;I"¯Constructs a new ERB object with the template specified in *str*.

An ERB object works by building a chunk of Ruby code that will output the
completed template when run.

If *trim_mode* is passed a String containing one or more of the following
modifiers, ERB will adjust its code generation as listed:

    %  enables Ruby code processing for lines beginning with %
    <> omit newline for lines starting with <% and ending in %>
    >  omit newline for lines ending in %>
    -  omit blank lines ending in -%>

*eoutvar* can be used to set the name of the variable ERB will build up its
output in.  This is useful when you need to run multiple ERB templates through
the same binding and/or when you want to control where output ends up.  Pass
the name of the variable to be used inside a String.

### Example

    require "erb"

    # build data class
    class Listings
      PRODUCT = { :name => "Chicken Fried Steak",
                  :desc => "A well messages pattie, breaded and fried.",
                  :cost => 9.95 }

      attr_reader :product, :price

      def initialize( product = "", price = "" )
        @product = product
        @price = price
      end

      def build
        b = binding
        # create and run templates, filling member data variables
        ERB.new(<<-'END_PRODUCT'.gsub(/^\s+/, ""), trim_mode: "", eoutvar: "@product").result b
          <%= PRODUCT[:name] %>
          <%= PRODUCT[:desc] %>
        END_PRODUCT
        ERB.new(<<-'END_PRICE'.gsub(/^\s+/, ""), trim_mode: "", eoutvar: "@price").result b
          <%= PRODUCT[:name] %> -- <%= PRODUCT[:cost] %>
          <%= PRODUCT[:desc] %>
        END_PRICE
      end
    end

    # setup template data
    listings = Listings.new
    listings.build

    puts listings.product + "\n" + listings.price

*Generates*

    Chicken Fried Steak
    A well messages pattie, breaded and fried.

    Chicken Fried Steak -- 9.95
    A well messages pattie, breaded and fried.

;T;0;;;I"initialize;F;I"ERB;T;[o;;I"P::String, ?eoutvar: ::String, ?trim_mode: ::Integer | ::String | ::NilClass;T;I"untyped;To;;I"%The Ruby code generated by ERB

;T;0;;;I"src;F;I"ERB;T;[o;;I" ;F;I"String;To;;I"The encoding to eval

;T;0;;;I"encoding;F;I"ERB;T;[o;;I" ;F;I"Encoding;To;;I"VThe optional *filename* argument passed to Kernel#eval when the ERB code is
run

;T;0;;;I"filename;F;I"ERB;T;[o;;I" ;F;I"String | ::NilClass;To;;I"VThe optional *filename* argument passed to Kernel#eval when the ERB code is
run

;T;0;;;I"filename=;F;I"ERB;T;[o;;I"::String | ::NilClass;T;I"untyped;To;;I"TThe optional *lineno* argument passed to Kernel#eval when the ERB code is run

;T;0;;;I"lineno;F;I"ERB;T;[o;;I" ;F;I"Integer;To;;I"TThe optional *lineno* argument passed to Kernel#eval when the ERB code is run

;T;0;;;I"lineno=;F;I"ERB;T;[o;;I"::Integer;T;I"untyped;To;;I"ºSets optional filename and line number that will be used in ERB code
evaluation and error reporting. See also #filename= and #lineno=

    erb = ERB.new('<%= some_x %>')
    erb.render
    # undefined local variable or method `some_x'
    #   from (erb):1

    erb.location = ['file.erb', 3]
    # All subsequent error reporting would use new location
    erb.render
    # undefined local variable or method `some_x'
    #   from file.erb:4

;T;0;;;I"location=;F;I"ERB;T;[o;;I""::Array[::String | ::Integer];T;I"untyped;To;;I"8Generate results and print them. (see ERB#result)

;T;0;;;I"run;F;I"ERB;T;[o;;I"?::Binding;T;I"untyped;To;;I"
Executes the generated ERB code to produce a completed template, returning the
results of that code.  (See ERB::new for details on how this process can be
affected by *safe_level*.)

*b* accepts a Binding object which is used to set the context of code
evaluation.

;T;0;;;I"result;F;I"ERB;T;[o;;I"?::Binding;T;I"String;To;;I"cRender a template on a new toplevel binding with local variables specified by
a Hash object.

;T;0;;;I"result_with_hash;F;I"ERB;T;[o;;I"::Hash[untyped, untyped];T;I"String;To;;I"1Define *methodname* as instance method of *mod* from compiled Ruby source.

example:
    filename = 'example.rhtml'   # 'arg1' and 'arg2' are used in example.rhtml
    erb = ERB.new(File.read(filename))
    erb.def_method(MyClass, 'render(arg1, arg2)', filename)
    print MyClass.new.render('foo', 123)

;T;0;;;I"def_method;F;I"ERB;T;[o;;I""::Module, ::String, ?::String;T;I"untyped;To;;I"VCreate unnamed module, define *methodname* as instance method of it, and
return it.

example:
    filename = 'example.rhtml'   # 'arg1' and 'arg2' are used in example.rhtml
    erb = ERB.new(File.read(filename))
    erb.filename = filename
    MyModule = erb.def_module('render(arg1, arg2)')
    class MyClass
      include MyModule
    end

;T;0;;;I"def_module;F;I"ERB;T;[o;;I"?::String;T;I"Module;To;;I"°Define unnamed class which has *methodname* as instance method, and return it.

example:
    class MyClass_
      def initialize(arg1, arg2)
        @arg1 = arg1;  @arg2 = arg2
      end
    end
    filename = 'example.rhtml'  # @arg1 and @arg2 are used in example.rhtml
    erb = ERB.new(File.read(filename))
    erb.filename = filename
    MyClass = erb.def_class(MyClass_, 'render()')
    print MyClass.new('foo', 123).render()

;T;0;;;I"def_class;F;I"ERB;T;[o;;I"?::Class, ?::String;T;I"
Class;To;;I"‚The Etc module provides access to information typically stored in files in the
/etc directory on Unix systems.

The information accessible consists of the information found in the
/etc/passwd and /etc/group files, plus information about the system's
temporary directory (/tmp) and configuration directory (/etc).

The Etc module provides a more reliable way to access information about the
logged in user than environment variables such as +$USER+.

## Example:

    require 'etc'

    login = Etc.getlogin
    info = Etc.getpwnam(login)
    username = info.gecos.split(/,/).first
    puts "Hello #{username}, I see your login name is #{login}"

Note that the methods provided by this module are not always secure. It should
be used for informational purposes, and not for security.

All operations defined in this module are class methods, so that you can
include the Etc module into your class.

;T;0;	I"Etc;T;
[ ;[ ;0;[ ;[ o;;I"¶Returns system configuration variable using confstr().

*name* should be a constant under `Etc` which begins with `CS_`.

The return value is a string or nil. nil means no configuration-defined value.
 (confstr() returns 0 but errno is not set.)

    Etc.confstr(Etc::CS_PATH) #=> "/bin:/usr/bin"

    # GNU/Linux
    Etc.confstr(Etc::CS_GNU_LIBC_VERSION) #=> "glibc 2.18"
    Etc.confstr(Etc::CS_GNU_LIBPTHREAD_VERSION) #=> "NPTL 2.18"

;T;0;;;I"confstr;F;I"Etc;T;[o;;I"::Integer p1;T;I"String?;To;;I"iEnds the process of scanning through the /etc/group file begun by ::getgrent,
and closes the file.

;T;0;;;I"endgrent;F;I"Etc;T;[o;;I" ;F;I"	void;To;;I"lEnds the process of scanning through the /etc/passwd file begun with
::getpwent, and closes the file.

;T;0;;;I"endpwent;F;I"Etc;T;[o;;I" ;F;I"	void;To;;I"BReturns an entry from the /etc/group file.

The first time it is called it opens the file and returns the first entry;
each successive call returns the next entry, or `nil` if the end of the file
has been reached.

To close the file when processing is complete, call ::endgrent.

Each entry is returned as a Group struct

;T;0;;;I"getgrent;F;I"Etc;T;[o;;I" ;F;I"Etc::Group?;To;;I"CReturns information about the group with specified integer `group_id`, as
found in /etc/group.

The information is returned as a Group struct.

See the unix manpage for `getgrgid(3)` for more detail.

### Example:

    Etc.getgrgid(100)
    #=> #<struct Etc::Group name="users", passwd="x", gid=100, mem=["meta", "root"]>

;T;0;;;I"getgrgid;F;I"Etc;T;[o;;I"?::Integer group_id;T;I"Etc::Group;To;;I";Returns information about the group with specified `name`, as found in
/etc/group.

The information is returned as a Group struct.

See the unix manpage for `getgrnam(3)` for more detail.

### Example:

    Etc.getgrnam('users')
    #=> #<struct Etc::Group name="users", passwd="x", gid=100, mem=["meta", "root"]>

;T;0;;;I"getgrnam;F;I"Etc;T;[o;;I"::String name;T;I"Etc::Group;To;;I"+Returns the short user name of the currently logged in user. Unfortunately, it
is often rather easy to fool ::getlogin.

Avoid ::getlogin for security-related purposes.

If ::getlogin fails, try ::getpwuid.

See the unix manpage for `getpwuid(3)` for more detail.

e.g.
    Etc.getlogin -> 'guest'

;T;0;;;I"getlogin;F;I"Etc;T;[o;;I" ;F;I"String?;To;;I"EReturns an entry from the /etc/passwd file.

The first time it is called it opens the file and returns the first entry;
each successive call returns the next entry, or `nil` if the end of the file
has been reached.

To close the file when processing is complete, call ::endpwent.

Each entry is returned as a Passwd struct.

;T;0;;;I"getpwent;F;I"Etc;T;[o;;I" ;F;I"Etc::Passwd?;To;;I"RReturns the /etc/passwd information for the user with specified login `name`.

The information is returned as a Passwd struct.

See the unix manpage for `getpwnam(3)` for more detail.

### Example:

    Etc.getpwnam('root')
    #=> #<struct Etc::Passwd name="root", passwd="x", uid=0, gid=0, gecos="root",dir="/root", shell="/bin/bash">

;T;0;;;I"getpwnam;F;I"Etc;T;[o;;I"::String name;T;I"Etc::Passwd;To;;I"—Returns the /etc/passwd information for the user with the given integer `uid`.

The information is returned as a Passwd struct.

If `uid` is omitted, the value from `Passwd[:uid]` is returned instead.

See the unix manpage for `getpwuid(3)` for more detail.

### Example:

    Etc.getpwuid(0)
    #=> #<struct Etc::Passwd name="root", passwd="x", uid=0, gid=0, gecos="root",dir="/root", shell="/bin/bash">

;T;0;;;I"getpwuid;F;I"Etc;T;[o;;I"?::Integer uid;T;I"Etc::Passwd;To;;I"Provides a convenient Ruby iterator which executes a block for each entry in
the /etc/group file.

The code block is passed an Group struct.

See ::getgrent above for details.

Example:

    require 'etc'

    Etc.group {|g|
      puts g.name + ": " + g.mem.join(', ')
    }

;T;0;;;I"
group;F;I"Etc;T;[o;;I" ;F;I"	void;To;;I" ;F;I"Etc::Group?;To;;I"mReturns the number of online processors.

The result is intended as the number of processes to use all available
processors.

This method is implemented using:
*   sched_getaffinity(): Linux
*   sysconf(_SC_NPROCESSORS_ONLN): GNU/Linux, NetBSD, FreeBSD, OpenBSD,
    DragonFly BSD, OpenIndiana, Mac OS X, AIX


Example:

    require 'etc'
    p Etc.nprocessors #=> 4

The result might be smaller number than physical cpus especially when ruby
process is bound to specific cpus. This is intended for getting better
parallel processing.

Example: (Linux)

    linux$ taskset 0x3 ./ruby -retc -e "p Etc.nprocessors"  #=> 2

;T;0;;;I"nprocessors;F;I"Etc;T;[o;;I" ;F;I"Integer;To;;I"Provides a convenient Ruby iterator which executes a block for each entry in
the /etc/passwd file.

The code block is passed an Passwd struct.

See ::getpwent above for details.

Example:

    require 'etc'

    Etc.passwd {|u|
      puts u.name + " = " + u.gecos
    }

;T;0;;;I"passwd;F;I"Etc;T;[o;;I" ;F;I"	void;To;;I" ;F;I"Etc::Passwd?;To;;I"{Resets the process of reading the /etc/group file, so that the next call to
::getgrent will return the first entry again.

;T;0;;;I"setgrent;F;I"Etc;T;[o;;I" ;F;I"	void;To;;I"|Resets the process of reading the /etc/passwd file, so that the next call to
::getpwent will return the first entry again.

;T;0;;;I"setpwent;F;I"Etc;T;[o;;I" ;F;I"	void;To;;I"JReturns system configuration variable using sysconf().

*name* should be a constant under `Etc` which begins with `SC_`.

The return value is an integer or nil. nil means indefinite limit.  (sysconf()
returns -1 but errno is not set.)

    Etc.sysconf(Etc::SC_ARG_MAX) #=> 2097152
    Etc.sysconf(Etc::SC_LOGIN_NAME_MAX) #=> 256

;T;0;;;I"sysconf;F;I"Etc;T;[o;;I"::Integer p1;T;I"Integer;To;;I":Returns system configuration directory.

This is typically "/etc", but is modified by the prefix used when Ruby was
compiled. For example, if Ruby is built and installed in /usr/local, returns
"/usr/local/etc" on other platforms than Windows. On Windows, this always
returns the directory provided by the system.

;T;0;;;I"sysconfdir;F;I"Etc;T;[o;;I" ;F;I"String;To;;I"<Returns system temporary directory; typically "/tmp".

;T;0;;;I"systmpdir;F;I"Etc;T;[o;;I" ;F;I"String;To;;I" Returns the system information obtained by uname system call.

The return value is a hash which has 5 keys at least:
    :sysname, :nodename, :release, :version, :machine

Example:

    require 'etc'
    require 'pp'

    pp Etc.uname
    #=> {:sysname=>"Linux",
    #    :nodename=>"boron",
    #    :release=>"2.6.18-6-xen-686",
    #    :version=>"#1 SMP Thu Nov 5 19:54:42 UTC 2009",
    #    :machine=>"i686"}

;T;0;;;I"
uname;F;I"Etc;T;[o;;I" ;F;I"g{ sysname: ::String, nodename: ::String, release: ::String, version: ::String, machine: ::String };To; ;0;0;	I"Etc::Group;T;
[ ;[ ;0;[ ;[ ;0;I"Struct;To;;0;0;;;I"[];F;I"Etc::Group;T;[o;;I"*untyped;T;I"untyped;To;;0;0;;;I"	each;F;I"Etc::Group;T;[o;;I" ;F;I"untyped;To;;0;0;;;I"inspect;F;I"Etc::Group;T;[o;;I" ;F;I"untyped;To;;0;0;;;I"keyword_init?;F;I"Etc::Group;T;[o;;I" ;F;I"untyped;To;;0;0;;;I"members;F;I"Etc::Group;T;[o;;I" ;F;I"untyped;To;;0;0;;;I"new;F;I"Etc::Group;T;[o;;I"*untyped;T;I"untyped;To;;0;0;;;I"gid;F;I"Etc::Group;T;[o;;I" ;F;I"Integer;To;;0;0;;;I"	gid=;F;I"Etc::Group;T;[o;;I"::Integer new_gid;T;I"	void;To;;0;0;;;I"mem;F;I"Etc::Group;T;[o;;I" ;F;I"Array[::String];To;;0;0;;;I"	mem=;F;I"Etc::Group;T;[o;;I"::Array[::String] new_mem;T;I"	void;To;;0;0;;;I"	name;F;I"Etc::Group;T;[o;;I" ;F;I"String;To;;0;0;;;I"
name=;F;I"Etc::Group;T;[o;;I"::String new_name;T;I"	void;To;;0;0;;;I"passwd;F;I"Etc::Group;T;[o;;I" ;F;I"String;To;;0;0;;;I"passwd=;F;I"Etc::Group;T;[o;;I"::String new_passwd;T;I"	void;To; ;0;0;	I"Etc::Passwd;T;
[ ;[ ;0;[ ;[ ;0;I"Struct;To;;0;0;;;I"[];F;I"Etc::Passwd;T;[o;;I"*untyped;T;I"untyped;To;;0;0;;;I"	each;F;I"Etc::Passwd;T;[o;;I" ;F;I"untyped;To;;0;0;;;I"inspect;F;I"Etc::Passwd;T;[o;;I" ;F;I"untyped;To;;0;0;;;I"keyword_init?;F;I"Etc::Passwd;T;[o;;I" ;F;I"untyped;To;;0;0;;;I"members;F;I"Etc::Passwd;T;[o;;I" ;F;I"untyped;To;;0;0;;;I"new;F;I"Etc::Passwd;T;[o;;I"*untyped;T;I"untyped;To;;0;0;;;I"change;F;I"Etc::Passwd;T;[o;;I" ;F;I"Integer;To;;0;0;;;I"change=;F;I"Etc::Passwd;T;[o;;I"::Integer new_change;T;I"	void;To;;0;0;;;I"dir;F;I"Etc::Passwd;T;[o;;I" ;F;I"String;To;;0;0;;;I"	dir=;F;I"Etc::Passwd;T;[o;;I"::String new_dir;T;I"	void;To;;0;0;;;I"expire;F;I"Etc::Passwd;T;[o;;I" ;F;I"Integer;To;;0;0;;;I"expire=;F;I"Etc::Passwd;T;[o;;I"::Integer new_expire;T;I"	void;To;;0;0;;;I"
gecos;F;I"Etc::Passwd;T;[o;;I" ;F;I"String;To;;0;0;;;I"gecos=;F;I"Etc::Passwd;T;[o;;I"::String new_gecos;T;I"	void;To;;0;0;;;I"gid;F;I"Etc::Passwd;T;[o;;I" ;F;I"Integer;To;;0;0;;;I"	gid=;F;I"Etc::Passwd;T;[o;;I"::Integer new_gid;T;I"	void;To;;0;0;;;I"	name;F;I"Etc::Passwd;T;[o;;I" ;F;I"String;To;;0;0;;;I"
name=;F;I"Etc::Passwd;T;[o;;I"::String new_name;T;I"	void;To;;0;0;;;I"passwd;F;I"Etc::Passwd;T;[o;;I" ;F;I"String;To;;0;0;;;I"passwd=;F;I"Etc::Passwd;T;[o;;I"::String new_passwd;T;I"	void;To;;0;0;;;I"
shell;F;I"Etc::Passwd;T;[o;;I" ;F;I"String;To;;0;0;;;I"shell=;F;I"Etc::Passwd;T;[o;;I"::String new_shell;T;I"	void;To;;0;0;;;I"uclass;F;I"Etc::Passwd;T;[o;;I" ;F;I"String;To;;0;0;;;I"uclass=;F;I"Etc::Passwd;T;[o;;I"::String new_uclass;T;I"	void;To;;0;0;;;I"uid;F;I"Etc::Passwd;T;[o;;I" ;F;I"Integer;To;;0;0;;;I"	uid=;F;I"Etc::Passwd;T;[o;;I"::Integer new_uid;T;I"	void;To;;I"# fileutils.rb

Copyright (c) 2000-2007 Minero Aoki

This program is free software. You can distribute/modify this program under
the same terms of ruby.

## module FileUtils

Namespace for several file utility methods for copying, moving, removing, etc.

### Module Functions

    require 'fileutils'

    FileUtils.cd(dir, **options)
    FileUtils.cd(dir, **options) {|dir| block }
    FileUtils.pwd()
    FileUtils.mkdir(dir, **options)
    FileUtils.mkdir(list, **options)
    FileUtils.mkdir_p(dir, **options)
    FileUtils.mkdir_p(list, **options)
    FileUtils.rmdir(dir, **options)
    FileUtils.rmdir(list, **options)
    FileUtils.ln(target, link, **options)
    FileUtils.ln(targets, dir, **options)
    FileUtils.ln_s(target, link, **options)
    FileUtils.ln_s(targets, dir, **options)
    FileUtils.ln_sf(target, link, **options)
    FileUtils.cp(src, dest, **options)
    FileUtils.cp(list, dir, **options)
    FileUtils.cp_r(src, dest, **options)
    FileUtils.cp_r(list, dir, **options)
    FileUtils.mv(src, dest, **options)
    FileUtils.mv(list, dir, **options)
    FileUtils.rm(list, **options)
    FileUtils.rm_r(list, **options)
    FileUtils.rm_rf(list, **options)
    FileUtils.install(src, dest, **options)
    FileUtils.chmod(mode, list, **options)
    FileUtils.chmod_R(mode, list, **options)
    FileUtils.chown(user, group, list, **options)
    FileUtils.chown_R(user, group, list, **options)
    FileUtils.touch(list, **options)

Possible `options` are:

`:force`
:   forced operation (rewrite files if exist, remove directories if not empty,
    etc.);
`:verbose`
:   print command to be run, in bash syntax, before performing it;
`:preserve`
:   preserve object's group, user and modification time on copying;
`:noop`
:   no changes are made (usable in combination with `:verbose` which will
    print the command to run)


Each method documents the options that it honours. See also ::commands,
::options and ::options_of methods to introspect which command have which
options.

All methods that have the concept of a "source" file or directory can take
either one file or a list of files in that argument.  See the method
documentation for examples.

There are some `low level' methods, which do not accept keyword arguments:

    FileUtils.copy_entry(src, dest, preserve = false, dereference_root = false, remove_destination = false)
    FileUtils.copy_file(src, dest, preserve = false, dereference = true)
    FileUtils.copy_stream(srcstream, deststream)
    FileUtils.remove_entry(path, force = false)
    FileUtils.remove_entry_secure(path, force = false)
    FileUtils.remove_file(path, force = false)
    FileUtils.compare_file(path_a, path_b)
    FileUtils.compare_stream(stream_a, stream_b)
    FileUtils.uptodate?(file, cmp_list)

## module FileUtils::Verbose

This module has all methods of FileUtils module, but it outputs messages
before acting.  This equates to passing the `:verbose` flag to methods in
FileUtils.

## module FileUtils::NoWrite

This module has all methods of FileUtils module, but never changes
files/directories.  This equates to passing the `:noop` flag to methods in
FileUtils.

## module FileUtils::DryRun

This module has all methods of FileUtils module, but never changes
files/directories.  This equates to passing the `:noop` and `:verbose` flags
to methods in FileUtils.

;T;0;	I"FileUtils;T;
[ ;[ ;0;[ ;[ o;;I"³Changes the current directory to the directory `dir`.

If this method is called with block, resumes to the previous working directory
after the block execution has finished.

    FileUtils.cd('/')  # change directory

    FileUtils.cd('/', verbose: true)   # change directory and report it

    FileUtils.cd('/') do  # change directory
      # ...               # do something
    end                   # return to original directory

;T;0;;;I"cd;F;I"FileUtils;T;[o;;I"/::FileUtils::path dir, ?verbose: ::boolish;T;I"	void;To;;I"/::FileUtils::path dir, ?verbose: ::boolish;T;I"X;Fo;;I"Changes permission bits on the named files (in `list`) to the bit pattern
represented by `mode`.

`mode` is the symbolic and absolute mode can be used.

Absolute mode is
    FileUtils.chmod 0755, 'somecommand'
    FileUtils.chmod 0644, %w(my.rb your.rb his.rb her.rb)
    FileUtils.chmod 0755, '/usr/bin/ruby', verbose: true

Symbolic mode is
    FileUtils.chmod "u=wrx,go=rx", 'somecommand'
    FileUtils.chmod "u=wr,go=rr", %w(my.rb your.rb his.rb her.rb)
    FileUtils.chmod "u=wrx,go=rx", '/usr/bin/ruby', verbose: true

"a"
:   is user, group, other mask.
"u"
:   is user's mask.
"g"
:   is group's mask.
"o"
:   is other's mask.
"w"
:   is write permission.
"r"
:   is read permission.
"x"
:   is execute permission.
"X"
:   is execute permission for directories only, must be used in conjunction
    with "+"
"s"
:   is uid, gid.
"t"
:   is sticky bit.
"+"
:   is added to a class given the specified mode.
"-"
:   Is removed from a given class given mode.
"="
:   Is the exact nature of the class will be given a specified mode.

;T;0;;;I"
chmod;F;I"FileUtils;T;[o;;I"^::FileUtils::mode mode, ::FileUtils::pathlist list, ?noop: ::boolish, ?verbose: ::boolish;T;I"	void;To;;I"ÀChanges permission bits on the named files (in `list`) to the bit pattern
represented by `mode`.

    FileUtils.chmod_R 0700, "/tmp/app.#{$$}"
    FileUtils.chmod_R "u=wrx", "/tmp/app.#{$$}"

;T;0;;;I"chmod_R;F;I"FileUtils;T;[o;;I"q::FileUtils::mode mode, ::FileUtils::pathlist list, ?noop: ::boolish, ?verbose: ::boolish, ?force: ::boolish;T;I"	void;To;;I"rChanges owner and group on the named files (in `list`) to the user `user` and
the group `group`.  `user` and `group` may be an ID (Integer/String) or a name
(String). If `user` or `group` is nil, this method does not change the
attribute.

    FileUtils.chown 'root', 'staff', '/usr/local/bin/ruby'
    FileUtils.chown nil, 'bin', Dir.glob('/usr/bin/*'), verbose: true

;T;0;;;I"
chown;F;I"FileUtils;T;[o;;I"g::String? user, ::String? group, ::FileUtils::pathlist list, ?noop: ::boolish, ?verbose: ::boolish;T;I"	void;To;;I"qChanges owner and group on the named files (in `list`) to the user `user` and
the group `group` recursively. `user` and `group` may be an ID
(Integer/String) or a name (String).  If `user` or `group` is nil, this method
does not change the attribute.

    FileUtils.chown_R 'www', 'www', '/var/www/htdocs'
    FileUtils.chown_R 'cvs', 'cvs', '/var/cvs', verbose: true

;T;0;;;I"chown_R;F;I"FileUtils;T;[o;;I"z::String? user, ::String? group, ::FileUtils::pathlist list, ?noop: ::boolish, ?verbose: ::boolish, ?force: ::boolish;T;I"	void;To;;I"‘Returns an Array of methods names which have the option `opt`.

    p FileUtils.collect_method(:preserve) #=> ["cp", "cp_r", "copy", "install"]

;T;0;;;I"collect_method;F;I"FileUtils;T;[o;;I"::Symbol opt;T;I"Array[::String];To;;I"›Returns an Array of names of high-level methods that accept any keyword
arguments.

    p FileUtils.commands  #=> ["chmod", "cp", "cp_r", "install", ...]

;T;0;;;I"commands;F;I"FileUtils;T;[o;;I" ;F;I"Array[::String];To;;I"ÐReturns true if the contents of a file `a` and a file `b` are identical.

    FileUtils.compare_file('somefile', 'somefile')       #=> true
    FileUtils.compare_file('/dev/null', '/dev/urandom')  #=> false

;T;0;;;I"compare_file;F;I"FileUtils;T;[o;;I"-::FileUtils::path a, ::FileUtils::path b;T;I"	bool;To;;I"JReturns true if the contents of a stream `a` and `b` are identical.

;T;0;;;I"compare_stream;F;I"FileUtils;T;[o;;I"::IO a, ::IO b;T;I"	bool;To;;I"UCopies a file system entry `src` to `dest`. If `src` is a directory, this
method copies its contents recursively. This method preserves file types, c.f.
symlink, directory... (FIFO, device files and etc. are not supported yet)

Both of `src` and `dest` must be a path name. `src` must exist, `dest` must
not exist.

If `preserve` is true, this method preserves owner, group, and modified time.
Permissions are copied regardless `preserve`.

If `dereference_root` is true, this method dereference tree root.

If `remove_destination` is true, this method removes each destination file
before copy.

;T;0;;;I"copy_entry;F;I"FileUtils;T;[o;;I"~::FileUtils::path src, ::FileUtils::path dest, ?::boolish preserve, ?::boolish dereference_root, ?::boolish remove_destination;T;I"	void;To;;I"]Copies file contents of `src` to `dest`. Both of `src` and `dest` must be a
path name.

;T;0;;;I"copy_file;F;I"FileUtils;T;[o;;I"_::FileUtils::path src, ::FileUtils::path dest, ?::boolish preserve, ?::boolish dereference;T;I"	void;To;;I"lCopies stream `src` to `dest`. `src` must respond to #read(n) and `dest` must
respond to #write(str).

;T;0;;;I"copy_stream;F;I"FileUtils;T;[o;;I""::_Reader src, ::_Writer dest;T;I"	void;To;;I"«Copies a file content `src` to `dest`.  If `dest` is a directory, copies `src`
to `dest/src`.

If `src` is a list of files, then `dest` must be a directory.

    FileUtils.cp 'eval.c', 'eval.c.org'
    FileUtils.cp %w(cgi.rb complex.rb date.rb), '/usr/lib/ruby/1.6'
    FileUtils.cp %w(cgi.rb complex.rb date.rb), '/usr/lib/ruby/1.6', verbose: true
    FileUtils.cp 'symlink', 'dest'   # copy content, "dest" is not a symlink

;T;0;;;I"cp;F;I"FileUtils;T;[o;;I"s::FileUtils::pathlist src, ::FileUtils::path dest, ?preserve: ::boolish, ?noop: ::boolish, ?verbose: ::boolish;T;I"	void;To;;I"šHard link `src` to `dest`. If `src` is a directory, this method links all its
contents recursively. If `dest` is a directory, links `src` to `dest/src`.

`src` can be a list of files.

If `dereference_root` is true, this method dereference tree root.

If `remove_destination` is true, this method removes each destination file
before copy.

    FileUtils.rm_r site_ruby + '/mylib', force: true
    FileUtils.cp_lr 'lib/', site_ruby + '/mylib'

    # Examples of linking several files to target directory.
    FileUtils.cp_lr %w(mail.rb field.rb debug/), site_ruby + '/tmail'
    FileUtils.cp_lr Dir.glob('*.rb'), '/home/aamine/lib/ruby', noop: true, verbose: true

    # If you want to link all contents of a directory instead of the
    # directory itself, c.f. src/x -> dest/x, src/y -> dest/y,
    # use the following code.
    FileUtils.cp_lr 'src/.', 'dest'  # cp_lr('src', 'dest') makes dest/src, but this doesn't.

;T;0;;;I"
cp_lr;F;I"FileUtils;T;[o;;I"–::FileUtils::pathlist src, ::FileUtils::path dest, ?noop: ::boolish, ?verbose: ::boolish, ?dereference_root: ::boolish, ?remove_destination: ::boolish;T;I"	void;To;;I"óCopies `src` to `dest`. If `src` is a directory, this method copies all its
contents recursively. If `dest` is a directory, copies `src` to `dest/src`.

`src` can be a list of files.

If `dereference_root` is true, this method dereference tree root.

If `remove_destination` is true, this method removes each destination file
before copy.

    # Installing Ruby library "mylib" under the site_ruby
    FileUtils.rm_r site_ruby + '/mylib', force: true
    FileUtils.cp_r 'lib/', site_ruby + '/mylib'

    # Examples of copying several files to target directory.
    FileUtils.cp_r %w(mail.rb field.rb debug/), site_ruby + '/tmail'
    FileUtils.cp_r Dir.glob('*.rb'), '/home/foo/lib/ruby', noop: true, verbose: true

    # If you want to copy all contents of a directory instead of the
    # directory itself, c.f. src/x -> dest/x, src/y -> dest/y,
    # use following code.
    FileUtils.cp_r 'src/.', 'dest'     # cp_r('src', 'dest') makes dest/src,
                                       # but this doesn't.

;T;0;;;I"	cp_r;F;I"FileUtils;T;[o;;I"¬::FileUtils::pathlist src, ::FileUtils::path dest, ?preserve: ::boolish, ?noop: ::boolish, ?verbose: ::boolish, ?dereference_root: ::boolish, ?remove_destination: ::boolish;T;I"	void;To;;I"ÜReturns true if the method `mid` have an option `opt`.

    p FileUtils.have_option?(:cp, :noop)     #=> true
    p FileUtils.have_option?(:rm, :force)    #=> true
    p FileUtils.have_option?(:rm, :preserve) #=> false

;T;0;;;I"have_option?;F;I"FileUtils;T;[o;;I"::Symbol mid, ::Symbol opt;T;I"	bool;To;;I"ZIf `src` is not same as `dest`, copies it and changes the permission mode to
`mode`.  If `dest` is a directory, destination is `dest`/`src`. This method
removes destination before copy.

    FileUtils.install 'ruby', '/usr/local/bin/ruby', mode: 0755, verbose: true
    FileUtils.install 'lib.rb', '/usr/local/lib/ruby/site_ruby', verbose: true

;T;0;;;I"install;F;I"FileUtils;T;[o;;I"«::FileUtils::path src, ::FileUtils::path dest, ?mode: ::FileUtils::mode?, ?owner: ::String?, ?group: ::String?, ?preserve: ::boolish, ?noop: ::boolish, ?verbose: ::boolish;T;I"	void;To;;I"oHard links a file system entry `src` to `dest`. If `src` is a directory, this
method links its contents recursively.

Both of `src` and `dest` must be a path name. `src` must exist, `dest` must
not exist.

If `dereference_root` is true, this method dereferences the tree root.

If `remove_destination` is true, this method removes each destination file
before copy.

;T;0;;;I"link_entry;F;I"FileUtils;T;[o;;I"n::FileUtils::path src, ::FileUtils::path dest, ?::boolish dereference_root, ?::boolish remove_destination;T;I"	void;To;;I"bIn the first form, creates a hard link `link` which points to `target`. If
`link` already exists, raises Errno::EEXIST. But if the `force` option is set,
overwrites `link`.

    FileUtils.ln 'gcc', 'cc', verbose: true
    FileUtils.ln '/usr/bin/emacs21', '/usr/bin/emacs'

In the second form, creates a link `dir/target` pointing to `target`. In the
third form, creates several hard links in the directory `dir`, pointing to
each item in `targets`. If `dir` is not a directory, raises Errno::ENOTDIR.

    FileUtils.cd '/sbin'
    FileUtils.ln %w(cp mv mkdir), '/bin'   # Now /sbin/cp and /bin/cp are linked.

;T;0;;;I"ln;F;I"FileUtils;T;[o;;I"p::FileUtils::pathlist src, ::FileUtils::path dest, ?force: ::boolish, ?noop: ::boolish, ?verbose: ::boolish;T;I"	void;To;;I"QIn the first form, creates a symbolic link `link` which points to `target`. If
`link` already exists, raises Errno::EEXIST. But if the `force` option is set,
overwrites `link`.

    FileUtils.ln_s '/usr/bin/ruby', '/usr/local/bin/ruby'
    FileUtils.ln_s 'verylongsourcefilename.c', 'c', force: true

In the second form, creates a link `dir/target` pointing to `target`. In the
third form, creates several symbolic links in the directory `dir`, pointing to
each item in `targets`. If `dir` is not a directory, raises Errno::ENOTDIR.

    FileUtils.ln_s Dir.glob('/bin/*.rb'), '/home/foo/bin'

;T;0;;;I"	ln_s;F;I"FileUtils;T;[o;;I"p::FileUtils::pathlist src, ::FileUtils::path dest, ?force: ::boolish, ?noop: ::boolish, ?verbose: ::boolish;T;I"	void;To;;I"6Same as

    FileUtils.ln_s(*args, force: true)

;T;0;;;I"
ln_sf;F;I"FileUtils;T;[o;;I"]::FileUtils::pathlist src, ::FileUtils::path dest, ?noop: ::boolish, ?verbose: ::boolish;T;I"	void;To;;I"ËCreates one or more directories.

    FileUtils.mkdir 'test'
    FileUtils.mkdir %w(tmp data)
    FileUtils.mkdir 'notexist', noop: true  # Does not really create.
    FileUtils.mkdir 'tmp', mode: 0700

;T;0;;;I"
mkdir;F;I"FileUtils;T;[o;;I"Y::FileUtils::pathlist list, ?mode: ::Integer?, ?noop: ::boolish, ?verbose: ::boolish;T;I"	void;To;;I"(Creates a directory and all its parent directories. For example,

    FileUtils.mkdir_p '/usr/local/lib/ruby'

causes to make following directories, if they do not exist.

*   /usr
*   /usr/local
*   /usr/local/lib
*   /usr/local/lib/ruby


You can pass several directories at a time in a list.

;T;0;;;I"mkdir_p;F;I"FileUtils;T;[o;;I"a::FileUtils::pathlist list, ?mode: ::FileUtils::mode?, ?noop: ::boolish, ?verbose: ::boolish;T;I"	void;To;;I"’Moves file(s) `src` to `dest`.  If `file` and `dest` exist on the different
disk partition, the file is copied then the original file is removed.

    FileUtils.mv 'badname.rb', 'goodname.rb'
    FileUtils.mv 'stuff.rb', '/notexist/lib/ruby', force: true  # no error

    FileUtils.mv %w(junk.txt dust.txt), '/home/foo/.trash/'
    FileUtils.mv Dir.glob('test*.rb'), 'test', noop: true, verbose: true

;T;0;;;I"mv;F;I"FileUtils;T;[o;;I"::FileUtils::pathlist src, ::FileUtils::path dest, ?force: ::boolish, ?noop: ::boolish, ?verbose: ::boolish, ?secure: ::boolish;T;I"	void;To;;I"wReturns an Array of option names.

    p FileUtils.options  #=> ["noop", "force", "verbose", "preserve", "mode"]

;T;0;;;I"options;F;I"FileUtils;T;[o;;I" ;F;I"Array[::String];To;;I"Returns an Array of option names of the method `mid`.

    p FileUtils.options_of(:rm)  #=> ["noop", "verbose", "force"]

;T;0;;;I"options_of;F;I"FileUtils;T;[o;;I"::Symbol mid;T;I"Array[::String];To;;I"1Returns the name of the current directory.

;T;0;;;I"pwd;F;I"FileUtils;T;[o;;I" ;F;I"String;To;;I"tRemoves a directory `dir` and its contents recursively. This method ignores
StandardError if `force` is true.

;T;0;;;I"remove_dir;F;I"FileUtils;T;[o;;I"-::FileUtils::path path, ?::boolish force;T;I"	void;To;;I"¼This method removes a file system entry `path`. `path` might be a regular
file, a directory, or something. If `path` is a directory, remove it
recursively.

See also remove_entry_secure.

;T;0;;;I"remove_entry;F;I"FileUtils;T;[o;;I"-::FileUtils::path path, ?::boolish force;T;I"	void;To;;I"dThis method removes a file system entry `path`.  `path` shall be a regular
file, a directory, or something.  If `path` is a directory, remove it
recursively.  This method is required to avoid TOCTTOU
(time-of-check-to-time-of-use) local security vulnerability of rm_r. #rm_r
causes security hole when:

*   Parent directory is world writable (including /tmp).
*   Removing directory tree includes world writable directory.
*   The system has symbolic link.


To avoid this security hole, this method applies special preprocess. If `path`
is a directory, this method chown(2) and chmod(2) all removing directories.
This requires the current process is the owner of the removing whole directory
tree, or is the super user (root).

WARNING: You must ensure that **ALL** parent directories cannot be moved by
other untrusted users.  For example, parent directories should not be owned by
untrusted users, and should not be world writable except when the sticky bit
set.

WARNING: Only the owner of the removing directory tree, or Unix super user
(root) should invoke this method.  Otherwise this method does not work.

For details of this security vulnerability, see Perl's case:

*   https://cve.mitre.org/cgi-bin/cvename.cgi?name=CAN-2005-0448
*   https://cve.mitre.org/cgi-bin/cvename.cgi?name=CAN-2004-0452


For fileutils.rb, this vulnerability is reported in [ruby-dev:26100].

;T;0;;;I"remove_entry_secure;F;I"FileUtils;T;[o;;I"-::FileUtils::path path, ?::boolish force;T;I"	void;To;;I"SRemoves a file `path`. This method ignores StandardError if `force` is true.

;T;0;;;I"remove_file;F;I"FileUtils;T;[o;;I"(::FileUtils::path path, ?void force;T;I"	void;To;;I"Remove file(s) specified in `list`.  This method cannot remove directories.
All StandardErrors are ignored when the :force option is set.

    FileUtils.rm %w( junk.txt dust.txt )
    FileUtils.rm Dir.glob('*.so')
    FileUtils.rm 'NotExistFile', force: true   # never raises exception

;T;0;;;I"rm;F;I"FileUtils;T;[o;;I"Y::FileUtils::pathlist list, ?force: ::boolish, ?noop: ::boolish, ?verbose: ::boolish;T;I"	void;To;;I"9Equivalent to

    FileUtils.rm(list, force: true)

;T;0;;;I"	rm_f;F;I"FileUtils;T;[o;;I"F::FileUtils::pathlist list, ?noop: ::boolish, ?verbose: ::boolish;T;I"	void;To;;I"þremove files `list`[0] `list`[1]... If `list`[n] is a directory, removes its
all contents recursively. This method ignores StandardError when :force option
is set.

    FileUtils.rm_r Dir.glob('/tmp/*')
    FileUtils.rm_r 'some_dir', force: true

WARNING: This method causes local vulnerability if one of parent directories
or removing directory tree are world writable (including /tmp, whose
permission is 1777), and the current process has strong privilege such as Unix
super user (root), and the system has symbolic link.  For secure removing,
read the documentation of remove_entry_secure carefully, and set :secure
option to true. Default is `secure: false`.

NOTE: This method calls remove_entry_secure if :secure option is set. See also
remove_entry_secure.

;T;0;;;I"	rm_r;F;I"FileUtils;T;[o;;I"m::FileUtils::pathlist list, ?force: ::boolish, ?noop: ::boolish, ?verbose: ::boolish, ?secure: ::boolish;T;I"	void;To;;I"ŽEquivalent to

    FileUtils.rm_r(list, force: true)

WARNING: This method causes local vulnerability. Read the documentation of
rm_r first.

;T;0;;;I"
rm_rf;F;I"FileUtils;T;[o;;I"Z::FileUtils::pathlist list, ?noop: ::boolish, ?verbose: ::boolish, ?secure: ::boolish;T;I"	void;To;;I"ãRemoves one or more directories.

    FileUtils.rmdir 'somedir'
    FileUtils.rmdir %w(somedir anydir otherdir)
    # Does not really remove directory; outputs message.
    FileUtils.rmdir 'somedir', verbose: true, noop: true

;T;0;;;I"
rmdir;F;I"FileUtils;T;[o;;I"[::FileUtils::pathlist list, ?parents: ::boolish, ?noop: ::boolish, ?verbose: ::boolish;T;I"	void;To;;I"ÎUpdates modification time (mtime) and access time (atime) of file(s) in
`list`.  Files are created if they don't exist.

    FileUtils.touch 'timestamp'
    FileUtils.touch Dir.glob('*.c');  system 'make'

;T;0;;;I"
touch;F;I"FileUtils;T;[o;;I"{::FileUtils::pathlist list, ?noop: ::boolish, ?verbose: ::boolish, ?mtime: (::Time | ::Numeric)?, ?nocreate: ::boolish;T;I"	void;To;;I"½Returns true if `new` is newer than all `old_list`. Non-existent files are
older than any file.

    FileUtils.uptodate?('hello.o', %w(hello.c hello.h)) or \
        system 'make hello.o'

;T;0;;;I"uptodate?;F;I"FileUtils;T;[o;;I":::FileUtils::path new, ::FileUtils::pathlist old_list;T;I"	bool;To;;I"&The `Find` module supports the top-down traversal of a set of file paths.

For example, to total the size of all files under your home directory,
ignoring anything in a "dot" directory (e.g. $HOME/.ssh):

    require 'find'

    total_size = 0

    Find.find(ENV["HOME"]) do |path|
      if FileTest.directory?(path)
        if File.basename(path).start_with?('.')
          Find.prune       # Don't look any further into this directory.
        else
          next
        end
      else
        total_size += FileTest.size(path)
      end
    end

;T;0;	I"	Find;T;
[ ;[ ;0;[ ;[ o;;I"òCalls the associated block with the name of every file and directory listed as
arguments, then recursively on their subdirectories, and so on.

Returns an enumerator if no block is given.

See the `Find` module documentation for an example.

;T;0;;;I"	find;F;I"	Find;T;[o;;I":*::String | ::_ToPath paths, ?ignore_error: ::boolish;T;I"Enumerator[::String, nil];To;;I":*::String | ::_ToPath paths, ?ignore_error: ::boolish;T;I"nil;To;;I"Skips the current file or directory, restarting the loop with the next entry.
If the current file is a directory, that directory will not be recursively
entered. Meaningful only within the block associated with Find::find.

See the `Find` module documentation for an example.

;T;0;;;I"
prune;F;I"	Find;T;[o;;I" ;F;I"	void;To;;I"¼	The Forwardable module provides delegation of specified methods to a
designated object, using the methods #def_delegator and #def_delegators.

For example, say you have a class RecordCollection which contains an array
`@records`.  You could provide the lookup method #record_number(), which
simply calls #[] on the `@records` array, like this:

    require 'forwardable'

    class RecordCollection
      attr_accessor :records
      extend Forwardable
      def_delegator :@records, :[], :record_number
    end

We can use the lookup method like so:

    r = RecordCollection.new
    r.records = [4,5,6]
    r.record_number(0)  # => 4

Further, if you wish to provide the methods #size, #<<, and #map, all of which
delegate to @records, this is how you can do it:

    class RecordCollection # re-open RecordCollection class
      def_delegators :@records, :size, :<<, :map
    end

    r = RecordCollection.new
    r.records = [1,2,3]
    r.record_number(0)   # => 1
    r.size               # => 3
    r << 4               # => [1, 2, 3, 4]
    r.map { |x| x * 2 }  # => [2, 4, 6, 8]

You can even extend regular objects with Forwardable.

    my_hash = Hash.new
    my_hash.extend Forwardable              # prepare object for delegation
    my_hash.def_delegator "STDOUT", "puts"  # add delegation for STDOUT.puts()
    my_hash.puts "Howdy!"

## Another example

You could use Forwardable as an alternative to inheritance, when you don't
want to inherit all methods from the superclass. For instance, here is how you
might add a range of `Array` instance methods to a new class `Queue`:

    class Queue
      extend Forwardable

      def initialize
        @q = [ ]    # prepare delegate object
      end

      # setup preferred interface, enq() and deq()...
      def_delegator :@q, :push, :enq
      def_delegator :@q, :shift, :deq

      # support some general Array methods that fit Queues well
      def_delegators :@q, :clear, :first, :push, :shift, :size
    end

    q = Thread::Queue.new
    q.enq 1, 2, 3, 4, 5
    q.push 6

    q.shift    # => 1
    while q.size > 0
      puts q.deq
    end

    q.enq "Ruby", "Perl", "Python"
    puts q.first
    q.clear
    puts q.first

This should output:

    2
    3
    4
    5
    6
    Ruby
    nil

## Notes

Be advised, RDoc will not detect delegated methods.

`forwardable.rb` provides single-method delegation via the def_delegator and
def_delegators methods. For full-class delegation via DelegateClass, see
`delegate.rb`.

;T;0;	I"Forwardable;T;
[ ;[ ;0;[ ;[ o;;I"ùTakes a hash as its argument.  The key is a symbol or an array of symbols.
These symbols correspond to method names, instance variable names, or constant
names (see def_delegator).  The value is the accessor to which the methods
will be delegated.

;T;0;;;I"instance_delegate;F;I"Forwardable;T;[o;;I"8::Hash[::Symbol | ::Array[::Symbol], ::Symbol] hash;T;I"	void;To;;I"2Shortcut for defining multiple delegator methods, but with no provision for
using a different name.  The following two code samples have the same effect:

    def_delegators :@records, :size, :<<, :map

    def_delegator :@records, :size
    def_delegator :@records, :<<
    def_delegator :@records, :map

;T;0;;;I"def_instance_delegators;F;I"Forwardable;T;[o;;I"4::Symbol | ::String accessor, *::Symbol methods;T;I"	void;To;;I"£Define `method` as delegator instance method with an optional alias name
`ali`. Method calls to `ali` will be delegated to `accessor.method`.
`accessor` should be a method name, instance variable name, or constant name.
Use the full path to the constant if providing the constant name. Returns the
name of the method defined.

    class MyQueue
      CONST = 1
      extend Forwardable
      attr_reader :queue
      def initialize
        @queue = []
      end

      def_delegator :@queue, :push, :mypush
      def_delegator 'MyQueue::CONST', :to_i
    end

    q = MyQueue.new
    q.mypush 42
    q.queue    #=> [42]
    q.push 23  #=> NoMethodError
    q.to_i     #=> 1

;T;0;;;I"def_instance_delegator;F;I"Forwardable;T;[o;;I"A::Symbol | ::String accessor, ::Symbol method, ?::Symbol ali;T;I"	void;To;;I"ÜSingleForwardable can be used to setup delegation at the object level as well.

    printer = String.new
    printer.extend SingleForwardable        # prepare object for delegation
    printer.def_delegator "STDOUT", "puts"  # add delegation for STDOUT.puts()
    printer.puts "Howdy!"

Also, SingleForwardable can be used to set up delegation for a Class or
Module.

    class Implementation
      def self.service
        puts "serviced!"
      end
    end

    module Facade
      extend SingleForwardable
      def_delegator :Implementation, :service
    end

    Facade.service #=> serviced!

If you want to use both Forwardable and SingleForwardable, you can use methods
def_instance_delegator and def_single_delegator, etc.

;T;0;	I"SingleForwardable;T;
[ ;[ ;0;[ ;[ o;;I"¹Takes a hash as its argument.  The key is a symbol or an array of symbols.
These symbols correspond to method names.  The value is the accessor to which
the methods will be delegated.

;T;0;;;I"single_delegate;F;I"SingleForwardable;T;[o;;I"8::Hash[::Symbol | ::Array[::Symbol], ::Symbol] hash;T;I"	void;To;;I"2Shortcut for defining multiple delegator methods, but with no provision for
using a different name.  The following two code samples have the same effect:

    def_delegators :@records, :size, :<<, :map

    def_delegator :@records, :size
    def_delegator :@records, :<<
    def_delegator :@records, :map

;T;0;;;I"def_single_delegators;F;I"SingleForwardable;T;[o;;I"4::Symbol | ::String accessor, *::Symbol methods;T;I"	void;To;;I"èDefines a method *method* which delegates to *accessor* (i.e. it calls the
method of the same name in *accessor*).  If *new_name* is provided, it is used
as the name for the delegate method. Returns the name of the method defined.

;T;0;;;I"def_single_delegator;F;I"SingleForwardable;T;[o;;I"A::Symbol | ::String accessor, ::Symbol method, ?::Symbol ali;T;I"	void;To; ;0;0;	I"IO::ConsoleMode;T;
[ ;[ ;0;[ ;[ ;0;0o;;0;0;;;I"
echo=;F;I"IO::ConsoleMode;T;[o;;I"	bool;T;I"	bool;To;;0;0;;;I"raw;F;I"IO::ConsoleMode;T;[o;;I"+?min: ::int, ?time: ::int, ?intr: bool;T;I"	self;To;;0;0;;;I"	raw!;F;I"IO::ConsoleMode;T;[o;;I"+?min: ::int, ?time: ::int, ?intr: bool;T;I"	self;To; ;I"›IPAddr provides a set of methods to manipulate an IP address.  Both IPv4 and
IPv6 are supported.

## Example

    require 'ipaddr'

    ipaddr1 = IPAddr.new "3ffe:505:2::1"

    p ipaddr1                   #=> #<IPAddr: IPv6:3ffe:0505:0002:0000:0000:0000:0000:0001/ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff>

    p ipaddr1.to_s              #=> "3ffe:505:2::1"

    ipaddr2 = ipaddr1.mask(48)  #=> #<IPAddr: IPv6:3ffe:0505:0002:0000:0000:0000:0000:0000/ffff:ffff:ffff:0000:0000:0000:0000:0000>

    p ipaddr2.to_s              #=> "3ffe:505:2::"

    ipaddr3 = IPAddr.new "192.168.2.0/24"

    p ipaddr3                   #=> #<IPAddr: IPv4:192.168.2.0/255.255.255.0>

;T;0;	I"IPAddr;T;
[ ;[I"Comparable;T;0;[ ;[ ;0;0o;;I"cCreates a new ipaddr containing the given network byte ordered string form of
an IP address.

;T;0;;;I"new_ntoh;F;I"IPAddr;T;[o;;I"::String addr;T;I"IPAddr;To;;I"\Convert a network byte ordered string form of an IP address into human
readable form.

;T;0;;;I"	ntop;F;I"IPAddr;T;[o;;I"::String addr;T;I"String;To;;I"JCreates a new ipaddr object either from a human readable IP address
representation in string, or from a packed in_addr value followed by an
address family.

In the former case, the following are the valid formats that will be
recognized: "address", "address/prefixlen" and "address/mask", where IPv6
address may be enclosed in square brackets (`[' and `]').  If a prefixlen or a
mask is specified, it returns a masked IP address.  Although the address
family is determined automatically from a specified string, you can specify
one explicitly by the optional second argument.

Otherwise an IP address is generated from a packed in_addr value and an
address family.

The IPAddr class defines many methods and operators, and some of those, such
as &, |, include? and ==, accept a string, or a packed in_addr value instead
of an IPAddr object.

;T;0;;;I"initialize;F;I"IPAddr;T;[o;;I"$?::String addr, ?untyped family;T;I"IPAddr;To;;I"1Returns a new ipaddr built by bitwise AND.

;T;0;;;I"&;F;I"IPAddr;T;[o;;I"untyped other;T;I"IPAddr;To;;I"8Returns a new ipaddr built by bitwise left shift.

;T;0;;;I"<<;F;I"IPAddr;T;[o;;I"::Integer num;T;I"IPAddr;To;;I"(Compares the ipaddr with another.

;T;0;;;I"<=>;F;I"IPAddr;T;[o;;I"untyped other;T;I"Integer?;To;;I"-Returns true if two ipaddrs are equal.

;T;0;;;I"==;F;I"IPAddr;T;[o;;I"untyped other;T;I"	bool;To;;I"9Returns a new ipaddr built by bitwise right-shift.

;T;0;;;I">>;F;I"IPAddr;T;[o;;I"::Integer num;T;I"IPAddr;To;;I"$Checks equality used by Hash.

;T;0;;;I"	eql?;F;I"IPAddr;T;[o;;I"untyped other;T;I"	bool;To;;I"@Returns a hash value used by Hash, Set, and Array classes

;T;0;;;I"	hash;F;I"IPAddr;T;[o;;I" ;F;I"Integer;To;;I"DReturns a network byte ordered string form of the IP address.

;T;0;;;I"	hton;F;I"IPAddr;T;[o;;I" ;F;I"String;To;;I"‰Returns true if the given ipaddr is in the range.

e.g.:
    require 'ipaddr'
    net1 = IPAddr.new("192.168.2.0/24")
    net2 = IPAddr.new("192.168.2.100")
    net3 = IPAddr.new("192.168.3.0")
    net4 = IPAddr.new("192.168.2.0/16")
    p net1.include?(net2)     #=> true
    p net1.include?(net3)     #=> false
    p net1.include?(net4)     #=> false
    p net4.include?(net1)     #=> true

;T;0;;;I"include?;F;I"IPAddr;T;[o;;I"untyped other;T;I"	bool;To;;I"tReturns a string containing a human-readable representation of the ipaddr.
("#<IPAddr: family:address/mask>")

;T;0;;;I"inspect;F;I"IPAddr;T;[o;;I" ;F;I"String;To;;I"GReturns a string for DNS reverse lookup compatible with RFC3172.

;T;0;;;I"ip6_arpa;F;I"IPAddr;T;[o;;I" ;F;I"String;To;;I"GReturns a string for DNS reverse lookup compatible with RFC1886.

;T;0;;;I"ip6_int;F;I"IPAddr;T;[o;;I" ;F;I"String;To;;I"5Returns true if the ipaddr is an IPv4 address.

;T;0;;;I"
ipv4?;F;I"IPAddr;T;[o;;I" ;F;I"	bool;To;;I"mReturns a new ipaddr built by converting the native IPv4 address into an
IPv4-compatible IPv6 address.

;T;0;;;I"ipv4_compat;F;I"IPAddr;T;[o;;I" ;F;I"IPAddr;To;;I"EReturns true if the ipaddr is an IPv4-compatible IPv6 address.

;T;0;;;I"ipv4_compat?;F;I"IPAddr;T;[o;;I" ;F;I"	bool;To;;I"iReturns a new ipaddr built by converting the native IPv4 address into an
IPv4-mapped IPv6 address.

;T;0;;;I"ipv4_mapped;F;I"IPAddr;T;[o;;I" ;F;I"IPAddr;To;;I"AReturns true if the ipaddr is an IPv4-mapped IPv6 address.

;T;0;;;I"ipv4_mapped?;F;I"IPAddr;T;[o;;I" ;F;I"	bool;To;;I"5Returns true if the ipaddr is an IPv6 address.

;T;0;;;I"
ipv6?;F;I"IPAddr;T;[o;;I" ;F;I"	bool;To;;I"ÏReturns true if the ipaddr is a link-local address.  IPv4 addresses in
169.254.0.0/16 reserved by RFC 3927 and Link-Local IPv6 Unicast Addresses in
fe80::/10 reserved by RFC 4291 are considered link-local.

;T;0;;;I"link_local?;F;I"IPAddr;T;[o;;I" ;F;I"	bool;To;;I"8Returns true if the ipaddr is a loopback address.

;T;0;;;I"loopback?;F;I"IPAddr;T;[o;;I" ;F;I"	bool;To;;I"}Returns a new ipaddr built by masking IP address with the given
prefixlen/netmask. (e.g. 8, 64, "255.255.255.0", etc.)

;T;0;;;I"	mask;F;I"IPAddr;T;[o;;I"#::String | ::Integer prefixlen;T;I"IPAddr;To;;I"¯Returns a new ipaddr built by converting the IPv6 address into a native IPv4
address.  If the IP address is not an IPv4-mapped or IPv4-compatible IPv6
address, returns self.

;T;0;;;I"native;F;I"IPAddr;T;[o;;I" ;F;I"IPAddr;To;;I"8Returns the prefix length in bits for the ipaddr.

;T;0;;;I"prefix;F;I"IPAddr;T;[o;;I" ;F;I"Integer;To;;I"%Sets the prefix length in bits

;T;0;;;I"prefix=;F;I"IPAddr;T;[o;;I"::Integer prefix;T;I"	self;To;;I"äReturns true if the ipaddr is a private address.  IPv4 addresses in
10.0.0.0/8, 172.16.0.0/12 and 192.168.0.0/16 as defined in RFC 1918 and IPv6
Unique Local Addresses in fc00::/7 as defined in RFC 4193 are considered
private.

;T;0;;;I"private?;F;I"IPAddr;T;[o;;I" ;F;I"	bool;To;;I"iReturns a string for DNS reverse lookup.  It returns a string in RFC3172 form
for an IPv6 address.

;T;0;;;I"reverse;F;I"IPAddr;T;[o;;I" ;F;I"String;To;;I"+Returns the successor to the ipaddr.

;T;0;;;I"	succ;F;I"IPAddr;T;[o;;I" ;F;I"IPAddr;To;;I"8Returns the integer representation of the ipaddr.

;T;0;;;I"	to_i;F;I"IPAddr;T;[o;;I" ;F;I"Integer;To;;I"6Creates a Range object for the network address.

;T;0;;;I"to_range;F;I"IPAddr;T;[o;;I" ;F;I"Range[::IPAddr];To;;I"AReturns a string containing the IP address representation.

;T;0;;;I"	to_s;F;I"IPAddr;T;[o;;I" ;F;I"String;To;;I"SReturns a string containing the IP address representation in canonical form.

;T;0;;;I"to_string;F;I"IPAddr;T;[o;;I" ;F;I"String;To;;I"0Returns a new ipaddr built by bitwise OR.

;T;0;;;I"|;F;I"IPAddr;T;[o;;I"untyped other;T;I"IPAddr;To;;I"6Returns a new ipaddr built by bitwise negation.

;T;0;;;I"~;F;I"IPAddr;T;[o;;I" ;F;I"IPAddr;To; ;I"_Generic IPAddr related error. Exceptions raised in this class should inherit
from Error.

;T;0;	I"IPAddr::Error;T;
[ ;[ ;0;[ ;[ ;0;I"ArgumentError;To; ;I"ARaised when the provided IP address is an invalid address.

;T;0;	I" IPAddr::InvalidAddressError;T;
[ ;[ ;0;[ ;[ ;0;I"IPAddr::Error;To; ;I"³Raised when the address family is invalid such as an address with an
unsupported family, an address with an inconsistent family, or an address
who's family cannot be determined.

;T;0;	I"IPAddr::AddressFamilyError;T;
[ ;[ ;0;[ ;[ ;0;I"IPAddr::Error;To; ;I"4Raised when the address is an invalid length.

;T;0;	I"IPAddr::InvalidPrefixError;T;
[ ;[ ;0;[ ;[ ;0;I" IPAddr::InvalidAddressError;To; ;I"*The base exception for JSON errors.

;T;0;	I"JSON::JSONError;T;
[ ;[ ;0;[ ;[ ;0;I"StandardError;To; ;I"HThis exception is raised if a generator or unparser error occurs.

;T;0;	I"JSON::GeneratorError;T;
[ ;[ ;0;[ ;[ ;0;I"JSON::JSONError;To; ;0;0;	I"JSON::UnparserError;T;
[ ;[ ;0;[ ;[ ;0;I"JSON::GeneratorError;To; ;I"9This exception is raised if a parser error occurs.

;T;0;	I"JSON::ParserError;T;
[ ;[ ;0;[ ;[ ;0;I"JSON::JSONError;To; ;I"UThis exception is raised if the nesting of parsed data structures is too deep.

;T;0;	I"JSON::NestingError;T;
[ ;[ ;0;[ ;[ ;0;I"JSON::ParserError;To; ;0;0;	I"JSON::State;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"eThis module holds all the modules/classes that implement JSON's functionality
as C extensions.

;T;0;	I"JSON::Ext;T;
[ ;[ ;0;[ ;[ o;;I"µThis is the JSON generator implemented as a C extension. It can be configured
to be used by setting

    JSON.generator = JSON::Ext::Generator

with the method generator= in JSON.

;T;0;	I"JSON::Ext::Generator;T;
[ ;[ ;0;[ ;[ o; ;0;0;	I" JSON::Ext::Generator::State;T;
[ ;[ ;0;[ ;[ ;0;0o; ;I"©This is the JSON parser implemented as a C extension. It can be configured to
be used by setting

    JSON.parser = JSON::Ext::Parser

with the method parser= in JSON.

;T;0;	I"JSON::Ext::Parser;T;
[ ;[ ;0;[ ;[ ;0;0o;;0;0;	I"JSON::Pure;T;
[ ;[ ;0;[ ;[ o;;0;0;	I"JSON::Pure::Generator;T;
[ ;[ ;0;[ ;[ o; ;0;0;	I"!JSON::Pure::Generator::State;T;
[ ;[ ;0;[ ;[ ;0;0o; ;0;0;	I"JSON::Pure::Parser;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"ØI# JavaScript Object Notation (JSON)

JSON is a lightweight data-interchange format.

A JSON value is one of the following:
*   Double-quoted text:  `"foo"`.
*   Number:  `1`, `1.0`, `2.0e2`.
*   Boolean:  `true`, `false`.
*   Null: `null`.
*   Array: an ordered list of values, enclosed by square brackets:
        ["foo", 1, 1.0, 2.0e2, true, false, null]

*   Object: a collection of name/value pairs, enclosed by curly braces; each
    name is double-quoted text; the values may be any JSON values:
        {"a": "foo", "b": 1, "c": 1.0, "d": 2.0e2, "e": true, "f": false, "g": null}


A JSON array or object may contain nested arrays, objects, and scalars to any
depth:
    {"foo": {"bar": 1, "baz": 2}, "bat": [0, 1, 2]}
    [{"foo": 0, "bar": 1}, ["baz", 2]]

## Using Module JSON

To make module JSON available in your code, begin with:
    require 'json'

All examples here assume that this has been done.

### Parsing JSON

You can parse a String containing JSON data using either of two methods:
*   `JSON.parse(source, opts)`
*   `JSON.parse!(source, opts)`


where
*   `source` is a Ruby object.
*   `opts` is a Hash object containing options that control both input allowed
    and output formatting.


The difference between the two methods is that JSON.parse! omits some checks
and may not be safe for some `source` data; use it only for data from trusted
sources. Use the safer method JSON.parse for less trusted sources.

#### Parsing JSON Arrays

When `source` is a JSON array, JSON.parse by default returns a Ruby Array:
    json = '["foo", 1, 1.0, 2.0e2, true, false, null]'
    ruby = JSON.parse(json)
    ruby # => ["foo", 1, 1.0, 200.0, true, false, nil]
    ruby.class # => Array

The JSON array may contain nested arrays, objects, and scalars to any depth:
    json = '[{"foo": 0, "bar": 1}, ["baz", 2]]'
    JSON.parse(json) # => [{"foo"=>0, "bar"=>1}, ["baz", 2]]

#### Parsing JSON Objects

When the source is a JSON object, JSON.parse by default returns a Ruby Hash:
    json = '{"a": "foo", "b": 1, "c": 1.0, "d": 2.0e2, "e": true, "f": false, "g": null}'
    ruby = JSON.parse(json)
    ruby # => {"a"=>"foo", "b"=>1, "c"=>1.0, "d"=>200.0, "e"=>true, "f"=>false, "g"=>nil}
    ruby.class # => Hash

The JSON object may contain nested arrays, objects, and scalars to any depth:
    json = '{"foo": {"bar": 1, "baz": 2}, "bat": [0, 1, 2]}'
    JSON.parse(json) # => {"foo"=>{"bar"=>1, "baz"=>2}, "bat"=>[0, 1, 2]}

#### Parsing JSON Scalars

When the source is a JSON scalar (not an array or object), JSON.parse returns
a Ruby scalar.

String:
    ruby = JSON.parse('"foo"')
    ruby # => 'foo'
    ruby.class # => String

Integer:
    ruby = JSON.parse('1')
    ruby # => 1
    ruby.class # => Integer

Float:
    ruby = JSON.parse('1.0')
    ruby # => 1.0
    ruby.class # => Float
    ruby = JSON.parse('2.0e2')
    ruby # => 200
    ruby.class # => Float

Boolean:
    ruby = JSON.parse('true')
    ruby # => true
    ruby.class # => TrueClass
    ruby = JSON.parse('false')
    ruby # => false
    ruby.class # => FalseClass

Null:
    ruby = JSON.parse('null')
    ruby # => nil
    ruby.class # => NilClass

#### Parsing Options

###### Input Options

Option `max_nesting` (Integer) specifies the maximum nesting depth allowed;
defaults to `100`; specify `false` to disable depth checking.

With the default, `false`:
    source = '[0, [1, [2, [3]]]]'
    ruby = JSON.parse(source)
    ruby # => [0, [1, [2, [3]]]]

Too deep:
    # Raises JSON::NestingError (nesting of 2 is too deep):
    JSON.parse(source, {max_nesting: 1})

Bad value:
    # Raises TypeError (wrong argument type Symbol (expected Fixnum)):
    JSON.parse(source, {max_nesting: :foo})

---

Option `allow_nan` (boolean) specifies whether to allow NaN, Infinity, and
MinusInfinity in `source`; defaults to `false`.

With the default, `false`:
    # Raises JSON::ParserError (225: unexpected token at '[NaN]'):
    JSON.parse('[NaN]')
    # Raises JSON::ParserError (232: unexpected token at '[Infinity]'):
    JSON.parse('[Infinity]')
    # Raises JSON::ParserError (248: unexpected token at '[-Infinity]'):
    JSON.parse('[-Infinity]')

Allow:
    source = '[NaN, Infinity, -Infinity]'
    ruby = JSON.parse(source, {allow_nan: true})
    ruby # => [NaN, Infinity, -Infinity]

###### Output Options

Option `symbolize_names` (boolean) specifies whether returned Hash keys should
be Symbols; defaults to `false` (use Strings).

With the default, `false`:
    source = '{"a": "foo", "b": 1.0, "c": true, "d": false, "e": null}'
    ruby = JSON.parse(source)
    ruby # => {"a"=>"foo", "b"=>1.0, "c"=>true, "d"=>false, "e"=>nil}

Use Symbols:
    ruby = JSON.parse(source, {symbolize_names: true})
    ruby # => {:a=>"foo", :b=>1.0, :c=>true, :d=>false, :e=>nil}

---

Option `object_class` (Class) specifies the Ruby class to be used for each
JSON object; defaults to Hash.

With the default, Hash:
    source = '{"a": "foo", "b": 1.0, "c": true, "d": false, "e": null}'
    ruby = JSON.parse(source)
    ruby.class # => Hash

Use class OpenStruct:
    ruby = JSON.parse(source, {object_class: OpenStruct})
    ruby # => #<OpenStruct a="foo", b=1.0, c=true, d=false, e=nil>

---

Option `array_class` (Class) specifies the Ruby class to be used for each JSON
array; defaults to Array.

With the default, Array:
    source = '["foo", 1.0, true, false, null]'
    ruby = JSON.parse(source)
    ruby.class # => Array

Use class Set:
    ruby = JSON.parse(source, {array_class: Set})
    ruby # => #<Set: {"foo", 1.0, true, false, nil}>

---

Option `create_additions` (boolean) specifies whether to use JSON additions in
parsing. See [\JSON Additions](#module-JSON-label-JSON+Additions).

### Generating JSON

To generate a Ruby String containing JSON data, use method
`JSON.generate(source, opts)`, where
*   `source` is a Ruby object.
*   `opts` is a Hash object containing options that control both input allowed
    and output formatting.


#### Generating JSON from Arrays

When the source is a Ruby Array, JSON.generate returns a String containing a
JSON array:
    ruby = [0, 's', :foo]
    json = JSON.generate(ruby)
    json # => '[0,"s","foo"]'

The Ruby Array array may contain nested arrays, hashes, and scalars to any
depth:
    ruby = [0, [1, 2], {foo: 3, bar: 4}]
    json = JSON.generate(ruby)
    json # => '[0,[1,2],{"foo":3,"bar":4}]'

#### Generating JSON from Hashes

When the source is a Ruby Hash, JSON.generate returns a String containing a
JSON object:
    ruby = {foo: 0, bar: 's', baz: :bat}
    json = JSON.generate(ruby)
    json # => '{"foo":0,"bar":"s","baz":"bat"}'

The Ruby Hash array may contain nested arrays, hashes, and scalars to any
depth:
    ruby = {foo: [0, 1], bar: {baz: 2, bat: 3}, bam: :bad}
    json = JSON.generate(ruby)
    json # => '{"foo":[0,1],"bar":{"baz":2,"bat":3},"bam":"bad"}'

#### Generating JSON from Other Objects

When the source is neither an Array nor a Hash, the generated JSON data
depends on the class of the source.

When the source is a Ruby Integer or Float, JSON.generate returns a String
containing a JSON number:
    JSON.generate(42) # => '42'
    JSON.generate(0.42) # => '0.42'

When the source is a Ruby String, JSON.generate returns a String containing a
JSON string (with double-quotes):
    JSON.generate('A string') # => '"A string"'

When the source is `true`, `false` or `nil`, JSON.generate returns a String
containing the corresponding JSON token:
    JSON.generate(true) # => 'true'
    JSON.generate(false) # => 'false'
    JSON.generate(nil) # => 'null'

When the source is none of the above, JSON.generate returns a String
containing a JSON string representation of the source:
    JSON.generate(:foo) # => '"foo"'
    JSON.generate(Complex(0, 0)) # => '"0+0i"'
    JSON.generate(Dir.new('.')) # => '"#<Dir>"'

#### Generating Options

###### Input Options

Option `allow_nan` (boolean) specifies whether `NaN`, `Infinity`, and
`-Infinity` may be generated; defaults to `false`.

With the default, `false`:
    # Raises JSON::GeneratorError (920: NaN not allowed in JSON):
    JSON.generate(JSON::NaN)
    # Raises JSON::GeneratorError (917: Infinity not allowed in JSON):
    JSON.generate(JSON::Infinity)
    # Raises JSON::GeneratorError (917: -Infinity not allowed in JSON):
    JSON.generate(JSON::MinusInfinity)

Allow:
    ruby = [Float::NaN, Float::Infinity, Float::MinusInfinity]
    JSON.generate(ruby, allow_nan: true) # => '[NaN,Infinity,-Infinity]'

---

Option `max_nesting` (Integer) specifies the maximum nesting depth in `obj`;
defaults to `100`.

With the default, `100`:
    obj = [[[[[[0]]]]]]
    JSON.generate(obj) # => '[[[[[[0]]]]]]'

Too deep:
    # Raises JSON::NestingError (nesting of 2 is too deep):
    JSON.generate(obj, max_nesting: 2)

###### Output Options

The default formatting options generate the most compact JSON data, all on one
line and with no whitespace.

You can use these formatting options to generate JSON data in a more open
format, using whitespace. See also JSON.pretty_generate.

*   Option `array_nl` (String) specifies a string (usually a newline) to be
    inserted after each JSON array; defaults to the empty String, `''`.
*   Option `object_nl` (String) specifies a string (usually a newline) to be
    inserted after each JSON object; defaults to the empty String, `''`.
*   Option `indent` (String) specifies the string (usually spaces) to be used
    for indentation; defaults to the empty String, `''`; defaults to the empty
    String, `''`; has no effect unless options `array_nl` or `object_nl`
    specify newlines.
*   Option `space` (String) specifies a string (usually a space) to be
    inserted after the colon in each JSON object's pair; defaults to the empty
    String, `''`.
*   Option `space_before` (String) specifies a string (usually a space) to be
    inserted before the colon in each JSON object's pair; defaults to the
    empty String, `''`.


In this example, `obj` is used first to generate the shortest JSON data (no
whitespace), then again with all formatting options specified:

    obj = {foo: [:bar, :baz], bat: {bam: 0, bad: 1}}
    json = JSON.generate(obj)
    puts 'Compact:', json
    opts = {
      array_nl: "\n",
      object_nl: "\n",
      indent: '  ',
      space_before: ' ',
      space: ' '
    }
    puts 'Open:', JSON.generate(obj, opts)

Output:
    Compact:
    {"foo":["bar","baz"],"bat":{"bam":0,"bad":1}}
    Open:
    {
      "foo" : [
        "bar",
        "baz"
    ],
      "bat" : {
        "bam" : 0,
        "bad" : 1
      }
    }

## JSON Additions

When you "round trip" a non-String object from Ruby to JSON and back, you have
a new String, instead of the object you began with:
    ruby0 = Range.new(0, 2)
    json = JSON.generate(ruby0)
    json # => '0..2"'
    ruby1 = JSON.parse(json)
    ruby1 # => '0..2'
    ruby1.class # => String

You can use JSON *additions* to preserve the original object. The addition is
an extension of a ruby class, so that:
*   JSON.generate stores more information in the JSON string.
*   JSON.parse, called with option `create_additions`, uses that information
    to create a proper Ruby object.


This example shows a Range being generated into JSON and parsed back into
Ruby, both without and with the addition for Range:
    ruby = Range.new(0, 2)
    # This passage does not use the addition for Range.
    json0 = JSON.generate(ruby)
    ruby0 = JSON.parse(json0)
    # This passage uses the addition for Range.
    require 'json/add/range'
    json1 = JSON.generate(ruby)
    ruby1 = JSON.parse(json1, create_additions: true)
    # Make a nice display.
    display = <<EOT
    Generated JSON:
      Without addition:  #{json0} (#{json0.class})
      With addition:     #{json1} (#{json1.class})
    Parsed JSON:
      Without addition:  #{ruby0.inspect} (#{ruby0.class})
      With addition:     #{ruby1.inspect} (#{ruby1.class})
    EOT
    puts display

This output shows the different results:
    Generated JSON:
      Without addition:  "0..2" (String)
      With addition:     {"json_class":"Range","a":[0,2,false]} (String)
    Parsed JSON:
      Without addition:  "0..2" (String)
      With addition:     0..2 (Range)

The JSON module includes additions for certain classes. You can also craft
custom additions. See [Custom \JSON
Additions](#module-JSON-label-Custom+JSON+Additions).

### Built-in Additions

The JSON module includes additions for certain classes. To use an addition,
`require` its source:
*   BigDecimal: `require 'json/add/bigdecimal'`
*   Complex: `require 'json/add/complex'`
*   Date: `require 'json/add/date'`
*   DateTime: `require 'json/add/date_time'`
*   Exception: `require 'json/add/exception'`
*   OpenStruct: `require 'json/add/ostruct'`
*   Range: `require 'json/add/range'`
*   Rational: `require 'json/add/rational'`
*   Regexp: `require 'json/add/regexp'`
*   Set: `require 'json/add/set'`
*   Struct: `require 'json/add/struct'`
*   Symbol: `require 'json/add/symbol'`
*   Time: `require 'json/add/time'`


To reduce punctuation clutter, the examples below show the generated JSON via
`puts`, rather than the usual `inspect`,

BigDecimal:
    require 'json/add/bigdecimal'
    ruby0 = BigDecimal(0) # 0.0
    json = JSON.generate(ruby0) # {"json_class":"BigDecimal","b":"27:0.0"}
    ruby1 = JSON.parse(json, create_additions: true) # 0.0
    ruby1.class # => BigDecimal

Complex:
    require 'json/add/complex'
    ruby0 = Complex(1+0i) # 1+0i
    json = JSON.generate(ruby0) # {"json_class":"Complex","r":1,"i":0}
    ruby1 = JSON.parse(json, create_additions: true) # 1+0i
    ruby1.class # Complex

Date:
    require 'json/add/date'
    ruby0 = Date.today # 2020-05-02
    json = JSON.generate(ruby0) # {"json_class":"Date","y":2020,"m":5,"d":2,"sg":2299161.0}
    ruby1 = JSON.parse(json, create_additions: true) # 2020-05-02
    ruby1.class # Date

DateTime:
    require 'json/add/date_time'
    ruby0 = DateTime.now # 2020-05-02T10:38:13-05:00
    json = JSON.generate(ruby0) # {"json_class":"DateTime","y":2020,"m":5,"d":2,"H":10,"M":38,"S":13,"of":"-5/24","sg":2299161.0}
    ruby1 = JSON.parse(json, create_additions: true) # 2020-05-02T10:38:13-05:00
    ruby1.class # DateTime

Exception (and its subclasses including RuntimeError):
    require 'json/add/exception'
    ruby0 = Exception.new('A message') # A message
    json = JSON.generate(ruby0) # {"json_class":"Exception","m":"A message","b":null}
    ruby1 = JSON.parse(json, create_additions: true) # A message
    ruby1.class # Exception
    ruby0 = RuntimeError.new('Another message') # Another message
    json = JSON.generate(ruby0) # {"json_class":"RuntimeError","m":"Another message","b":null}
    ruby1 = JSON.parse(json, create_additions: true) # Another message
    ruby1.class # RuntimeError

OpenStruct:
    require 'json/add/ostruct'
    ruby0 = OpenStruct.new(name: 'Matz', language: 'Ruby') # #<OpenStruct name="Matz", language="Ruby">
    json = JSON.generate(ruby0) # {"json_class":"OpenStruct","t":{"name":"Matz","language":"Ruby"}}
    ruby1 = JSON.parse(json, create_additions: true) # #<OpenStruct name="Matz", language="Ruby">
    ruby1.class # OpenStruct

Range:
    require 'json/add/range'
    ruby0 = Range.new(0, 2) # 0..2
    json = JSON.generate(ruby0) # {"json_class":"Range","a":[0,2,false]}
    ruby1 = JSON.parse(json, create_additions: true) # 0..2
    ruby1.class # Range

Rational:
    require 'json/add/rational'
    ruby0 = Rational(1, 3) # 1/3
    json = JSON.generate(ruby0) # {"json_class":"Rational","n":1,"d":3}
    ruby1 = JSON.parse(json, create_additions: true) # 1/3
    ruby1.class # Rational

Regexp:
    require 'json/add/regexp'
    ruby0 = Regexp.new('foo') # (?-mix:foo)
    json = JSON.generate(ruby0) # {"json_class":"Regexp","o":0,"s":"foo"}
    ruby1 = JSON.parse(json, create_additions: true) # (?-mix:foo)
    ruby1.class # Regexp

Set:
    require 'json/add/set'
    ruby0 = Set.new([0, 1, 2]) # #<Set: {0, 1, 2}>
    json = JSON.generate(ruby0) # {"json_class":"Set","a":[0,1,2]}
    ruby1 = JSON.parse(json, create_additions: true) # #<Set: {0, 1, 2}>
    ruby1.class # Set

Struct:
    require 'json/add/struct'
    Customer = Struct.new(:name, :address) # Customer
    ruby0 = Customer.new("Dave", "123 Main") # #<struct Customer name="Dave", address="123 Main">
    json = JSON.generate(ruby0) # {"json_class":"Customer","v":["Dave","123 Main"]}
    ruby1 = JSON.parse(json, create_additions: true) # #<struct Customer name="Dave", address="123 Main">
    ruby1.class # Customer

Symbol:
    require 'json/add/symbol'
    ruby0 = :foo # foo
    json = JSON.generate(ruby0) # {"json_class":"Symbol","s":"foo"}
    ruby1 = JSON.parse(json, create_additions: true) # foo
    ruby1.class # Symbol

Time:
    require 'json/add/time'
    ruby0 = Time.now # 2020-05-02 11:28:26 -0500
    json = JSON.generate(ruby0) # {"json_class":"Time","s":1588436906,"n":840560000}
    ruby1 = JSON.parse(json, create_additions: true) # 2020-05-02 11:28:26 -0500
    ruby1.class # Time

### Custom JSON Additions

In addition to the JSON additions provided, you can craft JSON additions of
your own, either for Ruby built-in classes or for user-defined classes.

Here's a user-defined class `Foo`:
    class Foo
      attr_accessor :bar, :baz
      def initialize(bar, baz)
        self.bar = bar
        self.baz = baz
      end
    end

Here's the JSON addition for it:
    # Extend class Foo with JSON addition.
    class Foo
      # Serialize Foo object with its class name and arguments
      def to_json(*args)
        {
          JSON.create_id  => self.class.name,
          'a'             => [ bar, baz ]
        }.to_json(*args)
      end
      # Deserialize JSON string by constructing new Foo object with arguments.
      def self.json_create(object)
        new(*object['a'])
      end
    end

Demonstration:
    require 'json'
    # This Foo object has no custom addition.
    foo0 = Foo.new(0, 1)
    json0 = JSON.generate(foo0)
    obj0 = JSON.parse(json0)
    # Lood the custom addition.
    require_relative 'foo_addition'
    # This foo has the custom addition.
    foo1 = Foo.new(0, 1)
    json1 = JSON.generate(foo1)
    obj1 = JSON.parse(json1, create_additions: true)
    #   Make a nice display.
    display = <<EOT
    Generated JSON:
      Without custom addition:  #{json0} (#{json0.class})
      With custom addition:     #{json1} (#{json1.class})
    Parsed JSON:
      Without custom addition:  #{obj0.inspect} (#{obj0.class})
      With custom addition:     #{obj1.inspect} (#{obj1.class})
    EOT
    puts display

Output:

    Generated JSON:
      Without custom addition:  "#<Foo:0x0000000006534e80>" (String)
      With custom addition:     {"json_class":"Foo","a":[0,1]} (String)
    Parsed JSON:
      Without custom addition:  "#<Foo:0x0000000006534e80>" (String)
      With custom addition:     #<Foo:0x0000000006473bb8 @bar=0, @baz=1> (Foo)

;T;0;	I"	JSON;T;
[ ;[ ;0;[ ;[ o;;I"If `object` is a String, calls JSON.parse with `object` and `opts` (see method
#parse):
    json = '[0, 1, null]'
    JSON[json]# => [0, 1, nil]

Otherwise, calls JSON.generate with `object` and `opts` (see method
#generate):
    ruby = [0, 1, nil]
    JSON[ruby] # => '[0,1,null]'

;T;0;;;I"[];F;I"	JSON;T;[o;;I")untyped object, ?::json_options opts;T;I"untyped;To;;I"GReturns the current create identifier. See also JSON.create_id=.

;T;0;;;I"create_id;F;I"	JSON;T;[o;;I" ;F;I"	_ToS;To;;I"¬Sets create identifier, which is used to decide if the *json_create* hook of a
class should be called; initial value is `json_class`:
    JSON.create_id # => 'json_class'

;T;0;;;I"create_id=;F;I"	JSON;T;[o;;I"::_ToS create_id;T;I"	_ToS;To;;0;0;;;I"deep_const_get;F;I"	JSON;T;[o;;I"::_ToS path;T;I"untyped;To;;I"ÆDumps `obj` as a JSON string, i.e. calls generate on the object and returns
the result.

The default options can be changed via method JSON.dump_default_options.

*   Argument `io`, if given, should respond to method `write`; the JSON String
    is written to `io`, and `io` is returned. If `io` is not given, the JSON
    String is returned.
*   Argument `limit`, if given, is passed to JSON.generate as option
    `max_nesting`.


---

When argument `io` is not given, returns the JSON String generated from `obj`:
    obj = {foo: [0, 1], bar: {baz: 2, bat: 3}, bam: :bad}
    json = JSON.dump(obj)
    json # => "{\"foo\":[0,1],\"bar\":{\"baz\":2,\"bat\":3},\"bam\":\"bad\"}"

When argument `io` is given, writes the JSON String to `io` and returns `io`:
    path = 't.json'
    File.open(path, 'w') do |file|
      JSON.dump(obj, file)
    end # => #<File:t.json (closed)>
    puts File.read(path)

Output:
    {"foo":[0,1],"bar":{"baz":2,"bat":3},"bam":"bad"}

;T;0;;;I"	dump;F;I"	JSON;T;[o;;I"$::_ToJson obj, ?::Integer limit;T;I"String;To;;I",::_ToJson obj, ::_JsonToWritableIO anIO;T;I"_JsonWrite;To;;I"7::_ToJson obj, ::_JsonWrite anIO, ?::Integer limit;T;I"_JsonWrite;To;;I"»Sets or returns the default options for the JSON.dump method. Initially:
    opts = JSON.dump_default_options
    opts # => {:max_nesting=>false, :allow_nan=>true, :escape_slash=>false}

;T;0;;;I"dump_default_options;F;I"	JSON;T;[o;;I" ;F;I"json_options;To;;I"»Sets or returns the default options for the JSON.dump method. Initially:
    opts = JSON.dump_default_options
    opts # => {:max_nesting=>false, :allow_nan=>true, :escape_slash=>false}

;T;0;;;I"dump_default_options=;F;I"	JSON;T;[o;;I"::json_options;T;I"json_options;To;;I"—Arguments `obj` and `opts` here are the same as arguments `obj` and `opts` in
JSON.generate.

By default, generates JSON data without checking for circular references in
`obj` (option `max_nesting` set to `false`, disabled).

Raises an exception if `obj` contains circular references:
    a = []; b = []; a.push(b); b.push(a)
    # Raises SystemStackError (stack level too deep):
    JSON.fast_generate(a)

;T;0;;;I"fast_generate;F;I"	JSON;T;[o;;I"(::_ToJson obj, ?::json_options opts;T;I"String;To;;I"8Returns a String containing the generated JSON data.

See also JSON.fast_generate, JSON.pretty_generate.

Argument `obj` is the Ruby object to be converted to JSON.

Argument `opts`, if given, contains a Hash of options for the generation. See
[Generating Options](#module-JSON-label-Generating+Options).

---

When `obj` is an Array, returns a String containing a JSON array:
    obj = ["foo", 1.0, true, false, nil]
    json = JSON.generate(obj)
    json # => '["foo",1.0,true,false,null]'

When `obj` is a Hash, returns a String containing a JSON object:
    obj = {foo: 0, bar: 's', baz: :bat}
    json = JSON.generate(obj)
    json # => '{"foo":0,"bar":"s","baz":"bat"}'

For examples of generating from other Ruby objects, see [Generating \JSON from
Other Objects](#module-JSON-label-Generating+JSON+from+Other+Objects).

---

Raises an exception if any formatting option is not a String.

Raises an exception if `obj` contains circular references:
    a = []; b = []; a.push(b); b.push(a)
    # Raises JSON::NestingError (nesting of 100 is too deep):
    JSON.generate(a)

;T;0;;;I"generate;F;I"	JSON;T;[o;;I"(::_ToJson obj, ?::json_options opts;T;I"String;To;;I"¤Returns the JSON generator module that is used by JSON. This is either
JSON::Ext::Generator or JSON::Pure::Generator:
    JSON.generator # => JSON::Ext::Generator

;T;0;;;I"generator;F;I"	JSON;T;[o;;I" ;F;I"json_generator;To;;0;0;;;I"generator=;F;I"	JSON;T;[o;;I"::json_generator generator;T;I"	void;To;;I"*Encodes string using String.encode.

;T;0;;;I"
iconv;F;I"	JSON;T;[o;;I"4::encoding to, ::encoding from, ::String string;T;I"String;To;;I"†Returns the Ruby objects created by parsing the given `source`.

*   Argument `source` must be, or be convertible to, a String:
    *   If `source` responds to instance method `to_str`, `source.to_str`
        becomes the source.
    *   If `source` responds to instance method `to_io`, `source.to_io.read`
        becomes the source.
    *   If `source` responds to instance method `read`, `source.read` becomes
        the source.
    *   If both of the following are true, source becomes the String `'null'`:
        *   Option `allow_blank` specifies a truthy value.
        *   The source, as defined above, is `nil` or the empty String `''`.

    *   Otherwise, `source` remains the source.

*   Argument `proc`, if given, must be a Proc that accepts one argument. It
    will be called recursively with each result (depth-first order). See
    details below. BEWARE: This method is meant to serialise data from trusted
    user input, like from your own database server or clients under your
    control, it could be dangerous to allow untrusted users to pass JSON
    sources into it.
*   Argument `opts`, if given, contains a Hash of options for the parsing. See
    [Parsing Options](#module-JSON-label-Parsing+Options). The default options
    can be changed via method JSON.load_default_options=.


---

When no `proc` is given, modifies `source` as above and returns the result of
`parse(source, opts)`;  see #parse.

Source for following examples:
    source = <<-EOT
    {
    "name": "Dave",
      "age" :40,
      "hats": [
        "Cattleman's",
        "Panama",
        "Tophat"
      ]
    }
    EOT

Load a String:
    ruby = JSON.load(source)
    ruby # => {"name"=>"Dave", "age"=>40, "hats"=>["Cattleman's", "Panama", "Tophat"]}

Load an IO object:
    require 'stringio'
    object = JSON.load(StringIO.new(source))
    object # => {"name"=>"Dave", "age"=>40, "hats"=>["Cattleman's", "Panama", "Tophat"]}

Load a File object:
    path = 't.json'
    File.write(path, source)
    File.open(path) do |file|
      JSON.load(file)
    end # => {"name"=>"Dave", "age"=>40, "hats"=>["Cattleman's", "Panama", "Tophat"]}

---

When `proc` is given:
*   Modifies `source` as above.
*   Gets the `result` from calling `parse(source, opts)`.
*   Recursively calls `proc(result)`.
*   Returns the final result.


Example:
    require 'json'

    # Some classes for the example.
    class Base
      def initialize(attributes)
        @attributes = attributes
      end
    end
    class User    < Base; end
    class Account < Base; end
    class Admin   < Base; end
    # The JSON source.
    json = <<-EOF
    {
      "users": [
          {"type": "User", "username": "jane", "email": "jane@example.com"},
          {"type": "User", "username": "john", "email": "john@example.com"}
      ],
      "accounts": [
          {"account": {"type": "Account", "paid": true, "account_id": "1234"}},
          {"account": {"type": "Account", "paid": false, "account_id": "1235"}}
      ],
      "admins": {"type": "Admin", "password": "0wn3d"}
    }
    EOF
    # Deserializer method.
    def deserialize_obj(obj, safe_types = %w(User Account Admin))
      type = obj.is_a?(Hash) && obj["type"]
      safe_types.include?(type) ? Object.const_get(type).new(obj) : obj
    end
    # Call to JSON.load
    ruby = JSON.load(json, proc {|obj|
      case obj
      when Hash
        obj.each {|k, v| obj[k] = deserialize_obj v }
      when Array
        obj.map! {|v| deserialize_obj v }
      end
    })
    pp ruby

Output:
    {"users"=>
       [#<User:0x00000000064c4c98
         @attributes=
           {"type"=>"User", "username"=>"jane", "email"=>"jane@example.com"}>,
         #<User:0x00000000064c4bd0
         @attributes=
           {"type"=>"User", "username"=>"john", "email"=>"john@example.com"}>],
     "accounts"=>
       [{"account"=>
           #<Account:0x00000000064c4928
           @attributes={"type"=>"Account", "paid"=>true, "account_id"=>"1234"}>},
        {"account"=>
           #<Account:0x00000000064c4680
           @attributes={"type"=>"Account", "paid"=>false, "account_id"=>"1235"}>}],
     "admins"=>
       #<Admin:0x00000000064c41f8
       @attributes={"type"=>"Admin", "password"=>"0wn3d"}>}

;T;0;;;I"	load;F;I"	JSON;T;[o;;I"]::string | ::_JsonReadableIO | ::_JsonRead source, ?::Proc proc, ?::json_options options;T;I"untyped;To;;I"ÎSets or returns default options for the JSON.load method. Initially:
    opts = JSON.load_default_options
    opts # => {:max_nesting=>false, :allow_nan=>true, :allow_blank=>true, :create_additions=>true}

;T;0;;;I"load_default_options;F;I"	JSON;T;[o;;I" ;F;I"json_options;To;;I"ÎSets or returns default options for the JSON.load method. Initially:
    opts = JSON.load_default_options
    opts # => {:max_nesting=>false, :allow_nan=>true, :allow_blank=>true, :create_additions=>true}

;T;0;;;I"load_default_options=;F;I"	JSON;T;[o;;I"::json_options;T;I"json_options;To;;I"æReturns the Ruby objects created by parsing the given `source`.

Argument `source` contains the String to be parsed.

Argument `opts`, if given, contains a Hash of options for the parsing. See
[Parsing Options](#module-JSON-label-Parsing+Options).

---

When `source` is a JSON array, returns a Ruby Array:
    source = '["foo", 1.0, true, false, null]'
    ruby = JSON.parse(source)
    ruby # => ["foo", 1.0, true, false, nil]
    ruby.class # => Array

When `source` is a JSON object, returns a Ruby Hash:
    source = '{"a": "foo", "b": 1.0, "c": true, "d": false, "e": null}'
    ruby = JSON.parse(source)
    ruby # => {"a"=>"foo", "b"=>1.0, "c"=>true, "d"=>false, "e"=>nil}
    ruby.class # => Hash

For examples of parsing for all JSON data types, see [Parsing
\JSON](#module-JSON-label-Parsing+JSON).

Parses nested JSON objects:
    source = <<-EOT
    {
    "name": "Dave",
      "age" :40,
      "hats": [
        "Cattleman's",
        "Panama",
        "Tophat"
      ]
    }
    EOT
    ruby = JSON.parse(source)
    ruby # => {"name"=>"Dave", "age"=>40, "hats"=>["Cattleman's", "Panama", "Tophat"]}

---

Raises an exception if `source` is not valid JSON:
    # Raises JSON::ParserError (783: unexpected token at ''):
    JSON.parse('')

;T;0;;;I"
parse;F;I"	JSON;T;[o;;I"*::string source, ?::json_options opts;T;I"untyped;To;;I"Calls
    parse(source, opts)

with `source` and possibly modified `opts`.

Differences from JSON.parse:
*   Option `max_nesting`, if not provided, defaults to `false`, which disables
    checking for nesting depth.
*   Option `allow_nan`, if not provided, defaults to `true`.

;T;0;;;I"parse!;F;I"	JSON;T;[o;;I"*::string source, ?::json_options opts;T;I"untyped;To;;I"”Returns the JSON parser class that is used by JSON. This is either
JSON::Ext::Parser or JSON::Pure::Parser:
    JSON.parser # => JSON::Ext::Parser

;T;0;;;I"parser;F;I"	JSON;T;[o;;I" ;F;I"json_parser;To;;0;0;;;I"parser=;F;I"	JSON;T;[o;;I"::json_parser parser;T;I"	void;To;;I"ûArguments `obj` and `opts` here are the same as arguments `obj` and `opts` in
JSON.generate.

Default options are:
    {
      indent: '  ',   # Two spaces
      space: ' ',     # One space
      array_nl: "\n", # Newline
      object_nl: "\n" # Newline
    }

Example:
    obj = {foo: [:bar, :baz], bat: {bam: 0, bad: 1}}
    json = JSON.pretty_generate(obj)
    puts json

Output:
    {
      "foo": [
        "bar",
        "baz"
      ],
      "bat": {
        "bam": 0,
        "bad": 1
      }
    }

;T;0;;;I"pretty_generate;F;I"	JSON;T;[o;;I"(::_ToJson obj, ?::json_options opts;T;I"untyped;To;;I"[Recursively calls passed *Proc* if the parsed data structure is an *Array* or
*Hash*

;T;0;;;I"recurse_proc;F;I"	JSON;T;[o;;I"untyped result;T;I"	void;To;;I"ÂSets or Returns the JSON generator state class that is used by JSON. This is
either JSON::Ext::Generator::State or JSON::Pure::Generator::State:
    JSON.state # => JSON::Ext::Generator::State

;T;0;;;I"
state;F;I"	JSON;T;[o;;I" ;F;I"json_state;To;;I"ÂSets or Returns the JSON generator state class that is used by JSON. This is
either JSON::Ext::Generator::State or JSON::Pure::Generator::State:
    JSON.state # => JSON::Ext::Generator::State

;T;0;;;I"state=;F;I"	JSON;T;[o;;I"::json_state;T;I"json_state;To; ;0;0;	I"OpenStruct;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"jDeserializes JSON string by constructing new Struct object with values `t`
serialized by `to_json`.

;T;0;;;I"json_create;F;I"OpenStruct;T;[o;;I"B::Hash[::String, ::String | ::Hash[::Symbol, untyped]] object;T;I"instance;To;;I"XReturns a hash, that will be turned into a JSON object and represent this
object.

;T;0;;;I"as_json;F;I"OpenStruct;T;[o;;I"*untyped;T;I"9Hash[::String, ::String | ::Hash[::Symbol, untyped]];To;;I"UStores class name (OpenStruct) with this struct's values `t` as a JSON string.

;T;0;;;I"to_json;F;I"OpenStruct;T;[o;;I"?::JSON::State state;T;I"String;To; ;0;0;	I"Set;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"RImport a JSON Marshalled object.

method used for JSON marshalling support.

;T;0;;;I"json_create;F;I"Set;T;[o;;I"3::Hash[::String, ::String | ::Array[A]] object;T;I"Set[A];To;;I"MMarshal the object to JSON.

method used for JSON marshalling support.

;T;0;;;I"as_json;F;I"Set;T;[o;;I"*untyped;T;I"*Hash[::String, ::String | ::Array[A]];To;;I"return the JSON value

;T;0;;;I"to_json;F;I"Set;T;[o;;I"?::JSON::State state;T;I"String;To; ;I"øThis library provides the Set class, which deals with a collection
of unordered values with no duplicates. It is a hybrid of Array's
intuitive inter-operation facilities and Hash's fast lookup.
The method `to_set` is added to Enumerable for convenience.
Set implements a collection of unordered values with no duplicates.
This is a hybrid of Array's intuitive inter-operation facilities and
Hash's fast lookup.
Set is easy to use with Enumerable objects (implementing `each`).
Most of the initializer methods and binary operators accept generic
Enumerable objects besides sets and arrays. An Enumerable object
can be converted to Set using the `to_set` method.
Set uses Hash as storage, so you must note the following points:
*   Equality of elements is determined according to Object#eql? and
     Object#hash. Use Set#compare_by_identity to make a set compare
     its elements by their identity.
*   Set assumes that the identity of each element does not change
     while it is stored. Modifying an element of a set will render the
     set to an unreliable state.
*   When a string is to be stored, a frozen copy of the string is
     stored instead unless the original string is already frozen.

## Comparison
The comparison operators `<`, `>`, `<=`, and `>=` are implemented as
shorthand for the {proper_,}{subset?,superset?} methods. The `<=>`
operator reflects this order, or return `nil` for sets that both
have distinct elements (`{x, y}` vs. `{x, z}` for example).
## Example
    require 'set'
s1 = Set[1, 2]                        #=> #<Set: {1, 2}>
s2 = [1, 2].to_set                    #=> #<Set: {1, 2}>
s1 == s2                              #=> true
s1.add("foo")                         #=> #<Set: {1, 2, "foo"}>
s1.merge([2, 6])                      #=> #<Set: {1, 2, "foo", 6}>
s1.subset?(s2)                        #=> false
s2.subset?(s1)                        #=> true

## Contact
*   Akinori MUSHA <mailto:knu@iDaemons.org> (current maintainer)

## What's Here
First, what's elsewhere. Class Set:
*   Inherits from [class
    Object](https://docs.ruby-lang.org/en/master/Object.html#class-Object-labe
    l-What-27s+Here).
*   Includes [module
     which provides dozens of additional
    g/en/master/Enumerable.html#module-Enumerable-label-What-27s+Here),
     which provides dozens of additional methods.

In particular, class Set does not have many methods of its own
for fetching or for iterating.
Instead, it relies on those in Enumerable.
Here, class Set provides methods that are useful for:
*   [Creating a Set](#class-Set-label-Methods+for+Creating+a+Set)
*   [Set Operations](#class-Set-label-Methods+for+Set+Operations)
*   [Comparing](#class-Set-label-Methods+for+Comparing)
*   [Querying](#class-Set-label-Methods+for+Querying)
*   [Assigning](#class-Set-label-Methods+for+Assigning)
*   [Deleting](#class-Set-label-Methods+for+Deleting)
*   [Converting](#class-Set-label-Methods+for+Converting)
*   [Iterating](#class-Set-label-Methods+for+Iterating)
*   [And more....](#class-Set-label-Other+Methods)

### Methods for Creating a Set
*   ::[] -
 Returns a new set containing the given objects.
*   ::new -
     Returns a new set containing either the given objects
     (if no block given) or the return values from the called block
     (if a block given).

### Methods for Set Operations
*   [|](#method-i-7C) (aliased as #union and #+) -
     Returns a new set containing all elements from `self`
     and all elements from a given enumerable (no duplicates).
*   [&](#method-i-26) (aliased as #intersection) -
     Returns a new set containing all elements common to `self`
     and a given enumerable.
*   [-](#method-i-2D) (aliased as #difference) -
     Returns a copy of `self` with all elements
     in a given enumerable removed.
*   [\^](#method-i-5E) -
     Returns a new set containing all elements from `self`
     and a given enumerable except those common to both.

### Methods for Comparing
*   [<=>](#method-i-3C-3D-3E) -
     Returns -1, 0, or 1 as `self` is less than, equal to,
     or greater than a given object.
*   [==](#method-i-3D-3D) -
     Returns whether `self` and a given enumerable are equal,
     as determined by Object#eql?.
*   #compare_by_identity? -
     Returns whether the set considers only identity
 when comparing elements.

### Methods for Querying
*   #length (aliased as #size) -
 Returns the count of elements.
*   #empty? -
 Returns whether the set has no elements.
*   #include? (aliased as #member? and #===) -
     Returns whether a given object is an element in the set.
*   #subset? (aliased as [<=](#method-i-3C-3D)) -
     Returns whether a given object is a subset of the set.
*   #proper_subset? (aliased as [<](#method-i-3C)) -
     Returns whether a given enumerable is a proper subset of the set.
*   #superset? (aliased as [<=](#method-i-3E-3D)]) -
     Returns whether a given enumerable is a superset of the set.
*   #proper_superset? (aliased as [>](#method-i-3E)) -
     Returns whether a given enumerable is a proper superset of the set.
*   #disjoint? -
     Returns `true` if the set and a given enumerable
     have no common elements, `false` otherwise.
*   #intersect? -
     Returns `true` if the set and a given enumerable -
     have any common elements, `false` otherwise.
*   #compare_by_identity? -
     Returns whether the set considers only identity
 when comparing elements.

### Methods for Assigning
*   #add (aliased as #<<) -
 Adds a given object to the set; returns `self`.
*   #add? -
     If the given object is not an element in the set,
     adds it and returns `self`; otherwise, returns `nil`.
*   #merge -
 Adds each given object to the set; returns `self`.
*   #replace -
     Replaces the contents of the set with the contents
     of a given enumerable.

### Methods for Deleting
*   #clear -
 Removes all elements in the set; returns `self`.
*   #delete -
 Removes a given object from the set; returns `self`.
*   #delete? -
     If the given object is an element in the set,
     removes it and returns `self`; otherwise, returns `nil`.
*   #subtract -
 Removes each given object from the set; returns `self`.
*   #delete_if - Removes elements specified by a given block.
*   #select! (aliased as #filter!) -
     Removes elements not specified by a given block.
*   #keep_if -
 Removes elements not specified by a given block.
*   #reject!
 Removes elements specified by a given block.

### Methods for Converting
*   #classify -
     Returns a hash that classifies the elements,
     as determined by the given block.
*   #collect! (aliased as #map!) -
     Replaces each element with a block return-value.
*   #divide -
     Returns a hash that classifies the elements,
     as determined by the given block;
     differs from #classify in that the block may accept
     either one or two arguments.
*   #flatten -
     Returns a new set that is a recursive flattening of `self`.
     #flatten! -
     Replaces each nested set in `self` with the elements from that set.
*   #inspect (aliased as #to_s) -
 Returns a string displaying the elements.
*   #join -
     Returns a string containing all elements, converted to strings
     as needed, and joined by the given record separator.
*   #to_a -
 Returns an array containing all set elements.
*   #to_set -
     Returns `self` if given no arguments and no block;
     with a block given, returns a new set consisting of block
 return values.

### Methods for Iterating
*   #each -
 Calls the block with each successive element; returns `self`.

### Other Methods
*   #reset -
     Resets the internal state; useful if an object
     has been modified while an element in the set.

;T;0;	I"Set;T;
[ ;[I"Enumerable;T;0;[ ;[ ;0;0o;;I"ÝCreates a new set containing the elements of the given enumerable
object.
If a block is given, the elements of enum are preprocessed by the
given block.
    Set.new([1, 2])                       #=> #<Set: {1, 2}>
    Set.new([1, 2, 1])                    #=> #<Set: {1, 2}>
    Set.new([1, 'c', :s])                 #=> #<Set: {1, "c", :s}>
    Set.new(1..5)                         #=> #<Set: {1, 2, 3, 4, 5}>
    Set.new([1, 2, 3]) { |x| x * x }      #=> #<Set: {1, 4, 9}>

;T;0;;;I"initialize;F;I"Set;T;[o;;I"::_Each[A];T;I"untyped;To;;I"::_Each[X];T;I"untyped;To;;I"	?nil;T;I"untyped;To;;I"ÓCreates a new set containing the given objects.
    Set[1, 2]                   # => #<Set: {1, 2}>
    Set[1, 2, 1]                # => #<Set: {1, 2}>
    Set[1, 'c', :s]             # => #<Set: {1, "c", :s}>

;T;0;;;I"[];F;I"Set;T;[o;;I"*X;T;I"Set[X];To;;I"ÜReturns a new set containing elements common to the set and the
given enumerable object.
    Set[1, 3, 5] & Set[3, 2, 1]             #=> #<Set: {3, 1}>
    Set['a', 'b', 'z'] & ['a', 'b', 'c']    #=> #<Set: {"a", "b"}>

;T;0;;;I"&;F;I"Set;T;[o;;I"::_Each[A];T;I"	self;To;;I"íReturns a new set built by merging the set and the elements of the
given enumerable object.
    Set[1, 2, 3] | Set[2, 4, 5]         #=> #<Set: {1, 2, 3, 4, 5}>
    Set[1, 5, 'z'] | (1..6)             #=> #<Set: {1, 5, "z", 2, 3, 4, 6}>

;T;0;;;I"|;F;I"Set;T;[o;;I"::_Each[A];T;I"	self;To;;I"ôReturns a new set built by duplicating the set, removing every
element that appears in the given enumerable object.
    Set[1, 3, 5] - Set[1, 5]                #=> #<Set: {3}>
    Set['a', 'b', 'z'] - ['a', 'c']         #=> #<Set: {"b", "z"}>

;T;0;;;I"-;F;I"Set;T;[o;;I"::_Each[A];T;I"	self;To;;I"Adds the given object to the set and returns self. Use `merge` to
add many elements at once.
    Set[1, 2].add(3)                    #=> #<Set: {1, 2, 3}>
    Set[1, 2].add([3, 4])               #=> #<Set: {1, 2, [3, 4]}>
    Set[1, 2].add(2)                    #=> #<Set: {1, 2}>

;T;0;;;I"add;F;I"Set;T;[o;;I"A;T;I"	self;To;;I"Adds the given object to the set and returns self. If the
object is already in the set, returns nil.
    Set[1, 2].add?(3)                    #=> #<Set: {1, 2, 3}>
    Set[1, 2].add?([3, 4])               #=> #<Set: {1, 2, [3, 4]}>
    Set[1, 2].add?(2)                    #=> nil

;T;0;;;I"	add?;F;I"Set;T;[o;;I"A;T;I"
self?;To;;I"´Returns true if the set contains the given object.
Note that `include?` and `member?` do not test member
equality using `==` as do other Enumerables.
See also Enumerable#include?

;T;0;;;I"include?;F;I"Set;T;[o;;I"A;T;I"	bool;To;;I"(Returns a new set containing elements exclusive between the set
and the given enumerable object. `(set ^ enum)` is equivalent to
`((set | enum) - (set & enum))`.
    Set[1, 2] ^ Set[2, 3]                   #=> #<Set: {3, 1}>
    Set[1, 'b', 'c'] ^ ['b', 'd']           #=> #<Set: {"d", 1, "c"}>

;T;0;;;I"^;F;I"Set;T;[o;;I"::_Each[A];T;I"	self;To;;I"Classifies the set by the return value of the given block and
returns a hash of {value => set of elements} pairs. The block is
called once for each element of the set, passing the element as
parameter.
    require 'set'
    files = Set.new(Dir.glob("*.rb"))
    hash = files.classify { |f| File.mtime(f).year }
    hash       #=> {2000=>#<Set: {"a.rb", "b.rb"}>,
               #    2001=>#<Set: {"c.rb", "d.rb", "e.rb"}>,
               #    2002=>#<Set: {"f.rb"}>}

Returns an enumerator if no block is given.

;T;0;;;I"classify;F;I"Set;T;[o;;I" ;F;I"Hash[X, self];To;;I"ÑRemoves all elements and returns self.
    set = Set[1, 'c', :s]             #=> #<Set: {1, "c", :s}>
    set.clear                         #=> #<Set: {}>
    set                               #=> #<Set: {}>

;T;0;;;I"
clear;F;I"Set;T;[o;;I" ;F;I"	self;To;;I"kReplaces the elements with ones returned by `collect()`.
Returns an enumerator if no block is given.

;T;0;;;I"collect!;F;I"Set;T;[o;;I" ;F;I"	self;To;;I"kDeletes the given object from the set and returns self. Use
`subtract` to delete many items at once.

;T;0;;;I"delete;F;I"Set;T;[o;;I"A;T;I"	self;To;;I"lDeletes the given object from the set and returns self. If the
object is not in the set, returns nil.

;T;0;;;I"delete?;F;I"Set;T;[o;;I"A;T;I"
self?;To;;I"ƒDeletes every element of the set for which block evaluates to
true, and returns self. Returns an enumerator if no block is
given.

;T;0;;;I"delete_if;F;I"Set;T;[o;;I" ;F;I"	self;To;;I"xEquivalent to Set#delete_if, but returns nil if no changes were
made. Returns an enumerator if no block is given.

;T;0;;;I"reject!;F;I"Set;T;[o;;I" ;F;I"	self;To;;I"<Returns true if the set and the given enumerable have
no element in common. This method is the opposite of `intersect?`.
    Set[1, 2, 3].disjoint? Set[3, 4]   #=> false
    Set[1, 2, 3].disjoint? Set[4, 5]   #=> true
    Set[1, 2, 3].disjoint? [3, 4]      #=> false
    Set[1, 2, 3].disjoint? 4..5        #=> true

;T;0;;;I"disjoint?;F;I"Set;T;[o;;I"	self;T;I"	bool;To;;I"YDivides the set into a set of subsets according to the commonality
defined by the given block.
If the arity of the block is 2, elements o1 and o2 are in common
if block.call(o1, o2) is true. Otherwise, elements o1 and o2 are
in common if block.call(o1) == block.call(o2).
    require 'set'
    numbers = Set[1, 3, 4, 6, 9, 10, 11]
    set = numbers.divide { |i,j| (i - j).abs == 1 }
    set        #=> #<Set: {#<Set: {1}>,
               #           #<Set: {11, 9, 10}>,
               #           #<Set: {3, 4}>,
               #           #<Set: {6}>}>

Returns an enumerator if no block is given.

;T;0;;;I"divide;F;I"Set;T;[o;;I" ;F;I"Set[self];To;;I" ;F;I"Set[self];To;;I"‡Calls the given block once for each element in the set, passing
the element as parameter. Returns an enumerator if no block is
given.

;T;0;;;I"	each;F;I"Set;T;[o;;I" ;F;I"	self;To;;I"4Returns true if the set contains no elements.

;T;0;;;I"empty?;F;I"Set;T;[o;;I" ;F;I"	bool;To;;I"_Returns a new set that is a copy of the set, flattening each
containing set recursively.

;T;0;;;I"flatten;F;I"Set;T;[o;;I" ;F;I"Set[untyped];To;;I"Returns true if the set and the given enumerable have at least one
element in common.
    Set[1, 2, 3].intersect? Set[4, 5]   #=> false
    Set[1, 2, 3].intersect? Set[3, 4]   #=> true
    Set[1, 2, 3].intersect? 4..5        #=> false
    Set[1, 2, 3].intersect? [3, 4]      #=> true

;T;0;;;I"intersect?;F;I"Set;T;[o;;I"	self;T;I"	bool;To;;I"„Deletes every element of the set for which block evaluates to
false, and returns self. Returns an enumerator if no block is
given.

;T;0;;;I"keep_if;F;I"Set;T;[o;;I" ;F;I"	self;To;;I"&Returns the number of elements.

;T;0;;;I"	size;F;I"Set;T;[o;;I" ;F;I"Integer;To;;I"VMerges the elements of the given enumerable object to the set and
returns self.

;T;0;;;I"
merge;F;I"Set;T;[o;;I"::_Each[A];T;I"	self;To;;I"<Returns true if the set is a subset of the given set.

;T;0;;;I"subset?;F;I"Set;T;[o;;I"	self;T;I"	bool;To;;0;0;;;I"proper_subst?;F;I"Set;T;[o;;I"	self;T;I"	bool;To;;I">Returns true if the set is a superset of the given set.

;T;0;;;I"superset?;F;I"Set;T;[o;;I"	self;T;I"	bool;To;;I"EReturns true if the set is a proper superset of the given set.

;T;0;;;I"proper_superset?;F;I"Set;T;[o;;I"	self;T;I"	bool;To;;I"Replaces the contents of the set with the contents of the given
enumerable object and returns self.
    set = Set[1, 'c', :s]             #=> #<Set: {1, "c", :s}>
    set.replace([1, 2])               #=> #<Set: {1, 2}>
    set                               #=> #<Set: {1, 2}>

;T;0;;;I"replace;F;I"Set;T;[o;;I"::_Each[A];T;I"	self;To;;I"‚Resets the internal state after modification to existing elements
and returns self.
Elements will be reindexed and deduplicated.

;T;0;;;I"
reset;F;I"Set;T;[o;;I" ;F;I"	self;To;;I"vEquivalent to Set#keep_if, but returns nil if no changes were
made. Returns an enumerator if no block is given.

;T;0;;;I"select!;F;I"Set;T;[o;;I" ;F;I"
self?;To;;I"ZDeletes every element that appears in the given enumerable object
and returns self.

;T;0;;;I"subtract;F;I"Set;T;[o;;I"::_Each[A];T;I"	self;To;;I"«Converts the set to an array. The order of elements is uncertain.
    Set[1, 2].to_a                    #=> [1, 2]
    Set[1, 'c', :s].to_a              #=> [1, "c", :s]

;T;0;;;I"	to_a;F;I"Set;T;[o;;I" ;F;I"Array[A];To; ;0;0;	I"Logger;T;
[ ;[ ;0;[ ;[ ;0;0o; ;0;0;	I"Logger;T;
[ ;[ ;0;[ ;[ ;0;0o; ;I"-not used after 1.2.7. just for compat.

;T;0;	I"Logger;T;
[ ;[I"Logger::Severity;T;0;[ ;[ ;0;0o;;I"kDump given message to the log device without any formatting.  If no log device
exists, return `nil`.

;T;0;;;I"<<;F;I"Logger;T;[o;;I"untyped msg;T;I"untyped | nil;To;;I"¦### Args

`severity`
:   Severity.  Constants are defined in Logger namespace: `DEBUG`, `INFO`,
    `WARN`, `ERROR`, `FATAL`, or `UNKNOWN`.
`message`
:   The log message.  A String or Exception.
`progname`
:   Program name string.  Can be omitted.  Treated as a message if no
    `message` and `block` are given.
`block`
:   Can be omitted.  Called to get a message string if `message` is nil.


### Return

When the given severity is not high enough (for this particular logger), log
no message, and return `true`.

### Description

Log a message if the given severity is high enough.  This is the generic
logging method.  Users will be more inclined to use #debug, #info, #warn,
#error, and #fatal.

**Message format**: `message` can be any object, but it has to be converted to
a String in order to log it.  Generally, `inspect` is used if the given object
is not a String. A special case is an `Exception` object, which will be
printed in detail, including message, class, and backtrace.  See #msg2str for
the implementation if required.

### Bugs

*   Logfile is not locked.
*   Append open does not need to lock file.
*   If the OS supports multi I/O, records possibly may be mixed.

;T;0;;;I"add;F;I"Logger;T;[o;;I"<::Integer severity, ?untyped message, ?untyped progname;T;I"	true;Fo;;I" Close the logging device.

;T;0;;;I"
close;F;I"Logger;T;[o;;I" ;F;I"untyped;To;;I"AReturns the date format being used.  See #datetime_format=

;T;0;;;I"datetime_format;F;I"Logger;T;[o;;I" ;F;I"String?;To;;I"`Set date-time format.

`datetime_format`
:   A string suitable for passing to `strftime`.

;T;0;;;I"datetime_format=;F;I"Logger;T;[o;;I"::String datetime_format;T;I"String;To;;I"nil datetime_format;T;I"nil;To;;I">Log a `DEBUG` message.

See #info for more information.

;T;0;;;I"
debug;F;I"Logger;T;[o;;I"?untyped progname;T;I"	true;Fo;;I""Sets the severity to DEBUG.

;T;0;;;I"debug!;F;I"Logger;T;[o;;I" ;F;I"Integer;To;;I"lReturns `true` if and only if the current severity level allows for the
printing of `DEBUG` messages.

;T;0;;;I"debug?;F;I"Logger;T;[o;;I" ;F;I"	bool;To;;I"?Log an `ERROR` message.

See #info for more information.

;T;0;;;I"
error;F;I"Logger;T;[o;;I"?untyped progname;T;I"	true;Fo;;I""Sets the severity to ERROR.

;T;0;;;I"error!;F;I"Logger;T;[o;;I" ;F;I"Integer;To;;I"lReturns `true` if and only if the current severity level allows for the
printing of `ERROR` messages.

;T;0;;;I"error?;F;I"Logger;T;[o;;I" ;F;I"	bool;To;;I">Log a `FATAL` message.

See #info for more information.

;T;0;;;I"
fatal;F;I"Logger;T;[o;;I"?untyped progname;T;I"	true;Fo;;I""Sets the severity to FATAL.

;T;0;;;I"fatal!;F;I"Logger;T;[o;;I" ;F;I"Integer;To;;I"lReturns `true` if and only if the current severity level allows for the
printing of `FATAL` messages.

;T;0;;;I"fatal?;F;I"Logger;T;[o;;I" ;F;I"	bool;To;;I"Logging formatter, as a `Proc` that will take four arguments and return the
formatted message. The arguments are:

`severity`
:   The Severity of the log message.
`time`
:   A Time instance representing when the message was logged.
`progname`
:   The #progname configured, or passed to the logger method.
`msg`
:   The *Object* the user passed to the log message; not necessarily a String.


The block should return an Object that can be written to the logging device
via `write`.  The default formatter is used when no formatter is set.

;T;0;;;I"formatter;F;I"Logger;T;[o;;I" ;F;I"Logger::_Formatter | nil;To;;I"Logging formatter, as a `Proc` that will take four arguments and return the
formatted message. The arguments are:

`severity`
:   The Severity of the log message.
`time`
:   A Time instance representing when the message was logged.
`progname`
:   The #progname configured, or passed to the logger method.
`msg`
:   The *Object* the user passed to the log message; not necessarily a String.


The block should return an Object that can be written to the logging device
via `write`.  The default formatter is used when no formatter is set.

;T;0;;;I"formatter=;F;I"Logger;T;[o;;I"::Logger::_Formatter;T;I"Logger::_Formatter;To;;I"nil;T;I"nil;To;;I"BLog an `INFO` message.

`message`
:   The message to log; does not need to be a String.
`progname`
:   In the block form, this is the #progname to use in the log message.  The
    default can be set with #progname=.
`block`
:   Evaluates to the message to log.  This is not evaluated unless the
    logger's level is sufficient to log the message.  This allows you to
    create potentially expensive logging messages that are only called when
    the logger is configured to show them.


### Examples

    logger.info("MainApp") { "Received connection from #{ip}" }
    # ...
    logger.info "Waiting for input from user"
    # ...
    logger.info { "User typed #{input}" }

You'll probably stick to the second form above, unless you want to provide a
program name (which you can do with #progname= as well).

### Return

See #add.

;T;0;;;I"	info;F;I"Logger;T;[o;;I"?untyped progname;T;I"	true;Fo;;I"!Sets the severity to INFO.

;T;0;;;I"
info!;F;I"Logger;T;[o;;I" ;F;I"Integer;To;;I"kReturns `true` if and only if the current severity level allows for the
printing of `INFO` messages.

;T;0;;;I"
info?;F;I"Logger;T;[o;;I" ;F;I"	bool;To;;I"8Logging severity threshold (e.g. `Logger::INFO`).

;T;0;;;I"
level;F;I"Logger;T;[o;;I" ;F;I"Integer;To;;I"WSet logging severity threshold.

`severity`
:   The Severity of the log message.

;T;0;;;I"level=;F;I"Logger;T;[o;;I""::Integer | ::String severity;T;I"Integer;To;;I"/Program name to include in log messages.

;T;0;;;I"progname;F;I"Logger;T;[o;;I" ;F;I"untyped;To;;I"/Program name to include in log messages.

;T;0;;;I"progname=;F;I"Logger;T;[o;;I"untyped;T;I"untyped;To;;I"### Args

`logdev`
:   The log device.  This is a filename (String) or IO object (typically
    `STDOUT`, `STDERR`, or an open file).  reopen the same filename if it is
    `nil`, do nothing for IO.  Default is `nil`.


### Description

Reopen a log device.

;T;0;;;I"reopen;F;I"Logger;T;[o;;I" ;F;I"	self;To;;I"::Logger::logdev?;T;I"	self;To;;I"}Log an `UNKNOWN` message.  This will be printed no matter what the logger's
level is.

See #info for more information.

;T;0;;;I"unknown;F;I"Logger;T;[o;;I"?untyped progname;T;I"	true;Fo;;I"=Log a `WARN` message.

See #info for more information.

;T;0;;;I"	warn;F;I"Logger;T;[o;;I"?untyped progname;T;I"	true;Fo;;I"!Sets the severity to WARN.

;T;0;;;I"
warn!;F;I"Logger;T;[o;;I" ;F;I"Integer;To;;I"kReturns `true` if and only if the current severity level allows for the
printing of `WARN` messages.

;T;0;;;I"
warn?;F;I"Logger;T;[o;;I" ;F;I"	bool;To;;I" ;T;0;;;I"format_message;F;I"Logger;T;[o;;I"F::String severity, ::Time datetime, untyped progname, untyped msg;T;I"	_ToS;To;;I" ;T;0;;;I"format_severity;F;I"Logger;T;[o;;I"::Integer severity;T;I"String;To;;I"$### Args

`logdev`
:   The log device.  This is a filename (String), IO object (typically
    `STDOUT`, `STDERR`, or an open file), `nil` (it writes nothing) or
    `File::NULL` (same as `nil`).
`shift_age`
:   Number of old log files to keep, **or** frequency of rotation (`daily`,
    `weekly` or `monthly`). Default value is 0, which disables log file
    rotation.
`shift_size`
:   Maximum logfile size in bytes (only applies when `shift_age` is a positive
    Integer). Defaults to `1048576` (1MB).
`level`
:   Logging severity threshold. Default values is Logger::DEBUG.
`progname`
:   Program name to include in log messages. Default value is nil.
`formatter`
:   Logging formatter. Default values is an instance of Logger::Formatter.
`datetime_format`
:   Date and time format. Default value is '%Y-%m-%d %H:%M:%S'.
`binmode`
:   Use binary mode on the log device. Default value is false.
`shift_period_suffix`
:   The log file suffix format for `daily`, `weekly` or `monthly` rotation.
    Default is '%Y%m%d'.


### Description

Create an instance.

;T;0;;;I"initialize;F;I"Logger;T;[o;;I"ê::Logger::logdev logdev, ?::Numeric | ::String shift_age, ?::Integer shift_size, ?shift_period_suffix: ::String, ?binmode: ::boolish, ?datetime_format: ::String, ?formatter: ::Logger::_Formatter, ?progname: ::String, ?level: ::Integer;T;I"	void;To; ;I"*Default formatter for log messages.

;T;0;	I"Logger::Formatter;T;
[ ;[ ;0;[ ;[ ;0;0o;;I" ;T;0;;;I"	call;F;I"Logger::Formatter;T;[o;;I"B::String severity, ::Time time, untyped progname, untyped msg;T;I"String;To;;I" ;T;0;;;I"format_datetime;F;I"Logger::Formatter;T;[o;;I"::Time time;T;I"untyped;To;;I" ;T;0;;;I"initialize;F;I"Logger::Formatter;T;[o;;I" ;F;I"	void;To;;I" ;T;0;;;I"msg2str;F;I"Logger::Formatter;T;[o;;I")::String | ::Exception | untyped msg;T;I"String;To; ;I"(Device used for logging messages.

;T;0;	I"Logger::LogDevice;T;
[ ;[I"MonitorMixin;TI"Logger::Period;T;0;[ ;[ ;0;0o;;I" ;T;0;;;I"
close;F;I"Logger::LogDevice;T;[o;;I" ;F;I"nil;To;;I" ;T;0;;;I"reopen;F;I"Logger::LogDevice;T;[o;;I"?::Logger::logdev log;T;I"	self;To;;I" ;T;0;;;I"
write;F;I"Logger::LogDevice;T;[o;;I"untyped message;T;I"untyped;To;;I" ;T;0;;;I"add_log_header;F;I"Logger::LogDevice;T;[o;;I"::IO file;T;I"untyped;To;;I" ;T;0;;;I"check_shift_log;F;I"Logger::LogDevice;T;[o;;I" ;F;I"untyped;To;;I" ;T;0;;;I"create_logfile;F;I"Logger::LogDevice;T;[o;;I"::String filename;T;I"	File;To;;I" ;T;0;;;I"initialize;F;I"Logger::LogDevice;T;[o;;I"~?untyped logdev, ?binmode: ::boolish, ?shift_period_suffix: ::String, ?shift_size: ::Integer, ?shift_age: ::Numeric | ::String;T;I"	void;To;;I" ;T;0;;;I"lock_shift_log;F;I"Logger::LogDevice;T;[o;;I" ;F;I"untyped;To;;I" ;T;0;;;I"open_logfile;F;I"Logger::LogDevice;T;[o;;I"::String filename;T;I"	File;To;;I" ;T;0;;;I"set_dev;F;I"Logger::LogDevice;T;[o;;I"::Logger::logdev log;T;I"untyped;To;;I" ;T;0;;;I"shift_log_age;F;I"Logger::LogDevice;T;[o;;I" ;F;I"	true;Fo;;I" ;T;0;;;I"shift_log_period;F;I"Logger::LogDevice;T;[o;;I"::Time period_end;T;I"	true;Fo;;0;0;	I"Logger::Period;T;
[ ;[ ;0;[ ;[ o;;I" ;T;0;;;I"next_rotate_time;F;I"Logger::Period;T;[o;;I"#::Time now, ::String shift_age;T;I"untyped;To;;I" ;T;0;;;I"previous_period_end;F;I"Logger::Period;T;[o;;I"#::Time now, ::String shift_age;T;I"untyped;To;;I"Logging severity.

;T;0;	I"Logger::Severity;T;
[ ;[ ;0;[ ;[ o; ;I"\Defines the API for Reporters. Subclass this and override whatever you want.
Go nuts.

;T;0;	I"Minitest::AbstractReporter;T;
[ ;[I"Mutex_m;T;0;[ ;[ ;0;0o;;I"#Starts reporting on the run.

;T;0;;;I"
start;F;I"Minitest::AbstractReporter;T;[o;;I" ;F;I"nil;To;;I"About to start running a test. This allows a reporter to show that it is
starting or that we are in the middle of a test run.

;T;0;;;I"prerecord;F;I"Minitest::AbstractReporter;T;[o;;I" untyped klass, untyped name;T;I"nil;To;;I"¾Output and record the result of the test. Call
[result#result_code](rdoc-ref:Runnable#result_code) to get the result
character string. Stores the result of the run if the run did not pass.

;T;0;;;I"record;F;I"Minitest::AbstractReporter;T;[o;;I"untyped result;T;I"nil;To;;I"&Outputs the summary of the run.

;T;0;;;I"report;F;I"Minitest::AbstractReporter;T;[o;;I" ;F;I"nil;To;;I"Did this run pass?

;T;0;;;I"passed?;F;I"Minitest::AbstractReporter;T;[o;;I" ;F;I"	true;Fo; ;I"Represents run failures.

;T;0;	I"Minitest::Assertion;T;
[ ;[ ;0;[ ;[ ;0;I"Exception;To;;0;0;;;I"
error;F;I"Minitest::Assertion;T;[o;;I" ;F;I"	self;To;;I"9Where was this run before an assertion was raised?

;T;0;;;I"location;F;I"Minitest::Assertion;T;[o;;I" ;F;I"untyped;To;;0;0;;;I"result_code;F;I"Minitest::Assertion;T;[o;;I" ;F;I"untyped;To;;0;0;;;I"result_label;F;I"Minitest::Assertion;T;[o;;I" ;F;I""Failure";To;;I"nMinitest Assertions.  All assertion methods accept a `msg` which is printed if
the assertion fails.

Protocol: Nearly everything here boils up to `assert`, which expects to be
able to increment an instance accessor named `assertions`. This is not
provided by Assertions and must be provided by the thing including Assertions.
See Minitest::Runnable for an example.

;T;0;	I"Minitest::Assertions;T;
[ ;[ ;0;[ ;[ o;;0;0;;;I"inspect;F;I"Minitest::Assertions;T;[o;;I" ;F;I""UNDEFINED";To;;I"dReturns the diff command to use in #diff. Tries to intelligently figure out
what diff to use.

;T;0;;;I"	diff;F;I"Minitest::Assertions;T;[o;;I" ;F;I"untyped;To;;I",Set the diff command to use in #diff.

;T;0;;;I"
diff=;F;I"Minitest::Assertions;T;[o;;I"untyped o;T;I"untyped;To;;I"÷Returns a diff between `exp` and `act`. If there is no known diff command or
if it doesn't make sense to diff the output (single line, short output), then
it simply returns a basic comparison between the two.

See `things_to_diff` for more info.

;T;0;;;I"	diff;F;I"Minitest::Assertions;T;[o;;I"untyped exp, untyped act;T;I"String | untyped;To;;I"6Returns things to diff [expect, butwas], or [nil, nil] if nothing to diff.

Criterion:

1.  Strings include newlines or escaped newlines, but not both.
2.  or:  String lengths are > 30 characters.
3.  or:  Strings are equal to each other (but maybe different encodings?).
4.  and: we found a diff executable.

;T;0;;;I"things_to_diff;F;I"Minitest::Assertions;T;[o;;I"untyped exp, untyped act;T;I"untyped;To;;I"´This returns a human-readable version of `obj`. By default #inspect is called.
You can override this to use #pretty_inspect if you want.

See Minitest::Test.make_my_diffs_pretty!

;T;0;;;I"
mu_pp;F;I"Minitest::Assertions;T;[o;;I"untyped obj;T;I"untyped;To;;I"ôThis returns a diff-able more human-readable version of `obj`. This differs
from the regular mu_pp because it expands escaped newlines and makes
hex-values (like object_ids) generic. This uses mu_pp to do the first pass and
then cleans it up.

;T;0;;;I"mu_pp_for_diff;F;I"Minitest::Assertions;T;[o;;I"untyped obj;T;I"untyped;To;;I"%Fails unless `test` is truthy.

;T;0;;;I"assert;F;I"Minitest::Assertions;T;[o;;I" untyped test, ?untyped? msg;T;I"	true;Fo;;0;0;;;I"_synchronize;F;I"Minitest::Assertions;T;[o;;I" ;F;I"untyped;To;;I"#Fails unless `obj` is empty.

;T;0;;;I"assert_empty;F;I"Minitest::Assertions;T;[o;;I"untyped obj, ?untyped? msg;T;I"untyped;To;;I"xFails unless `exp == act` printing the difference between the two, if
possible.

If there is no visible difference but the assertion fails, you should suspect
that your #== is buggy, or your inspect output is missing crucial details.
For nicer structural diffing, set Minitest::Test.make_my_diffs_pretty!

For floats use assert_in_delta.

See also: Minitest::Assertions.diff

;T;0;;;I"assert_equal;F;I"Minitest::Assertions;T;[o;;I",untyped exp, untyped act, ?untyped? msg;T;I"untyped;To;;I"‰For comparing Floats.  Fails unless `exp` and `act` are within `delta` of each
other.

    assert_in_delta Math::PI, (22.0 / 7.0), 0.01

;T;0;;;I"assert_in_delta;F;I"Minitest::Assertions;T;[o;;I"<untyped exp, untyped act, ?::Float delta, ?untyped? msg;T;I"untyped;To;;I"eFor comparing Floats.  Fails unless `exp` and `act` have a relative error less
than `epsilon`.

;T;0;;;I"assert_in_epsilon;F;I"Minitest::Assertions;T;[o;;I">untyped exp, untyped act, ?::Float epsilon, ?untyped? msg;T;I"untyped;To;;I"0Fails unless `collection` includes `obj`.

;T;0;;;I"assert_includes;F;I"Minitest::Assertions;T;[o;;I"3untyped collection, untyped obj, ?untyped? msg;T;I"untyped;To;;I"2Fails unless `obj` is an instance of `cls`.

;T;0;;;I"assert_instance_of;F;I"Minitest::Assertions;T;[o;;I",untyped cls, untyped obj, ?untyped? msg;T;I"untyped;To;;I"-Fails unless `obj` is a kind of `cls`.

;T;0;;;I"assert_kind_of;F;I"Minitest::Assertions;T;[o;;I",untyped cls, untyped obj, ?untyped? msg;T;I"untyped;To;;I")Fails unless `matcher` `=~` `obj`.

;T;0;;;I"assert_match;F;I"Minitest::Assertions;T;[o;;I"0untyped matcher, untyped obj, ?untyped? msg;T;I"untyped;To;;I" Fails unless `obj` is nil

;T;0;;;I"assert_nil;F;I"Minitest::Assertions;T;[o;;I"untyped obj, ?untyped? msg;T;I"untyped;To;;I"LFor testing with binary operators. Eg:

    assert_operator 5, :<=, 4

;T;0;;;I"assert_operator;F;I"Minitest::Assertions;T;[o;;I"7untyped o1, untyped op, ?untyped o2, ?untyped? msg;T;I"untyped;To;;I"WFails if stdout or stderr do not output the expected results. Pass in nil if
you don't care about that streams output. Pass in "" if you require it to be
silent. Pass in a regexp if you want to pattern match.

    assert_output(/hey/) { method_with_output }

NOTE: this uses #capture_io, not #capture_subprocess_io.

See also: #assert_silent

;T;0;;;I"assert_output;F;I"Minitest::Assertions;T;[o;;I"'?untyped? stdout, ?untyped? stderr;T;I"untyped;To;;I""Fails unless `path` exists.

;T;0;;;I"assert_path_exists;F;I"Minitest::Assertions;T;[o;;I" untyped path, ?untyped? msg;T;I"untyped;To;;I"¥For testing with predicates. Eg:

    assert_predicate str, :empty?

This is really meant for specs and is front-ended by assert_operator:

    str.must_be :empty?

;T;0;;;I"assert_predicate;F;I"Minitest::Assertions;T;[o;;I"*untyped o1, untyped op, ?untyped? msg;T;I"untyped;To;;I"rFails unless the block raises one of `exp`. Returns the exception matched so
you can check the message, attributes, etc.

`exp` takes an optional message on the end to help explain failures and
defaults to StandardError if no exception class is passed. Eg:

    assert_raises(CustomError) { method_with_custom_error }

With custom error message:

    assert_raises(CustomError, 'This should have raised CustomError') { method_with_custom_error }

Using the returned object:

    error = assert_raises(CustomError) do
      raise CustomError, 'This is really bad'
    end

    assert_equal 'This is really bad', error.message

;T;0;;;I"assert_raises;F;I"Minitest::Assertions;T;[o;;I"*untyped exp;T;I"untyped;To;;I"-Fails unless `obj` responds to `meth`.

;T;0;;;I"assert_respond_to;F;I"Minitest::Assertions;T;[o;;I"-untyped obj, untyped meth, ?untyped? msg;T;I"untyped;To;;I"/Fails unless `exp` and `act` are #equal?

;T;0;;;I"assert_same;F;I"Minitest::Assertions;T;[o;;I",untyped exp, untyped act, ?untyped? msg;T;I"untyped;To;;I"c`send_ary` is a receiver, message and arguments.

Fails unless the call returns a true value

;T;0;;;I"assert_send;F;I"Minitest::Assertions;T;[o;;I""untyped send_ary, ?untyped? m;T;I"untyped;To;;I"YFails if the block outputs anything to stderr or stdout.

See also: #assert_output

;T;0;;;I"assert_silent;F;I"Minitest::Assertions;T;[o;;I" ;F;I"untyped;To;;I"*Fails unless the block throws `sym`

;T;0;;;I"assert_throws;F;I"Minitest::Assertions;T;[o;;I"untyped sym, ?untyped? msg;T;I"untyped;To;;I"HCaptures $stdout and $stderr into strings:

    out, err = capture_io do
      puts "Some info"
      warn "You did a bad thing"
    end

    assert_match %r%info%, out
    assert_match %r%bad%, err

NOTE: For efficiency, this method uses StringIO and does not capture IO for
subprocesses. Use #capture_subprocess_io for that.

;T;0;;;I"capture_io;F;I"Minitest::Assertions;T;[o;;I" ;F;I"untyped;To;;I"¨Captures $stdout and $stderr into strings, using Tempfile to ensure that
subprocess IO is captured as well.

    out, err = capture_subprocess_io do
      system "echo Some info"
      system "echo You did a bad thing 1>&2"
    end

    assert_match %r%info%, out
    assert_match %r%bad%, err

NOTE: This method is approximately 10x slower than #capture_io so only use it
when you need to test the output of a subprocess.

;T;0;;;I"capture_subprocess_io;F;I"Minitest::Assertions;T;[o;;I" ;F;I"untyped;To;;I"(Returns details for exception `e`

;T;0;;;I"exception_details;F;I"Minitest::Assertions;T;[o;;I"untyped e, untyped msg;T;I"untyped;To;;I"¶Fails after a given date (in the local time zone). This allows you to put
time-bombs in your tests if you need to keep something around until a later
date lest you forget about it.

;T;0;;;I"fail_after;F;I"Minitest::Assertions;T;[o;;I"1untyped y, untyped m, untyped d, untyped msg;T;I"untyped | nil;To;;I"Fails with `msg`.

;T;0;;;I"
flunk;F;I"Minitest::Assertions;T;[o;;I"?untyped? msg;T;I"untyped;To;;I"LReturns a proc that will output `msg` along with the default message.

;T;0;;;I"message;F;I"Minitest::Assertions;T;[o;;I"$?untyped? msg, ?untyped? ending;T;I"untyped;To;;I"#used for counting assertions

;T;0;;;I"	pass;F;I"Minitest::Assertions;T;[o;;I"?untyped? _msg;T;I"untyped;To;;I"!Fails if `test` is truthy.

;T;0;;;I"refute;F;I"Minitest::Assertions;T;[o;;I" untyped test, ?untyped? msg;T;I"untyped;To;;I"Fails if `obj` is empty.

;T;0;;;I"refute_empty;F;I"Minitest::Assertions;T;[o;;I"untyped obj, ?untyped? msg;T;I"untyped;To;;I">Fails if `exp == act`.

For floats use refute_in_delta.

;T;0;;;I"refute_equal;F;I"Minitest::Assertions;T;[o;;I",untyped exp, untyped act, ?untyped? msg;T;I"untyped;To;;I"tFor comparing Floats.  Fails if `exp` is within `delta` of `act`.

    refute_in_delta Math::PI, (22.0 / 7.0)

;T;0;;;I"refute_in_delta;F;I"Minitest::Assertions;T;[o;;I"<untyped exp, untyped act, ?::Float delta, ?untyped? msg;T;I"untyped;To;;I"aFor comparing Floats.  Fails if `exp` and `act` have a relative error less
than `epsilon`.

;T;0;;;I"refute_in_epsilon;F;I"Minitest::Assertions;T;[o;;I":untyped a, untyped b, ?::Float epsilon, ?untyped? msg;T;I"untyped;To;;I",Fails if `collection` includes `obj`.

;T;0;;;I"refute_includes;F;I"Minitest::Assertions;T;[o;;I"3untyped collection, untyped obj, ?untyped? msg;T;I"untyped;To;;I".Fails if `obj` is an instance of `cls`.

;T;0;;;I"refute_instance_of;F;I"Minitest::Assertions;T;[o;;I",untyped cls, untyped obj, ?untyped? msg;T;I"untyped;To;;I")Fails if `obj` is a kind of `cls`.

;T;0;;;I"refute_kind_of;F;I"Minitest::Assertions;T;[o;;I",untyped cls, untyped obj, ?untyped? msg;T;I"untyped;To;;I"%Fails if `matcher` `=~` `obj`.

;T;0;;;I"refute_match;F;I"Minitest::Assertions;T;[o;;I"0untyped matcher, untyped obj, ?untyped? msg;T;I"untyped;To;;I"Fails if `obj` is nil.

;T;0;;;I"refute_nil;F;I"Minitest::Assertions;T;[o;;I"untyped obj, ?untyped? msg;T;I"untyped;To;;I"wFails if `o1` is not `op` `o2`. Eg:

    refute_operator 1, :>, 2 #=> pass
    refute_operator 1, :<, 2 #=> fail

;T;0;;;I"refute_operator;F;I"Minitest::Assertions;T;[o;;I"7untyped o1, untyped op, ?untyped o2, ?untyped? msg;T;I"untyped;To;;I"Fails if `path` exists.

;T;0;;;I"refute_path_exists;F;I"Minitest::Assertions;T;[o;;I" untyped path, ?untyped? msg;T;I"untyped;To;;I"¡For testing with predicates.

    refute_predicate str, :empty?

This is really meant for specs and is front-ended by refute_operator:

    str.wont_be :empty?

;T;0;;;I"refute_predicate;F;I"Minitest::Assertions;T;[o;;I"*untyped o1, untyped op, ?untyped? msg;T;I"untyped;To;;I"5Fails if `obj` responds to the message `meth`.

;T;0;;;I"refute_respond_to;F;I"Minitest::Assertions;T;[o;;I"-untyped obj, untyped meth, ?untyped? msg;T;I"untyped;To;;I"@Fails if `exp` is the same (by object identity) as `act`.

;T;0;;;I"refute_same;F;I"Minitest::Assertions;T;[o;;I",untyped exp, untyped act, ?untyped? msg;T;I"untyped;To;;I"‰Skips the current run. If run in verbose-mode, the skipped run gets listed at
the end of the run but doesn't cause a failure exit code.

;T;0;;;I"	skip;F;I"Minitest::Assertions;T;[o;;I"?untyped? msg, ?untyped bt;T;I"untyped;To;;I"ÇSkips the current run until a given date (in the local time zone). This allows
you to put some fixes on hold until a later date, but still holds you
accountable and prevents you from forgetting it.

;T;0;;;I"skip_until;F;I"Minitest::Assertions;T;[o;;I"1untyped y, untyped m, untyped d, untyped msg;T;I"untyped;To;;I"6Was this testcase skipped? Meant for #teardown.

;T;0;;;I"skipped?;F;I"Minitest::Assertions;T;[o;;I" ;F;I"untyped;To;;I"/Assert that the mock verifies correctly.

;T;0;;;I"assert_mock;F;I"Minitest::Assertions;T;[o;;I"untyped mock;T;I"untyped;To; ;I"SThe standard backtrace filter for minitest.

See Minitest.backtrace_filter=.

;T;0;	I"Minitest::BacktraceFilter;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"dFilter `bt` to something useful. Returns the whole thing if $DEBUG (ruby) or
$MT_DEBUG (env).

;T;0;;;I"filter;F;I"Minitest::BacktraceFilter;T;[o;;I"untyped bt;T;I"$Array["No backtrace"] | untyped;To; ;I"/The spec version of Minitest::Benchmark.

;T;0;	I"Minitest::BenchSpec;T;
[ ;[I")Minitest::Spec::DSL::InstanceMethods;T;0;[ ;[ ;0;I"Minitest::Benchmark;To;;I"This is used to define a new benchmark method. You usually don't use this
directly and is intended for those needing to write new performance curve fits
(eg: you need a specific polynomial fit).

See ::bench_performance_linear for an example of how to use this.

;T;0;;;I"
bench;F;I"Minitest::BenchSpec;T;[o;;I"untyped name;T;I"untyped;To;;I"©Specifies the ranges used for benchmarking for that class.

    bench_range do
      bench_exp(2, 16, 2)
    end

See Minitest::Benchmark#bench_range for more details.

;T;0;;;I"bench_range;F;I"Minitest::BenchSpec;T;[o;;I" ;F;I"untyped;To;;I"ÔCreate a benchmark that verifies that the performance is linear.

    describe "my class Bench" do
      bench_performance_linear "fast_algorithm", 0.9999 do |n|
        @obj.fast_algorithm(n)
      end
    end

;T;0;;;I"bench_performance_linear;F;I"Minitest::BenchSpec;T;[o;;I"%untyped name, ?::Float threshold;T;I"untyped;To;;I"ÒCreate a benchmark that verifies that the performance is constant.

    describe "my class Bench" do
      bench_performance_constant "zoom_algorithm!" do |n|
        @obj.zoom_algorithm!(n)
      end
    end

;T;0;;;I"bench_performance_constant;F;I"Minitest::BenchSpec;T;[o;;I"%untyped name, ?::Float threshold;T;I"untyped;To;;I"ÌCreate a benchmark that verifies that the performance is exponential.

    describe "my class Bench" do
      bench_performance_exponential "algorithm" do |n|
        @obj.algorithm(n)
      end
    end

;T;0;;;I""bench_performance_exponential;F;I"Minitest::BenchSpec;T;[o;;I"%untyped name, ?::Float threshold;T;I"untyped;To;;I"ÌCreate a benchmark that verifies that the performance is logarithmic.

    describe "my class Bench" do
      bench_performance_logarithmic "algorithm" do |n|
        @obj.algorithm(n)
      end
    end

;T;0;;;I""bench_performance_logarithmic;F;I"Minitest::BenchSpec;T;[o;;I"%untyped name, ?::Float threshold;T;I"untyped;To;;I"ÀCreate a benchmark that verifies that the performance is power.

    describe "my class Bench" do
      bench_performance_power "algorithm" do |n|
        @obj.algorithm(n)
      end
    end

;T;0;;;I"bench_performance_power;F;I"Minitest::BenchSpec;T;[o;;I"%untyped name, ?::Float threshold;T;I"untyped;To; ;I"Subclass Benchmark to create your own benchmark runs. Methods starting with
"bench_" get executed on a per-class.

See Minitest::Assertions

;T;0;	I"Minitest::Benchmark;T;
[ ;[ ;0;[ ;[ ;0;I"Minitest::Test;To;;0;0;;;I"io;F;I"Minitest::Benchmark;T;[o;;I" ;F;I"untyped;To;;0;0;;;I"io;F;I"Minitest::Benchmark;T;[o;;I" ;F;I"untyped;To;;0;0;;;I"run;F;I"Minitest::Benchmark;T;[o;;I"8untyped reporter, ?::Hash[untyped, untyped] options;T;I"untyped;To;;0;0;;;I"runnable_methods;F;I"Minitest::Benchmark;T;[o;;I" ;F;I"untyped;To;;I"ˆReturns a set of ranges stepped exponentially from `min` to `max` by powers of
`base`. Eg:

    bench_exp(2, 16, 2) # => [2, 4, 8, 16]

;T;0;;;I"bench_exp;F;I"Minitest::Benchmark;T;[o;;I".untyped min, untyped max, ?::Integer base;T;I"untyped;To;;I"}Returns a set of ranges stepped linearly from `min` to `max` by `step`. Eg:

    bench_linear(20, 40, 10) # => [20, 30, 40]

;T;0;;;I"bench_linear;F;I"Minitest::Benchmark;T;[o;;I".untyped min, untyped max, ?::Integer step;T;I"untyped;To;;I"àSpecifies the ranges used for benchmarking for that class. Defaults to
exponential growth from 1 to 10k by powers of 10. Override if you need
different ranges for your benchmarks.

See also: ::bench_exp and ::bench_linear.

;T;0;;;I"bench_range;F;I"Minitest::Benchmark;T;[o;;I" ;F;I"untyped;To;;I"ÆRuns the given `work`, gathering the times of each run. Range and times are
then passed to a given `validation` proc. Outputs the benchmark name and times
in tab-separated format, making it easy to paste into a spreadsheet for
graphing or further analysis.

Ranges are specified by ::bench_range.

Eg:

    def bench_algorithm
      validation = proc { |x, y| ... }
      assert_performance validation do |n|
        @obj.algorithm(n)
      end
    end

;T;0;;;I"assert_performance;F;I"Minitest::Benchmark;T;[o;;I"untyped validation;T;I"untyped;To;;I"ŒRuns the given `work` and asserts that the times gathered fit to match a
constant rate (eg, linear slope == 0) within a given `threshold`. Note:
because we're testing for a slope of 0, R^2 is not a good determining factor
for the fit, so the threshold is applied against the slope itself. As such,
you probably want to tighten it from the default.

See
https://www.graphpad.com/guides/prism/8/curve-fitting/reg_intepretingnonlinr2.
htm for more details.

Fit is calculated by #fit_linear.

Ranges are specified by ::bench_range.

Eg:

    def bench_algorithm
      assert_performance_constant 0.9999 do |n|
        @obj.algorithm(n)
      end
    end

;T;0;;;I" assert_performance_constant;F;I"Minitest::Benchmark;T;[o;;I"?::Float threshold;T;I"untyped;To;;I"KRuns the given `work` and asserts that the times gathered fit to match a
exponential curve within a given error `threshold`.

Fit is calculated by #fit_exponential.

Ranges are specified by ::bench_range.

Eg:

    def bench_algorithm
      assert_performance_exponential 0.9999 do |n|
        @obj.algorithm(n)
      end
    end

;T;0;;;I"#assert_performance_exponential;F;I"Minitest::Benchmark;T;[o;;I"?::Float threshold;T;I"untyped;To;;I"KRuns the given `work` and asserts that the times gathered fit to match a
logarithmic curve within a given error `threshold`.

Fit is calculated by #fit_logarithmic.

Ranges are specified by ::bench_range.

Eg:

    def bench_algorithm
      assert_performance_logarithmic 0.9999 do |n|
        @obj.algorithm(n)
      end
    end

;T;0;;;I"#assert_performance_logarithmic;F;I"Minitest::Benchmark;T;[o;;I"?::Float threshold;T;I"untyped;To;;I"=Runs the given `work` and asserts that the times gathered fit to match a
straight line within a given error `threshold`.

Fit is calculated by #fit_linear.

Ranges are specified by ::bench_range.

Eg:

    def bench_algorithm
      assert_performance_linear 0.9999 do |n|
        @obj.algorithm(n)
      end
    end

;T;0;;;I"assert_performance_linear;F;I"Minitest::Benchmark;T;[o;;I"?::Float threshold;T;I"untyped;To;;I"<Runs the given `work` and asserts that the times gathered curve fit to match a
power curve within a given error `threshold`.

Fit is calculated by #fit_power.

Ranges are specified by ::bench_range.

Eg:

    def bench_algorithm
      assert_performance_power 0.9999 do |x|
        @obj.algorithm
      end
    end

;T;0;;;I"assert_performance_power;F;I"Minitest::Benchmark;T;[o;;I"?::Float threshold;T;I"untyped;To;;I"ƒTakes an array of x/y pairs and calculates the general R^2 value.

See: http://en.wikipedia.org/wiki/Coefficient_of_determination

;T;0;;;I"fit_error;F;I"Minitest::Benchmark;T;[o;;I"untyped xys;T;I"untyped;To;;I"žTo fit a functional form: y = ae^(bx).

Takes x and y values and returns [a, b, r^2].

See: http://mathworld.wolfram.com/LeastSquaresFittingExponential.html

;T;0;;;I"fit_exponential;F;I"Minitest::Benchmark;T;[o;;I"untyped xs, untyped ys;T;I"untyped;To;;I"¢To fit a functional form: y = a + b*ln(x).

Takes x and y values and returns [a, b, r^2].

See: http://mathworld.wolfram.com/LeastSquaresFittingLogarithmic.html

;T;0;;;I"fit_logarithmic;F;I"Minitest::Benchmark;T;[o;;I"untyped xs, untyped ys;T;I"untyped;To;;I"ŽFits the functional form: a + bx.

Takes x and y values and returns [a, b, r^2].

See: http://mathworld.wolfram.com/LeastSquaresFitting.html

;T;0;;;I"fit_linear;F;I"Minitest::Benchmark;T;[o;;I"untyped xs, untyped ys;T;I"untyped;To;;I"˜To fit a functional form: y = ax^b.

Takes x and y values and returns [a, b, r^2].

See: http://mathworld.wolfram.com/LeastSquaresFittingPowerLaw.html

;T;0;;;I"fit_power;F;I"Minitest::Benchmark;T;[o;;I"untyped xs, untyped ys;T;I"untyped;To;;I"ÉEnumerates over `enum` mapping `block` if given, returning the sum of the
result. Eg:

    sigma([1, 2, 3])                # => 1 + 2 + 3 => 6
    sigma([1, 2, 3]) { |n| n ** 2 } # => 1 + 4 + 9 => 14

;T;0;;;I"
sigma;F;I"Minitest::Benchmark;T;[o;;I"untyped enum;T;I"untyped;To;;I"uReturns a proc that calls the specified fit method and asserts that the error
is within a tolerable threshold.

;T;0;;;I"validation_for_fit;F;I"Minitest::Benchmark;T;[o;;I"#untyped msg, untyped threshold;T;I"untyped;To; ;I"-Dispatch to multiple reporters as one.

;T;0;	I" Minitest::CompositeReporter;T;
[ ;[ ;0;[ ;[ ;0;I"Minitest::AbstractReporter;To;;0;0;;;I"initialize;F;I" Minitest::CompositeReporter;T;[o;;I"*untyped reporters;T;I"	void;To;;0;0;;;I"io;F;I" Minitest::CompositeReporter;T;[o;;I" ;F;I"untyped;To;;I"'Add another reporter to the mix.

;T;0;;;I"<<;F;I" Minitest::CompositeReporter;T;[o;;I"untyped reporter;T;I"untyped;To;;0;0;;;I"passed?;F;I" Minitest::CompositeReporter;T;[o;;I" ;F;I"untyped;To;;0;0;;;I"
start;F;I" Minitest::CompositeReporter;T;[o;;I" ;F;I"untyped;To;;0;0;;;I"prerecord;F;I" Minitest::CompositeReporter;T;[o;;I" untyped klass, untyped name;T;I"untyped;To;;0;0;;;I"record;F;I" Minitest::CompositeReporter;T;[o;;I"untyped result;T;I"untyped;To;;0;0;;;I"report;F;I" Minitest::CompositeReporter;T;[o;;I" ;F;I"untyped;To; ;0;0;	I"Minitest::Expectation;T;
[ ;[ ;0;[ ;[ ;0;I"Struct;To;;I"ºIt's where you hide your "assertions".

Please note, because of the way that expectations are implemented, all
expectations (eg must_equal) are dependent upon a thread local variable
`:current_spec`. If your specs rely on mixing threads into the specs
themselves, you're better off using assertions or the new _(value) wrapper.
For example:

    it "should still work in threads" do
      my_threaded_thingy do
        (1+1).must_equal 2                  # bad
        assert_equal 2, 1+1                 # good
        _(1 + 1).must_equal 2               # good
        value(1 + 1).must_equal 2           # good, also #expect
        _ { 1 + "1" }.must_raise TypeError  # good
      end
    end

;T;0;	I"Minitest::Expectations;T;
[ ;[ ;0;[ ;[ o;;I"ƒProvides a simple set of guards that you can use in your tests to skip
execution if it is not applicable. These methods are mixed into Test as both
instance and class methods so you can use them inside or outside of the test
methods.

    def test_something_for_mri
      skip "bug 1234"  if jruby?
      # ...
    end

    if windows? then
      # ... lots of test methods ...
    end

;T;0;	I"Minitest::Guard;T;
[ ;[ ;0;[ ;[ o;;I" Is this running on jruby?

;T;0;;;I"jruby?;F;I"Minitest::Guard;T;[o;;I"?untyped platform;T;I"untyped;To;;I"!Is this running on maglev?

;T;0;;;I"maglev?;F;I"Minitest::Guard;T;[o;;I"?untyped platform;T;I"untyped;To;;I"Is this running on mri?

;T;0;;;I"	mri?;F;I"Minitest::Guard;T;[o;;I"?untyped platform;T;I"untyped;To;;I" Is this running on macOS?

;T;0;;;I"	osx?;F;I"Minitest::Guard;T;[o;;I"?untyped platform;T;I"untyped;To;;I"#Is this running on rubinius?

;T;0;;;I"rubinius?;F;I"Minitest::Guard;T;[o;;I"?untyped platform;T;I"untyped;To;;I""Is this running on windows?

;T;0;;;I"windows?;F;I"Minitest::Guard;T;[o;;I"?untyped platform;T;I"untyped;To; ;I"ZA simple and clean mock object framework.

All mock objects are an instance of Mock

;T;0;	I"Minitest::Mock;T;
[ ;[ ;0;[ ;[ ;0;0o;;0;0;;;I"initialize;F;I"Minitest::Mock;T;[o;;I"?untyped? delegator;T;I"	void;To;;I"’Expect that method `name` is called, optionally with `args` or a `blk`, and
returns `retval`.

    @mock.expect(:meaning_of_life, 42)
    @mock.meaning_of_life # => 42

    @mock.expect(:do_something_with, true, [some_obj, true])
    @mock.do_something_with(some_obj, true) # => true

    @mock.expect(:do_something_else, true) do |a1, a2|
      a1 == "buggs" && a2 == :bunny
    end

`args` is compared to the expected args using case equality (ie, the '==='
operator), allowing for less specific expectations.

    @mock.expect(:uses_any_string, true, [String])
    @mock.uses_any_string("foo") # => true
    @mock.verify  # => true

    @mock.expect(:uses_one_string, true, ["foo"])
    @mock.uses_one_string("bar") # => raises MockExpectationError

If a method will be called multiple times, specify a new expect for each one.
They will be used in the order you define them.

    @mock.expect(:ordinal_increment, 'first')
    @mock.expect(:ordinal_increment, 'second')

    @mock.ordinal_increment # => 'first'
    @mock.ordinal_increment # => 'second'
    @mock.ordinal_increment # => raises MockExpectationError "No more expects available for :ordinal_increment"

;T;0;;;I"expect;F;I"Minitest::Mock;T;[o;;I"0untyped name, untyped retval, ?untyped args;T;I"	self;To;;0;0;;;I"__call;F;I"Minitest::Mock;T;[o;;I"untyped name, untyped data;T;I"untyped;To;;I"Verify that all methods were called as expected. Raises `MockExpectationError`
if the mock object was not called as expected.

;T;0;;;I"verify;F;I"Minitest::Mock;T;[o;;I" ;F;I"	true;Fo;;0;0;;;I"method_missing;F;I"Minitest::Mock;T;[o;;I"untyped sym, *untyped args;T;I"untyped;To;;0;0;;;I"respond_to?;F;I"Minitest::Mock;T;[o;;I"'untyped sym, ?bool include_private;T;I"true | untyped;Fo; ;I"9The engine used to run multiple tests in parallel.

;T;0;	I"!Minitest::Parallel::Executor;T;
[ ;[ ;0;[ ;[ ;0;0o;;I">Create a parallel test executor of with `size` workers.

;T;0;;;I"initialize;F;I"!Minitest::Parallel::Executor;T;[o;;I"untyped size;T;I"	void;To;;I"Start the executor

;T;0;;;I"
start;F;I"!Minitest::Parallel::Executor;T;[o;;I" ;F;I"untyped;To;;I"Add a job to the queue

;T;0;;;I"<<;F;I"!Minitest::Parallel::Executor;T;[o;;I"untyped work;T;I"untyped;To;;I"Shuts down the pool of workers by signalling them to quit and waiting for them
all to finish what they're currently working on.

;T;0;;;I"shutdown;F;I"!Minitest::Parallel::Executor;T;[o;;I" ;F;I"untyped;To;;0;0;	I"+Minitest::Parallel::Test::ClassMethods;T;
[ ;[ ;0;[ ;[ o;;I":nodoc:
;T;0;;;I"run_one_method;F;I"+Minitest::Parallel::Test::ClassMethods;T;[o;;I"9untyped klass, untyped method_name, untyped reporter;T;I"untyped;To;;0;0;;;I"test_order;F;I"+Minitest::Parallel::Test::ClassMethods;T;[o;;I" ;F;I":parallel;Fo;;0;0;	I"Minitest::Parallel::Test;T;
[ ;[ ;0;[ ;[ o;;0;0;;;I"_synchronize;F;I"Minitest::Parallel::Test;T;[o;;I" ;F;I"untyped;To;;0;0;	I"Minitest::Parallel;T;
[ ;[ ;0;[ ;[ o; ;I"Show your testing pride!

;T;0;	I"Minitest::PrideIO;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"OActivate the pride plugin. Called from both -p option and minitest/pride

;T;0;;;I"pride!;F;I"Minitest::PrideIO;T;[o;;I" ;F;I"untyped;To;;I"(Are we showing our testing pride?

;T;0;;;I"pride?;F;I"Minitest::PrideIO;T;[o;;I" ;F;I"untyped;To;;0;0;;;I"initialize;F;I"Minitest::PrideIO;T;[o;;I"untyped io;T;I"	void;To;;I")Wrap print to colorize the output.

;T;0;;;I"
print;F;I"Minitest::PrideIO;T;[o;;I"untyped o;T;I"untyped;To;;0;0;;;I"	puts;F;I"Minitest::PrideIO;T;[o;;I"*untyped o;T;I"untyped;To;;I"Color a string.

;T;0;;;I"
pride;F;I"Minitest::PrideIO;T;[o;;I"untyped string;T;I"String;To;;0;0;;;I"method_missing;F;I"Minitest::PrideIO;T;[o;;I"untyped msg, *untyped args;T;I"untyped;To; ;I"\If you thought the PrideIO was colorful...

(Inspired by lolcat, but with clean math)

;T;0;	I"Minitest::PrideLOL;T;
[ ;[ ;0;[ ;[ ;0;I"Minitest::PrideIO;To;;0;0;;;I"initialize;F;I"Minitest::PrideLOL;T;[o;;I"untyped io;T;I"	void;To;;I"2Make the string even more colorful. Damnit.

;T;0;;;I"
pride;F;I"Minitest::PrideLOL;T;[o;;I"untyped string;T;I"String;To; ;I"A very simple reporter that prints the "dots" during the run.

This is added to the top-level CompositeReporter at the start of the run. If
you want to change the output of minitest via a plugin, pull this out of the
composite and replace it with your own.

;T;0;	I"Minitest::ProgressReporter;T;
[ ;[ ;0;[ ;[ ;0;I"Minitest::Reporter;To;;0;0;;;I"prerecord;F;I"Minitest::ProgressReporter;T;[o;;I" untyped klass, untyped name;T;I"untyped | nil;To;;0;0;;;I"record;F;I"Minitest::ProgressReporter;T;[o;;I"untyped result;T;I"untyped;To;;I"iShared code for anything that can get passed to a Reporter. See Minitest::Test
& Minitest::Result.

;T;0;	I"Minitest::Reportable;T;
[ ;[ ;0;[ ;[ o;;I"|Did this run pass?

Note: skipped runs are not considered passing, but they don't cause the
process to exit non-zero.

;T;0;;;I"passed?;F;I"Minitest::Reportable;T;[o;;I" ;F;I"untyped;To;;I"\The location identifier of this test. Depends on a method existing called
class_name.

;T;0;;;I"location;F;I"Minitest::Reportable;T;[o;;I" ;F;I"String;To;;0;0;;;I"class_name;F;I"Minitest::Reportable;T;[o;;I" ;F;I"untyped;To;;I"?Returns ".", "F", or "E" based on the result of the run.

;T;0;;;I"result_code;F;I"Minitest::Reportable;T;[o;;I" ;F;I"untyped;To;;I"Was this run skipped?

;T;0;;;I"skipped?;F;I"Minitest::Reportable;T;[o;;I" ;F;I"untyped;To;;I"Did this run error?

;T;0;;;I"error?;F;I"Minitest::Reportable;T;[o;;I" ;F;I"untyped;To; ;0;0;	I"Minitest::Reporter;T;
[ ;[ ;0;[ ;[ ;0;I"Minitest::AbstractReporter;To;;0;0;;;I"initialize;F;I"Minitest::Reporter;T;[o;;I"3?untyped io, ?::Hash[untyped, untyped] options;T;I"	void;To; ;I"%This represents a test result in a clean way that can be marshalled over a
wire. Tests can do anything they want to the test instance and can create
conditions that cause Marshal.dump to blow up. By using Result.from(a_test)
you can be reasonably sure that the test result can be marshalled.

;T;0;	I"Minitest::Result;T;
[ ;[I"Minitest::Reportable;T;0;[ ;[ ;0;I"Minitest::Runnable;To;;I"9Create a new test result from a Runnable instance.

;T;0;;;I"	from;F;I"Minitest::Result;T;[o;;I"untyped runnable;T;I"untyped;To;;0;0;;;I"class_name;F;I"Minitest::Result;T;[o;;I" ;F;I"untyped;To;;0;0;;;I"	to_s;F;I"Minitest::Result;T;[o;;I" ;F;I"untyped;To; ;I"±Represents anything "runnable", like Test, Spec, Benchmark, or whatever you
can dream up.

Subclasses of this are automatically registered and available in
Runnable.runnables.

;T;0;	I"Minitest::Runnable;T;
[ ;[ ;0;[ ;[ ;0;0o;;0;0;;;I"time_it;F;I"Minitest::Runnable;T;[o;;I" ;F;I"untyped;To;;I"Name of the run.

;T;0;;;I"	name;F;I"Minitest::Runnable;T;[o;;I" ;F;I"untyped;To;;I"Set the name of the run.

;T;0;;;I"
name=;F;I"Minitest::Runnable;T;[o;;I"untyped o;T;I"untyped;To;;I">Returns all instance methods matching the pattern `re`.

;T;0;;;I"methods_matching;F;I"Minitest::Runnable;T;[o;;I"untyped re;T;I"untyped;To;;0;0;;;I"
reset;F;I"Minitest::Runnable;T;[o;;I" ;F;I"untyped;To;;I"Responsible for running all runnable methods in a given class, each in its own
instance. Each instance is passed to the reporter to record.

;T;0;;;I"run;F;I"Minitest::Runnable;T;[o;;I"8untyped reporter, ?::Hash[untyped, untyped] options;T;I"nil | untyped;To;;I"øRuns a single method and has the reporter record the result. This was
considered internal API but is factored out of run so that subclasses can
specialize the running of an individual test. See
Minitest::ParallelTest::ClassMethods for an example.

;T;0;;;I"run_one_method;F;I"Minitest::Runnable;T;[o;;I"9untyped klass, untyped method_name, untyped reporter;T;I"untyped;To;;0;0;;;I"with_info_handler;F;I"Minitest::Runnable;T;[o;;I"untyped reporter;T;I"untyped;To;;0;0;;;I"on_signal;F;I"Minitest::Runnable;T;[o;;I"!untyped name, untyped action;T;I"untyped;To;;I"|Each subclass of Runnable is responsible for overriding this method to return
all runnable methods. See #methods_matching.

;T;0;;;I"runnable_methods;F;I"Minitest::Runnable;T;[o;;I" ;F;I"untyped;To;;I"*Returns all subclasses of Runnable.

;T;0;;;I"runnables;F;I"Minitest::Runnable;T;[o;;I" ;F;I"untyped;To;;0;0;;;I"marshal_dump;F;I"Minitest::Runnable;T;[o;;I" ;F;I"Array[untyped];To;;0;0;;;I"marshal_load;F;I"Minitest::Runnable;T;[o;;I"untyped ary;T;I"untyped;To;;0;0;;;I"failure;F;I"Minitest::Runnable;T;[o;;I" ;F;I"untyped;To;;0;0;;;I"initialize;F;I"Minitest::Runnable;T;[o;;I"untyped name;T;I"	void;To;;I"2Runs a single method. Needs to return self.

;T;0;;;I"run;F;I"Minitest::Runnable;T;[o;;I" ;F;I"untyped;To;;I"|Did this run pass?

Note: skipped runs are not considered passing, but they don't cause the
process to exit non-zero.

;T;0;;;I"passed?;F;I"Minitest::Runnable;T;[o;;I" ;F;I"untyped;To;;I"vReturns a single character string to print based on the result of the run. One
of `"."`, `"F"`, `"E"` or `"S"`.

;T;0;;;I"result_code;F;I"Minitest::Runnable;T;[o;;I" ;F;I"untyped;To;;I"?Was this run skipped? See #passed? for more information.

;T;0;;;I"skipped?;F;I"Minitest::Runnable;T;[o;;I" ;F;I"untyped;To;;0;0;;;I"inherited;F;I"Minitest::Runnable;T;[o;;I"untyped klass;T;I"untyped;To; ;I",Assertion raised when skipping a run.

;T;0;	I"Minitest::Skip;T;
[ ;[ ;0;[ ;[ ;0;I"Minitest::Assertion;To;;0;0;;;I"result_label;F;I"Minitest::Skip;T;[o;;I" ;F;I""Skipped";To;;I"#Rdoc... why are you so dumb?

;T;0;	I")Minitest::Spec::DSL::InstanceMethods;T;
[ ;[ ;0;[ ;[ o;;I"oTakes a value or a block and returns a value monad that has all of
Expectations methods available to it.

    _(1 + 1).must_equal 2

And for blocks:

    _ { 1 + "1" }.must_raise TypeError

This method of expectation-based testing is preferable to straight-expectation
methods (on Object) because it stores its test context, bypassing our hacky
use of thread-local variables.

NOTE: At some point, the methods on Object will be deprecated and then
removed.

It is also aliased to #value and #expect for your aesthetic pleasure:

         _(1 + 1).must_equal 2
     value(1 + 1).must_equal 2
    expect(1 + 1).must_equal 2

;T;0;;;I"_;F;I")Minitest::Spec::DSL::InstanceMethods;T;[o;;I"?untyped? value;T;I"untyped;To;;0;0;;;I"before_setup;F;I")Minitest::Spec::DSL::InstanceMethods;T;[o;;I" ;F;I"untyped;To;;I"EOh look! A Minitest::Spec::DSL module! Eat your heart out DHH.

;T;0;	I"Minitest::Spec::DSL;T;
[ ;[ ;0;[ ;[ o;;I"‰Register a new type of spec that matches the spec's description. This method
can take either a Regexp and a spec class or a spec class and a block that
takes the description and returns true if it matches.

Eg:

    register_spec_type(/Controller$/, Minitest::Spec::Rails)

or:

    register_spec_type(Minitest::Spec::RailsModel) do |desc|
      desc.superclass == ActiveRecord::Base
    end

;T;0;;;I"register_spec_type;F;I"Minitest::Spec::DSL;T;[o;;I"*untyped args;T;I"untyped;To;;I"Figure out the spec class to use based on a spec's description. Eg:

    spec_type("BlahController") # => Minitest::Spec::Rails

;T;0;;;I"spec_type;F;I"Minitest::Spec::DSL;T;[o;;I"&untyped desc, *untyped additional;T;I"untyped;To;;0;0;;;I"describe_stack;F;I"Minitest::Spec::DSL;T;[o;;I" ;F;I"untyped;To;;0;0;;;I"children;F;I"Minitest::Spec::DSL;T;[o;;I" ;F;I"untyped;To;;0;0;;;I"nuke_test_methods!;F;I"Minitest::Spec::DSL;T;[o;;I" ;F;I"untyped;To;;I"«Define a 'before' action. Inherits the way normal methods should.

NOTE: `type` is ignored and is only there to make porting easier.

Equivalent to Minitest::Test#setup.

;T;0;;;I"before;F;I"Minitest::Spec::DSL;T;[o;;I"?untyped? _type;T;I"untyped;To;;I"®Define an 'after' action. Inherits the way normal methods should.

NOTE: `type` is ignored and is only there to make porting easier.

Equivalent to Minitest::Test#teardown.

;T;0;;;I"
after;F;I"Minitest::Spec::DSL;T;[o;;I"?untyped? _type;T;I"untyped;To;;I"ÄDefine an expectation with name `desc`. Name gets morphed to a proper test
method name. For some freakish reason, people who write specs don't like class
inheritance, so this goes way out of its way to make sure that expectations
aren't inherited.

This is also aliased to #specify and doesn't require a `desc` arg.

Hint: If you *do* want inheritance, use minitest/test. You can mix and match
between assertions and expectations as much as you want.

;T;0;;;I"it;F;I"Minitest::Spec::DSL;T;[o;;I"?::String desc;T;I"untyped;To;;I"sEssentially, define an accessor for `name` with `block`.

Why use let instead of def? I honestly don't know.

;T;0;;;I"let;F;I"Minitest::Spec::DSL;T;[o;;I"untyped name;T;I"untyped;To;;I"kAnother lazy man's accessor generator. Made even more lazy by setting the name
for you to `subject`.

;T;0;;;I"subject;F;I"Minitest::Spec::DSL;T;[o;;I" ;F;I"untyped;To;;0;0;;;I"create;F;I"Minitest::Spec::DSL;T;[o;;I"untyped name, untyped desc;T;I"untyped;To;;0;0;;;I"	name;F;I"Minitest::Spec::DSL;T;[o;;I" ;F;I"untyped;To;;0;0;;;I"	to_s;F;I"Minitest::Spec::DSL;T;[o;;I" ;F;I"untyped;To;;0;0;;;I"extended;F;I"Minitest::Spec::DSL;T;[o;;I"untyped obj;T;I"untyped;To; ;I"}Minitest::Spec -- The faster, better, less-magical spec framework!

For a list of expectations, see Minitest::Expectations.

;T;0;	I"Minitest::Spec;T;
[ ;[I")Minitest::Spec::DSL::InstanceMethods;T;0;[ ;[ ;0;I"Minitest::Test;To;;0;0;;;I"current;F;I"Minitest::Spec;T;[o;;I" ;F;I"untyped;To;;0;0;;;I"initialize;F;I"Minitest::Spec;T;[o;;I"untyped name;T;I"	void;To; ;I"A reporter that gathers statistics about a test run. Does not do any IO
because meant to be used as a parent class for a reporter that does.

If you want to create an entirely different type of output (eg, CI, HTML,
etc), this is the place to start.

Example:

    class JenkinsCIReporter < StatisticsReporter
      def report
        super  # Needed to calculate some statistics

        print "<testsuite "
        print "tests='#{count}' "
        print "failures='#{failures}' "
        # Remaining XML...
      end
    end

;T;0;	I"!Minitest::StatisticsReporter;T;
[ ;[ ;0;[ ;[ ;0;I"Minitest::Reporter;To;;0;0;;;I"initialize;F;I"!Minitest::StatisticsReporter;T;[o;;I"3?untyped io, ?::Hash[untyped, untyped] options;T;I"	void;To;;0;0;;;I"passed?;F;I"!Minitest::StatisticsReporter;T;[o;;I" ;F;I"untyped;To;;0;0;;;I"
start;F;I"!Minitest::StatisticsReporter;T;[o;;I" ;F;I"untyped;To;;0;0;;;I"record;F;I"!Minitest::StatisticsReporter;T;[o;;I"untyped result;T;I"untyped;To;;I"(Report on the tracked statistics.

;T;0;;;I"report;F;I"!Minitest::StatisticsReporter;T;[o;;I" ;F;I"untyped;To; ;I"A reporter that prints the header, summary, and failure details at the end of
the run.

This is added to the top-level CompositeReporter at the start of the run. If
you want to change the output of minitest via a plugin, pull this out of the
composite and replace it with your own.

;T;0;	I"Minitest::SummaryReporter;T;
[ ;[ ;0;[ ;[ ;0;I"!Minitest::StatisticsReporter;To;;0;0;;;I"
start;F;I"Minitest::SummaryReporter;T;[o;;I" ;F;I"untyped;To;;0;0;;;I"report;F;I"Minitest::SummaryReporter;T;[o;;I" ;F;I"untyped;To;;0;0;;;I"statistics;F;I"Minitest::SummaryReporter;T;[o;;I" ;F;I"untyped;To;;0;0;;;I"aggregated_results;F;I"Minitest::SummaryReporter;T;[o;;I"untyped io;T;I"untyped;To;;0;0;;;I"	to_s;F;I"Minitest::SummaryReporter;T;[o;;I" ;F;I"untyped;To;;0;0;;;I"summary;F;I"Minitest::SummaryReporter;T;[o;;I" ;F;I"untyped;To;;I" ;T;0;;;I"binary_string;F;I"Minitest::SummaryReporter;T;[o;;I" ;F;I"untyped;To;;I"šProvides before/after hooks for setup and teardown. These are meant for
library writers, NOT for regular test authors. See #before_setup for an
example.

;T;0;	I"#Minitest::Test::LifecycleHooks;T;
[ ;[ ;0;[ ;[ o;;I"ŠRuns before every test, before setup. This hook is meant for libraries to
extend minitest. It is not meant to be used by test developers.

As a simplistic example:

    module MyMinitestPlugin
      def before_setup
        super
        # ... stuff to do before setup is run
      end

      def after_setup
        # ... stuff to do after setup is run
        super
      end

      def before_teardown
        super
        # ... stuff to do before teardown is run
      end

      def after_teardown
        # ... stuff to do after teardown is run
        super
      end
    end

    class MiniTest::Test
      include MyMinitestPlugin
    end

;T;0;;;I"before_setup;F;I"#Minitest::Test::LifecycleHooks;T;[o;;I" ;F;I"nil;To;;I"GRuns before every test. Use this to set up before each test run.

;T;0;;;I"
setup;F;I"#Minitest::Test::LifecycleHooks;T;[o;;I" ;F;I"nil;To;;I"­Runs before every test, after setup. This hook is meant for libraries to
extend minitest. It is not meant to be used by test developers.

See #before_setup for an example.

;T;0;;;I"after_setup;F;I"#Minitest::Test::LifecycleHooks;T;[o;;I" ;F;I"nil;To;;I"°Runs after every test, before teardown. This hook is meant for libraries to
extend minitest. It is not meant to be used by test developers.

See #before_setup for an example.

;T;0;;;I"before_teardown;F;I"#Minitest::Test::LifecycleHooks;T;[o;;I" ;F;I"nil;To;;I"GRuns after every test. Use this to clean up after each test run.

;T;0;;;I"teardown;F;I"#Minitest::Test::LifecycleHooks;T;[o;;I" ;F;I"nil;To;;I"¯Runs after every test, after teardown. This hook is meant for libraries to
extend minitest. It is not meant to be used by test developers.

See #before_setup for an example.

;T;0;;;I"after_teardown;F;I"#Minitest::Test::LifecycleHooks;T;[o;;I" ;F;I"nil;To; ;I"ƒSubclass Test to create your own tests. Typically you'll want a Test subclass
per implementation class.

See Minitest::Assertions

;T;0;	I"Minitest::Test;T;
[ ;[	I"Minitest::Assertions;TI"Minitest::Reportable;TI"#Minitest::Test::LifecycleHooks;TI"Minitest::Guard;T;0;[ ;[ ;0;I"Minitest::Runnable;To;;0;0;;;I"class_name;F;I"Minitest::Test;T;[o;;I" ;F;I"untyped;To;;I"¤Call this at the top of your tests when you absolutely positively need to have
ordered tests. In doing so, you're admitting that you suck and your tests are
weak.

;T;0;;;I"-i_suck_and_my_tests_are_order_dependent!;F;I"Minitest::Test;T;[o;;I" ;F;I"untyped;To;;I"¿Make diffs for this Test use #pretty_inspect so that diff in assert_equal can
have more details. NOTE: this is much slower than the regular inspect but much
more usable for complex objects.

;T;0;;;I"make_my_diffs_pretty!;F;I"Minitest::Test;T;[o;;I" ;F;I"untyped;To;;I"™Call this at the top of your tests when you want to run your tests in
parallel. In doing so, you're admitting that you rule and your tests are
awesome.

;T;0;;;I"parallelize_me!;F;I"Minitest::Test;T;[o;;I" ;F;I"untyped;To;;I"”Returns all instance methods starting with "test_". Based on #test_order, the
methods are either sorted, randomized (default), or run in parallel.

;T;0;;;I"runnable_methods;F;I"Minitest::Test;T;[o;;I" ;F;I"untyped;To;;I"}Defines the order to run tests (:random by default). Override this or use a
convenience method to change it for your tests.

;T;0;;;I"test_order;F;I"Minitest::Test;T;[o;;I" ;F;I":random;Fo;;I"4Runs a single test with setup/teardown hooks.

;T;0;;;I"run;F;I"Minitest::Test;T;[o;;I" ;F;I"untyped;To;;0;0;;;I"capture_exceptions;F;I"Minitest::Test;T;[o;;I" ;F;I"untyped;To;;0;0;;;I"sanitize_exception;F;I"Minitest::Test;T;[o;;I"untyped e;T;I"untyped;To;;0;0;;;I"with_info_handler;F;I"Minitest::Test;T;[o;;I" ;F;I"untyped;To; ;I"KAssertion wrapping an unexpected error that was raised during a run.

;T;0;	I"Minitest::UnexpectedError;T;
[ ;[ ;0;[ ;[ ;0;I"Minitest::Assertion;To;;0;0;;;I"initialize;F;I"Minitest::UnexpectedError;T;[o;;I"untyped error;T;I"	void;To;;0;0;;;I"backtrace;F;I"Minitest::UnexpectedError;T;[o;;I" ;F;I"untyped;To;;0;0;;;I"message;F;I"Minitest::UnexpectedError;T;[o;;I" ;F;I"String;To;;0;0;;;I"result_label;F;I"Minitest::UnexpectedError;T;[o;;I" ;F;I""Error";To; ;0;0;	I"Minitest::Unit::TestCase;T;
[ ;[ ;0;[ ;[ ;0;I"Minitest::Test;To;;0;0;;;I"inherited;F;I"Minitest::Unit::TestCase;T;[o;;I"untyped klass;T;I"untyped;To; ;0;0;	I"Minitest::Unit;T;
[ ;[ ;0;[ ;[ ;0;0o;;0;0;;;I"autorun;F;I"Minitest::Unit;T;[o;;I" ;F;I"untyped;To;;0;0;;;I"after_tests;F;I"Minitest::Unit;T;[o;;I" ;F;I"untyped;To;;I"Ón# minitest/{test,spec,mock,benchmark}

home
:   https://github.com/seattlerb/minitest
bugs
:   https://github.com/seattlerb/minitest/issues
rdoc
:   http://docs.seattlerb.org/minitest
vim
:   https://github.com/sunaku/vim-ruby-minitest
emacs
:   https://github.com/arthurnn/minitest-emacs


## DESCRIPTION:

minitest provides a complete suite of testing facilities supporting TDD, BDD,
mocking, and benchmarking.

    "I had a class with Jim Weirich on testing last week and we were
     allowed to choose our testing frameworks. Kirk Haines and I were
     paired up and we cracked open the code for a few test
     frameworks...

     I MUST say that minitest is *very* readable / understandable
     compared to the 'other two' options we looked at. Nicely done and
     thank you for helping us keep our mental sanity."

    -- Wayne E. Seguin

minitest/test is a small and incredibly fast unit testing framework. It
provides a rich set of assertions to make your tests clean and readable.

minitest/spec is a functionally complete spec engine. It hooks onto
minitest/test and seamlessly bridges test assertions over to spec
expectations.

minitest/benchmark is an awesome way to assert the performance of your
algorithms in a repeatable manner. Now you can assert that your newb co-worker
doesn't replace your linear algorithm with an exponential one!

minitest/mock by Steven Baker, is a beautifully tiny mock (and stub) object
framework.

minitest/pride shows pride in testing and adds coloring to your test output. I
guess it is an example of how to write IO pipes too. :P

minitest/test is meant to have a clean implementation for language
implementors that need a minimal set of methods to bootstrap a working test
suite. For example, there is no magic involved for test-case discovery.

    "Again, I can't praise enough the idea of a testing/specing
     framework that I can actually read in full in one sitting!"

    -- Piotr Szotkowski

Comparing to rspec:

    rspec is a testing DSL. minitest is ruby.

    -- Adam Hawkins, "Bow Before MiniTest"

minitest doesn't reinvent anything that ruby already provides, like: classes,
modules, inheritance, methods. This means you only have to learn ruby to use
minitest and all of your regular OO practices like extract-method refactorings
still apply.

## FEATURES/PROBLEMS:

*   minitest/autorun - the easy and explicit way to run all your tests.
*   minitest/test - a very fast, simple, and clean test system.
*   minitest/spec - a very fast, simple, and clean spec system.
*   minitest/mock - a simple and clean mock/stub system.
*   minitest/benchmark - an awesome way to assert your algorithm's
    performance.
*   minitest/pride - show your pride in testing!
*   Incredibly small and fast runner, but no bells and whistles.
*   Written by squishy human beings. Software can never be perfect. We will
    all eventually die.


## RATIONALE:

See design_rationale.rb to see how specs and tests work in minitest.

## SYNOPSIS:

Given that you'd like to test the following class:

    class Meme
      def i_can_has_cheezburger?
        "OHAI!"
      end

      def will_it_blend?
        "YES!"
      end
    end

### Unit tests

Define your tests as methods beginning with `test_`.

    require "minitest/autorun"

    class TestMeme < Minitest::Test
      def setup
        @meme = Meme.new
      end

      def test_that_kitty_can_eat
        assert_equal "OHAI!", @meme.i_can_has_cheezburger?
      end

      def test_that_it_will_not_blend
        refute_match /^no/i, @meme.will_it_blend?
      end

      def test_that_will_be_skipped
        skip "test this later"
      end
    end

### Specs

    require "minitest/autorun"

    describe Meme do
      before do
        @meme = Meme.new
      end

      describe "when asked about cheeseburgers" do
        it "must respond positively" do
          _(@meme.i_can_has_cheezburger?).must_equal "OHAI!"
        end
      end

      describe "when asked about blending possibilities" do
        it "won't say no" do
          _(@meme.will_it_blend?).wont_match /^no/i
        end
      end
    end

For matchers support check out:

*   https://github.com/wojtekmach/minitest-matchers
*   https://github.com/rmm5t/minitest-matchers_vaccine


### Benchmarks

Add benchmarks to your tests.

    # optionally run benchmarks, good for CI-only work!
    require "minitest/benchmark" if ENV["BENCH"]

    class TestMeme < Minitest::Benchmark
      # Override self.bench_range or default range is [1, 10, 100, 1_000, 10_000]
      def bench_my_algorithm
        assert_performance_linear 0.9999 do |n| # n is a range value
          @obj.my_algorithm(n)
        end
      end
    end

Or add them to your specs. If you make benchmarks optional, you'll need to
wrap your benchmarks in a conditional since the methods won't be defined. In
minitest 5, the describe name needs to match `/Bench(mark)?$/`.

    describe "Meme Benchmark" do
      if ENV["BENCH"] then
        bench_performance_linear "my_algorithm", 0.9999 do |n|
          100.times do
            @obj.my_algorithm(n)
          end
        end
      end
    end

outputs something like:

    # Running benchmarks:

    TestBlah    100     1000    10000
    bench_my_algorithm   0.006167        0.079279        0.786993
    bench_other_algorithm        0.061679        0.792797        7.869932

Output is tab-delimited to make it easy to paste into a spreadsheet.

### Mocks

Mocks and stubs defined using terminology by Fowler & Meszaros at
http://www.martinfowler.com/bliki/TestDouble.html:

"Mocks are pre-programmed with expectations which form a specification of the
calls they are expected to receive. They can throw an exception if they
receive a call they don't expect and are checked during verification to ensure
they got all the calls they were expecting."

    class MemeAsker
      def initialize(meme)
        @meme = meme
      end

      def ask(question)
        method = question.tr(" ", "_") + "?"
        @meme.__send__(method)
      end
    end

    require "minitest/autorun"

    describe MemeAsker, :ask do
      describe "when passed an unpunctuated question" do
        it "should invoke the appropriate predicate method on the meme" do
          @meme = Minitest::Mock.new
          @meme_asker = MemeAsker.new @meme
          @meme.expect :will_it_blend?, :return_value

          @meme_asker.ask "will it blend"

          @meme.verify
        end
      end
    end

#### Multi-threading and Mocks

Minitest mocks do not support multi-threading. If it works, fine, if it
doesn't you can use regular ruby patterns and facilities like local variables.
Here's an example of asserting that code inside a thread is run:

    def test_called_inside_thread
      called = false
      pr = Proc.new { called = true }
      thread = Thread.new(&pr)
      thread.join
      assert called, "proc not called"
    end

### Stubs

Mocks and stubs are defined using terminology by Fowler & Meszaros at
http://www.martinfowler.com/bliki/TestDouble.html:

"Stubs provide canned answers to calls made during the test".

Minitest's stub method overrides a single method for the duration of the
block.

    def test_stale_eh
      obj_under_test = Something.new

      refute obj_under_test.stale?

      Time.stub :now, Time.at(0) do   # stub goes away once the block is done
        assert obj_under_test.stale?
      end
    end

A note on stubbing: In order to stub a method, the method must actually exist
prior to stubbing. Use a singleton method to create a new non-existing method:

    def obj_under_test.fake_method
      ...
    end

### Running Your Tests

Ideally, you'll use a rake task to run your tests, either piecemeal or all at
once. Both rake and rails ship with rake tasks for running your tests. BUT!
You don't have to:

    % ruby -Ilib:test test/minitest/test_minitest_test.rb
    Run options: --seed 37685

    # Running:

    ...................................................................... (etc)

    Finished in 0.107130s, 1446.8403 runs/s, 2959.0217 assertions/s.

    155 runs, 317 assertions, 0 failures, 0 errors, 0 skips

There are runtime options available, both from minitest itself, and also
provided via plugins. To see them, simply run with `--help`:

    % ruby -Ilib:test test/minitest/test_minitest_test.rb --help
    minitest options:
        -h, --help                       Display this help.
        -s, --seed SEED                  Sets random seed. Also via env. Eg: SEED=n rake
        -v, --verbose                    Verbose. Show progress processing files.
        -n, --name PATTERN               Filter run on /regexp/ or string.
        -e, --exclude PATTERN            Exclude /regexp/ or string from run.

    Known extensions: pride, autotest
        -p, --pride                      Pride. Show your testing pride!
        -a, --autotest                   Connect to autotest server.

You can set up a rake task to run all your tests by adding this to your
Rakefile:

    require "rake/testtask"

    Rake::TestTask.new(:test) do |t|
      t.libs << "test"
      t.libs << "lib"
      t.test_files = FileList["test/**/test_*.rb"]
    end

    task :default => :test

## Writing Extensions

To define a plugin, add a file named minitest/XXX_plugin.rb to your
project/gem. That file must be discoverable via ruby's LOAD_PATH (via rubygems
or otherwise). Minitest will find and require that file using Gem.find_files.
It will then try to call `plugin_XXX_init` during startup. The option
processor will also try to call `plugin_XXX_options` passing the OptionParser
instance and the current options hash. This lets you register your own
command-line options. Here's a totally bogus example:

    # minitest/bogus_plugin.rb:

    module Minitest
      def self.plugin_bogus_options(opts, options)
        opts.on "--myci", "Report results to my CI" do
          options[:myci] = true
          options[:myci_addr] = get_myci_addr
          options[:myci_port] = get_myci_port
        end
      end

      def self.plugin_bogus_init(options)
        self.reporter << MyCI.new(options) if options[:myci]
      end
    end

### Adding custom reporters

Minitest uses composite reporter to output test results using multiple
reporter instances. You can add new reporters to the composite during the
init_plugins phase. As we saw in `plugin_bogus_init` above, you simply add
your reporter instance to the composite via `<<`.

`AbstractReporter` defines the API for reporters. You may subclass it and
override any method you want to achieve your desired behavior.

start
:   Called when the run has started.
record
:   Called for each result, passed or otherwise.
report
:   Called at the end of the run.
passed?
:   Called to see if you detected any problems.


Using our example above, here is how we might implement MyCI:

    # minitest/bogus_plugin.rb

    module Minitest
      class MyCI < AbstractReporter
        attr_accessor :results, :addr, :port

        def initialize options
          self.results = []
          self.addr = options[:myci_addr]
          self.port = options[:myci_port]
        end

        def record result
          self.results << result
        end

        def report
          CI.connect(addr, port).send_results self.results
        end
      end

      # code from above...
    end

## FAQ

### What versions are compatible with what? Or what versions are supported?

Minitest is a dependency of rails, which until fairly recently had an
overzealous backwards compatibility policy. As such, I'm stuck supporting
versions of ruby that are long past EOL. Once rails 5.2 is dropped (hopefully
April 2021), I get to drop a bunch of versions of ruby that I have to
currently test against.

(As of 2021-01-31)

Current versions of rails: (https://endoflife.date/rails)

    | rails | min ruby | rec ruby | minitest | status   |
    |-------+----------+----------+----------+----------|
    |   7.0 | >= 2.7   |      3.0 | >= 5.1   | Future   |
    |   6.1 | >= 2.5   |      3.0 | >= 5.1   | Current  |
    |   6.0 | >= 2.5   |      2.6 | >= 5.1   | Security |
    |   5.2 | >= 2.2.2 |      2.5 | ~> 5.1   | Security | EOL @railsconf 2021?

Current versions of ruby: (https://endoflife.date/ruby)

    | ruby | Status  |   EOL Date |
    |------+---------+------------|
    |  3.0 | Current | 2024-03-31 |
    |  2.7 | Maint   | 2023-03-31 |
    |  2.6 | Maint*  | 2022-03-31 |
    |  2.5 | EOL     | 2021-03-31 |
    |  2.4 | EOL     | 2020-03-31 |
    |  2.3 | EOL     | 2019-03-31 |
    |  2.2 | EOL     | 2018-03-31 |

See also:

*   https://www.fastruby.io/blog/ruby/rails/versions/compatibility-table.html
*   https://jamesjeffersconsulting.com/ruby-rails-version-matrix/


### How to test SimpleDelegates?

The following implementation and test:

    class Worker < SimpleDelegator
      def work
      end
    end

    describe Worker do
      before do
        @worker = Worker.new(Object.new)
      end

      it "must respond to work" do
        _(@worker).must_respond_to :work
      end
    end

outputs a failure:

      1) Failure:
    Worker#test_0001_must respond to work [bug11.rb:16]:
    Expected #<Object:0x007f9e7184f0a0> (Object) to respond to #work.

Worker is a SimpleDelegate which in 1.9+ is a subclass of BasicObject.
Expectations are put on Object (one level down) so the Worker (SimpleDelegate)
hits `method_missing` and delegates down to the `Object.new` instance. That
object doesn't respond to work so the test fails.

You can bypass `SimpleDelegate#method_missing` by extending the worker with
`Minitest::Expectations`. You can either do that in your setup at the instance
level, like:

    before do
      @worker = Worker.new(Object.new)
      @worker.extend Minitest::Expectations
    end

or you can extend the Worker class (within the test file!), like:

    class Worker
      include ::Minitest::Expectations
    end

### How to share code across test classes?

Use a module. That's exactly what they're for:

    module UsefulStuff
      def useful_method
        # ...
      end
    end

    describe Blah do
      include UsefulStuff

      def test_whatever
        # useful_method available here
      end
    end

Remember, `describe` simply creates test classes. It's just ruby at the end of
the day and all your normal Good Ruby Rules (tm) apply. If you want to extend
your test using setup/teardown via a module, just make sure you ALWAYS call
super. before/after automatically call super for you, so make sure you don't
do it twice.

### How to run code before a group of tests?

Use a constant with begin...end like this:

    describe Blah do
      SETUP = begin
         # ... this runs once when describe Blah starts
      end
      # ...
    end

This can be useful for expensive initializations or sharing state. Remember,
this is just ruby code, so you need to make sure this technique and sharing
state doesn't interfere with your tests.

### Why am I seeing `uninitialized constant MiniTest::Test (NameError)`?

Are you running the test with Bundler (e.g. via `bundle exec` )? If so, in
order to require minitest, you must first add the `gem 'minitest'` to your
Gemfile and run `bundle`. Once it's installed, you should be able to require
minitest and run your tests.

## Prominent Projects using Minitest:

*   arel
*   journey
*   mime-types
*   nokogiri
*   rails (active_support et al)
*   rake
*   rdoc
*   ...and of course, everything from seattle.rb...


## Developing Minitest:

Minitest requires [Hoe](https://rubygems.org/gems/hoe).

### Minitest's own tests require UTF-8 external encoding.

This is a common problem in Windows, where the default external Encoding is
often CP850, but can affect any platform. Minitest can run test suites using
any Encoding, but to run Minitest's own tests you must have a default external
Encoding of UTF-8.

If your encoding is wrong, you'll see errors like:

    --- expected
    +++ actual
    @@ -1,2 +1,3 @@
     # encoding: UTF-8
     -"Expected /\\w+/ to not match \"blah blah blah\"."
     +"Expected /\\w+/ to not match # encoding: UTF-8
     +\"blah blah blah\"."

To check your current encoding, run:

    ruby -e 'puts Encoding.default_external'

If your output is something other than UTF-8, you can set the RUBYOPTS env
variable to a value of '-Eutf-8'. Something like:

    RUBYOPT='-Eutf-8' ruby -e 'puts Encoding.default_external'

Check your OS/shell documentation for the precise syntax (the above will not
work on a basic Windows CMD prompt, look for the SET command). Once you've got
it successfully outputing UTF-8, use the same setting when running rake in
Minitest.

### Minitest's own tests require GNU (or similar) diff.

This is also a problem primarily affecting Windows developers. PowerShell has
a command called diff, but it is not suitable for use with Minitest.

If you see failures like either of these, you are probably missing diff tool:

      4) Failure:
    TestMinitestUnitTestCase#test_assert_equal_different_long [D:/ruby/seattlerb/minitest/test/minitest/test_minitest_test.rb:936]:
    Expected: "--- expected\n+++ actual\n@@ -1 +1 @@\n-\"hahahahahahahahahahahahahahahahahahahaha\"\n+\"blahblahblahblahblahblahblahblahblahblah\"\n"
      Actual: "Expected: \"hahahahahahahahahahahahahahahahahahahaha\"\n  Actual: \"blahblahblahblahblahblahblahblahblahblah\""

      5) Failure:
    TestMinitestUnitTestCase#test_assert_equal_different_collection_hash_hex_invisible [D:/ruby/seattlerb/minitest/test/minitest/test_minitest_test.rb:845]:
    Expected: "No visible difference in the Hash#inspect output.\nYou should look at the implementation of #== on Hash or its members.\n
    {1=>#<Object:0xXXXXXX>}"
      Actual: "Expected: {1=>#<Object:0x00000003ba0470>}\n  Actual: {1=>#<Object:0x00000003ba0448>}"

If you use Cygwin or MSYS2 or similar there are packages that include a GNU
diff for Windows. If you don't, you can download GNU diffutils from
http://gnuwin32.sourceforge.net/packages/diffutils.htm (make sure to add it to
your PATH).

You can make sure it's installed and path is configured properly with:

    diff.exe -v

There are multiple lines of output, the first should be something like:

    diff (GNU diffutils) 2.8.1

If you are using PowerShell make sure you run diff.exe, not just diff, which
will invoke the PowerShell built in function.

## Known Extensions:

capybara_minitest_spec
:   Bridge between Capybara RSpec matchers and Minitest::Spec expectations
    (e.g. `page.must_have_content("Title")`).
color_pound_spec_reporter
:   Test names print Ruby Object types in color with your Minitest Spec style
    tests.
minispec-metadata
:   Metadata for describe/it blocks & CLI tag filter. E.g. `it "requires JS
    driver", js: true do` & `ruby test.rb --tag js` runs tests tagged :js.
minispec-rails
:   Minimal support to use Spec style in Rails 5+.
mini-apivore
:   for swagger based automated API testing.
minitest-around
:   Around block for minitest. An alternative to setup/teardown dance.
minitest-assert_errors
:   Adds Minitest assertions to test for errors raised or not raised by
    Minitest itself.
minitest-autotest
:   autotest is a continuous testing facility meant to be used during
    development.
minitest-bacon
:   minitest-bacon extends minitest with bacon-like functionality.
minitest-bang
:   Adds support for RSpec-style let! to immediately invoke let statements
    before each test.
minitest-bisect
:   Helps you isolate and debug random test failures.
minitest-blink1_reporter
:   Display test results with a Blink1.
minitest-capistrano
:   Assertions and expectations for testing Capistrano recipes.
minitest-capybara
:   Capybara matchers support for minitest unit and spec.
minitest-chef-handler
:   Run Minitest suites as Chef report handlers
minitest-ci
:   CI reporter plugin for Minitest.
minitest-context
:   Defines contexts for code reuse in Minitest specs that share common
    expectations.
minitest-debugger
:   Wraps assert so failed assertions drop into the ruby debugger.
minitest-display
:   Patches Minitest to allow for an easily configurable output.
minitest-documentation
:   Minimal documentation format inspired by rspec's.
minitest-doc_reporter
:   Detailed output inspired by rspec's documentation format.
minitest-emoji
:   Print out emoji for your test passes, fails, and skips.
minitest-english
:   Semantically symmetric aliases for assertions and expectations.
minitest-excludes
:   Clean API for excluding certain tests you don't want to run under certain
    conditions.
minitest-fail-fast
:   Reimplements RSpec's "fail fast" feature
minitest-filecontent
:   Support unit tests with expectation results in files. Differing results
    will be stored again in files.
minitest-filesystem
:   Adds assertion and expectation to help testing filesystem contents.
minitest-firemock
:   Makes your Minitest mocks more resilient.
minitest-focus
:   Focus on one test at a time.
minitest-gcstats
:   A minitest plugin that adds a report of the top tests by number of objects
    allocated.
minitest-global_expectations
:   Support minitest expectation methods for all objects
minitest-great_expectations
:   Generally useful additions to minitest's assertions and expectations.
minitest-growl
:   Test notifier for minitest via growl.
minitest-happy
:   GLOBALLY ACTIVATE MINITEST PRIDE! RAWR!
minitest-have_tag
:   Adds Minitest assertions to test for the existence of HTML tags, including
    contents, within a provided string.
minitest-heat
:   Reporting that builds a heat map of failure locations
minitest-hooks
:   Around and before_all/after_all/around_all hooks
minitest-hyper
:   Pretty, single-page HTML reports for your Minitest runs
minitest-implicit-subject
:   Implicit declaration of the test subject.
minitest-instrument
:   Instrument ActiveSupport::Notifications when test method is executed.
minitest-instrument-db
:   Store information about speed of test execution provided by
    minitest-instrument in database.
minitest-junit
:   JUnit-style XML reporter for minitest.
minitest-keyword
:   Use Minitest assertions with keyword arguments.
minitest-libnotify
:   Test notifier for minitest via libnotify.
minitest-line
:   Run test at line number.
minitest-logger
:   Define assert_log and enable minitest to test log messages. Supports
    Logger and Log4r::Logger.
minitest-macruby
:   Provides extensions to minitest for macruby UI testing.
minitest-matchers
:   Adds support for RSpec-style matchers to minitest.
minitest-matchers_vaccine
:   Adds assertions that adhere to the matcher spec, but without any
    expectation infections.
minitest-metadata
:   Annotate tests with metadata (key-value).
minitest-mock_expectations
:   Provides method call assertions for minitest.
minitest-mongoid
:   Mongoid assertion matchers for Minitest.
minitest-must_not
:   Provides must_not as an alias for wont in Minitest.
minitest-optional_retry
:   Automatically retry failed test to help with flakiness.
minitest-osx
:   Reporter for the Mac OS X notification center.
minitest-parallel_fork
:   Fork-based parallelization
minitest-parallel-db
:   Run tests in parallel with a single database.
minitest-power_assert
:   PowerAssert for Minitest.
minitest-predicates
:   Adds support for .predicate? methods.
minitest-profile
:   List the 10 slowest tests in your suite.
minitest-rails
:   Minitest integration for Rails 3.x.
minitest-rails-capybara
:   Capybara integration for Minitest::Rails.
minitest-reporters
:   Create customizable Minitest output formats.
minitest-rg
:   Colored red/green output for Minitest.
minitest-rspec_mocks
:   Use RSpec Mocks with Minitest.
minitest-server
:   minitest-server provides a client/server setup with your minitest process,
    allowing your test run to send its results directly to a handler.
minitest-sequel
:   Minitest assertions to speed-up development and testing of Ruby Sequel
    database setups.
minitest-shared_description
:   Support for shared specs and shared spec subclasses
minitest-should_syntax
:   RSpec-style `x.should == y` assertions for Minitest.
minitest-shouldify
:   Adding all manner of shoulds to Minitest (bad idea)
minitest-snail
:   Print a list of tests that take too long
minitest-spec-context
:   Provides rspec-ish context method to Minitest::Spec.
minitest-spec-expect
:   Expect syntax for Minitest::Spec (e.g. expect(sequences).to_include
    :celery_man).
minitest-spec-magic
:   Minitest::Spec extensions for Rails and beyond.
minitest-spec-rails
:   Drop in Minitest::Spec superclass for ActiveSupport::TestCase.
minitest-sprint
:   Runs (Get it? It's fast!) your tests and makes it easier to rerun
    individual failures.
minitest-stately
:   Find leaking state between tests
minitest-stub_any_instance
:   Stub any instance of a method on the given class for the duration of a
    block.
minitest-stub-const
:   Stub constants for the duration of a block.
minitest-tags
:   Add tags for minitest.
minitest-unordered
:   Adds a new assertion to minitest for checking the contents of a
    collection, ignoring element order.
minitest-vcr
:   Automatic cassette managment with Minitest::Spec and VCR.
minitest_log
:   Adds structured logging, data explication, and verdicts.
minitest_owrapper
:   Get tests results as a TestResult object.
minitest_should
:   Shoulda style syntax for minitest test::unit.
minitest_tu_shim
:   Bridges between test/unit and minitest.
mongoid-minitest
:   Minitest matchers for Mongoid.
mutant-minitest
:   Minitest integration for mutant.
pry-rescue
:   A pry plugin w/ minitest support. See pry-rescue/minitest.rb.
rematch
:   Declutter your test files from large hardcoded data and update them
    automatically when your code changes.
rspec2minitest
:   Easily translate any RSpec matchers to Minitest assertions and
    expectations.


## Unknown Extensions:

Authors... Please send me a pull request with a description of your minitest
extension.

*   assay-minitest
*   detroit-minitest
*   em-minitest-spec
*   flexmock-minitest
*   guard-minitest
*   guard-minitest-decisiv
*   minitest-activemodel
*   minitest-ar-assertions
*   minitest-capybara-unit
*   minitest-colorer
*   minitest-deluxe
*   minitest-extra-assertions
*   minitest-rails-shoulda
*   minitest-spec
*   minitest-spec-should
*   minitest-sugar
*   spork-minitest


## Minitest related goods

*   minitest/pride fabric:
    http://www.spoonflower.com/fabric/3928730-again-by-katie_allen


## REQUIREMENTS:

*   Ruby 2.3+. No magic is involved. I hope.


## INSTALL:

    sudo gem install minitest

On 1.9, you already have it. To get newer candy you can still install the gem,
and then requiring "minitest/autorun" should automatically pull it in. If not,
you'll need to do it yourself:

    gem "minitest"     # ensures you"re using the gem, and not the built-in MT
    require "minitest/autorun"

    # ... usual testing stuffs ...

DO NOTE: There is a serious problem with the way that ruby 1.9/2.0 packages
their own gems. They install a gem specification file, but don't install the
gem contents in the gem path. This messes up Gem.find_files and many other
things (gem which, gem contents, etc).

Just install minitest as a gem for real and you'll be happier.

## LICENSE:

(The MIT License)

Copyright (c) Ryan Davis, seattle.rb

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the 'Software'), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

;T;0;	I"Minitest;T;
[ ;[ ;0;[ ;[ o;;I"0Registers Minitest to run at process exit

;T;0;;;I"autorun;F;I"Minitest;T;[o;;I" ;F;I"untyped;To;;I"‡A simple hook allowing you to run a block of code after everything is done
running. Eg:

    Minitest.after_run { p $debugging_info }

;T;0;;;I"after_run;F;I"Minitest;T;[o;;I" ;F;I"untyped;To;;0;0;;;I"init_plugins;F;I"Minitest;T;[o;;I"untyped options;T;I"untyped;To;;0;0;;;I"load_plugins;F;I"Minitest;T;[o;;I" ;F;I"nil | untyped;To;;I"bThis is the top-level run method. Everything starts from here. It tells each
Runnable sub-class to run, and each of those are responsible for doing
whatever they do.

The overall structure of a run looks like this:

    Minitest.autorun
      Minitest.run(args)
        Minitest.__run(reporter, options)
          Runnable.runnables.each
            runnable.run(reporter, options)
              self.runnable_methods.each
                self.run_one_method(self, runnable_method, reporter)
                  Minitest.run_one_method(klass, runnable_method)
                    klass.new(runnable_method).run

;T;0;;;I"run;F;I"Minitest;T;[o;;I"?untyped args;T;I"untyped;To;;I"TInternal run method. Responsible for telling all Runnable sub-classes to run.

;T;0;;;I"
__run;F;I"Minitest;T;[o;;I"&untyped reporter, untyped options;T;I"untyped;To;;0;0;;;I"process_args;F;I"Minitest;T;[o;;I"?untyped args;T;I"untyped;To;;0;0;;;I"filter_backtrace;F;I"Minitest;T;[o;;I"untyped bt;T;I"untyped;To;;0;0;;;I"run_one_method;F;I"Minitest;T;[o;;I"'untyped klass, untyped method_name;T;I"untyped;To;;I":nodoc:
;T;0;;;I"clock_time;F;I"Minitest;T;[o;;I" ;F;I"untyped;To;;0;0;;;I"plugin_pride_options;F;I"Minitest;T;[o;;I"#untyped opts, untyped _options;T;I"untyped;To;;0;0;;;I"plugin_pride_init;F;I"Minitest;T;[o;;I"untyped options;T;I"untyped | nil;To; ;I"ÅUse the Monitor class when you want to have a lock object for blocks with
mutual exclusion.

    require 'monitor'

    lock = Monitor.new
    lock.synchronize do
      # exclusive access
    end

;T;0;	I"Monitor;T;
[ ;[ ;0;[ ;[ ;0;0o;;I" ;T;0;;;I"
enter;F;I"Monitor;T;[o;;I" ;F;I"nil;To;;I" ;T;0;;;I"	exit;F;I"Monitor;T;[o;;I" ;F;I"nil;To;;I" ;T;0;;;I"mon_check_owner;F;I"Monitor;T;[o;;I" ;F;I"nil;To;;I" ;T;0;;;I"mon_locked?;F;I"Monitor;T;[o;;I" ;F;I"	bool;To;;I" ;T;0;;;I"mon_owned?;F;I"Monitor;T;[o;;I" ;F;I"	bool;To;;I" ;T;0;;;I"new_cond;F;I"Monitor;T;[o;;I" ;F;I"$MonitorMixin::ConditionVariable;To;;I" ;T;0;;;I"synchronize;F;I"Monitor;T;[o;;I" ;F;I"T;Fo;;I" ;T;0;;;I"try_enter;F;I"Monitor;T;[o;;I" ;F;I"	bool;To;;I" ;T;0;;;I"wait_for_cond;F;I"Monitor;T;[o;;I":::MonitorMixin::ConditionVariable, ::Numeric? timeout;T;I"untyped;To;;0;0;	I"MonitorMixin;T;
[ ;[ ;0;[ ;[ o;;I" ;T;0;;;I"extend_object;F;I"MonitorMixin;T;[o;;I"untyped obj;T;I"untyped;To;;I" Enters exclusive section.

;T;0;;;I"mon_enter;F;I"MonitorMixin;T;[o;;I" ;F;I"nil;To;;I" Leaves exclusive section.

;T;0;;;I"mon_exit;F;I"MonitorMixin;T;[o;;I" ;F;I"nil;To;;I";Returns true if this monitor is locked by any thread

;T;0;;;I"mon_locked?;F;I"MonitorMixin;T;[o;;I" ;F;I"	bool;To;;I"@Returns true if this monitor is locked by current thread.

;T;0;;;I"mon_owned?;F;I"MonitorMixin;T;[o;;I" ;F;I"	bool;To;;I"—Enters exclusive section and executes the block.  Leaves the exclusive section
automatically when the block exits.  See example under `MonitorMixin`.

;T;0;;;I"mon_synchronize;F;I"MonitorMixin;T;[o;;I" ;F;I"T;Fo;;I"KAttempts to enter exclusive section.  Returns `false` if lock fails.

;T;0;;;I"mon_try_enter;F;I"MonitorMixin;T;[o;;I" ;F;I"	bool;To;;I"XCreates a new MonitorMixin::ConditionVariable associated with the Monitor
object.

;T;0;;;I"new_cond;F;I"MonitorMixin;T;[o;;I" ;F;I"$MonitorMixin::ConditionVariable;To;;I"™Use `extend MonitorMixin` or `include MonitorMixin` instead of this
constructor.  Have look at the examples above to understand how to use this
module.

;T;0;;;I"initialize;F;I"MonitorMixin;T;[o;;I"*untyped;T;I"	void;To;;I" ;T;0;;;I"mon_check_owner;F;I"MonitorMixin;T;[o;;I" ;F;I"nil;To;;I"}Initializes the MonitorMixin after being included in a class or when an object
has been extended with the MonitorMixin

;T;0;;;I"mon_initialize;F;I"MonitorMixin;T;[o;;I" ;F;I"untyped;To; ;I"¹FIXME: This isn't documented in Nutshell.

Since MonitorMixin.new_cond returns a ConditionVariable, and the example above
calls while_wait and signal, this class should be documented.

;T;0;	I"$MonitorMixin::ConditionVariable;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"2Wakes up all threads waiting for this lock.

;T;0;;;I"broadcast;F;I"$MonitorMixin::ConditionVariable;T;[o;;I" ;F;I"Thread::ConditionVariable;To;;I"?Wakes up the first thread in line waiting for this lock.

;T;0;;;I"signal;F;I"$MonitorMixin::ConditionVariable;T;[o;;I" ;F;I"Thread::ConditionVariable;To;;I"ÐReleases the lock held in the associated monitor and waits; reacquires the
lock on wakeup.

If `timeout` is given, this method returns after `timeout` seconds passed,
even if no other thread doesn't signal.

;T;0;;;I"	wait;F;I"$MonitorMixin::ConditionVariable;T;[o;;I"?::Numeric? timeout;T;I"untyped;To;;I"ICalls wait repeatedly until the given block yields a truthy value.

;T;0;;;I"wait_until;F;I"$MonitorMixin::ConditionVariable;T;[o;;I" ;F;I"untyped;To;;I"ICalls wait repeatedly while the given block yields a truthy value.

;T;0;;;I"wait_while;F;I"$MonitorMixin::ConditionVariable;T;[o;;I" ;F;I"untyped;To;;I" ;T;0;;;I"initialize;F;I"$MonitorMixin::ConditionVariable;T;[o;;I"::Monitor monitor;T;I"	void;To;;I"n# mutex_m.rb

When 'mutex_m' is required, any object that extends or includes Mutex_m will
be treated like a Mutex.

Start by requiring the standard library Mutex_m:

    require "mutex_m.rb"

From here you can extend an object with Mutex instance methods:

    obj = Object.new
    obj.extend Mutex_m

Or mixin Mutex_m into your module to your class inherit Mutex instance methods
--- remember to call super() in your class initialize method.

    class Foo
      include Mutex_m
      def initialize
        # ...
        super()
      end
      # ...
    end
    obj = Foo.new
    # this obj can be handled like Mutex

;T;0;	I"Mutex_m;T;
[ ;[ ;0;[ ;[ o;;0;0;;;I"append_features;F;I"Mutex_m;T;[o;;I"::Module cl;T;I"untyped;To;;0;0;;;I"define_aliases;F;I"Mutex_m;T;[o;;I"::Module cl;T;I"untyped;To;;0;0;;;I"extend_object;F;I"Mutex_m;T;[o;;I"::Object obj;T;I"untyped;To;;0;0;;;I"mu_extended;F;I"Mutex_m;T;[o;;I" ;F;I"untyped;To;;I"See Thread::Mutex#lock

;T;0;;;I"mu_lock;F;I"Mutex_m;T;[o;;I" ;F;I"Thread::Mutex;To;;I" See Thread::Mutex#locked?

;T;0;;;I"mu_locked?;F;I"Mutex_m;T;[o;;I" ;F;I"	bool;To;;I"$See Thread::Mutex#synchronize

;T;0;;;I"mu_synchronize;F;I"Mutex_m;T;[o;;I" ;F;I"T;Fo;;I"!See Thread::Mutex#try_lock

;T;0;;;I"mu_try_lock;F;I"Mutex_m;T;[o;;I" ;F;I"	bool;To;;I"See Thread::Mutex#unlock

;T;0;;;I"mu_unlock;F;I"Mutex_m;T;[o;;I" ;F;I"Thread::Mutex;To;;I"See Thread::Mutex#sleep

;T;0;;;I"
sleep;F;I"Mutex_m;T;[o;;I"?::Numeric timeout;T;I"Integer?;To;;0;0;;;I"initialize;F;I"Mutex_m;T;[o;;I"*untyped args;T;I"untyped;To;;0;0;;;I"mu_initialize;F;I"Mutex_m;T;[o;;I" ;F;I"untyped;To;;0;0;	I"Net;T;
[ ;[ ;0;[ ;[ o; ;0;0;	I"Net::Protocol;T;
[ ;[ ;0;[ ;[ ;0;0o; ;0;0;	I"Net::ProtocolError;T;
[ ;[ ;0;[ ;[ ;0;I"StandardError;To; ;0;0;	I"Net::ProtoSyntaxError;T;
[ ;[ ;0;[ ;[ ;0;I"Net::ProtocolError;To; ;0;0;	I"Net::ProtoFatalError;T;
[ ;[ ;0;[ ;[ ;0;I"Net::ProtocolError;To; ;0;0;	I"Net::ProtoUnknownError;T;
[ ;[ ;0;[ ;[ ;0;I"Net::ProtocolError;To; ;0;0;	I"Net::ProtoServerError;T;
[ ;[ ;0;[ ;[ ;0;I"Net::ProtocolError;To; ;0;0;	I"Net::ProtoAuthError;T;
[ ;[ ;0;[ ;[ ;0;I"Net::ProtocolError;To; ;0;0;	I"Net::ProtoCommandError;T;
[ ;[ ;0;[ ;[ ;0;I"Net::ProtocolError;To; ;0;0;	I"Net::ProtoRetriableError;T;
[ ;[ ;0;[ ;[ ;0;I"Net::ProtocolError;To; ;0;0;	I"Net::HTTPBadResponse;T;
[ ;[ ;0;[ ;[ ;0;I"StandardError;To; ;0;0;	I"Net::HTTPHeaderSyntaxError;T;
[ ;[ ;0;[ ;[ ;0;I"StandardError;To; ;I"vOpenTimeout, a subclass of Timeout::Error, is raised if a connection cannot be
created within the open_timeout.

;T;0;	I"Net::OpenTimeout;T;
[ ;[ ;0;[ ;[ ;0;I"Timeout::Error;To; ;I"~ReadTimeout, a subclass of Timeout::Error, is raised if a chunk of the
response cannot be read within the read_timeout.

;T;0;	I"Net::ReadTimeout;T;
[ ;[ ;0;[ ;[ ;0;I"Timeout::Error;To; ;I"–WriteTimeout, a subclass of Timeout::Error, is raised if a chunk of the
response cannot be written within the write_timeout.  Not raised on Windows.

;T;0;	I"Net::WriteTimeout;T;
[ ;[ ;0;[ ;[ ;0;I"Timeout::Error;To; ;I"e(## An HTTP client API for Ruby.

Net::HTTP provides a rich library which can be used to build HTTP user-agents.
 For more details about HTTP see
[RFC2616](http://www.ietf.org/rfc/rfc2616.txt).

Net::HTTP is designed to work closely with URI.  URI::HTTP#host,
URI::HTTP#port and URI::HTTP#request_uri are designed to work with Net::HTTP.

If you are only performing a few GET requests you should try OpenURI.

## Simple Examples

All examples assume you have loaded Net::HTTP with:

    require 'net/http'

This will also require 'uri' so you don't need to require it separately.

The Net::HTTP methods in the following section do not persist connections.
They are not recommended if you are performing many HTTP requests.

### GET

    Net::HTTP.get('example.com', '/index.html') # => String

### GET by URI

    uri = URI('http://example.com/index.html?count=10')
    Net::HTTP.get(uri) # => String

### GET with Dynamic Parameters

    uri = URI('http://example.com/index.html')
    params = { :limit => 10, :page => 3 }
    uri.query = URI.encode_www_form(params)

    res = Net::HTTP.get_response(uri)
    puts res.body if res.is_a?(Net::HTTPSuccess)

### POST

    uri = URI('http://www.example.com/search.cgi')
    res = Net::HTTP.post_form(uri, 'q' => 'ruby', 'max' => '50')
    puts res.body

### POST with Multiple Values

    uri = URI('http://www.example.com/search.cgi')
    res = Net::HTTP.post_form(uri, 'q' => ['ruby', 'perl'], 'max' => '50')
    puts res.body

## How to use Net::HTTP

The following example code can be used as the basis of an HTTP user-agent
which can perform a variety of request types using persistent connections.

    uri = URI('http://example.com/some_path?query=string')

    Net::HTTP.start(uri.host, uri.port) do |http|
      request = Net::HTTP::Get.new uri

      response = http.request request # Net::HTTPResponse object
    end

Net::HTTP::start immediately creates a connection to an HTTP server which is
kept open for the duration of the block.  The connection will remain open for
multiple requests in the block if the server indicates it supports persistent
connections.

If you wish to re-use a connection across multiple HTTP requests without
automatically closing it you can use ::new and then call #start and #finish
manually.

The request types Net::HTTP supports are listed below in the section "HTTP
Request Classes".

For all the Net::HTTP request objects and shortcut request methods you may
supply either a String for the request path or a URI from which Net::HTTP will
extract the request path.

### Response Data

    uri = URI('http://example.com/index.html')
    res = Net::HTTP.get_response(uri)

    # Headers
    res['Set-Cookie']            # => String
    res.get_fields('set-cookie') # => Array
    res.to_hash['set-cookie']    # => Array
    puts "Headers: #{res.to_hash.inspect}"

    # Status
    puts res.code       # => '200'
    puts res.message    # => 'OK'
    puts res.class.name # => 'HTTPOK'

    # Body
    puts res.body if res.response_body_permitted?

### Following Redirection

Each Net::HTTPResponse object belongs to a class for its response code.

For example, all 2XX responses are instances of a Net::HTTPSuccess subclass, a
3XX response is an instance of a Net::HTTPRedirection subclass and a 200
response is an instance of the Net::HTTPOK class.  For details of response
classes, see the section "HTTP Response Classes" below.

Using a case statement you can handle various types of responses properly:

    def fetch(uri_str, limit = 10)
      # You should choose a better exception.
      raise ArgumentError, 'too many HTTP redirects' if limit == 0

      response = Net::HTTP.get_response(URI(uri_str))

      case response
      when Net::HTTPSuccess then
        response
      when Net::HTTPRedirection then
        location = response['location']
        warn "redirected to #{location}"
        fetch(location, limit - 1)
      else
        response.value
      end
    end

    print fetch('http://www.ruby-lang.org')

### POST

A POST can be made using the Net::HTTP::Post request class.  This example
creates a URL encoded POST body:

    uri = URI('http://www.example.com/todo.cgi')
    req = Net::HTTP::Post.new(uri)
    req.set_form_data('from' => '2005-01-01', 'to' => '2005-03-31')

    res = Net::HTTP.start(uri.hostname, uri.port) do |http|
      http.request(req)
    end

    case res
    when Net::HTTPSuccess, Net::HTTPRedirection
      # OK
    else
      res.value
    end

To send multipart/form-data use Net::HTTPHeader#set_form:

    req = Net::HTTP::Post.new(uri)
    req.set_form([['upload', File.open('foo.bar')]], 'multipart/form-data')

Other requests that can contain a body such as PUT can be created in the same
way using the corresponding request class (Net::HTTP::Put).

### Setting Headers

The following example performs a conditional GET using the If-Modified-Since
header.  If the files has not been modified since the time in the header a Not
Modified response will be returned.  See RFC 2616 section 9.3 for further
details.

    uri = URI('http://example.com/cached_response')
    file = File.stat 'cached_response'

    req = Net::HTTP::Get.new(uri)
    req['If-Modified-Since'] = file.mtime.rfc2822

    res = Net::HTTP.start(uri.hostname, uri.port) {|http|
      http.request(req)
    }

    open 'cached_response', 'w' do |io|
      io.write res.body
    end if res.is_a?(Net::HTTPSuccess)

### Basic Authentication

Basic authentication is performed according to
[RFC2617](http://www.ietf.org/rfc/rfc2617.txt).

    uri = URI('http://example.com/index.html?key=value')

    req = Net::HTTP::Get.new(uri)
    req.basic_auth 'user', 'pass'

    res = Net::HTTP.start(uri.hostname, uri.port) {|http|
      http.request(req)
    }
    puts res.body

### Streaming Response Bodies

By default Net::HTTP reads an entire response into memory.  If you are
handling large files or wish to implement a progress bar you can instead
stream the body directly to an IO.

    uri = URI('http://example.com/large_file')

    Net::HTTP.start(uri.host, uri.port) do |http|
      request = Net::HTTP::Get.new uri

      http.request request do |response|
        open 'large_file', 'w' do |io|
          response.read_body do |chunk|
            io.write chunk
          end
        end
      end
    end

### HTTPS

HTTPS is enabled for an HTTP connection by Net::HTTP#use_ssl=.

    uri = URI('https://secure.example.com/some_path?query=string')

    Net::HTTP.start(uri.host, uri.port, :use_ssl => true) do |http|
      request = Net::HTTP::Get.new uri
      response = http.request request # Net::HTTPResponse object
    end

Or if you simply want to make a GET request, you may pass in an URI object
that has an HTTPS URL. Net::HTTP automatically turns on TLS verification if
the URI object has a 'https' URI scheme.

    uri = URI('https://example.com/')
    Net::HTTP.get(uri) # => String

In previous versions of Ruby you would need to require 'net/https' to use
HTTPS. This is no longer true.

### Proxies

Net::HTTP will automatically create a proxy from the `http_proxy` environment
variable if it is present.  To disable use of `http_proxy`, pass `nil` for the
proxy address.

You may also create a custom proxy:

    proxy_addr = 'your.proxy.host'
    proxy_port = 8080

    Net::HTTP.new('example.com', nil, proxy_addr, proxy_port).start { |http|
      # always proxy via your.proxy.addr:8080
    }

See Net::HTTP.new for further details and examples such as proxies that
require a username and password.

### Compression

Net::HTTP automatically adds Accept-Encoding for compression of response
bodies and automatically decompresses gzip and deflate responses unless a
Range header was sent.

Compression can be disabled through the Accept-Encoding: identity header.

## HTTP Request Classes

Here is the HTTP request class hierarchy.

*   Net::HTTPRequest
    *   Net::HTTP::Get
    *   Net::HTTP::Head
    *   Net::HTTP::Post
    *   Net::HTTP::Patch
    *   Net::HTTP::Put
    *   Net::HTTP::Proppatch
    *   Net::HTTP::Lock
    *   Net::HTTP::Unlock
    *   Net::HTTP::Options
    *   Net::HTTP::Propfind
    *   Net::HTTP::Delete
    *   Net::HTTP::Move
    *   Net::HTTP::Copy
    *   Net::HTTP::Mkcol
    *   Net::HTTP::Trace



## HTTP Response Classes

Here is HTTP response class hierarchy.  All classes are defined in Net module
and are subclasses of Net::HTTPResponse.

HTTPUnknownResponse
:   For unhandled HTTP extensions
HTTPInformation
:   1xx
HTTPContinue
:   100
HTTPSwitchProtocol
:   101
HTTPProcessing
:   102
HTTPEarlyHints
:   103
HTTPSuccess
:   2xx
HTTPOK
:   200
HTTPCreated
:   201
HTTPAccepted
:   202
HTTPNonAuthoritativeInformation
:   203
HTTPNoContent
:   204
HTTPResetContent
:   205
HTTPPartialContent
:   206
HTTPMultiStatus
:   207
HTTPAlreadyReported
:   208
HTTPIMUsed
:   226
HTTPRedirection
:   3xx
HTTPMultipleChoices
:   300
HTTPMovedPermanently
:   301
HTTPFound
:   302
HTTPSeeOther
:   303
HTTPNotModified
:   304
HTTPUseProxy
:   305
HTTPTemporaryRedirect
:   307
HTTPPermanentRedirect
:   308
HTTPClientError
:   4xx
HTTPBadRequest
:   400
HTTPUnauthorized
:   401
HTTPPaymentRequired
:   402
HTTPForbidden
:   403
HTTPNotFound
:   404
HTTPMethodNotAllowed
:   405
HTTPNotAcceptable
:   406
HTTPProxyAuthenticationRequired
:   407
HTTPRequestTimeOut
:   408
HTTPConflict
:   409
HTTPGone
:   410
HTTPLengthRequired
:   411
HTTPPreconditionFailed
:   412
HTTPRequestEntityTooLarge
:   413
HTTPRequestURITooLong
:   414
HTTPUnsupportedMediaType
:   415
HTTPRequestedRangeNotSatisfiable
:   416
HTTPExpectationFailed
:   417
HTTPMisdirectedRequest
:   421
HTTPUnprocessableEntity
:   422
HTTPLocked
:   423
HTTPFailedDependency
:   424
HTTPUpgradeRequired
:   426
HTTPPreconditionRequired
:   428
HTTPTooManyRequests
:   429
HTTPRequestHeaderFieldsTooLarge
:   431
HTTPUnavailableForLegalReasons
:   451
HTTPServerError
:   5xx
HTTPInternalServerError
:   500
HTTPNotImplemented
:   501
HTTPBadGateway
:   502
HTTPServiceUnavailable
:   503
HTTPGatewayTimeOut
:   504
HTTPVersionNotSupported
:   505
HTTPVariantAlsoNegotiates
:   506
HTTPInsufficientStorage
:   507
HTTPLoopDetected
:   508
HTTPNotExtended
:   510
HTTPNetworkAuthenticationRequired
:   511


There is also the Net::HTTPBadResponse exception which is raised when there is
a protocol error.

;T;0;	I"Net::HTTP;T;
[ ;[ ;0;[ ;[ ;0;I"Net::Protocol;To;;I"VTurns on net/http 1.2 (Ruby 1.8) features. Defaults to ON in Ruby 1.8 or
later.

;T;0;;;I"version_1_2;F;I"Net::HTTP;T;[o;;I" ;F;I"TrueClass;To;;I"IReturns true if net/http is in version 1.2 mode. Defaults to true.

;T;0;;;I"version_1_2?;F;I"Net::HTTP;T;[o;;I" ;F;I"TrueClass;To;;0;0;;;I"version_1_1?;F;I"Net::HTTP;T;[o;;I" ;F;I"FalseClass;To;;I"ªGets the body text from the target and outputs it to $stdout.  The target can
either be specified as (`uri`, `headers`), or as (`host`, `path`, `port` =
80); so:

    Net::HTTP.get_print URI('http://www.example.com/index.html')

or:

    Net::HTTP.get_print 'www.example.com', '/index.html'

you can also specify request headers:

    Net::HTTP.get_print URI('http://www.example.com/index.html'), { 'Accept' => 'text/html' }

;T;0;;;I"get_print;F;I"Net::HTTP;T;[o;;I":::URI::Generic uri, ?::Hash[::String, untyped] header;T;I"	void;To;;I"2::String host, ::String path, ?::Integer port;T;I"	void;To;;I"µSends a GET request to the target and returns the HTTP response as a string.
The target can either be specified as (`uri`, `headers`), or as (`host`,
`path`, `port` = 80); so:

    print Net::HTTP.get(URI('http://www.example.com/index.html'))

or:

    print Net::HTTP.get('www.example.com', '/index.html')

you can also specify request headers:

    Net::HTTP.get(URI('http://www.example.com/index.html'), { 'Accept' => 'text/html' })

;T;0;;;I"get;F;I"Net::HTTP;T;[o;;I":::URI::Generic uri, ?::Hash[::String, untyped] header;T;I"String;To;;I"2::String host, ::String path, ?::Integer port;T;I"String;To;;I"	Sends a GET request to the target and returns the HTTP response as a
Net::HTTPResponse object.  The target can either be specified as (`uri`,
`headers`), or as (`host`, `path`, `port` = 80); so:

    res = Net::HTTP.get_response(URI('http://www.example.com/index.html'))
    print res.body

or:

    res = Net::HTTP.get_response('www.example.com', '/index.html')
    print res.body

you can also specify request headers:

    Net::HTTP.get_response(URI('http://www.example.com/index.html'), { 'Accept' => 'text/html' })

;T;0;;;I"get_response;F;I"Net::HTTP;T;[o;;I":::URI::Generic uri, ?::Hash[::String, untyped] header;T;I"Net::HTTPResponse;To;;I"2::String host, ::String path, ?::Integer port;T;I"Net::HTTPResponse;To;;I"Posts data to the specified URI object.

Example:

    require 'net/http'
    require 'uri'

    Net::HTTP.post URI('http://www.example.com/api/search'),
                   { "q" => "ruby", "max" => "50" }.to_json,
                   "Content-Type" => "application/json"

;T;0;;;I"	post;F;I"Net::HTTP;T;[o;;I"I::URI::Generic url, ::String data, ?::Hash[::String, untyped] header;T;I"Net::HTTPResponse;To;;I"Posts HTML form data to the specified URI object. The form data must be
provided as a Hash mapping from String to String. Example:

    { "cmd" => "search", "q" => "ruby", "max" => "50" }

This method also does Basic Authentication if and only if `url`.user exists.
But userinfo for authentication is deprecated (RFC3986). So this feature will
be removed.

Example:

    require 'net/http'

    Net::HTTP.post_form URI('http://www.example.com/search.cgi'),
                        { "q" => "ruby", "max" => "50" }

;T;0;;;I"post_form;F;I"Net::HTTP;T;[o;;I"9::URI::Generic url, ::Hash[::String, untyped] params;T;I"Net::HTTPResponse;To;;I"AThe default port to use for HTTP requests; defaults to 80.

;T;0;;;I"default_port;F;I"Net::HTTP;T;[o;;I" ;F;I"Integer;To;;I"AThe default port to use for HTTP requests; defaults to 80.

;T;0;;;I"http_default_port;F;I"Net::HTTP;T;[o;;I" ;F;I"Integer;To;;I"CThe default port to use for HTTPS requests; defaults to 443.

;T;0;;;I"https_default_port;F;I"Net::HTTP;T;[o;;I" ;F;I"Integer;To;;I"oCreates a new Net::HTTP object, then additionally opens the TCP connection and
HTTP session.

Arguments are the following:
*address*
:   hostname or IP address of the server
*port*
:   port of the server
*p_addr*
:   address of proxy
*p_port*
:   port of proxy
*p_user*
:   user of proxy
*p_pass*
:   pass of proxy
*opt*
:   optional hash


*opt* sets following values by its accessor. The keys are ipaddr, ca_file,
ca_path, cert, cert_store, ciphers, keep_alive_timeout,
close_on_empty_response, key, open_timeout, read_timeout, write_timeout,
ssl_timeout, ssl_version, use_ssl, verify_callback, verify_depth and
verify_mode. If you set :use_ssl as true, you can use https and default value
of verify_mode is set as OpenSSL::SSL::VERIFY_PEER.

If the optional block is given, the newly created Net::HTTP object is passed
to it and closed when the block finishes.  In this case, the return value of
this method is the return value of the block.  If no block is given, the
return value of this method is the newly created Net::HTTP object itself, and
the caller is responsible for closing it upon completion using the finish()
method.

;T;0;;;I"
start;F;I"Net::HTTP;T;[o;;I"œ::String address, ?::Integer? port, ?::String | :ENV | nil p_addr, ?::Integer? p_port, ?::String? p_user, ?::String? p_pass, ?::Hash[::Symbol, untyped]? opt;T;I"Net::HTTP;To;;I"œ::String address, ?::Integer? port, ?::String | :ENV | nil p_addr, ?::Integer? p_port, ?::String? p_user, ?::String? p_pass, ?::Hash[::Symbol, untyped]? opt;T;I"T;Fo;;I"½Creates a new Net::HTTP object for the specified server address, without
opening the TCP connection or initializing the HTTP session. The `address`
should be a DNS hostname or IP address.

;T;0;;;I"new;F;I"Net::HTTP;T;[o;;I"‘::String address, ?::Integer? port, ?::String | :ENV | nil p_addr, ?::Integer? p_port, ?::String? p_user, ?::String? p_pass, ?untyped? p_no_proxy;T;I"Net::HTTP;To;;I" ;T;0;;;I"inspect;F;I"Net::HTTP;T;[o;;I" ;F;I"String;To;;I"æ**WARNING** This method opens a serious security hole. Never use this method
in production code.

Sets an output stream for debugging.

    http = Net::HTTP.new(hostname)
    http.set_debug_output $stderr
    http.start { .... }

;T;0;;;I"set_debug_output;F;I"Net::HTTP;T;[o;;I"::IO output;T;I"	void;To;;I"9Returns true if the HTTP session has been started.

;T;0;;;I"started?;F;I"Net::HTTP;T;[o;;I" ;F;I"	bool;To;;I"7Returns true if SSL/TLS is being used with HTTP.

;T;0;;;I"use_ssl?;F;I"Net::HTTP;T;[o;;I" ;F;I"	bool;To;;I"—Turn on/off SSL. This flag must be set before starting session. If you change
use_ssl value after session started, a Net::HTTP object raises IOError.

;T;0;;;I"use_ssl=;F;I"Net::HTTP;T;[o;;I"::boolish flag;T;I"	void;To;;I";Returns the X.509 certificates the server presented.

;T;0;;;I"peer_cert;F;I"Net::HTTP;T;[o;;I" ;F;I"nil | untyped;To;;I"4Opens a TCP connection and HTTP session.

When this method is called with a block, it passes the Net::HTTP object to the
block, and closes the TCP connection and HTTP session after the block has been
executed.

When called with a block, it returns the return value of the block; otherwise,
it returns self.

;T;0;;;I"
start;F;I"Net::HTTP;T;[o;;I" ;F;I"T;Fo;;I" ;F;I"Net::HTTP;To;;I"sFinishes the HTTP session and closes the TCP connection. Raises IOError if the
session has not been started.

;T;0;;;I"finish;F;I"Net::HTTP;T;[o;;I" ;F;I"	void;To;;I"õCreates an HTTP proxy class which behaves like Net::HTTP, but performs all
access via the specified proxy.

This class is obsolete.  You may pass these same parameters directly to
Net::HTTP.new.  See Net::HTTP.new for details of the arguments.

;T;0;;;I"
Proxy;F;I"Net::HTTP;T;[o;;I"Z?::Symbol | ::String p_addr, ?::Integer? p_port, ?::String? p_user, ?::String? p_pass;T;I"untyped;To;;I"Hreturns true if self is a class which was created by HTTP::Proxy.

;T;0;;;I"proxy_class?;F;I"Net::HTTP;T;[o;;I" ;F;I"	bool;To;;I";True if requests for this connection will be proxied

;T;0;;;I"proxy?;F;I"Net::HTTP;T;[o;;I" ;F;I"	bool;To;;I"OTrue if the proxy for this connection is determined from the environment

;T;0;;;I"proxy_from_env?;F;I"Net::HTTP;T;[o;;I" ;F;I"	bool;To;;0;0;;;I"proxy_uri;F;I"Net::HTTP;T;[o;;I" ;F;I"nil | ::URI::Generic;To;;I"5Retrieves data from `path` on the connected-to host which may be an absolute
path String or a URI to extract the path from.

`initheader` must be a Hash like { 'Accept' => '**/**', ... }, and it defaults
to an empty hash. If `initheader` doesn't have the key 'accept-encoding', then
a value of "gzip;q=1.0,deflate;q=0.6,identity;q=0.3" is used, so that gzip
compression is used in preference to deflate compression, which is used in
preference to no compression. Ruby doesn't have libraries to support the
compress (Lempel-Ziv) compression, so that is not supported.  The intent of
this is to reduce bandwidth by default.   If this routine sets up compression,
then it does the decompression also, removing the header as well to prevent
confusion.  Otherwise it leaves the body as it found it.

This method returns a Net::HTTPResponse object.

If called with a block, yields each fragment of the entity body in turn as a
string as it is read from the socket.  Note that in this case, the returned
response object will **not** contain a (meaningful) body.

`dest` argument is obsolete. It still works but you must not use it.

This method never raises an exception.

    response = http.get('/index.html')

    # using block
    File.open('result.txt', 'w') {|f|
      http.get('/~foo/') do |str|
        f.write str
      end
    }

;T;0;;;I"get;F;I"Net::HTTP;T;[o;;I"D::String path, ?::Hash[::String, untyped] initheader, ?bot dest;T;I"Net::HTTPResponse;To;;I"aGets only the header from `path` on the connected-to host. `header` is a Hash
like { 'Accept' => '**/**', ... }.

This method returns a Net::HTTPResponse object.

This method never raises an exception.

    response = nil
    Net::HTTP.start('some.www.server', 80) {|http|
      response = http.head('/index.html')
    }
    p response['content-type']

;T;0;;;I"	head;F;I"Net::HTTP;T;[o;;I"9::String path, ?::Hash[::String, untyped] initheader;T;I"Net::HTTPResponse;To;;I"DPosts `data` (must be a String) to `path`. `header` must be a Hash like {
'Accept' => '**/**', ... }.

This method returns a Net::HTTPResponse object.

If called with a block, yields each fragment of the entity body in turn as a
string as it is read from the socket.  Note that in this case, the returned
response object will **not** contain a (meaningful) body.

`dest` argument is obsolete. It still works but you must not use it.

This method never raises exception.

    response = http.post('/cgi-bin/search.rb', 'query=foo')

    # using block
    File.open('result.txt', 'w') {|f|
      http.post('/cgi-bin/search.rb', 'query=foo') do |str|
        f.write str
      end
    }

You should set Content-Type: header field for POST. If no Content-Type: field
given, this method uses "application/x-www-form-urlencoded" by default.

;T;0;;;I"	post;F;I"Net::HTTP;T;[o;;I"S::String path, ::String data, ?::Hash[::String, untyped] initheader, ?bot dest;T;I"Net::HTTPResponse;To;;I"ZSends a PATCH request to the `path` and gets a response, as an HTTPResponse
object.

;T;0;;;I"
patch;F;I"Net::HTTP;T;[o;;I"S::String path, ::String data, ?::Hash[::String, untyped] initheader, ?bot dest;T;I"Net::HTTPResponse;To;;0;0;;;I"put;F;I"Net::HTTP;T;[o;;I"H::String path, ::String data, ?::Hash[::String, untyped] initheader;T;I"Net::HTTPResponse;To;;I"^Sends a PROPPATCH request to the `path` and gets a response, as an
HTTPResponse object.

;T;0;;;I"proppatch;F;I"Net::HTTP;T;[o;;I"H::String path, ::String body, ?::Hash[::String, untyped] initheader;T;I"Net::HTTPResponse;To;;I"YSends a LOCK request to the `path` and gets a response, as an HTTPResponse
object.

;T;0;;;I"	lock;F;I"Net::HTTP;T;[o;;I"H::String path, ::String body, ?::Hash[::String, untyped] initheader;T;I"Net::HTTPResponse;To;;I"[Sends a UNLOCK request to the `path` and gets a response, as an HTTPResponse
object.

;T;0;;;I"unlock;F;I"Net::HTTP;T;[o;;I"H::String path, ::String body, ?::Hash[::String, untyped] initheader;T;I"Net::HTTPResponse;To;;I"\Sends a OPTIONS request to the `path` and gets a response, as an HTTPResponse
object.

;T;0;;;I"options;F;I"Net::HTTP;T;[o;;I"9::String path, ?::Hash[::String, untyped] initheader;T;I"Net::HTTPResponse;To;;I"]Sends a PROPFIND request to the `path` and gets a response, as an HTTPResponse
object.

;T;0;;;I"propfind;F;I"Net::HTTP;T;[o;;I"I::String path, ?untyped? body, ?::Hash[::String, untyped] initheader;T;I"Net::HTTPResponse;To;;I"[Sends a DELETE request to the `path` and gets a response, as an HTTPResponse
object.

;T;0;;;I"delete;F;I"Net::HTTP;T;[o;;I"9::String path, ?::Hash[::String, untyped] initheader;T;I"Net::HTTPResponse;To;;I"YSends a MOVE request to the `path` and gets a response, as an HTTPResponse
object.

;T;0;;;I"	move;F;I"Net::HTTP;T;[o;;I"9::String path, ?::Hash[::String, untyped] initheader;T;I"Net::HTTPResponse;To;;I"YSends a COPY request to the `path` and gets a response, as an HTTPResponse
object.

;T;0;;;I"	copy;F;I"Net::HTTP;T;[o;;I"9::String path, ?::Hash[::String, untyped] initheader;T;I"Net::HTTPResponse;To;;I"ZSends a MKCOL request to the `path` and gets a response, as an HTTPResponse
object.

;T;0;;;I"
mkcol;F;I"Net::HTTP;T;[o;;I"I::String path, ?untyped? body, ?::Hash[::String, untyped] initheader;T;I"Net::HTTPResponse;To;;I"ZSends a TRACE request to the `path` and gets a response, as an HTTPResponse
object.

;T;0;;;I"
trace;F;I"Net::HTTP;T;[o;;I"9::String path, ?::Hash[::String, untyped] initheader;T;I"Net::HTTPResponse;To;;I"²Sends a GET request to the `path`. Returns the response as a Net::HTTPResponse
object.

When called with a block, passes an HTTPResponse object to the block. The body
of the response will not have been read yet; the block can process it using
HTTPResponse#read_body, if desired.

Returns the response.

This method never raises Net::* exceptions.

    response = http.request_get('/index.html')
    # The entity body is already read in this case.
    p response['content-type']
    puts response.body

    # Using a block
    http.request_get('/index.html') {|response|
      p response['content-type']
      response.read_body do |str|   # read body now
        print str
      end
    }

;T;0;;;I"request_get;F;I"Net::HTTP;T;[o;;I"9::String path, ?::Hash[::String, untyped] initheader;T;I"Net::HTTPResponse;To;;I"ðSends a HEAD request to the `path` and returns the response as a
Net::HTTPResponse object.

Returns the response.

This method never raises Net::* exceptions.

    response = http.request_head('/index.html')
    p response['content-type']

;T;0;;;I"request_head;F;I"Net::HTTP;T;[o;;I"9::String path, ?::Hash[::String, untyped] initheader;T;I"Net::HTTPResponse;To;;I"üSends a POST request to the `path`.

Returns the response as a Net::HTTPResponse object.

When called with a block, the block is passed an HTTPResponse object.  The
body of that response will not have been read yet; the block can process it
using HTTPResponse#read_body, if desired.

Returns the response.

This method never raises Net::* exceptions.

    # example
    response = http.request_post('/cgi-bin/nice.rb', 'datadatadata...')
    p response.status
    puts response.body          # body is already read in this case

    # using block
    http.request_post('/cgi-bin/nice.rb', 'datadatadata...') {|response|
      p response.status
      p response['content-type']
      response.read_body do |str|   # read body now
        print str
      end
    }

;T;0;;;I"request_post;F;I"Net::HTTP;T;[o;;I"H::String path, ::String data, ?::Hash[::String, untyped] initheader;T;I"Net::HTTPResponse;To;;0;0;;;I"request_put;F;I"Net::HTTP;T;[o;;I"H::String path, ::String data, ?::Hash[::String, untyped] initheader;T;I"Net::HTTPResponse;To;;I"ùSends an HTTP request to the HTTP server. Also sends a DATA string if `data`
is given.

Returns a Net::HTTPResponse object.

This method never raises Net::* exceptions.

    response = http.send_request('GET', '/index.html')
    puts response.body

;T;0;;;I"send_request;F;I"Net::HTTP;T;[o;;I"V::String name, ::String path, ?::String? data, ?::Hash[::String, untyped]? header;T;I"Net::HTTPResponse;To;;I"Sends an HTTPRequest object `req` to the HTTP server.

If `req` is a Net::HTTP::Post or Net::HTTP::Put request containing data, the
data is also sent. Providing data for a Net::HTTP::Head or Net::HTTP::Get
request results in an ArgumentError.

Returns an HTTPResponse object.

When called with a block, passes an HTTPResponse object to the block. The body
of the response will not have been read yet; the block can process it using
HTTPResponse#read_body, if desired.

This method never raises Net::* exceptions.

;T;0;;;I"request;F;I"Net::HTTP;T;[o;;I",::Net::HTTPRequest req, ?::String? body;T;I"Net::HTTPResponse;To; ;I"ÎHTTPGenericRequest is the parent of the Net::HTTPRequest class. Do not use
this directly; use a subclass of Net::HTTPRequest.

Mixes in the Net::HTTPHeader module to provide easier access to HTTP headers.

;T;0;	I"Net::HTTPGenericRequest;T;
[ ;[I"Net::HTTPHeader;T;0;[ ;[ ;0;0o;;I" ;T;0;;;I"initialize;F;I"Net::HTTPGenericRequest;T;[o;;I"~::String m, ::boolish reqbody, ::boolish resbody, ::URI::Generic | ::String uri_or_path, ?::Hash[::String, untyped] initheader;T;I"Net::HTTP;To;;I" ;T;0;;;I"inspect;F;I"Net::HTTPGenericRequest;T;[o;;I" ;F;I"String;To;;0;0;;;I"[]=;F;I"Net::HTTPGenericRequest;T;[o;;I"untyped key, untyped val;T;I"	void;To;;I" ;T;0;;;I"request_body_permitted?;F;I"Net::HTTPGenericRequest;T;[o;;I" ;F;I"	bool;To;;I" ;T;0;;;I"response_body_permitted?;F;I"Net::HTTPGenericRequest;T;[o;;I" ;F;I"	bool;To;;I" ;T;0;;;I"body_exist?;F;I"Net::HTTPGenericRequest;T;[o;;I" ;F;I"	bool;To;;I"[The HTTPHeader module defines methods for reading and writing HTTP headers.

It is used as a mixin by other classes, to provide hash-like access to HTTP
header values. Unlike raw hash access, HTTPHeader provides access via
case-insensitive keys. It also provides methods for accessing commonly-used
HTTP header values in more convenient formats.

;T;0;	I"Net::HTTPHeader;T;
[ ;[ ;0;[ ;[ o;;I" ;T;0;;;I"initialize_http_header;F;I"Net::HTTPHeader;T;[o;;I"(::Hash[untyped, untyped] initheader;T;I"	void;To;;0;0;;;I"	size;F;I"Net::HTTPHeader;T;[o;;I" ;F;I"Integer;To;;I"ƒReturns the header field corresponding to the case-insensitive key. For
example, a key of "Content-Type" might return "text/html"

;T;0;;;I"[];F;I"Net::HTTPHeader;T;[o;;I"::Net::HTTPHeader::key key;T;I"nil | ::String;To;;I"GSets the header field corresponding to the case-insensitive key.

;T;0;;;I"[]=;F;I"Net::HTTPHeader;T;[o;;I",::Net::HTTPHeader::key key, untyped val;T;I"	void;To;;I"”Ruby 1.8.3
:   Adds a value to a named header field, instead of replacing its value.
    Second argument `val` must be a String. See also #[]=, #[] and
    #get_fields.

        request.add_field 'X-My-Header', 'a'
        p request['X-My-Header']              #=> "a"
        p request.get_fields('X-My-Header')   #=> ["a"]
        request.add_field 'X-My-Header', 'b'
        p request['X-My-Header']              #=> "a, b"
        p request.get_fields('X-My-Header')   #=> ["a", "b"]
        request.add_field 'X-My-Header', 'c'
        p request['X-My-Header']              #=> "a, b, c"
        p request.get_fields('X-My-Header')   #=> ["a", "b", "c"]

;T;0;;;I"add_field;F;I"Net::HTTPHeader;T;[o;;I",::Net::HTTPHeader::key key, untyped val;T;I"	void;To;;I" ;T;0;;;I"set_field;F;I"Net::HTTPHeader;T;[o;;I",::Net::HTTPHeader::key key, untyped val;T;I"	void;To;;I" ;T;0;;;I"append_field_value;F;I"Net::HTTPHeader;T;[o;;I"untyped ary, untyped val;T;I"	void;To;;I"Ruby 1.8.3
:   Returns an array of header field strings corresponding to the
    case-insensitive `key`.  This method allows you to get duplicated header
    fields without any processing.  See also #[].

        p response.get_fields('Set-Cookie')
          #=> ["session=al98axx; expires=Fri, 31-Dec-1999 23:58:23",
               "query=rubyscript; expires=Fri, 31-Dec-1999 23:58:23"]
        p response['Set-Cookie']
          #=> "session=al98axx; expires=Fri, 31-Dec-1999 23:58:23, query=rubyscript; expires=Fri, 31-Dec-1999 23:58:23"

;T;0;;;I"get_fields;F;I"Net::HTTPHeader;T;[o;;I"::Net::HTTPHeader::key key;T;I"nil | ::Array[::String];To;;I"ÑReturns the header field corresponding to the case-insensitive key. Returns
the default value `args`, or the result of the block, or raises an IndexError
if there's no header field named `key` See Hash#fetch

;T;0;;;I"
fetch;F;I"Net::HTTPHeader;T;[o;;I"::Net::HTTPHeader::key key;T;I"String;To;;I"(::Net::HTTPHeader::key key, untyped;T;I"untyped;To;;I"::Net::HTTPHeader::key key;T;I"untyped;To;;I"éIterates through the header names and values, passing in the name and value to
the code block supplied.

Returns an enumerator if no block is given.

Example:

    response.header.each_header {|key,value| puts "#{key} = #{value}" }

;T;0;;;I"each_header;F;I"Net::HTTPHeader;T;[o;;I" ;F;I"&Hash[::String, ::Array[::String]];To;;I" ;F;I"LEnumerator[[ ::String, ::String ], ::Hash[::String, ::Array[::String]]];To;;I"‹Iterates through the header names in the header, passing each header name to
the code block.

Returns an enumerator if no block is given.

;T;0;;;I"each_name;F;I"Net::HTTPHeader;T;[o;;I" ;F;I"&Hash[::String, ::Array[::String]];To;;I" ;F;I">Enumerator[::String, ::Hash[::String, ::Array[::String]]];To;;I"Iterates through the header names in the header, passing capitalized header
names to the code block.

Note that header names are capitalized systematically; capitalization may not
match that used by the remote HTTP server in its response.

Returns an enumerator if no block is given.

;T;0;;;I"each_capitalized_name;F;I"Net::HTTPHeader;T;[o;;I" ;F;I"&Hash[::String, ::Array[::String]];To;;I" ;F;I">Enumerator[::String, ::Hash[::String, ::Array[::String]]];To;;I"yIterates through header values, passing each value to the code block.

Returns an enumerator if no block is given.

;T;0;;;I"each_value;F;I"Net::HTTPHeader;T;[o;;I" ;F;I"&Hash[::String, ::Array[::String]];To;;I" ;F;I">Enumerator[::String, ::Hash[::String, ::Array[::String]]];To;;I"ARemoves a header field, specified by case-insensitive key.

;T;0;;;I"delete;F;I"Net::HTTPHeader;T;[o;;I"::Net::HTTPHeader::key key;T;I"Array[::String] | nil;To;;I"#true if `key` header exists.

;T;0;;;I"	key?;F;I"Net::HTTPHeader;T;[o;;I"::Net::HTTPHeader::key key;T;I"	bool;To;;I"¼Returns a Hash consisting of header names and array of values. e.g.
{"cache-control" => ["private"],
    "content-type" => ["text/html"],
    "date" => ["Wed, 22 Jun 2005 22:11:50 GMT"]}

;T;0;;;I"to_hash;F;I"Net::HTTPHeader;T;[o;;I" ;F;I"&Hash[::String, ::Array[::String]];To;;I"ÿAs for #each_header, except the keys are provided in capitalized form.

Note that header names are capitalized systematically; capitalization may not
match that used by the remote HTTP server in its response.

Returns an enumerator if no block is given.

;T;0;;;I"each_capitalized;F;I"Net::HTTPHeader;T;[o;;I" ;F;I"&Hash[::String, ::Array[::String]];To;;I" ;F;I"LEnumerator[[ ::String, ::String ], ::Hash[::String, ::Array[::String]]];To;;I" ;T;0;;;I"capitalize;F;I"Net::HTTPHeader;T;[o;;I" ::Net::HTTPHeader::key name;T;I"String;To;;I"{Returns an Array of Range objects which represent the Range: HTTP header
field, or `nil` if there is no such header.

;T;0;;;I"
range;F;I"Net::HTTPHeader;T;[o;;I" ;F;I"&nil | ::Array[::Range[::Integer]];To;;I"ÃSets the HTTP Range: header. Accepts either a Range object as a single
argument, or a beginning index and a length from that index. Example:

    req.range = (0..1023)
    req.set_range 0, 1023

;T;0;;;I"set_range;F;I"Net::HTTPHeader;T;[o;;I"4::Range[::Integer] | ::Numeric r, ?::Integer? e;T;I"Range[::Integer];To;;I"|Returns an Integer object which represents the HTTP Content-Length: header
field, or `nil` if that field was not provided.

;T;0;;;I"content_length;F;I"Net::HTTPHeader;T;[o;;I" ;F;I"nil | ::Integer;To;;I" ;T;0;;;I"content_length=;F;I"Net::HTTPHeader;T;[o;;I"::Integer len;T;I"	void;To;;I"ÖReturns "true" if the "transfer-encoding" header is present and set to
"chunked".  This is an HTTP/1.1 feature, allowing the content to be sent in
"chunks" without at the outset stating the entire content length.

;T;0;;;I"chunked?;F;I"Net::HTTPHeader;T;[o;;I" ;F;I"	bool;To;;I"ÑReturns a Range object which represents the value of the Content-Range: header
field. For a partial entity body, this indicates where this fragment fits
inside the full entity body, as range of byte offsets.

;T;0;;;I"content_range;F;I"Net::HTTPHeader;T;[o;;I" ;F;I"Range[::Integer] | nil;To;;I"DThe length of the range represented in Content-Range: header.

;T;0;;;I"range_length;F;I"Net::HTTPHeader;T;[o;;I" ;F;I"nil | ::Integer;To;;I"Returns a content type string such as "text/html". This method returns nil if
Content-Type: header field does not exist.

;T;0;;;I"content_type;F;I"Net::HTTPHeader;T;[o;;I" ;F;I"nil | ::String;To;;I"zReturns a content type string such as "text". This method returns nil if
Content-Type: header field does not exist.

;T;0;;;I"main_type;F;I"Net::HTTPHeader;T;[o;;I" ;F;I"nil | ::String;To;;I"ªReturns a content type string such as "html". This method returns nil if
Content-Type: header field does not exist or sub-type is not given (e.g.
"Content-Type: text").

;T;0;;;I"sub_type;F;I"Net::HTTPHeader;T;[o;;I" ;F;I"nil | ::String;To;;I"ÃAny parameters specified for the content type, returned as a Hash. For
example, a header of Content-Type: text/html; charset=EUC-JP would result in
type_params returning {'charset' => 'EUC-JP'}

;T;0;;;I"type_params;F;I"Net::HTTPHeader;T;[o;;I" ;F;I"Hash[untyped, untyped];To;;I"ÛSets the content type in an HTTP header. The `type` should be a full HTTP
content type, e.g. "text/html". The `params` are an optional Hash of
parameters to add after the content type, e.g. {'charset' => 'iso-8859-1'}

;T;0;;;I"set_content_type;F;I"Net::HTTPHeader;T;[o;;I"D::Net::HTTPHeader::key `type`, ?::Hash[untyped, untyped] params;T;I"	void;To;;I"ÔSet header fields and a body from HTML form data. `params` should be an Array
of Arrays or a Hash containing HTML form data. Optional argument `sep` means
data record separator.

Values are URL encoded as necessary and the content-type is set to
application/x-www-form-urlencoded

Example:
    http.form_data = {"q" => "ruby", "lang" => "en"}
    http.form_data = {"q" => ["ruby", "perl"], "lang" => "en"}
    http.set_form_data({"q" => "ruby", "lang" => "en"}, ';')

;T;0;;;I"set_form_data;F;I"Net::HTTPHeader;T;[o;;I"3::Hash[untyped, untyped] params, ?::String sep;T;I"	void;To;;I"@Set an HTML form data set.
`params`
:   The form data to set, which should be an enumerable. See below for more
    details.
`enctype`
:   The content type to use to encode the form submission, which should be
    application/x-www-form-urlencoded or multipart/form-data.
`formopt`
:   An options hash, supporting the following options:
    :boundary
:       The boundary of the multipart message. If not given, a random boundary
        will be used.
    :charset
:       The charset of the form submission. All field names and values of
        non-file fields should be encoded with this charset.



Each item of params should respond to `each` and yield 2-3 arguments, or an
array of 2-3 elements. The arguments yielded should be:
    * The name of the field.
    * The value of the field, it should be a String or a File or IO-like.
    * An options hash, supporting the following options, only
      used for file uploads:
      :filename :: The name of the file to use.
      :content_type :: The content type of the uploaded file.

Each item is a file field or a normal field. If `value` is a File object or
the `opt` hash has a :filename key, the item is treated as a file field.

If Transfer-Encoding is set as chunked, this sends the request using chunked
encoding. Because chunked encoding is HTTP/1.1 feature, you should confirm
that the server supports HTTP/1.1 before using chunked encoding.

Example:
    req.set_form([["q", "ruby"], ["lang", "en"]])

    req.set_form({"f"=>File.open('/path/to/filename')},
                 "multipart/form-data",
                 charset: "UTF-8",
    )

    req.set_form([["f",
                   File.open('/path/to/filename.bar'),
                   {filename: "other-filename.foo"}
                 ]],
                 "multipart/form-data",
    )

See also RFC 2388, RFC 2616, HTML 4.01, and HTML5

;T;0;;;I"set_form;F;I"Net::HTTPHeader;T;[o;;I"Z::Hash[untyped, untyped] params, ?::String enctype, ?::Hash[untyped, untyped] formopt;T;I"	void;To;;I"?Set the Authorization: header for "Basic" authorization.

;T;0;;;I"basic_auth;F;I"Net::HTTPHeader;T;[o;;I"(::String account, ::String password;T;I"	void;To;;I"ASet Proxy-Authorization: header for "Basic" authorization.

;T;0;;;I"proxy_basic_auth;F;I"Net::HTTPHeader;T;[o;;I"(::String account, ::String password;T;I"	void;To;;I" ;T;0;;;I"basic_encode;F;I"Net::HTTPHeader;T;[o;;I"(::String account, ::String password;T;I"String;To;;I" ;T;0;;;I"connection_close?;F;I"Net::HTTPHeader;T;[o;;I" ;F;I"	bool;To;;I" ;T;0;;;I"connection_keep_alive?;F;I"Net::HTTPHeader;T;[o;;I" ;F;I"	bool;To; ;I"ÝHTTP request class. This class wraps together the request header and the
request path. You cannot use this class directly. Instead, you should use one
of its subclasses: Net::HTTP::Get, Net::HTTP::Post, Net::HTTP::Head.

;T;0;	I"Net::HTTPRequest;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPGenericRequest;To;;I"ãCreates an HTTP request object for `path`.

`initheader` are the default headers to use.  Net::HTTP adds Accept-Encoding
to enable compression of the response body unless Accept-Encoding or Range are
supplied in `initheader`.

;T;0;;;I"initialize;F;I"Net::HTTPRequest;T;[o;;I"9::String path, ?::Hash[::String, untyped] initheader;T;I"	void;To;;I">::URI::Generic uri, ?::Hash[::String, untyped] initheader;T;I"	void;To; ;I"`See Net::HTTPGenericRequest for attributes and methods. See Net::HTTP for
usage examples.

;T;0;	I"Net::HTTP::Get;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPRequest;To; ;I"`See Net::HTTPGenericRequest for attributes and methods. See Net::HTTP for
usage examples.

;T;0;	I"Net::HTTP::Head;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPRequest;To; ;I"`See Net::HTTPGenericRequest for attributes and methods. See Net::HTTP for
usage examples.

;T;0;	I"Net::HTTP::Post;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPRequest;To; ;I"`See Net::HTTPGenericRequest for attributes and methods. See Net::HTTP for
usage examples.

;T;0;	I"Net::HTTP::Put;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPRequest;To; ;I"`See Net::HTTPGenericRequest for attributes and methods. See Net::HTTP for
usage examples.

;T;0;	I"Net::HTTP::Delete;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPRequest;To; ;I">See Net::HTTPGenericRequest for attributes and methods.

;T;0;	I"Net::HTTP::Options;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPRequest;To; ;I">See Net::HTTPGenericRequest for attributes and methods.

;T;0;	I"Net::HTTP::Trace;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPRequest;To; ;I">See Net::HTTPGenericRequest for attributes and methods.

;T;0;	I"Net::HTTP::Patch;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPRequest;To; ;I">See Net::HTTPGenericRequest for attributes and methods.

;T;0;	I"Net::HTTP::Propfind;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPRequest;To; ;I">See Net::HTTPGenericRequest for attributes and methods.

;T;0;	I"Net::HTTP::Proppatch;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPRequest;To; ;I">See Net::HTTPGenericRequest for attributes and methods.

;T;0;	I"Net::HTTP::Mkcol;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPRequest;To; ;I">See Net::HTTPGenericRequest for attributes and methods.

;T;0;	I"Net::HTTP::Copy;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPRequest;To; ;I">See Net::HTTPGenericRequest for attributes and methods.

;T;0;	I"Net::HTTP::Move;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPRequest;To; ;I">See Net::HTTPGenericRequest for attributes and methods.

;T;0;	I"Net::HTTP::Lock;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPRequest;To; ;I">See Net::HTTPGenericRequest for attributes and methods.

;T;0;	I"Net::HTTP::Unlock;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPRequest;To; ;I"UHTTP response class.

This class wraps together the response header and the response body (the
entity requested).

It mixes in the HTTPHeader module, which provides access to response header
values both via hash-like methods and via individual readers.

Note that each possible HTTP response code defines its own HTTPResponse
subclass. All classes are defined under the Net module. Indentation indicates
inheritance.  For a list of the classes see Net::HTTP.

Correspondence `HTTP code => class` is stored in CODE_TO_OBJ constant:

    Net::HTTPResponse::CODE_TO_OBJ['404'] #=> Net::HTTPNotFound

;T;0;	I"Net::HTTPResponse;T;
[ ;[I"Net::HTTPHeader;T;0;[ ;[ ;0;0o;;I"'true if the response has a body.

;T;0;;;I"body_permitted?;F;I"Net::HTTPResponse;T;[o;;I" ;F;I"	bool;To;;I" ;T;0;;;I"inspect;F;I"Net::HTTPResponse;T;[o;;I" ;F;I"String;To;;0;0;;;I"code_type;F;I"Net::HTTPResponse;T;[o;;I" ;F;I"untyped;To;;0;0;;;I"error!;F;I"Net::HTTPResponse;T;[o;;I" ;F;I"untyped;To;;0;0;;;I"error_type;F;I"Net::HTTPResponse;T;[o;;I" ;F;I"dNet::HTTPError | ::Net::HTTPServerException | ::Net::HTTPRetriableError | ::Net::HTTPFatalError;To;;I"ARaises an HTTP error if the response is not 2xx (success).

;T;0;;;I"
value;F;I"Net::HTTPResponse;T;[o;;I" ;F;I"nil | untyped;To;;0;0;;;I"	uri=;F;I"Net::HTTPResponse;T;[o;;I"::URI::Generic uri;T;I"	void;To;;I".Gets the entity body returned by the remote HTTP server.

If a block is given, the body is passed to the block, and the body is provided
in fragments, as it is read in from the socket.

If `dest` argument is given, response is read into that variable, with
`dest#<<` method (it could be String or IO, or any other object responding to
`<<`).

Calling this method a second or subsequent time for the same HTTPResponse
object will return the value already read.

    http.request_get('/index.html') {|res|
      puts res.read_body
    }

    http.request_get('/index.html') {|res|
      p res.read_body.object_id   # 538149362
      p res.read_body.object_id   # 538149362
    }

    # using iterator
    http.request_get('/index.html') {|res|
      res.read_body do |segment|
        print segment
      end
    }

;T;0;;;I"read_body;F;I"Net::HTTPResponse;T;[o;;I" ;F;I"String;To;;I"$::Net::HTTPResponse::_Dest dest;T;I"String;To;;I" ;F;I"String;To;;I"?Returns the full entity body.

Calling this method a second or subsequent time will return the string already
read.

    http.request_get('/index.html') {|res|
      puts res.body
    }

    http.request_get('/index.html') {|res|
      p res.body.object_id   # 538149362
      p res.body.object_id   # 538149362
    }

;T;0;;;I"	body;F;I"Net::HTTPResponse;T;[o;;I" ;F;I"String;To;;I"fBecause it may be necessary to modify the body, Eg, decompression this method
facilitates that.

;T;0;;;I"
body=;F;I"Net::HTTPResponse;T;[o;;I"untyped value;T;I"	void;To; ;I"UHTTP response class.

This class wraps together the response header and the response body (the
entity requested).

It mixes in the HTTPHeader module, which provides access to response header
values both via hash-like methods and via individual readers.

Note that each possible HTTP response code defines its own HTTPResponse
subclass. All classes are defined under the Net module. Indentation indicates
inheritance.  For a list of the classes see Net::HTTP.

Correspondence `HTTP code => class` is stored in CODE_TO_OBJ constant:

    Net::HTTPResponse::CODE_TO_OBJ['404'] #=> Net::HTTPNotFound

;T;0;	I"Net::HTTPResponse;T;
[ ;[ ;0;[ ;[ ;0;0o; ;I"Qhttps://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml

;T;0;	I"Net::HTTPUnknownResponse;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPResponse;To; ;0;0;	I"Net::HTTPInformation;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPResponse;To; ;0;0;	I"Net::HTTPSuccess;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPResponse;To; ;0;0;	I"Net::HTTPRedirection;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPResponse;To; ;0;0;	I"Net::HTTPClientError;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPResponse;To; ;0;0;	I"Net::HTTPServerError;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPResponse;To; ;0;0;	I"Net::HTTPContinue;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPInformation;To; ;0;0;	I"Net::HTTPSwitchProtocol;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPInformation;To; ;0;0;	I"Net::HTTPProcessing;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPInformation;To; ;0;0;	I"Net::HTTPEarlyHints;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPInformation;To; ;0;0;	I"Net::HTTPOK;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPSuccess;To; ;0;0;	I"Net::HTTPCreated;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPSuccess;To; ;0;0;	I"Net::HTTPAccepted;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPSuccess;To; ;0;0;	I")Net::HTTPNonAuthoritativeInformation;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPSuccess;To; ;0;0;	I"Net::HTTPNoContent;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPSuccess;To; ;0;0;	I"Net::HTTPResetContent;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPSuccess;To; ;0;0;	I"Net::HTTPPartialContent;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPSuccess;To; ;0;0;	I"Net::HTTPMultiStatus;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPSuccess;To; ;0;0;	I"Net::HTTPAlreadyReported;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPSuccess;To; ;0;0;	I"Net::HTTPIMUsed;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPSuccess;To; ;0;0;	I"Net::HTTPMultipleChoices;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPRedirection;To; ;0;0;	I"Net::HTTPMovedPermanently;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPRedirection;To; ;0;0;	I"Net::HTTPFound;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPRedirection;To; ;0;0;	I"Net::HTTPSeeOther;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPRedirection;To; ;0;0;	I"Net::HTTPNotModified;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPRedirection;To; ;0;0;	I"Net::HTTPUseProxy;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPRedirection;To; ;I"*306 Switch Proxy - no longer unused

;T;0;	I"Net::HTTPTemporaryRedirect;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPRedirection;To; ;0;0;	I"Net::HTTPPermanentRedirect;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPRedirection;To; ;0;0;	I"Net::HTTPBadRequest;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPClientError;To; ;0;0;	I"Net::HTTPUnauthorized;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPClientError;To; ;0;0;	I"Net::HTTPPaymentRequired;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPClientError;To; ;0;0;	I"Net::HTTPForbidden;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPClientError;To; ;0;0;	I"Net::HTTPNotFound;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPClientError;To; ;0;0;	I"Net::HTTPMethodNotAllowed;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPClientError;To; ;0;0;	I"Net::HTTPNotAcceptable;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPClientError;To; ;0;0;	I")Net::HTTPProxyAuthenticationRequired;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPClientError;To; ;0;0;	I"Net::HTTPRequestTimeout;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPClientError;To; ;0;0;	I"Net::HTTPConflict;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPClientError;To; ;0;0;	I"Net::HTTPGone;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPClientError;To; ;0;0;	I"Net::HTTPLengthRequired;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPClientError;To; ;0;0;	I" Net::HTTPPreconditionFailed;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPClientError;To; ;0;0;	I"Net::HTTPPayloadTooLarge;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPClientError;To; ;0;0;	I"Net::HTTPURITooLong;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPClientError;To; ;0;0;	I""Net::HTTPUnsupportedMediaType;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPClientError;To; ;0;0;	I"!Net::HTTPRangeNotSatisfiable;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPClientError;To; ;0;0;	I"Net::HTTPExpectationFailed;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPClientError;To; ;I"N418 I'm a teapot - RFC 2324; a joke RFC 420 Enhance Your Calm - Twitter

;T;0;	I" Net::HTTPMisdirectedRequest;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPClientError;To; ;0;0;	I"!Net::HTTPUnprocessableEntity;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPClientError;To; ;0;0;	I"Net::HTTPLocked;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPClientError;To; ;0;0;	I"Net::HTTPFailedDependency;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPClientError;To; ;I"7425 Unordered Collection - existed only in draft

;T;0;	I"Net::HTTPUpgradeRequired;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPClientError;To; ;0;0;	I""Net::HTTPPreconditionRequired;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPClientError;To; ;0;0;	I"Net::HTTPTooManyRequests;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPClientError;To; ;0;0;	I")Net::HTTPRequestHeaderFieldsTooLarge;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPClientError;To; ;0;0;	I"(Net::HTTPUnavailableForLegalReasons;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPClientError;To; ;I"‹444 No Response - Nginx 449 Retry With - Microsoft 450 Blocked by Windows
Parental Controls - Microsoft 499 Client Closed Request - Nginx

;T;0;	I"!Net::HTTPInternalServerError;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPServerError;To; ;0;0;	I"Net::HTTPNotImplemented;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPServerError;To; ;0;0;	I"Net::HTTPBadGateway;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPServerError;To; ;0;0;	I" Net::HTTPServiceUnavailable;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPServerError;To; ;0;0;	I"Net::HTTPGatewayTimeout;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPServerError;To; ;0;0;	I"!Net::HTTPVersionNotSupported;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPServerError;To; ;0;0;	I"#Net::HTTPVariantAlsoNegotiates;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPServerError;To; ;0;0;	I"!Net::HTTPInsufficientStorage;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPServerError;To; ;0;0;	I"Net::HTTPLoopDetected;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPServerError;To; ;I"A509 Bandwidth Limit Exceeded - Apache bw/limited extension

;T;0;	I"Net::HTTPNotExtended;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPServerError;To; ;0;0;	I"+Net::HTTPNetworkAuthenticationRequired;T;
[ ;[ ;0;[ ;[ ;0;I"Net::HTTPServerError;To;;I"tNet::HTTP exception class. You cannot use Net::HTTPExceptions directly;
instead, you must use its subclasses.

;T;0;	I"Net::HTTPExceptions;T;
[ ;[ ;0;[ ;[ o;;0;0;;;I"initialize;F;I"Net::HTTPExceptions;T;[o;;I"untyped msg, untyped res;T;I"untyped;To; ;0;0;	I"Net::HTTPError;T;
[ ;[I"Net::HTTPExceptions;T;0;[ ;[ ;0;I"Net::ProtocolError;To; ;0;0;	I"Net::HTTPRetriableError;T;
[ ;[I"Net::HTTPExceptions;T;0;[ ;[ ;0;I"Net::ProtoRetriableError;To; ;0;0;	I"Net::HTTPServerException;T;
[ ;[I"Net::HTTPExceptions;T;0;[ ;[ ;0;I"Net::ProtoServerError;To; ;0;0;	I"Net::HTTPFatalError;T;
[ ;[I"Net::HTTPExceptions;T;0;[ ;[ ;0;I"Net::ProtoFatalError;To;;I"
NKF - Ruby extension for Network Kanji Filter

## Description

This is a Ruby Extension version of nkf (Network Kanji Filter). It converts
the first argument and returns converted result. Conversion details are
specified by flags as the first argument.

**Nkf** is a yet another kanji code converter among networks, hosts and
terminals. It converts input kanji code to designated kanji code such as
ISO-2022-JP, Shift_JIS, EUC-JP, UTF-8 or UTF-16.

One of the most unique faculty of **nkf** is the guess of the input kanji
encodings. It currently recognizes ISO-2022-JP, Shift_JIS, EUC-JP, UTF-8 and
UTF-16. So users needn't set the input kanji code explicitly.

By default, X0201 kana is converted into X0208 kana. For X0201 kana, SO/SI,
SSO and ESC-(-I methods are supported. For automatic code detection, nkf
assumes no X0201 kana in Shift_JIS. To accept X0201 in Shift_JIS, use **-X**,
**-x** or **-S**.

## Flags

### -b -u

Output is buffered (DEFAULT), Output is unbuffered.

### -j -s -e -w -w16 -w32

Output code is ISO-2022-JP (7bit JIS), Shift_JIS, EUC-JP, UTF-8N, UTF-16BE,
UTF-32BE. Without this option and compile option, ISO-2022-JP is assumed.

### -J -S -E -W -W16 -W32

Input assumption is JIS 7 bit, Shift_JIS, EUC-JP, UTF-8, UTF-16, UTF-32.

#### -J

Assume  JIS input. It also accepts EUC-JP. This is the default. This flag does
not exclude Shift_JIS.

#### -S

Assume Shift_JIS and X0201 kana input. It also accepts JIS. EUC-JP is
recognized as X0201 kana. Without **-x** flag, X0201 kana (halfwidth kana) is
converted into X0208.

#### -E

Assume EUC-JP input. It also accepts JIS. Same as -J.

### -t

No conversion.

### -i_

Output sequence to designate JIS-kanji. (DEFAULT B)

### -o_

Output sequence to designate ASCII. (DEFAULT B)

### -r

{de/en}crypt ROT13/47

### -[h](123) --hiragana --katakana --katakana-hiragana

-h1 --hiragana
:   Katakana to Hiragana conversion.

-h2 --katakana
:   Hiragana to Katakana conversion.

-h3 --katakana-hiragana
:   Katakana to Hiragana and Hiragana to Katakana conversion.


### -T

Text mode output (MS-DOS)

### -l

ISO8859-1 (Latin-1) support

### -f[`m` [- `n`]]

Folding on `m` length with `n` margin in a line. Without this option, fold
length is 60 and fold margin is 10.

### -F

New line preserving line folding.

### -[Z](0-3)

Convert X0208 alphabet (Fullwidth Alphabets) to ASCII.

-Z -Z0
:   Convert X0208 alphabet to ASCII.

-Z1
:   Converts X0208 kankaku to single ASCII space.

-Z2
:   Converts X0208 kankaku to double ASCII spaces.

-Z3
:   Replacing Fullwidth >, <, ", & into '&gt;', '&lt;', '&quot;', '&amp;' as
    in HTML.


### -X -x

Assume X0201 kana in MS-Kanji. With **-X** or without this option, X0201 is
converted into X0208 Kana. With **-x**, try to preserve X0208 kana and do not
convert X0201 kana to X0208. In JIS output, ESC-(-I is used. In EUC output,
SSO is used.

### -[B](0-2)

Assume broken JIS-Kanji input, which lost ESC. Useful when your site is using
old B-News Nihongo patch.

-B1
:   allows any char after ESC-( or ESC-$.

-B2
:   forces ASCII after NL.


### -I

Replacing non iso-2022-jp char into a geta character (substitute character in
Japanese).

### -d -c

Delete r in line feed, Add r in line feed.

### -[m](BQN0)

MIME ISO-2022-JP/ISO8859-1 decode. (DEFAULT) To see ISO8859-1 (Latin-1) -l is
necessary.

-mB
:   Decode MIME base64 encoded stream. Remove header or other part before

conversion.

-mQ
:   Decode MIME quoted stream. '_' in quoted stream is converted to space.

-mN
:   Non-strict decoding.

It allows line break in the middle of the base64 encoding.

-m0
:   No MIME decode.


### -M

MIME encode. Header style. All ASCII code and control characters are intact.
Kanji conversion is performed before encoding, so this cannot be used as a
picture encoder.

-MB
:   MIME encode Base64 stream.

-MQ
:   Perform quoted encoding.


### -l

Input and output code is ISO8859-1 (Latin-1) and ISO-2022-JP. **-s**, **-e**
and **-x** are not compatible with this option.

### -[L](uwm)

new line mode Without this option, nkf doesn't convert line breaks.

-Lu
:   unix (LF)

-Lw
:   windows (CRLF)

-Lm
:   mac (CR)


### --fj --unix --mac --msdos --windows

convert for these system

### --jis --euc --sjis --mime --base64

convert for named code

### --jis-input --euc-input --sjis-input --mime-input --base64-input

assume input system

### --ic=`input codeset` --oc=`output codeset`

Set the input or output codeset. NKF supports following codesets and those
codeset name are case insensitive.

ISO-2022-JP
:   a.k.a. RFC1468, 7bit JIS, JUNET

EUC-JP (eucJP-nkf)
:   a.k.a. AT&T JIS, Japanese EUC, UJIS

eucJP-ascii
:   a.k.a. x-eucjp-open-19970715-ascii

eucJP-ms
:   a.k.a. x-eucjp-open-19970715-ms

CP51932
:   Microsoft Version of EUC-JP.

Shift_JIS
:   SJIS, MS-Kanji

Windows-31J
:   a.k.a. CP932

UTF-8
:   same as UTF-8N

UTF-8N
:   UTF-8 without BOM

UTF-8-BOM
:   UTF-8 with BOM

UTF-16
:   same as UTF-16BE

UTF-16BE
:   UTF-16 Big Endian without BOM

UTF-16BE-BOM
:   UTF-16 Big Endian with BOM

UTF-16LE
:   UTF-16 Little Endian without BOM

UTF-16LE-BOM
:   UTF-16 Little Endian with BOM

UTF-32
:   same as UTF-32BE

UTF-32BE
:   UTF-32 Big Endian without BOM

UTF-32BE-BOM
:   UTF-32 Big Endian with BOM

UTF-32LE
:   UTF-32 Little Endian without BOM

UTF-32LE-BOM
:   UTF-32 Little Endian with BOM

UTF8-MAC
:   NKDed UTF-8, a.k.a. UTF8-NFD (input only)


### --fb-{skip, html, xml, perl, java, subchar}

Specify the way that nkf handles unassigned characters. Without this option,
--fb-skip is assumed.

### --prefix= `escape character` `target character` ..

When nkf converts to Shift_JIS, nkf adds a specified escape character to
specified 2nd byte of Shift_JIS characters. 1st byte of argument is the escape
character and following bytes are target characters.

### --no-cp932ext

Handle the characters extended in CP932 as unassigned characters.

## --no-best-fit-chars

When Unicode to Encoded byte conversion, don't convert characters which is not
round trip safe. When Unicode to Unicode conversion, with this and -x option,
nkf can be used as UTF converter. (In other words, without this and -x option,
nkf doesn't save some characters)

When nkf convert string which related to path, you should use this option.

### --cap-input

Decode hex encoded characters.

### --url-input

Unescape percent escaped characters.

### --

Ignore rest of -option.

;T;0;	I"NKF;T;
[ ;[ ;0;[ ;[ o;;I"8Returns guessed encoding of *str* by nkf routine.

;T;0;;;I"
guess;F;I"NKF;T;[o;;I"::String str;T;I"Encoding;To;;I"–Convert *str* and return converted result. Conversion details are specified by
*opt* as String.

    require 'nkf'
    output = NKF.nkf("-s", input)

;T;0;;;I"nkf;F;I"NKF;T;[o;;I"::String opt, ::String str;T;I"String;To;;I"L:OpenSSL provides SSL, TLS and general purpose cryptography.  It wraps the
[OpenSSL](https://www.openssl.org/) library.

# Examples

All examples assume you have loaded OpenSSL with:

    require 'openssl'

These examples build atop each other.  For example the key created in the next
is used in throughout these examples.

## Keys

### Creating a Key

This example creates a 2048 bit RSA keypair and writes it to the current
directory.

    key = OpenSSL::PKey::RSA.new 2048

    open 'private_key.pem', 'w' do |io| io.write key.to_pem end
    open 'public_key.pem', 'w' do |io| io.write key.public_key.to_pem end

### Exporting a Key

Keys saved to disk without encryption are not secure as anyone who gets ahold
of the key may use it unless it is encrypted.  In order to securely export a
key you may export it with a pass phrase.

    cipher = OpenSSL::Cipher.new 'aes-256-cbc'
    pass_phrase = 'my secure pass phrase goes here'

    key_secure = key.export cipher, pass_phrase

    open 'private.secure.pem', 'w' do |io|
      io.write key_secure
    end

OpenSSL::Cipher.ciphers returns a list of available ciphers.

### Loading a Key

A key can also be loaded from a file.

    key2 = OpenSSL::PKey.read File.read 'private_key.pem'
    key2.public? # => true
    key2.private? # => true

or

    key3 = OpenSSL::PKey.read File.read 'public_key.pem'
    key3.public? # => true
    key3.private? # => false

### Loading an Encrypted Key

OpenSSL will prompt you for your pass phrase when loading an encrypted key. If
you will not be able to type in the pass phrase you may provide it when
loading the key:

    key4_pem = File.read 'private.secure.pem'
    pass_phrase = 'my secure pass phrase goes here'
    key4 = OpenSSL::PKey.read key4_pem, pass_phrase

## RSA Encryption

RSA provides encryption and decryption using the public and private keys. You
can use a variety of padding methods depending upon the intended use of
encrypted data.

### Encryption & Decryption

Asymmetric public/private key encryption is slow and victim to attack in cases
where it is used without padding or directly to encrypt larger chunks of data.
Typical use cases for RSA encryption involve "wrapping" a symmetric key with
the public key of the recipient who would "unwrap" that symmetric key again
using their private key. The following illustrates a simplified example of
such a key transport scheme. It shouldn't be used in practice, though,
standardized protocols should always be preferred.

    wrapped_key = key.public_encrypt key

A symmetric key encrypted with the public key can only be decrypted with the
corresponding private key of the recipient.

    original_key = key.private_decrypt wrapped_key

By default PKCS#1 padding will be used, but it is also possible to use other
forms of padding, see PKey::RSA for further details.

### Signatures

Using "private_encrypt" to encrypt some data with the private key is
equivalent to applying a digital signature to the data. A verifying party may
validate the signature by comparing the result of decrypting the signature
with "public_decrypt" to the original data. However, OpenSSL::PKey already has
methods "sign" and "verify" that handle digital signatures in a standardized
way - "private_encrypt" and "public_decrypt" shouldn't be used in practice.

To sign a document, a cryptographically secure hash of the document is
computed first, which is then signed using the private key.

    signature = key.sign 'SHA256', document

To validate the signature, again a hash of the document is computed and the
signature is decrypted using the public key. The result is then compared to
the hash just computed, if they are equal the signature was valid.

    if key.verify 'SHA256', signature, document
      puts 'Valid'
    else
      puts 'Invalid'
    end

## PBKDF2 Password-based Encryption

If supported by the underlying OpenSSL version used, Password-based Encryption
should use the features of PKCS5. If not supported or if required by legacy
applications, the older, less secure methods specified in RFC 2898 are also
supported (see below).

PKCS5 supports PBKDF2 as it was specified in PKCS#5
[v2.0](http://www.rsa.com/rsalabs/node.asp?id=2127). It still uses a password,
a salt, and additionally a number of iterations that will slow the key
derivation process down. The slower this is, the more work it requires being
able to brute-force the resulting key.

### Encryption

The strategy is to first instantiate a Cipher for encryption, and then to
generate a random IV plus a key derived from the password using PBKDF2. PKCS
#5 v2.0 recommends at least 8 bytes for the salt, the number of iterations
largely depends on the hardware being used.

    cipher = OpenSSL::Cipher.new 'aes-256-cbc'
    cipher.encrypt
    iv = cipher.random_iv

    pwd = 'some hopefully not to easily guessable password'
    salt = OpenSSL::Random.random_bytes 16
    iter = 20000
    key_len = cipher.key_len
    digest = OpenSSL::Digest.new('SHA256')

    key = OpenSSL::PKCS5.pbkdf2_hmac(pwd, salt, iter, key_len, digest)
    cipher.key = key

    Now encrypt the data:

    encrypted = cipher.update document
    encrypted << cipher.final

### Decryption

Use the same steps as before to derive the symmetric AES key, this time
setting the Cipher up for decryption.

    cipher = OpenSSL::Cipher.new 'aes-256-cbc'
    cipher.decrypt
    cipher.iv = iv # the one generated with #random_iv

    pwd = 'some hopefully not to easily guessable password'
    salt = ... # the one generated above
    iter = 20000
    key_len = cipher.key_len
    digest = OpenSSL::Digest.new('SHA256')

    key = OpenSSL::PKCS5.pbkdf2_hmac(pwd, salt, iter, key_len, digest)
    cipher.key = key

    Now decrypt the data:

    decrypted = cipher.update encrypted
    decrypted << cipher.final

## PKCS #5 Password-based Encryption

PKCS #5 is a password-based encryption standard documented at
[RFC2898](http://www.ietf.org/rfc/rfc2898.txt).  It allows a short password or
passphrase to be used to create a secure encryption key. If possible, PBKDF2
as described above should be used if the circumstances allow it.

PKCS #5 uses a Cipher, a pass phrase and a salt to generate an encryption key.

    pass_phrase = 'my secure pass phrase goes here'
    salt = '8 octets'

### Encryption

First set up the cipher for encryption

    encryptor = OpenSSL::Cipher.new 'aes-256-cbc'
    encryptor.encrypt
    encryptor.pkcs5_keyivgen pass_phrase, salt

Then pass the data you want to encrypt through

    encrypted = encryptor.update 'top secret document'
    encrypted << encryptor.final

### Decryption

Use a new Cipher instance set up for decryption

    decryptor = OpenSSL::Cipher.new 'aes-256-cbc'
    decryptor.decrypt
    decryptor.pkcs5_keyivgen pass_phrase, salt

Then pass the data you want to decrypt through

    plain = decryptor.update encrypted
    plain << decryptor.final

## X509 Certificates

### Creating a Certificate

This example creates a self-signed certificate using an RSA key and a SHA1
signature.

    key = OpenSSL::PKey::RSA.new 2048
    name = OpenSSL::X509::Name.parse '/CN=nobody/DC=example'

    cert = OpenSSL::X509::Certificate.new
    cert.version = 2
    cert.serial = 0
    cert.not_before = Time.now
    cert.not_after = Time.now + 3600

    cert.public_key = key.public_key
    cert.subject = name

### Certificate Extensions

You can add extensions to the certificate with OpenSSL::SSL::ExtensionFactory
to indicate the purpose of the certificate.

    extension_factory = OpenSSL::X509::ExtensionFactory.new nil, cert

    cert.add_extension \
      extension_factory.create_extension('basicConstraints', 'CA:FALSE', true)

    cert.add_extension \
      extension_factory.create_extension(
        'keyUsage', 'keyEncipherment,dataEncipherment,digitalSignature')

    cert.add_extension \
      extension_factory.create_extension('subjectKeyIdentifier', 'hash')

The list of supported extensions (and in some cases their possible values) can
be derived from the "objects.h" file in the OpenSSL source code.

### Signing a Certificate

To sign a certificate set the issuer and use OpenSSL::X509::Certificate#sign
with a digest algorithm.  This creates a self-signed cert because we're using
the same name and key to sign the certificate as was used to create the
certificate.

    cert.issuer = name
    cert.sign key, OpenSSL::Digest.new('SHA1')

    open 'certificate.pem', 'w' do |io| io.write cert.to_pem end

### Loading a Certificate

Like a key, a cert can also be loaded from a file.

    cert2 = OpenSSL::X509::Certificate.new File.read 'certificate.pem'

### Verifying a Certificate

Certificate#verify will return true when a certificate was signed with the
given public key.

    raise 'certificate can not be verified' unless cert2.verify key

## Certificate Authority

A certificate authority (CA) is a trusted third party that allows you to
verify the ownership of unknown certificates.  The CA issues key signatures
that indicate it trusts the user of that key.  A user encountering the key can
verify the signature by using the CA's public key.

### CA Key

CA keys are valuable, so we encrypt and save it to disk and make sure it is
not readable by other users.

    ca_key = OpenSSL::PKey::RSA.new 2048
    pass_phrase = 'my secure pass phrase goes here'

    cipher = OpenSSL::Cipher.new 'aes-256-cbc'

    open 'ca_key.pem', 'w', 0400 do |io|
      io.write ca_key.export(cipher, pass_phrase)
    end

### CA Certificate

A CA certificate is created the same way we created a certificate above, but
with different extensions.

    ca_name = OpenSSL::X509::Name.parse '/CN=ca/DC=example'

    ca_cert = OpenSSL::X509::Certificate.new
    ca_cert.serial = 0
    ca_cert.version = 2
    ca_cert.not_before = Time.now
    ca_cert.not_after = Time.now + 86400

    ca_cert.public_key = ca_key.public_key
    ca_cert.subject = ca_name
    ca_cert.issuer = ca_name

    extension_factory = OpenSSL::X509::ExtensionFactory.new
    extension_factory.subject_certificate = ca_cert
    extension_factory.issuer_certificate = ca_cert

    ca_cert.add_extension \
      extension_factory.create_extension('subjectKeyIdentifier', 'hash')

This extension indicates the CA's key may be used as a CA.

    ca_cert.add_extension \
      extension_factory.create_extension('basicConstraints', 'CA:TRUE', true)

This extension indicates the CA's key may be used to verify signatures on both
certificates and certificate revocations.

    ca_cert.add_extension \
      extension_factory.create_extension(
        'keyUsage', 'cRLSign,keyCertSign', true)

Root CA certificates are self-signed.

    ca_cert.sign ca_key, OpenSSL::Digest.new('SHA1')

The CA certificate is saved to disk so it may be distributed to all the users
of the keys this CA will sign.

    open 'ca_cert.pem', 'w' do |io|
      io.write ca_cert.to_pem
    end

### Certificate Signing Request

The CA signs keys through a Certificate Signing Request (CSR).  The CSR
contains the information necessary to identify the key.

    csr = OpenSSL::X509::Request.new
    csr.version = 0
    csr.subject = name
    csr.public_key = key.public_key
    csr.sign key, OpenSSL::Digest.new('SHA1')

A CSR is saved to disk and sent to the CA for signing.

    open 'csr.pem', 'w' do |io|
      io.write csr.to_pem
    end

### Creating a Certificate from a CSR

Upon receiving a CSR the CA will verify it before signing it.  A minimal
verification would be to check the CSR's signature.

    csr = OpenSSL::X509::Request.new File.read 'csr.pem'

    raise 'CSR can not be verified' unless csr.verify csr.public_key

After verification a certificate is created, marked for various usages, signed
with the CA key and returned to the requester.

    csr_cert = OpenSSL::X509::Certificate.new
    csr_cert.serial = 0
    csr_cert.version = 2
    csr_cert.not_before = Time.now
    csr_cert.not_after = Time.now + 600

    csr_cert.subject = csr.subject
    csr_cert.public_key = csr.public_key
    csr_cert.issuer = ca_cert.subject

    extension_factory = OpenSSL::X509::ExtensionFactory.new
    extension_factory.subject_certificate = csr_cert
    extension_factory.issuer_certificate = ca_cert

    csr_cert.add_extension \
      extension_factory.create_extension('basicConstraints', 'CA:FALSE')

    csr_cert.add_extension \
      extension_factory.create_extension(
        'keyUsage', 'keyEncipherment,dataEncipherment,digitalSignature')

    csr_cert.add_extension \
      extension_factory.create_extension('subjectKeyIdentifier', 'hash')

    csr_cert.sign ca_key, OpenSSL::Digest.new('SHA1')

    open 'csr_cert.pem', 'w' do |io|
      io.write csr_cert.to_pem
    end

## SSL and TLS Connections

Using our created key and certificate we can create an SSL or TLS connection.
An SSLContext is used to set up an SSL session.

    context = OpenSSL::SSL::SSLContext.new

### SSL Server

An SSL server requires the certificate and private key to communicate securely
with its clients:

    context.cert = cert
    context.key = key

Then create an SSLServer with a TCP server socket and the context.  Use the
SSLServer like an ordinary TCP server.

    require 'socket'

    tcp_server = TCPServer.new 5000
    ssl_server = OpenSSL::SSL::SSLServer.new tcp_server, context

    loop do
      ssl_connection = ssl_server.accept

      data = ssl_connection.gets

      response = "I got #{data.dump}"
      puts response

      ssl_connection.puts "I got #{data.dump}"
      ssl_connection.close
    end

### SSL client

An SSL client is created with a TCP socket and the context. SSLSocket#connect
must be called to initiate the SSL handshake and start encryption.  A key and
certificate are not required for the client socket.

Note that SSLSocket#close doesn't close the underlying socket by default. Set
SSLSocket#sync_close to true if you want.

    require 'socket'

    tcp_socket = TCPSocket.new 'localhost', 5000
    ssl_client = OpenSSL::SSL::SSLSocket.new tcp_socket, context
    ssl_client.sync_close = true
    ssl_client.connect

    ssl_client.puts "hello server!"
    puts ssl_client.gets

    ssl_client.close # shutdown the TLS connection and close tcp_socket

### Peer Verification

An unverified SSL connection does not provide much security.  For enhanced
security the client or server can verify the certificate of its peer.

The client can be modified to verify the server's certificate against the
certificate authority's certificate:

    context.ca_file = 'ca_cert.pem'
    context.verify_mode = OpenSSL::SSL::VERIFY_PEER

    require 'socket'

    tcp_socket = TCPSocket.new 'localhost', 5000
    ssl_client = OpenSSL::SSL::SSLSocket.new tcp_socket, context
    ssl_client.connect

    ssl_client.puts "hello server!"
    puts ssl_client.gets

If the server certificate is invalid or `context.ca_file` is not set when
verifying peers an OpenSSL::SSL::SSLError will be raised.

;T;0;	I"OpenSSL;T;
[ ;[ ;0;[ ;[ o;;I"µReturns a Digest subclass by *name*

    require 'openssl'

    OpenSSL::Digest("MD5")
    # => OpenSSL::Digest::MD5

    Digest("Foo")
    # => NameError: wrong constant name Foo

;T;0;;;I"Digest;F;I"OpenSSL;T;[o;;I"::String name;T;I"!singleton(::OpenSSL::Digest);To;;I" ;T;0;;;I"
debug;F;I"OpenSSL;T;[o;;I" ;F;I"	bool;To;;I"zTurns on or off debug mode. With debug mode, all errors added to the OpenSSL
error queue will be printed to stderr.

;T;0;;;I"debug=;F;I"OpenSSL;T;[o;;I"::boolish;T;I"U;Fo;;I"~See any remaining errors held in queue.

Any errors you see here are probably due to a bug in Ruby's OpenSSL
implementation.

;T;0;;;I"errors;F;I"OpenSSL;T;[o;;I" ;F;I"Array[::String];To;;I" ;T;0;;;I"fips_mode;F;I"OpenSSL;T;[o;;I" ;F;I"	bool;To;;I".Turns FIPS mode on or off. Turning on FIPS mode will obviously only have an
effect for FIPS-capable installations of the OpenSSL library. Trying to do so
otherwise will result in an error.

### Examples
    OpenSSL.fips_mode = true   # turn FIPS mode on
    OpenSSL.fips_mode = false  # and off again

;T;0;;;I"fips_mode=;F;I"OpenSSL;T;[o;;I"::boolish;T;I"U;Fo;;I" Constant time memory comparison for fixed length strings, such as results of
HMAC calculations.

Returns `true` if the strings are identical, `false` if they are of the same
length but not identical. If the length is different, `ArgumentError` is
raised.

;T;0;;;I" fixed_length_secure_compare;F;I"OpenSSL;T;[o;;I"::String, ::String;T;I"	bool;To;;I"¤Constant time memory comparison. Inputs are hashed using SHA-256 to mask the
length of the secret. Returns `true` if the strings are identical, `false`
otherwise.

;T;0;;;I"secure_compare;F;I"OpenSSL;T;[o;;I"::String a, ::String b;T;I"	bool;To;;I"FAbstract Syntax Notation One (or ASN.1) is a notation syntax to describe data
structures and is defined in ITU-T X.680. ASN.1 itself does not mandate any
encoding or parsing rules, but usually ASN.1 data structures are encoded using
the Distinguished Encoding Rules (DER) or less often the Basic Encoding Rules
(BER) described in ITU-T X.690. DER and BER encodings are binary
Tag-Length-Value (TLV) encodings that are quite concise compared to other
popular data description formats such as XML, JSON etc. ASN.1 data structures
are very common in cryptographic applications, e.g. X.509 public key
certificates or certificate revocation lists (CRLs) are all defined in ASN.1
and DER-encoded. ASN.1, DER and BER are the building blocks of applied
cryptography. The ASN1 module provides the necessary classes that allow
generation of ASN.1 data structures and the methods to encode them using a DER
encoding. The decode method allows parsing arbitrary BER-/DER-encoded data to
a Ruby object that can then be modified and re-encoded at will.

## ASN.1 class hierarchy

The base class representing ASN.1 structures is ASN1Data. ASN1Data offers
attributes to read and set the *tag*, the *tag_class* and finally the *value*
of a particular ASN.1 item. Upon parsing, any tagged values (implicit or
explicit) will be represented by ASN1Data instances because their "real type"
can only be determined using out-of-band information from the ASN.1 type
declaration. Since this information is normally known when encoding a type,
all sub-classes of ASN1Data offer an additional attribute *tagging* that
allows to encode a value implicitly (`:IMPLICIT`) or explicitly (`:EXPLICIT`).

### Constructive

Constructive is, as its name implies, the base class for all constructed
encodings, i.e. those that consist of several values, opposed to "primitive"
encodings with just one single value. The value of an Constructive is always
an Array.

#### ASN1::Set and ASN1::Sequence

The most common constructive encodings are SETs and SEQUENCEs, which is why
there are two sub-classes of Constructive representing each of them.

### Primitive

This is the super class of all primitive values. Primitive itself is not used
when parsing ASN.1 data, all values are either instances of a corresponding
sub-class of Primitive or they are instances of ASN1Data if the value was
tagged implicitly or explicitly. Please cf. Primitive documentation for
details on sub-classes and their respective mappings of ASN.1 data types to
Ruby objects.

## Possible values for *tagging*

When constructing an ASN1Data object the ASN.1 type definition may require
certain elements to be either implicitly or explicitly tagged. This can be
achieved by setting the *tagging* attribute manually for sub-classes of
ASN1Data. Use the symbol `:IMPLICIT` for implicit tagging and `:EXPLICIT` if
the element requires explicit tagging.

## Possible values for *tag_class*

It is possible to create arbitrary ASN1Data objects that also support a
PRIVATE or APPLICATION tag class. Possible values for the *tag_class*
attribute are:
*   `:UNIVERSAL` (the default for untagged values)
*   `:CONTEXT_SPECIFIC` (the default for tagged values)
*   `:APPLICATION`
*   `:PRIVATE`


## Tag constants

There is a constant defined for each universal tag:
*   OpenSSL::ASN1::EOC (0)
*   OpenSSL::ASN1::BOOLEAN (1)
*   OpenSSL::ASN1::INTEGER (2)
*   OpenSSL::ASN1::BIT_STRING (3)
*   OpenSSL::ASN1::OCTET_STRING (4)
*   OpenSSL::ASN1::NULL (5)
*   OpenSSL::ASN1::OBJECT (6)
*   OpenSSL::ASN1::ENUMERATED (10)
*   OpenSSL::ASN1::UTF8STRING (12)
*   OpenSSL::ASN1::SEQUENCE (16)
*   OpenSSL::ASN1::SET (17)
*   OpenSSL::ASN1::NUMERICSTRING (18)
*   OpenSSL::ASN1::PRINTABLESTRING (19)
*   OpenSSL::ASN1::T61STRING (20)
*   OpenSSL::ASN1::VIDEOTEXSTRING (21)
*   OpenSSL::ASN1::IA5STRING (22)
*   OpenSSL::ASN1::UTCTIME (23)
*   OpenSSL::ASN1::GENERALIZEDTIME (24)
*   OpenSSL::ASN1::GRAPHICSTRING (25)
*   OpenSSL::ASN1::ISO64STRING (26)
*   OpenSSL::ASN1::GENERALSTRING (27)
*   OpenSSL::ASN1::UNIVERSALSTRING (28)
*   OpenSSL::ASN1::BMPSTRING (30)


## UNIVERSAL_TAG_NAME constant

An Array that stores the name of a given tag number. These names are the same
as the name of the tag constant that is additionally defined, e.g.
+[UNIVERSAL_TAG_NAME](2) = "INTEGER"+ and +OpenSSL::ASN1::INTEGER = 2+.

## Example usage

### Decoding and viewing a DER-encoded file
    require 'openssl'
    require 'pp'
    der = File.binread('data.der')
    asn1 = OpenSSL::ASN1.decode(der)
    pp der

### Creating an ASN.1 structure and DER-encoding it
    require 'openssl'
    version = OpenSSL::ASN1::Integer.new(1)
    # Explicitly 0-tagged implies context-specific tag class
    serial = OpenSSL::ASN1::Integer.new(12345, 0, :EXPLICIT, :CONTEXT_SPECIFIC)
    name = OpenSSL::ASN1::PrintableString.new('Data 1')
    sequence = OpenSSL::ASN1::Sequence.new( [ version, serial, name ] )
    der = sequence.to_der

;T;0;	I"OpenSSL::ASN1;T;
[ ;[ ;0;[ ;[ o;;0;0;;;I"BMPString;F;I"OpenSSL::ASN1;T;[o;;I"J::String value, ?::OpenSSL::bn tag, ?::OpenSSL::ASN1::tagging tagging;T;I"OpenSSL::ASN1::BMPString;To;;0;0;;;I"BitString;F;I"OpenSSL::ASN1;T;[o;;I"J::String value, ?::OpenSSL::bn tag, ?::OpenSSL::ASN1::tagging tagging;T;I"OpenSSL::ASN1::BitString;To;;0;0;;;I"Boolean;F;I"OpenSSL::ASN1;T;[o;;I"K::boolish value, ?::OpenSSL::bn tag, ?::OpenSSL::ASN1::tagging tagging;T;I"OpenSSL::ASN1::Boolean;To;;0;0;;;I"EndOfContent;F;I"OpenSSL::ASN1;T;[o;;I" ;F;I" OpenSSL::ASN1::EndOfContent;To;;0;0;;;I"Enumerated;F;I"OpenSSL::ASN1;T;[o;;I"O::OpenSSL::bn value, ?::OpenSSL::bn tag, ?::OpenSSL::ASN1::tagging tagging;T;I"OpenSSL::ASN1::Enumerated;To;;0;0;;;I"GeneralString;F;I"OpenSSL::ASN1;T;[o;;I"J::String value, ?::OpenSSL::bn tag, ?::OpenSSL::ASN1::tagging tagging;T;I"!OpenSSL::ASN1::GeneralString;To;;0;0;;;I"GeneralizedTime;F;I"OpenSSL::ASN1;T;[o;;I"H::Time value, ?::OpenSSL::bn tag, ?::OpenSSL::ASN1::tagging tagging;T;I"#OpenSSL::ASN1::GeneralizedTime;To;;0;0;;;I"GraphicString;F;I"OpenSSL::ASN1;T;[o;;I"J::String value, ?::OpenSSL::bn tag, ?::OpenSSL::ASN1::tagging tagging;T;I"!OpenSSL::ASN1::GraphicString;To;;0;0;;;I"IA5String;F;I"OpenSSL::ASN1;T;[o;;I"J::String value, ?::OpenSSL::bn tag, ?::OpenSSL::ASN1::tagging tagging;T;I"OpenSSL::ASN1::IA5String;To;;0;0;;;I"ISO64String;F;I"OpenSSL::ASN1;T;[o;;I"J::String value, ?::OpenSSL::bn tag, ?::OpenSSL::ASN1::tagging tagging;T;I"OpenSSL::ASN1::ISO64String;To;;0;0;;;I"Integer;F;I"OpenSSL::ASN1;T;[o;;I"O::OpenSSL::bn value, ?::OpenSSL::bn tag, ?::OpenSSL::ASN1::tagging tagging;T;I"OpenSSL::ASN1::Integer;To;;0;0;;;I"	Null;F;I"OpenSSL::ASN1;T;[o;;I"nil;T;I"OpenSSL::ASN1::Null;To;;0;0;;;I"NumericString;F;I"OpenSSL::ASN1;T;[o;;I"J::String value, ?::OpenSSL::bn tag, ?::OpenSSL::ASN1::tagging tagging;T;I"!OpenSSL::ASN1::NumericString;To;;0;0;;;I"ObjectId;F;I"OpenSSL::ASN1;T;[o;;I"J::String value, ?::OpenSSL::bn tag, ?::OpenSSL::ASN1::tagging tagging;T;I"OpenSSL::ASN1::ObjectId;To;;0;0;;;I"OctetString;F;I"OpenSSL::ASN1;T;[o;;I"J::String value, ?::OpenSSL::bn tag, ?::OpenSSL::ASN1::tagging tagging;T;I"OpenSSL::ASN1::OctetString;To;;0;0;;;I"PrintableString;F;I"OpenSSL::ASN1;T;[o;;I"J::String value, ?::OpenSSL::bn tag, ?::OpenSSL::ASN1::tagging tagging;T;I"#OpenSSL::ASN1::PrintableString;To;;0;0;;;I"Sequence;F;I"OpenSSL::ASN1;T;[o;;I"d::Array[::OpenSSL::ASN1::ASN1Data] value, ?::OpenSSL::bn tag, ?::OpenSSL::ASN1::tagging tagging;T;I"OpenSSL::ASN1::Sequence;To;;0;0;;;I"Set;F;I"OpenSSL::ASN1;T;[o;;I"d::Array[::OpenSSL::ASN1::ASN1Data] value, ?::OpenSSL::bn tag, ?::OpenSSL::ASN1::tagging tagging;T;I"OpenSSL::ASN1::Set;To;;0;0;;;I"T61String;F;I"OpenSSL::ASN1;T;[o;;I"J::String value, ?::OpenSSL::bn tag, ?::OpenSSL::ASN1::tagging tagging;T;I"OpenSSL::ASN1::T61String;To;;0;0;;;I"UTCTime;F;I"OpenSSL::ASN1;T;[o;;I"H::Time value, ?::OpenSSL::bn tag, ?::OpenSSL::ASN1::tagging tagging;T;I"OpenSSL::ASN1::UTCTime;To;;0;0;;;I"UTF8String;F;I"OpenSSL::ASN1;T;[o;;I"J::String value, ?::OpenSSL::bn tag, ?::OpenSSL::ASN1::tagging tagging;T;I"OpenSSL::ASN1::UTF8String;To;;0;0;;;I"UniversalString;F;I"OpenSSL::ASN1;T;[o;;I"J::String value, ?::OpenSSL::bn tag, ?::OpenSSL::ASN1::tagging tagging;T;I"#OpenSSL::ASN1::UniversalString;To;;0;0;;;I"VideotexString;F;I"OpenSSL::ASN1;T;[o;;I"J::String value, ?::OpenSSL::bn tag, ?::OpenSSL::ASN1::tagging tagging;T;I""OpenSSL::ASN1::VideotexString;To;;I"Decodes a BER- or DER-encoded value and creates an ASN1Data instance. *der*
may be a String or any object that features a `.to_der` method transforming it
into a BER-/DER-encoded String+

## Example
    der = File.binread('asn1data')
    asn1 = OpenSSL::ASN1.decode(der)

;T;0;;;I"decode;F;I"OpenSSL::ASN1;T;[o;;I"+::String | ::OpenSSL::ASN1::_ToDer der;T;I"OpenSSL::ASN1::ASN1Data;To;;I"DSimilar to #decode with the difference that #decode expects one distinct value
represented in *der*. #decode_all on the contrary decodes a sequence of
sequential BER/DER values lined up in *der* and returns them as an array.

## Example
    ders = File.binread('asn1data_seq')
    asn1_ary = OpenSSL::ASN1.decode_all(ders)

;T;0;;;I"decode_all;F;I"OpenSSL::ASN1;T;[o;;I"+::String | ::OpenSSL::ASN1::_ToDer der;T;I"%Array[::OpenSSL::ASN1::ASN1Data];To;;I"~If a block is given, it prints out each of the elements encountered. Block
parameters are (in that order):
*   depth: The recursion depth, plus one with each constructed value being
    encountered (Integer)
*   offset: Current byte offset (Integer)
*   header length: Combined length in bytes of the Tag and Length headers.
    (Integer)
*   length: The overall remaining length of the entire data (Integer)
*   constructed: Whether this value is constructed or not (Boolean)
*   tag_class: Current tag class (Symbol)
*   tag: The current tag number (Integer)


## Example
    der = File.binread('asn1data.der')
    OpenSSL::ASN1.traverse(der) do | depth, offset, header_len, length, constructed, tag_class, tag|
      puts "Depth: #{depth} Offset: #{offset} Length: #{length}"
      puts "Header length: #{header_len} Tag: #{tag} Tag class: #{tag_class} Constructed: #{constructed}"
    end

;T;0;;;I"traverse;F;I"OpenSSL::ASN1;T;[o;;I"+::String | ::OpenSSL::ASN1::_ToDer der;T;I"	void;To; ;I""The top-level class representing any ASN.1 object. When parsed by ASN1.decode,
tagged values are always represented by an instance of ASN1Data.

## The role of ASN1Data for parsing tagged values

When encoding an ASN.1 type it is inherently clear what original type (e.g.
INTEGER, OCTET STRING etc.) this value has, regardless of its tagging. But
opposed to the time an ASN.1 type is to be encoded, when parsing them it is
not possible to deduce the "real type" of tagged values. This is why tagged
values are generally parsed into ASN1Data instances, but with a different
outcome for implicit and explicit tagging.

### Example of a parsed implicitly tagged value

An implicitly 1-tagged INTEGER value will be parsed as an ASN1Data with
*   *tag* equal to 1
*   *tag_class* equal to `:CONTEXT_SPECIFIC`
*   *value* equal to a String that carries the raw encoding of the INTEGER.

This implies that a subsequent decoding step is required to completely decode
implicitly tagged values.

### Example of a parsed explicitly tagged value

An explicitly 1-tagged INTEGER value will be parsed as an ASN1Data with
*   *tag* equal to 1
*   *tag_class* equal to `:CONTEXT_SPECIFIC`
*   *value* equal to an Array with one single element, an instance of
    OpenSSL::ASN1::Integer, i.e. the inner element is the non-tagged primitive
    value, and the tagging is represented in the outer ASN1Data


## Example - Decoding an implicitly tagged INTEGER
    int = OpenSSL::ASN1::Integer.new(1, 0, :IMPLICIT) # implicit 0-tagged
    seq = OpenSSL::ASN1::Sequence.new( [int] )
    der = seq.to_der
    asn1 = OpenSSL::ASN1.decode(der)
    # pp asn1 => #<OpenSSL::ASN1::Sequence:0x87326e0
    #              @indefinite_length=false,
    #              @tag=16,
    #              @tag_class=:UNIVERSAL,
    #              @tagging=nil,
    #              @value=
    #                [#<OpenSSL::ASN1::ASN1Data:0x87326f4
    #                   @indefinite_length=false,
    #                   @tag=0,
    #                   @tag_class=:CONTEXT_SPECIFIC,
    #                   @value="\x01">]>
    raw_int = asn1.value[0]
    # manually rewrite tag and tag class to make it an UNIVERSAL value
    raw_int.tag = OpenSSL::ASN1::INTEGER
    raw_int.tag_class = :UNIVERSAL
    int2 = OpenSSL::ASN1.decode(raw_int)
    puts int2.value # => 1

## Example - Decoding an explicitly tagged INTEGER
    int = OpenSSL::ASN1::Integer.new(1, 0, :EXPLICIT) # explicit 0-tagged
    seq = OpenSSL::ASN1::Sequence.new( [int] )
    der = seq.to_der
    asn1 = OpenSSL::ASN1.decode(der)
    # pp asn1 => #<OpenSSL::ASN1::Sequence:0x87326e0
    #              @indefinite_length=false,
    #              @tag=16,
    #              @tag_class=:UNIVERSAL,
    #              @tagging=nil,
    #              @value=
    #                [#<OpenSSL::ASN1::ASN1Data:0x87326f4
    #                   @indefinite_length=false,
    #                   @tag=0,
    #                   @tag_class=:CONTEXT_SPECIFIC,
    #                   @value=
    #                     [#<OpenSSL::ASN1::Integer:0x85bf308
    #                        @indefinite_length=false,
    #                        @tag=2,
    #                        @tag_class=:UNIVERSAL
    #                        @tagging=nil,
    #                        @value=1>]>]>
    int2 = asn1.value[0].value[0]
    puts int2.value # => 1

;T;0;	I"OpenSSL::ASN1::ASN1Data;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"ŸNever `nil`. A boolean value indicating whether the encoding uses indefinite
length (in the case of parsing) or whether an indefinite length form shall be
used (in the encoding case). In DER, every value uses definite length form.
But in scenarios where large amounts of data need to be transferred it might
be desirable to have some kind of streaming support available. For example,
huge OCTET STRINGs are preferably sent in smaller-sized chunks, each at a
time. This is possible in BER by setting the length bytes of an encoding to
zero and by this indicating that the following value will be sent in chunks.
Indefinite length encodings are always constructed. The end of such a stream
of chunks is indicated by sending a EOC (End of Content) tag. SETs and
SEQUENCEs may use an indefinite length encoding, but also primitive types such
as e.g. OCTET STRINGS or BIT STRINGS may leverage this functionality (cf.
ITU-T X.690).

;T;0;;;I"indefinite_length;F;I"OpenSSL::ASN1::ASN1Data;T;[o;;I" ;F;I"	bool;To;;I"ŸNever `nil`. A boolean value indicating whether the encoding uses indefinite
length (in the case of parsing) or whether an indefinite length form shall be
used (in the encoding case). In DER, every value uses definite length form.
But in scenarios where large amounts of data need to be transferred it might
be desirable to have some kind of streaming support available. For example,
huge OCTET STRINGs are preferably sent in smaller-sized chunks, each at a
time. This is possible in BER by setting the length bytes of an encoding to
zero and by this indicating that the following value will be sent in chunks.
Indefinite length encodings are always constructed. The end of such a stream
of chunks is indicated by sending a EOC (End of Content) tag. SETs and
SEQUENCEs may use an indefinite length encoding, but also primitive types such
as e.g. OCTET STRINGS or BIT STRINGS may leverage this functionality (cf.
ITU-T X.690).

;T;0;;;I"indefinite_length=;F;I"OpenSSL::ASN1::ASN1Data;T;[o;;I"::boolish;T;I"U;Fo;;I"LAn Integer representing the tag number of this ASN1Data. Never `nil`.

;T;0;;;I"tag;F;I"OpenSSL::ASN1::ASN1Data;T;[o;;I" ;F;I"OpenSSL::bn;To;;I"LAn Integer representing the tag number of this ASN1Data. Never `nil`.

;T;0;;;I"	tag=;F;I"OpenSSL::ASN1::ASN1Data;T;[o;;I"::Integer;T;I"Integer;To;;I"::OpenSSL::BN;T;I"OpenSSL::BN;To;;I"kA Symbol representing the tag class of this ASN1Data. Never `nil`. See
ASN1Data for possible values.

;T;0;;;I"tag_class;F;I"OpenSSL::ASN1::ASN1Data;T;[o;;I" ;F;I"OpenSSL::ASN1::tag_class;To;;I"kA Symbol representing the tag class of this ASN1Data. Never `nil`. See
ASN1Data for possible values.

;T;0;;;I"tag_class=;F;I"OpenSSL::ASN1::ASN1Data;T;[o;;I"::OpenSSL::ASN1::tag_class;T;I"OpenSSL::ASN1::tag_class;To;;I"Encodes this ASN1Data into a DER-encoded String value. The result is
DER-encoded except for the possibility of indefinite length forms. Indefinite
length forms are not allowed in strict DER, so strictly speaking the result of
such an encoding would be a BER-encoding.

;T;0;;;I"to_der;F;I"OpenSSL::ASN1::ASN1Data;T;[o;;I" ;F;I"String;To;;I"‰Carries the value of a ASN.1 type. Please confer Constructive and Primitive
for the mappings between ASN.1 data types and Ruby classes.

;T;0;;;I"
value;F;I"OpenSSL::ASN1::ASN1Data;T;[o;;I" ;F;I"untyped;To;;I"‰Carries the value of a ASN.1 type. Please confer Constructive and Primitive
for the mappings between ASN.1 data types and Ruby classes.

;T;0;;;I"value=;F;I"OpenSSL::ASN1::ASN1Data;T;[o;;I"untyped;T;I"untyped;To;;I"Î*value*: Please have a look at Constructive and Primitive to see how Ruby
types are mapped to ASN.1 types and vice versa.

*tag*: An Integer indicating the tag number.

*tag_class*: A Symbol indicating the tag class. Please cf. ASN1 for possible
values.

## Example
    asn1_int = OpenSSL::ASN1Data.new(42, 2, :UNIVERSAL) # => Same as OpenSSL::ASN1::Integer.new(42)
    tagged_int = OpenSSL::ASN1Data.new(42, 0, :CONTEXT_SPECIFIC) # implicitly 0-tagged INTEGER

;T;0;;;I"initialize;F;I"OpenSSL::ASN1::ASN1Data;T;[o;;I"Guntyped value, ::Integer tag, ::OpenSSL::ASN1::tag_class tag_class;T;I"	void;To; ;I"^Generic error class for all errors raised in ASN1 and any of the classes
defined in it.

;T;0;	I"OpenSSL::ASN1::ASN1Error;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::OpenSSLError;To; ;0;0;	I"OpenSSL::ASN1::BMPString;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::ASN1::Primitive;To; ;0;0;	I"OpenSSL::ASN1::BitString;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::ASN1::Primitive;To;;0;0;;;I"unused_bits;F;I"OpenSSL::ASN1::BitString;T;[o;;I" ;F;I"Integer;To;;0;0;;;I"unused_bits=;F;I"OpenSSL::ASN1::BitString;T;[o;;I"::Integer;T;I"Integer;To;;0;0;;;I"
value;F;I"OpenSSL::ASN1::BitString;T;[o;;I" ;F;I"String;To;;0;0;;;I"value=;F;I"OpenSSL::ASN1::BitString;T;[o;;I"::String;T;I"String;To; ;0;0;	I"OpenSSL::ASN1::Boolean;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::ASN1::Primitive;To;;0;0;;;I"
value;F;I"OpenSSL::ASN1::Boolean;T;[o;;I" ;F;I"	bool;To;;0;0;;;I"value=;F;I"OpenSSL::ASN1::Boolean;T;[o;;I"::boolish;T;I"U;Fo; ;I"ƒThe parent class for all constructed encodings. The *value* attribute of a
Constructive is always an Array. Attributes are the same as for ASN1Data, with
the addition of *tagging*.

## SET and SEQUENCE

Most constructed encodings come in the form of a SET or a SEQUENCE. These
encodings are represented by one of the two sub-classes of Constructive:
*   OpenSSL::ASN1::Set
*   OpenSSL::ASN1::Sequence

Please note that tagged sequences and sets are still parsed as instances of
ASN1Data. Find further details on tagged values there.

### Example - constructing a SEQUENCE
    int = OpenSSL::ASN1::Integer.new(1)
    str = OpenSSL::ASN1::PrintableString.new('abc')
    sequence = OpenSSL::ASN1::Sequence.new( [ int, str ] )

### Example - constructing a SET
    int = OpenSSL::ASN1::Integer.new(1)
    str = OpenSSL::ASN1::PrintableString.new('abc')
    set = OpenSSL::ASN1::Set.new( [ int, str ] )

;T;0;	I" OpenSSL::ASN1::Constructive;T;
[ ;[I"Enumerable;T;0;[ ;[ ;0;I"OpenSSL::ASN1::ASN1Data;To;;I"ÙCalls the given block once for each element in self, passing that element as
parameter *asn1*. If no block is given, an enumerator is returned instead.

## Example
    asn1_ary.each do |asn1|
      puts asn1
    end

;T;0;;;I"	each;F;I" OpenSSL::ASN1::Constructive;T;[o;;I" ;F;I"	self;To;;I"ÕMay be used as a hint for encoding a value either implicitly or explicitly by
setting it either to `:IMPLICIT` or to `:EXPLICIT`. *tagging* is not set when
a ASN.1 structure is parsed using OpenSSL::ASN1.decode.

;T;0;;;I"tagging;F;I" OpenSSL::ASN1::Constructive;T;[o;;I" ;F;I"OpenSSL::ASN1::tagging?;To;;I"ÕMay be used as a hint for encoding a value either implicitly or explicitly by
setting it either to `:IMPLICIT` or to `:EXPLICIT`. *tagging* is not set when
a ASN.1 structure is parsed using OpenSSL::ASN1.decode.

;T;0;;;I"tagging=;F;I" OpenSSL::ASN1::Constructive;T;[o;;I"::OpenSSL::ASN1::tagging;T;I"OpenSSL::ASN1::tagging;To;;I"'See ASN1Data#to_der for details.

;T;0;;;I"to_der;F;I" OpenSSL::ASN1::Constructive;T;[o;;I" ;F;I"String;To;;I"á*value*: is mandatory.

*tag*: optional, may be specified for tagged values. If no *tag* is specified,
the UNIVERSAL tag corresponding to the Primitive sub-class is used by default.

*tagging*: may be used as an encoding hint to encode a value either explicitly
or implicitly, see ASN1 for possible values.

*tag_class*: if *tag* and *tagging* are `nil` then this is set to `:UNIVERSAL`
by default. If either *tag* or *tagging* are set then `:CONTEXT_SPECIFIC` is
used as the default. For possible values please cf. ASN1.

## Example
    int = OpenSSL::ASN1::Integer.new(42)
    zero_tagged_int = OpenSSL::ASN1::Integer.new(42, 0, :IMPLICIT)
    private_explicit_zero_tagged_int = OpenSSL::ASN1::Integer.new(42, 0, :EXPLICIT, :PRIVATE)

;T;0;;;I"initialize;F;I" OpenSSL::ASN1::Constructive;T;[o;;I"'::Array[::OpenSSL::ASN1::ASN1Data];T;I"	void;To; ;0;0;	I" OpenSSL::ASN1::EndOfContent;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::ASN1::ASN1Data;To;;0;0;;;I"to_der;F;I" OpenSSL::ASN1::EndOfContent;T;[o;;I" ;F;I"String;To;;0;0;;;I"initialize;F;I" OpenSSL::ASN1::EndOfContent;T;[o;;I" ;F;I"	void;To; ;0;0;	I"OpenSSL::ASN1::Enumerated;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::ASN1::Primitive;To;;0;0;;;I"
value;F;I"OpenSSL::ASN1::Enumerated;T;[o;;I" ;F;I"Integer;To;;0;0;;;I"value=;F;I"OpenSSL::ASN1::Enumerated;T;[o;;I"::Integer;T;I"Integer;To; ;0;0;	I"!OpenSSL::ASN1::GeneralString;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::ASN1::Primitive;To;;0;0;;;I"
value;F;I"!OpenSSL::ASN1::GeneralString;T;[o;;I" ;F;I"String;To;;0;0;;;I"value=;F;I"!OpenSSL::ASN1::GeneralString;T;[o;;I"::String;T;I"String;To; ;0;0;	I"#OpenSSL::ASN1::GeneralizedTime;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::ASN1::Primitive;To;;0;0;;;I"
value;F;I"#OpenSSL::ASN1::GeneralizedTime;T;[o;;I" ;F;I"	Time;To;;0;0;;;I"value=;F;I"#OpenSSL::ASN1::GeneralizedTime;T;[o;;I"::Time;T;I"	Time;To; ;0;0;	I"!OpenSSL::ASN1::GraphicString;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::ASN1::Primitive;To;;0;0;;;I"
value;F;I"!OpenSSL::ASN1::GraphicString;T;[o;;I" ;F;I"String;To;;0;0;;;I"value=;F;I"!OpenSSL::ASN1::GraphicString;T;[o;;I"::String;T;I"String;To; ;0;0;	I"OpenSSL::ASN1::IA5String;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::ASN1::Primitive;To;;0;0;;;I"
value;F;I"OpenSSL::ASN1::IA5String;T;[o;;I" ;F;I"String;To;;0;0;;;I"value=;F;I"OpenSSL::ASN1::IA5String;T;[o;;I"::String;T;I"String;To; ;0;0;	I"OpenSSL::ASN1::ISO64String;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::ASN1::Primitive;To;;0;0;;;I"
value;F;I"OpenSSL::ASN1::ISO64String;T;[o;;I" ;F;I"String;To;;0;0;;;I"value=;F;I"OpenSSL::ASN1::ISO64String;T;[o;;I"::String;T;I"String;To; ;0;0;	I"OpenSSL::ASN1::Integer;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::ASN1::Primitive;To;;0;0;;;I"
value;F;I"OpenSSL::ASN1::Integer;T;[o;;I" ;F;I"Integer;To;;0;0;;;I"value=;F;I"OpenSSL::ASN1::Integer;T;[o;;I"::Integer;T;I"Integer;To; ;0;0;	I"OpenSSL::ASN1::Null;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::ASN1::Primitive;To;;0;0;;;I"
value;F;I"OpenSSL::ASN1::Null;T;[o;;I" ;F;I"nil;To;;0;0;;;I"value=;F;I"OpenSSL::ASN1::Null;T;[o;;I"nil;T;I"nil;To; ;0;0;	I"!OpenSSL::ASN1::NumericString;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::ASN1::Primitive;To;;0;0;;;I"
value;F;I"!OpenSSL::ASN1::NumericString;T;[o;;I" ;F;I"String;To;;0;0;;;I"value=;F;I"!OpenSSL::ASN1::NumericString;T;[o;;I"::String;T;I"String;To; ;I";Represents the primitive object id for OpenSSL::ASN1

;T;0;	I"OpenSSL::ASN1::ObjectId;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::ASN1::Primitive;To;;I"ìThis adds a new ObjectId to the internal tables. Where *object_id* is the
numerical form, *short_name* is the short name, and *long_name* is the long
name.

Returns `true` if successful. Raises an OpenSSL::ASN1::ASN1Error if it fails.

;T;0;;;I"register;F;I"OpenSSL::ASN1::ObjectId;T;[o;;I"?::String object_id, ::String short_name, ::String ong_name;T;I"	bool;To;;0;0;;;I"
value;F;I"OpenSSL::ASN1::ObjectId;T;[o;;I" ;F;I"String;To;;0;0;;;I"value=;F;I"OpenSSL::ASN1::ObjectId;T;[o;;I"::String;T;I"String;To;;I"9Returns `true` if *other_oid* is the same as *oid*

;T;0;;;I"==;F;I"OpenSSL::ASN1::ObjectId;T;[o;;I"$::OpenSSL::ASN1::ObjectId other;T;I"	bool;To;;I"HThe long name of the ObjectId, as defined in <openssl/objects.h>.

;T;0;;;I"ln;F;I"OpenSSL::ASN1::ObjectId;T;[o;;I" ;F;I"String?;To;;I"`Returns a String representing the Object Identifier in the dot notation, e.g.
"1.2.3.4.5"

;T;0;;;I"oid;F;I"OpenSSL::ASN1::ObjectId;T;[o;;I" ;F;I"String;To;;I"IThe short name of the ObjectId, as defined in <openssl/objects.h>.

;T;0;;;I"sn;F;I"OpenSSL::ASN1::ObjectId;T;[o;;I" ;F;I"String?;To; ;0;0;	I"OpenSSL::ASN1::OctetString;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::ASN1::Primitive;To;;0;0;;;I"
value;F;I"OpenSSL::ASN1::OctetString;T;[o;;I" ;F;I"String;To;;0;0;;;I"value=;F;I"OpenSSL::ASN1::OctetString;T;[o;;I"::String;T;I"String;To; ;I"The parent class for all primitive encodings. Attributes are the same as for
ASN1Data, with the addition of *tagging*. Primitive values can never be
encoded with indefinite length form, thus it is not possible to set the
*indefinite_length* attribute for Primitive and its sub-classes.

## Primitive sub-classes and their mapping to Ruby classes
*   OpenSSL::ASN1::EndOfContent    <=> *value* is always `nil`
*   OpenSSL::ASN1::Boolean         <=> *value* is `true` or `false`
*   OpenSSL::ASN1::Integer         <=> *value* is an OpenSSL::BN
*   OpenSSL::ASN1::BitString       <=> *value* is a String
*   OpenSSL::ASN1::OctetString     <=> *value* is a String
*   OpenSSL::ASN1::Null            <=> *value* is always `nil`
*   OpenSSL::ASN1::Object          <=> *value* is a String
*   OpenSSL::ASN1::Enumerated      <=> *value* is an OpenSSL::BN
*   OpenSSL::ASN1::UTF8String      <=> *value* is a String
*   OpenSSL::ASN1::NumericString   <=> *value* is a String
*   OpenSSL::ASN1::PrintableString <=> *value* is a String
*   OpenSSL::ASN1::T61String       <=> *value* is a String
*   OpenSSL::ASN1::VideotexString  <=> *value* is a String
*   OpenSSL::ASN1::IA5String       <=> *value* is a String
*   OpenSSL::ASN1::UTCTime         <=> *value* is a Time
*   OpenSSL::ASN1::GeneralizedTime <=> *value* is a Time
*   OpenSSL::ASN1::GraphicString   <=> *value* is a String
*   OpenSSL::ASN1::ISO64String     <=> *value* is a String
*   OpenSSL::ASN1::GeneralString   <=> *value* is a String
*   OpenSSL::ASN1::UniversalString <=> *value* is a String
*   OpenSSL::ASN1::BMPString       <=> *value* is a String


## OpenSSL::ASN1::BitString

### Additional attributes
*unused_bits*: if the underlying BIT STRING's length is a multiple of 8 then
*unused_bits* is 0. Otherwise *unused_bits* indicates the number of bits that
are to be ignored in the final octet of the BitString's *value*.

## OpenSSL::ASN1::ObjectId

NOTE: While OpenSSL::ASN1::ObjectId.new will allocate a new ObjectId, it is
not typically allocated this way, but rather that are received from parsed
ASN1 encodings.

### Additional attributes
*   *sn*: the short name as defined in <openssl/objects.h>.
*   *ln*: the long name as defined in <openssl/objects.h>.
*   *oid*: the object identifier as a String, e.g. "1.2.3.4.5"
*   *short_name*: alias for *sn*.
*   *long_name*: alias for *ln*.


## Examples
With the Exception of OpenSSL::ASN1::EndOfContent, each Primitive class
constructor takes at least one parameter, the *value*.

### Creating EndOfContent
    eoc = OpenSSL::ASN1::EndOfContent.new

### Creating any other Primitive
    prim = <class>.new(value) # <class> being one of the sub-classes except EndOfContent
    prim_zero_tagged_implicit = <class>.new(value, 0, :IMPLICIT)
    prim_zero_tagged_explicit = <class>.new(value, 0, :EXPLICIT)

;T;0;	I"OpenSSL::ASN1::Primitive;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::ASN1::ASN1Data;To;;I"ÕMay be used as a hint for encoding a value either implicitly or explicitly by
setting it either to `:IMPLICIT` or to `:EXPLICIT`. *tagging* is not set when
a ASN.1 structure is parsed using OpenSSL::ASN1.decode.

;T;0;;;I"tagging;F;I"OpenSSL::ASN1::Primitive;T;[o;;I" ;F;I"OpenSSL::ASN1::tagging?;To;;I"ÕMay be used as a hint for encoding a value either implicitly or explicitly by
setting it either to `:IMPLICIT` or to `:EXPLICIT`. *tagging* is not set when
a ASN.1 structure is parsed using OpenSSL::ASN1.decode.

;T;0;;;I"tagging=;F;I"OpenSSL::ASN1::Primitive;T;[o;;I"::OpenSSL::ASN1::tagging;T;I"OpenSSL::ASN1::tagging;To;;I"'See ASN1Data#to_der for details.

;T;0;;;I"to_der;F;I"OpenSSL::ASN1::Primitive;T;[o;;I" ;F;I"String;To;;I"á*value*: is mandatory.

*tag*: optional, may be specified for tagged values. If no *tag* is specified,
the UNIVERSAL tag corresponding to the Primitive sub-class is used by default.

*tagging*: may be used as an encoding hint to encode a value either explicitly
or implicitly, see ASN1 for possible values.

*tag_class*: if *tag* and *tagging* are `nil` then this is set to `:UNIVERSAL`
by default. If either *tag* or *tagging* are set then `:CONTEXT_SPECIFIC` is
used as the default. For possible values please cf. ASN1.

## Example
    int = OpenSSL::ASN1::Integer.new(42)
    zero_tagged_int = OpenSSL::ASN1::Integer.new(42, 0, :IMPLICIT)
    private_explicit_zero_tagged_int = OpenSSL::ASN1::Integer.new(42, 0, :EXPLICIT, :PRIVATE)

;T;0;;;I"initialize;F;I"OpenSSL::ASN1::Primitive;T;[o;;I"Tuntyped value, ?::OpenSSL::ASN1::Integer tag, ?::OpenSSL::ASN1::tagging tagging;T;I"	void;To; ;0;0;	I"#OpenSSL::ASN1::PrintableString;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::ASN1::Primitive;To;;0;0;;;I"
value;F;I"#OpenSSL::ASN1::PrintableString;T;[o;;I" ;F;I"String;To;;0;0;;;I"value=;F;I"#OpenSSL::ASN1::PrintableString;T;[o;;I"::String;T;I"String;To; ;0;0;	I"OpenSSL::ASN1::Sequence;T;
[ ;[ ;0;[ ;[ ;0;I" OpenSSL::ASN1::Constructive;To;;0;0;;;I"
value;F;I"OpenSSL::ASN1::Sequence;T;[o;;I" ;F;I"%Array[::OpenSSL::ASN1::ASN1Data];To;;0;0;;;I"value=;F;I"OpenSSL::ASN1::Sequence;T;[o;;I"'::Array[::OpenSSL::ASN1::ASN1Data];T;I"%Array[::OpenSSL::ASN1::ASN1Data];To; ;0;0;	I"OpenSSL::ASN1::Set;T;
[ ;[ ;0;[ ;[ ;0;I" OpenSSL::ASN1::Constructive;To; ;0;0;	I"OpenSSL::ASN1::T61String;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::ASN1::Primitive;To;;0;0;;;I"
value;F;I"OpenSSL::ASN1::T61String;T;[o;;I" ;F;I"String;To;;0;0;;;I"value=;F;I"OpenSSL::ASN1::T61String;T;[o;;I"::String;T;I"String;To; ;0;0;	I"OpenSSL::ASN1::UTCTime;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::ASN1::Primitive;To;;0;0;;;I"
value;F;I"OpenSSL::ASN1::UTCTime;T;[o;;I" ;F;I"	Time;To;;0;0;;;I"value=;F;I"OpenSSL::ASN1::UTCTime;T;[o;;I"::Time;T;I"	Time;To; ;0;0;	I"OpenSSL::ASN1::UTF8String;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::ASN1::Primitive;To;;0;0;;;I"
value;F;I"OpenSSL::ASN1::UTF8String;T;[o;;I" ;F;I"String;To;;0;0;;;I"value=;F;I"OpenSSL::ASN1::UTF8String;T;[o;;I"::String;T;I"String;To; ;0;0;	I"#OpenSSL::ASN1::UniversalString;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::ASN1::Primitive;To;;0;0;;;I"
value;F;I"#OpenSSL::ASN1::UniversalString;T;[o;;I" ;F;I"String;To;;0;0;;;I"value=;F;I"#OpenSSL::ASN1::UniversalString;T;[o;;I"::String;T;I"String;To; ;0;0;	I""OpenSSL::ASN1::VideotexString;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::ASN1::Primitive;To;;0;0;;;I"
value;F;I""OpenSSL::ASN1::VideotexString;T;[o;;I" ;F;I"String;To;;0;0;;;I"value=;F;I""OpenSSL::ASN1::VideotexString;T;[o;;I"::String;T;I"String;To; ;0;0;	I"OpenSSL::BN;T;
[ ;[I"Comparable;T;0;[ ;[ ;0;0o;;I"Generates a random prime number of bit length *bits*. If *safe* is set to
`true`, generates a safe prime. If *add* is specified, generates a prime that
fulfills condition `p % add = rem`.

### Parameters
*   *bits* - integer
*   *safe* - boolean
*   *add* - BN
*   *rem* - BN

;T;0;;;I"generate_prime;F;I"OpenSSL::BN;T;[o;;I"L::Integer bits, ?::boolish safe, ?::OpenSSL::bn add, ?::OpenSSL::bn rem;T;I"instance;To;;0;0;;;I"pseudo_rand;F;I"OpenSSL::BN;T;[o;;I"*untyped;T;I"untyped;To;;0;0;;;I"pseudo_rand_range;F;I"OpenSSL::BN;T;[o;;I"untyped;T;I"untyped;To;;I"nGenerates a cryptographically strong pseudo-random number of `bits`.

See also the man page BN_rand(3).

;T;0;;;I"	rand;F;I"OpenSSL::BN;T;[o;;I"*untyped;T;I"untyped;To;;I"~Generates a cryptographically strong pseudo-random number in the range
0...`range`.

See also the man page BN_rand_range(3).

;T;0;;;I"rand_range;F;I"OpenSSL::BN;T;[o;;I"untyped;T;I"untyped;To;;I" ;T;0;;;I"%;F;I"OpenSSL::BN;T;[o;;I"
::int;T;I"instance;To;;I" ;T;0;;;I"*;F;I"OpenSSL::BN;T;[o;;I"
::int;T;I"instance;To;;I" ;T;0;;;I"**;F;I"OpenSSL::BN;T;[o;;I"
::int;T;I"instance;To;;I" ;T;0;;;I"+;F;I"OpenSSL::BN;T;[o;;I"
::int;T;I"instance;To;;I" ;T;0;;;I"+@;F;I"OpenSSL::BN;T;[o;;I" ;F;I"instance;To;;I" ;T;0;;;I"-;F;I"OpenSSL::BN;T;[o;;I"
::int;T;I"instance;To;;I" ;T;0;;;I"-@;F;I"OpenSSL::BN;T;[o;;I" ;F;I"instance;To;;I"(Division of OpenSSL::BN instances

;T;0;;;I"/;F;I"OpenSSL::BN;T;[o;;I"
::int;T;I"[ instance, instance ];To;;I" ;T;0;;;I"<<;F;I"OpenSSL::BN;T;[o;;I"
::int;T;I"instance;To;;I"…Returns `true` only if *obj* has the same value as *bn*. Contrast this with
OpenSSL::BN#eql?, which requires obj to be OpenSSL::BN.

;T;0;;;I"==;F;I"OpenSSL::BN;T;[o;;I"untyped;T;I"	bool;To;;I" ;T;0;;;I">>;F;I"OpenSSL::BN;T;[o;;I"
::int;T;I"int;To;;I"MTests bit *bit* in *bn* and returns `true` if set, `false` if not set.

;T;0;;;I"bit_set?;F;I"OpenSSL::BN;T;[o;;I"
::int;T;I"	bool;To;;I" ;T;0;;;I"clear_bit!;F;I"OpenSSL::BN;T;[o;;I"
::int;T;I"	void;To;;I" ;T;0;;;I"cmp;F;I"OpenSSL::BN;T;[o;;I"::Integer;T;I"Integer;To;;I" ;T;0;;;I"coerce;F;I"OpenSSL::BN;T;[o;;I"::Integer;T;I"Array[::Integer];To;;I"::OpenSSL::BN;T;I"Array[::OpenSSL::BN];To;;I" ;T;0;;;I"	copy;F;I"OpenSSL::BN;T;[o;;I"
::int;T;I"instance;To;;I"’Returns `true` only if *obj* is a `OpenSSL::BN` with the same value as *bn*.
Contrast this with OpenSSL::BN#==, which performs type conversions.

;T;0;;;I"	eql?;F;I"OpenSSL::BN;T;[o;;I"untyped other;T;I"	bool;To;;I" ;T;0;;;I"gcd;F;I"OpenSSL::BN;T;[o;;I"
::int;T;I"instance;To;;I"BReturns a hash code for this object.

See also Object#hash.

;T;0;;;I"	hash;F;I"OpenSSL::BN;T;[o;;I" ;F;I"Integer;To;;I" ;T;0;;;I"lshift!;F;I"OpenSSL::BN;T;[o;;I"::int bits;T;I"	self;To;;0;0;;;I"mask_bits!;F;I"OpenSSL::BN;T;[o;;I"
::int;T;I"	void;To;;I" ;T;0;;;I"mod_add;F;I"OpenSSL::BN;T;[o;;I"::int, ::int;T;I"instance;To;;I" ;T;0;;;I"mod_exp;F;I"OpenSSL::BN;T;[o;;I"::int, ::int;T;I"instance;To;;I" ;T;0;;;I"mod_inverse;F;I"OpenSSL::BN;T;[o;;I"
::int;T;I"instance;To;;I" ;T;0;;;I"mod_mul;F;I"OpenSSL::BN;T;[o;;I"::int, ::int;T;I"instance;To;;I" ;T;0;;;I"mod_sqr;F;I"OpenSSL::BN;T;[o;;I"
::int;T;I"instance;To;;I" ;T;0;;;I"mod_sub;F;I"OpenSSL::BN;T;[o;;I"::int, ::int;T;I"instance;To;;I" ;T;0;;;I"negative?;F;I"OpenSSL::BN;T;[o;;I" ;F;I"	bool;To;;I" ;T;0;;;I"num_bits;F;I"OpenSSL::BN;T;[o;;I" ;F;I"Integer;To;;I" ;T;0;;;I"num_bytes;F;I"OpenSSL::BN;T;[o;;I" ;F;I"Integer;To;;I" ;T;0;;;I"	odd?;F;I"OpenSSL::BN;T;[o;;I" ;F;I"	bool;To;;I" ;T;0;;;I"	one?;F;I"OpenSSL::BN;T;[o;;I" ;F;I"	bool;To;;I" ;T;0;;;I"pretty_print;F;I"OpenSSL::BN;T;[o;;I"untyped q;T;I"untyped;To;;I"ˆPerforms a Miller-Rabin probabilistic primality test for `bn`.

**`checks` parameter is deprecated in version 3.0.** It has no effect.

;T;0;;;I"prime?;F;I"OpenSSL::BN;T;[o;;I"?::int checks;T;I"	bool;To;;I"µPerforms a Miller-Rabin probabilistic primality test for `bn`.

**Deprecated in version 3.0.** Use #prime? instead.

`checks` and `trial_div` parameters no longer have any effect.

;T;0;;;I"prime_fasttest?;F;I"OpenSSL::BN;T;[o;;I"$?::int checks, ?::int trial_div;T;I"	bool;To;;I" ;T;0;;;I"rshift!;F;I"OpenSSL::BN;T;[o;;I"::int bits;T;I"	self;To;;I" ;T;0;;;I"set_bit!;F;I"OpenSSL::BN;T;[o;;I"::int bit;T;I"	self;To;;I" ;T;0;;;I"sqr;F;I"OpenSSL::BN;T;[o;;I" ;F;I"instance;To;;I" ;T;0;;;I"
to_bn;F;I"OpenSSL::BN;T;[o;;I" ;F;I"	self;To;;I" ;T;0;;;I"	to_i;F;I"OpenSSL::BN;T;[o;;I" ;F;I"Integer;To;;I"&Returns the string representation of the bignum.

BN.new can parse the encoded string to convert back into an OpenSSL::BN.

`base`
:   The format. Must be one of the following:
    *   `0`  - MPI format. See the man page BN_bn2mpi(3) for details.
    *   `2`  - Variable-length and big-endian binary encoding. The sign of the
        bignum is ignored.
    *   `10` - Decimal number representation, with a leading '-' for a
        negative bignum.
    *   `16` - Hexadeciaml number representation, with a leading '-' for a
        negative bignum.

;T;0;;;I"	to_s;F;I"OpenSSL::BN;T;[o;;I" ;F;I"String;To;;I"0;T;I"String;To;;I"2;T;I"String;To;;I"10;T;I"String;To;;I"16;T;I"String;To;;I"::int base;T;I"String;To;;I" ;T;0;;;I"	ucmp;F;I"OpenSSL::BN;T;[o;;I"::int bn2;T;I"Integer;To;;I" ;T;0;;;I"
zero?;F;I"OpenSSL::BN;T;[o;;I" ;F;I"	bool;To;;I"ÊConstruct a new OpenSSL BIGNUM object.

If `bn` is an Integer or OpenSSL::BN, a new instance of OpenSSL::BN
representing the same value is returned. See also Integer#to_bn for the
short-hand.

If a String is given, the content will be parsed according to `base`.

`string`
:   The string to be parsed.
`base`
:   The format. Must be one of the following:
    *   `0`  - MPI format. See the man page BN_mpi2bn(3) for details.
    *   `2`  - Variable-length and big-endian binary encoding of a positive
        number.
    *   `10` - Decimal number representation, with a leading '-' for a
        negative number.
    *   `16` - Hexadeciaml number representation, with a leading '-' for a
        negative number.

;T;0;;;I"initialize;F;I"OpenSSL::BN;T;[	o;;I"instance;T;I"	void;To;;I"
::int;T;I"	void;To;;I"::string;T;I"	void;To;;I"::string, 0 | 2 | 10 | 16;T;I"	void;To;;I" ;T;0;;;I"initialize_copy;F;I"OpenSSL::BN;T;[o;;I"instance other;T;I"instance;To; ;I"5Generic Error for all of OpenSSL::BN (big num)

;T;0;	I"OpenSSL::BNError;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::OpenSSLError;To;;I"ÐOpenSSL IO buffering mix-in module.

This module allows an OpenSSL::SSL::SSLSocket to behave like an IO.

You typically won't use this module directly, you can see it implemented in
OpenSSL::SSL::SSLSocket.

;T;0;	I"OpenSSL::Buffering;T;
[ ;[ ;0;[ ;[ o;;I"YWrites *s* to the stream.  *s* will be converted to a String using `.to_s`
method.

;T;0;;;I"<<;F;I"OpenSSL::Buffering;T;[o;;I"::String s;T;I"	self;To;;I";Closes the SSLSocket and flushes any unwritten data.

;T;0;;;I"
close;F;I"OpenSSL::Buffering;T;[o;;I" ;F;I"	void;To;;I"jExecutes the block for every line in the stream where lines are separated by
*eol*.

See also #gets

;T;0;;;I"	each;F;I"OpenSSL::Buffering;T;[o;;I"?::String eol;T;I"	void;To;;I">Calls the given block once for each byte in the stream.

;T;0;;;I"each_byte;F;I"OpenSSL::Buffering;T;[o;;I" ;F;I"	void;To;;I"ZReturns true if the stream is at file which means there is no more data to be
read.

;T;0;;;I"	eof?;F;I"OpenSSL::Buffering;T;[o;;I" ;F;I"	bool;To;;I".Flushes buffered data to the SSLSocket.

;T;0;;;I"
flush;F;I"OpenSSL::Buffering;T;[o;;I" ;F;I"	self;To;;I"RReads one character from the stream.  Returns nil if called at end of file.

;T;0;;;I"	getc;F;I"OpenSSL::Buffering;T;[o;;I" ;F;I"String?;To;;I"BReads the next "line" from the stream.  Lines are separated by *eol*.  If
*limit* is provided the result will not be longer than the given number of
bytes.

*eol* may be a String or Regexp.

Unlike IO#gets the line read will not be assigned to +$_+.

Unlike IO#gets the separator must be provided if a limit is provided.

;T;0;;;I"	gets;F;I"OpenSSL::Buffering;T;[o;;I"/?::String | ::Regexp eol, ?::Integer limit;T;I"String?;To;;I"CWrites *args* to the stream.

See IO#print for full details.

;T;0;;;I"
print;F;I"OpenSSL::Buffering;T;[o;;I"*untyped args;T;I"nil;To;;I"‹Formats and writes to the stream converting parameters under control of the
format string.

See Kernel#sprintf for format string details.

;T;0;;;I"printf;F;I"OpenSSL::Buffering;T;[o;;I"*::String format_string, *untyped args;T;I"nil;To;;I"`Writes *args* to the stream along with a record separator.

See IO#puts for full details.

;T;0;;;I"	puts;F;I"OpenSSL::Buffering;T;[o;;I"*untyped args;T;I"nil;To;;I"’Reads *size* bytes from the stream.  If *buf* is provided it must reference a
string which will receive the data.

See IO#read for full details.

;T;0;;;I"	read;F;I"OpenSSL::Buffering;T;[o;;I"$?::Integer? size, ?::String buf;T;I"String?;To;;I"¼Reads at most *maxlen* bytes in the non-blocking manner.

When no data can be read without blocking it raises OpenSSL::SSL::SSLError
extended by IO::WaitReadable or IO::WaitWritable.

IO::WaitReadable means SSL needs to read internally so read_nonblock should be
called again when the underlying IO is readable.

IO::WaitWritable means SSL needs to write internally so read_nonblock should
be called again after the underlying IO is writable.

OpenSSL::Buffering#read_nonblock needs two rescue clause as follows:

    # emulates blocking read (readpartial).
    begin
      result = ssl.read_nonblock(maxlen)
    rescue IO::WaitReadable
      IO.select([io])
      retry
    rescue IO::WaitWritable
      IO.select(nil, [io])
      retry
    end

Note that one reason that read_nonblock writes to the underlying IO is when
the peer requests a new TLS/SSL handshake.  See openssl the FAQ for more
details.  http://www.openssl.org/support/faq.html

By specifying a keyword argument *exception* to `false`, you can indicate that
read_nonblock should not raise an IO::Wait*able exception, but return the
symbol `:wait_writable` or `:wait_readable` instead. At EOF, it will return
`nil` instead of raising EOFError.

;T;0;;;I"read_nonblock;F;I"OpenSSL::Buffering;T;[o;;I"6::Integer maxlen, ?::String buf, ?exception: true;T;I"String;To;;I"6::Integer maxlen, ?::String buf, exception: false;T;I"3String | :wait_writable | :wait_readable | nil;To;;I"XReads a one-character string from the stream.  Raises an EOFError at end of
file.

;T;0;;;I"readchar;F;I"OpenSSL::Buffering;T;[o;;I" ;F;I"String;To;;I"dReads a line from the stream which is separated by *eol*.

Raises EOFError if at end of file.

;T;0;;;I"readline;F;I"OpenSSL::Buffering;T;[o;;I"?::String eol;T;I"String;To;;I"PReads lines from the stream which are separated by *eol*.

See also #gets

;T;0;;;I"readlines;F;I"OpenSSL::Buffering;T;[o;;I"?::String eol;T;I"Array[::String];To;;I"£Reads at most *maxlen* bytes from the stream.  If *buf* is provided it must
reference a string which will receive the data.

See IO#readpartial for full details.

;T;0;;;I"readpartial;F;I"OpenSSL::Buffering;T;[o;;I"$::Integer maxlen, ?::String buf;T;I"String;To;;I"GThe "sync mode" of the SSLSocket.

See IO#sync for full details.

;T;0;;;I"	sync;F;I"OpenSSL::Buffering;T;[o;;I" ;F;I"	bool;To;;I"GThe "sync mode" of the SSLSocket.

See IO#sync for full details.

;T;0;;;I"
sync=;F;I"OpenSSL::Buffering;T;[o;;I"::boolish;T;I"	void;To;;I"äPushes character *c* back onto the stream such that a subsequent buffered
character read will return it.

Unlike IO#getc multiple bytes may be pushed back onto the stream.

Has no effect on unbuffered reads (such as #sysread).

;T;0;;;I"ungetc;F;I"OpenSSL::Buffering;T;[o;;I"::String c;T;I"String;To;;I"Writes *s* to the stream.  If the argument is not a String it will be
converted using `.to_s` method.  Returns the number of bytes written.

;T;0;;;I"
write;F;I"OpenSSL::Buffering;T;[o;;I"*::_ToS s;T;I"Integer;To;;I"óWrites *s* in the non-blocking manner.

If there is buffered data, it is flushed first.  This may block.

write_nonblock returns number of bytes written to the SSL connection.

When no data can be written without blocking it raises OpenSSL::SSL::SSLError
extended by IO::WaitReadable or IO::WaitWritable.

IO::WaitReadable means SSL needs to read internally so write_nonblock should
be called again after the underlying IO is readable.

IO::WaitWritable means SSL needs to write internally so write_nonblock should
be called again after underlying IO is writable.

So OpenSSL::Buffering#write_nonblock needs two rescue clause as follows.

    # emulates blocking write.
    begin
      result = ssl.write_nonblock(str)
    rescue IO::WaitReadable
      IO.select([io])
      retry
    rescue IO::WaitWritable
      IO.select(nil, [io])
      retry
    end

Note that one reason that write_nonblock reads from the underlying IO is when
the peer requests a new TLS/SSL handshake.  See the openssl FAQ for more
details.  http://www.openssl.org/support/faq.html

By specifying a keyword argument *exception* to `false`, you can indicate that
write_nonblock should not raise an IO::Wait*able exception, but return the
symbol `:wait_writable` or `:wait_readable` instead.

;T;0;;;I"write_nonblock;F;I"OpenSSL::Buffering;T;[o;;I"::_ToS s, ?exception: true;T;I"Integer;To;;I"::_ToS s, exception: false;T;I"4Integer | :wait_writable | :wait_readable | nil;To;;I",Consumes *size* bytes from the buffer

;T;0;;;I"consume_rbuff;F;I"OpenSSL::Buffering;T;[o;;I"?untyped size;T;I"untyped;To;;I"zWrites *s* to the buffer.  When the buffer is full or #sync is true the buffer
is flushed to the underlying socket.

;T;0;;;I"do_write;F;I"OpenSSL::Buffering;T;[o;;I"untyped s;T;I"untyped;To;;I"5Fills the buffer from the underlying SSLSocket

;T;0;;;I"fill_rbuff;F;I"OpenSSL::Buffering;T;[o;;I" ;F;I"untyped;To; ;I"2A buffer which will retain binary encoding.

;T;0;	I"OpenSSL::Buffering::Buffer;T;
[ ;[ ;0;[ ;[ ;0;I"String;To;;I" ;T;0;;;I"<<;F;I"OpenSSL::Buffering::Buffer;T;[o;;I"::String string;T;I"	self;To; ;I"Provides symmetric algorithms for encryption and decryption. The algorithms
that are available depend on the particular version of OpenSSL that is
installed.

### Listing all supported algorithms

A list of supported algorithms can be obtained by

    puts OpenSSL::Cipher.ciphers

### Instantiating a Cipher

There are several ways to create a Cipher instance. Generally, a Cipher
algorithm is categorized by its name, the key length in bits and the cipher
mode to be used. The most generic way to create a Cipher is the following

    cipher = OpenSSL::Cipher.new('<name>-<key length>-<mode>')

That is, a string consisting of the hyphenated concatenation of the individual
components name, key length and mode. Either all uppercase or all lowercase
strings may be used, for example:

    cipher = OpenSSL::Cipher.new('aes-128-cbc')

### Choosing either encryption or decryption mode

Encryption and decryption are often very similar operations for symmetric
algorithms, this is reflected by not having to choose different classes for
either operation, both can be done using the same class. Still, after
obtaining a Cipher instance, we need to tell the instance what it is that we
intend to do with it, so we need to call either

    cipher.encrypt

or

    cipher.decrypt

on the Cipher instance. This should be the first call after creating the
instance, otherwise configuration that has already been set could get lost in
the process.

### Choosing a key

Symmetric encryption requires a key that is the same for the encrypting and
for the decrypting party and after initial key establishment should be kept as
private information. There are a lot of ways to create insecure keys, the most
notable is to simply take a password as the key without processing the
password further. A simple and secure way to create a key for a particular
Cipher is

    cipher = OpenSSL::Cipher.new('aes-256-cfb')
    cipher.encrypt
    key = cipher.random_key # also sets the generated key on the Cipher

If you absolutely need to use passwords as encryption keys, you should use
Password-Based Key Derivation Function 2 (PBKDF2) by generating the key with
the help of the functionality provided by OpenSSL::PKCS5.pbkdf2_hmac_sha1 or
OpenSSL::PKCS5.pbkdf2_hmac.

Although there is Cipher#pkcs5_keyivgen, its use is deprecated and it should
only be used in legacy applications because it does not use the newer PKCS#5
v2 algorithms.

### Choosing an IV

The cipher modes CBC, CFB, OFB and CTR all need an "initialization vector", or
short, IV. ECB mode is the only mode that does not require an IV, but there is
almost no legitimate use case for this mode because of the fact that it does
not sufficiently hide plaintext patterns. Therefore

**You should never use ECB mode unless you are absolutely sure that you
absolutely need it**

Because of this, you will end up with a mode that explicitly requires an IV in
any case. Although the IV can be seen as public information, i.e. it may be
transmitted in public once generated, it should still stay unpredictable to
prevent certain kinds of attacks. Therefore, ideally

**Always create a secure random IV for every encryption of your Cipher**

A new, random IV should be created for every encryption of data. Think of the
IV as a nonce (number used once) - it's public but random and unpredictable. A
secure random IV can be created as follows

    cipher = ...
    cipher.encrypt
    key = cipher.random_key
    iv = cipher.random_iv # also sets the generated IV on the Cipher

Although the key is generally a random value, too, it is a bad choice as an
IV. There are elaborate ways how an attacker can take advantage of such an IV.
As a general rule of thumb, exposing the key directly or indirectly should be
avoided at all cost and exceptions only be made with good reason.

### Calling Cipher#final

ECB (which should not be used) and CBC are both block-based modes. This means
that unlike for the other streaming-based modes, they operate on fixed-size
blocks of data, and therefore they require a "finalization" step to produce or
correctly decrypt the last block of data by appropriately handling some form
of padding. Therefore it is essential to add the output of
OpenSSL::Cipher#final to your encryption/decryption buffer or you will end up
with decryption errors or truncated data.

Although this is not really necessary for streaming-mode ciphers, it is still
recommended to apply the same pattern of adding the output of Cipher#final
there as well - it also enables you to switch between modes more easily in the
future.

### Encrypting and decrypting some data

    data = "Very, very confidential data"

    cipher = OpenSSL::Cipher.new('aes-128-cbc')
    cipher.encrypt
    key = cipher.random_key
    iv = cipher.random_iv

    encrypted = cipher.update(data) + cipher.final
    ...
    decipher = OpenSSL::Cipher.new('aes-128-cbc')
    decipher.decrypt
    decipher.key = key
    decipher.iv = iv

    plain = decipher.update(encrypted) + decipher.final

    puts data == plain #=> true

### Authenticated Encryption and Associated Data (AEAD)

If the OpenSSL version used supports it, an Authenticated Encryption mode
(such as GCM or CCM) should always be preferred over any unauthenticated mode.
Currently, OpenSSL supports AE only in combination with Associated Data (AEAD)
where additional associated data is included in the encryption process to
compute a tag at the end of the encryption. This tag will also be used in the
decryption process and by verifying its validity, the authenticity of a given
ciphertext is established.

This is superior to unauthenticated modes in that it allows to detect if
somebody effectively changed the ciphertext after it had been encrypted. This
prevents malicious modifications of the ciphertext that could otherwise be
exploited to modify ciphertexts in ways beneficial to potential attackers.

An associated data is used where there is additional information, such as
headers or some metadata, that must be also authenticated but not necessarily
need to be encrypted. If no associated data is needed for encryption and later
decryption, the OpenSSL library still requires a value to be set - "" may be
used in case none is available.

An example using the GCM (Galois/Counter Mode). You have 16 bytes *key*, 12
bytes (96 bits) *nonce* and the associated data *auth_data*. Be sure not to
reuse the *key* and *nonce* pair. Reusing an nonce ruins the security
guarantees of GCM mode.

    cipher = OpenSSL::Cipher.new('aes-128-gcm').encrypt
    cipher.key = key
    cipher.iv = nonce
    cipher.auth_data = auth_data

    encrypted = cipher.update(data) + cipher.final
    tag = cipher.auth_tag # produces 16 bytes tag by default

Now you are the receiver. You know the *key* and have received *nonce*,
*auth_data*, *encrypted* and *tag* through an untrusted network. Note that GCM
accepts an arbitrary length tag between 1 and 16 bytes. You may additionally
need to check that the received tag has the correct length, or you allow
attackers to forge a valid single byte tag for the tampered ciphertext with a
probability of 1/256.

    raise "tag is truncated!" unless tag.bytesize == 16
    decipher = OpenSSL::Cipher.new('aes-128-gcm').decrypt
    decipher.key = key
    decipher.iv = nonce
    decipher.auth_tag = tag
    decipher.auth_data = auth_data

    decrypted = decipher.update(encrypted) + decipher.final

    puts data == decrypted #=> true

;T;0;	I"OpenSSL::Cipher;T;
[ ;[ ;0;[ ;[ ;0;0o;;I">Returns the names of all available ciphers in an array.

;T;0;;;I"ciphers;F;I"OpenSSL::Cipher;T;[o;;I" ;F;I"Array[::String];To;;I"Sets the cipher's additional authenticated data. This field must be set when
using AEAD cipher modes such as GCM or CCM. If no associated data shall be
used, this method must **still** be called with a value of "". The contents of
this field should be non-sensitive data which will be added to the ciphertext
to generate the authentication tag which validates the contents of the
ciphertext.

The AAD must be set prior to encryption or decryption. In encryption mode, it
must be set after calling Cipher#encrypt and setting Cipher#key= and
Cipher#iv=. When decrypting, the authenticated data must be set after key, iv
and especially **after** the authentication tag has been set. I.e. set it only
after calling Cipher#decrypt, Cipher#key=, Cipher#iv= and Cipher#auth_tag=
first.

;T;0;;;I"auth_data=;F;I"OpenSSL::Cipher;T;[o;;I"::String;T;I"String;To;;I"MGets the authentication tag generated by Authenticated Encryption Cipher modes
(GCM for example). This tag may be stored along with the ciphertext, then set
on the decryption cipher to authenticate the contents of the ciphertext
against changes. If the optional integer parameter *tag_len* is given, the
returned tag will be *tag_len* bytes long. If the parameter is omitted, the
default length of 16 bytes or the length previously set by #auth_tag_len= will
be used. For maximum security, the longest possible should be chosen.

The tag may only be retrieved after calling Cipher#final.

;T;0;;;I"auth_tag;F;I"OpenSSL::Cipher;T;[o;;I"?::Integer tag_len;T;I"String;To;;I"Sets the authentication tag to verify the integrity of the ciphertext. This
can be called only when the cipher supports AE. The tag must be set after
calling Cipher#decrypt, Cipher#key= and Cipher#iv=, but before calling
Cipher#final. After all decryption is performed, the tag is verified
automatically in the call to Cipher#final.

For OCB mode, the tag length must be supplied with #auth_tag_len= beforehand.

;T;0;;;I"auth_tag=;F;I"OpenSSL::Cipher;T;[o;;I"::String;T;I"String;To;;I"0Sets the length of the authentication tag to be generated or to be given for
AEAD ciphers that requires it as in input parameter. Note that not all AEAD
ciphers support this method.

In OCB mode, the length must be supplied both when encrypting and when
decrypting, and must be before specifying an IV.

;T;0;;;I"auth_tag_len=;F;I"OpenSSL::Cipher;T;[o;;I"::Integer;T;I"Integer;To;;I"TIndicated whether this Cipher instance uses an Authenticated Encryption mode.

;T;0;;;I"authenticated?;F;I"OpenSSL::Cipher;T;[o;;I" ;F;I"	bool;To;;I"PReturns the size in bytes of the blocks on which this Cipher operates on.

;T;0;;;I"block_size;F;I"OpenSSL::Cipher;T;[o;;I" ;F;I"Integer;To;;I"	Initializes the Cipher for decryption.

Make sure to call Cipher#encrypt or Cipher#decrypt before using any of the
following methods:

    #key=, #iv=, #random_key, #random_iv, #pkcs5_keyivgen
:

Internally calls EVP_CipherInit_ex(ctx, NULL, NULL, NULL, NULL, 0).

;T;0;;;I"decrypt;F;I"OpenSSL::Cipher;T;[o;;I" ;F;I"	self;To;;I"	Initializes the Cipher for encryption.

Make sure to call Cipher#encrypt or Cipher#decrypt before using any of the
following methods:

    #key=, #iv=, #random_key, #random_iv, #pkcs5_keyivgen
:

Internally calls EVP_CipherInit_ex(ctx, NULL, NULL, NULL, NULL, 1).

;T;0;;;I"encrypt;F;I"OpenSSL::Cipher;T;[o;;I" ;F;I"	self;To;;I"Returns the remaining data held in the cipher object. Further calls to
Cipher#update or Cipher#final will return garbage. This call should always be
made as the last call of an encryption or decryption operation, after having
fed the entire plaintext or ciphertext to the Cipher instance.

If an authenticated cipher was used, a CipherError is raised if the tag could
not be authenticated successfully. Only call this method after setting the
authentication tag and passing the entire contents of the ciphertext into the
cipher.

;T;0;;;I"
final;F;I"OpenSSL::Cipher;T;[o;;I" ;F;I"String;To;;I"”Sets the cipher IV. Please note that since you should never be using ECB mode,
an IV is always explicitly required and should be set prior to encryption. The
IV itself can be safely transmitted in public, but it should be unpredictable
to prevent certain kinds of attacks. You may use Cipher#random_iv to create a
secure random IV.

Only call this method after calling Cipher#encrypt or Cipher#decrypt.

;T;0;;;I"iv=;F;I"OpenSSL::Cipher;T;[o;;I"::String iv;T;I"String;To;;I"FReturns the expected length in bytes for an IV for this Cipher.

;T;0;;;I"iv_len;F;I"OpenSSL::Cipher;T;[o;;I" ;F;I"Integer;To;;I"ÉSets the IV/nonce length of the Cipher. Normally block ciphers don't allow
changing the IV length, but some make use of IV for 'nonce'. You may need this
for interoperability with other applications.

;T;0;;;I"iv_len=;F;I"OpenSSL::Cipher;T;[o;;I"::Integer;T;I"Integer;To;;I"]Sets the cipher key. To generate a key, you should either use a secure random
byte string or, if the key is to be derived from a password, you should rely
on PBKDF2 functionality provided by OpenSSL::PKCS5. To generate a secure
random-based key, Cipher#random_key may be used.

Only call this method after calling Cipher#encrypt or Cipher#decrypt.

;T;0;;;I"	key=;F;I"OpenSSL::Cipher;T;[o;;I"::String key;T;I"String;To;;I"5Returns the key length in bytes of the Cipher.

;T;0;;;I"key_len;F;I"OpenSSL::Cipher;T;[o;;I" ;F;I"Integer;To;;I"=Sets the key length of the cipher.  If the cipher is a fixed length cipher
then attempting to set the key length to any value other than the fixed value
is an error.

Under normal circumstances you do not need to call this method (and probably
shouldn't).

See EVP_CIPHER_CTX_set_key_length for further information.

;T;0;;;I"key_len=;F;I"OpenSSL::Cipher;T;[o;;I"::Integer;T;I"Integer;To;;I"`Returns the name of the cipher which may differ slightly from the original
name provided.

;T;0;;;I"	name;F;I"OpenSSL::Cipher;T;[o;;I" ;F;I"String;To;;I"…Enables or disables padding. By default encryption operations are padded using
standard block padding and the padding is checked and removed when decrypting.
If the pad parameter is zero then no padding is performed, the total amount of
data encrypted or decrypted must then be a multiple of the block size or an
error will occur.

See EVP_CIPHER_CTX_set_padding for further information.

;T;0;;;I"padding=;F;I"OpenSSL::Cipher;T;[o;;I"::Integer;T;I"Integer;To;;I"NGenerates and sets the key/IV based on a password.

**WARNING**: This method is only PKCS5 v1.5 compliant when using RC2, RC4-40,
or DES with MD5 or SHA1. Using anything else (like AES) will generate the
key/iv using an OpenSSL specific method. This method is deprecated and should
no longer be used. Use a PKCS5 v2 key generation method from OpenSSL::PKCS5
instead.

### Parameters
*   *salt* must be an 8 byte string if provided.
*   *iterations* is an integer with a default of 2048.
*   *digest* is a Digest object that defaults to 'MD5'


A minimum of 1000 iterations is recommended.

;T;0;;;I"pkcs5_keyivgen;F;I"OpenSSL::Cipher;T;[o;;I"K::String pass, ?::String salt, ?::Integer iterations, ?::String digest;T;I"	void;To;;I"£Generate a random IV with OpenSSL::Random.random_bytes and sets it to the
cipher, and returns it.

You must call #encrypt or #decrypt before calling this method.

;T;0;;;I"random_iv;F;I"OpenSSL::Cipher;T;[o;;I" ;F;I"String;To;;I"¤Generate a random key with OpenSSL::Random.random_bytes and sets it to the
cipher, and returns it.

You must call #encrypt or #decrypt before calling this method.

;T;0;;;I"random_key;F;I"OpenSSL::Cipher;T;[o;;I" ;F;I"String;To;;I"ÜFully resets the internal state of the Cipher. By using this, the same Cipher
instance may be used several times for encryption or decryption tasks.

Internally calls EVP_CipherInit_ex(ctx, NULL, NULL, NULL, NULL, -1).

;T;0;;;I"
reset;F;I"OpenSSL::Cipher;T;[o;;I" ;F;I"	self;To;;I"`Encrypts data in a streaming fashion. Hand consecutive blocks of data to the
#update method in order to encrypt it. Returns the encrypted data chunk. When
done, the output of Cipher#final should be additionally added to the result.

If *buffer* is given, the encryption/decryption result will be written to it.
*buffer* will be resized automatically.

;T;0;;;I"update;F;I"OpenSSL::Cipher;T;[o;;I"$::String data, ?::String buffer;T;I"String;To;;0;0;;;I"ciphers;F;I"OpenSSL::Cipher;T;[o;;I" ;F;I"Array[::String];To;;I"ŠThe string must contain a valid cipher name like "aes-256-cbc".

A list of cipher names is available by calling OpenSSL::Cipher.ciphers.

;T;0;;;I"initialize;F;I"OpenSSL::Cipher;T;[o;;I"::String cipher_name;T;I"	void;To;;I" ;T;0;;;I"initialize_copy;F;I"OpenSSL::Cipher;T;[o;;I"untyped;T;I"untyped;To; ;0;0;	I"OpenSSL::Cipher::AES;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::Cipher;To;;0;0;;;I"initialize;F;I"OpenSSL::Cipher::AES;T;[o;;I"*::_ToS args;T;I"	void;To; ;0;0;	I"OpenSSL::Cipher::AES128;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::Cipher;To;;0;0;;;I"initialize;F;I"OpenSSL::Cipher::AES128;T;[o;;I"?::_ToS mode;T;I"	void;To; ;0;0;	I"OpenSSL::Cipher::AES192;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::Cipher;To;;0;0;;;I"initialize;F;I"OpenSSL::Cipher::AES192;T;[o;;I"?::_ToS mode;T;I"	void;To; ;0;0;	I"OpenSSL::Cipher::AES256;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::Cipher;To;;0;0;;;I"initialize;F;I"OpenSSL::Cipher::AES256;T;[o;;I"?::_ToS mode;T;I"	void;To; ;0;0;	I"OpenSSL::Cipher::BF;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::Cipher;To;;0;0;;;I"initialize;F;I"OpenSSL::Cipher::BF;T;[o;;I"*::_ToS args;T;I"	void;To; ;0;0;	I"OpenSSL::Cipher::CAST5;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::Cipher;To;;0;0;;;I"initialize;F;I"OpenSSL::Cipher::CAST5;T;[o;;I"*::_ToS args;T;I"	void;To; ;I"aDeprecated.

This class is only provided for backwards compatibility. Use OpenSSL::Cipher.

;T;0;	I"OpenSSL::Cipher::Cipher;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::Cipher;To; ;0;0;	I"!OpenSSL::Cipher::CipherError;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::OpenSSLError;To; ;0;0;	I"OpenSSL::Cipher::DES;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::Cipher;To;;0;0;;;I"initialize;F;I"OpenSSL::Cipher::DES;T;[o;;I"*::_ToS args;T;I"	void;To; ;0;0;	I"OpenSSL::Cipher::IDEA;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::Cipher;To;;0;0;;;I"initialize;F;I"OpenSSL::Cipher::IDEA;T;[o;;I"*::_ToS args;T;I"	void;To; ;0;0;	I"OpenSSL::Cipher::RC2;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::Cipher;To;;0;0;;;I"initialize;F;I"OpenSSL::Cipher::RC2;T;[o;;I"*::_ToS args;T;I"	void;To; ;0;0;	I"OpenSSL::Cipher::RC4;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::Cipher;To;;0;0;;;I"initialize;F;I"OpenSSL::Cipher::RC4;T;[o;;I"*::_ToS args;T;I"	void;To; ;0;0;	I"OpenSSL::Cipher::RC5;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::Cipher;To;;0;0;;;I"initialize;F;I"OpenSSL::Cipher::RC5;T;[o;;I"*::_ToS args;T;I"	void;To; ;I"Configuration for the openssl library.

Many system's installation of openssl library will depend on your system
configuration. See the value of OpenSSL::Config::DEFAULT_CONFIG_FILE for the
location of the file for your host.

See also http://www.openssl.org/docs/apps/config.html

;T;0;	I"OpenSSL::Config;T;
[ ;[I"Enumerable;T;0;[ ;[ ;0;0o;;0;0;;;I"	load;F;I"OpenSSL::Config;T;[o;;I"?::_ToS filename;T;I"instance;To;;I"QParses a given *string* as a blob that contains configuration for OpenSSL.

;T;0;;;I"
parse;F;I"OpenSSL::Config;T;[o;;I"::String string;T;I"instance;To;;I"\Parses the configuration data read from *io* and returns the whole content as
a Hash.

;T;0;;;I"parse_config;F;I"OpenSSL::Config;T;[o;;I"::IO io;T;I"/Hash[::String, ::Hash[::String, ::String]];To;;I"ŠGets all key-value pairs in a specific *section* from the current
configuration.

Given the following configurating file being loaded:

    config = OpenSSL::Config.load('foo.cnf')
      #=> #<OpenSSL::Config sections=["default"]>
    puts config.to_s
      #=> [ default ]
      #   foo=bar

You can get a hash of the specific section like so:

    config['default']
      #=> {"foo"=>"bar"}

;T;0;;;I"[];F;I"OpenSSL::Config;T;[o;;I"::String section;T;I"Hash[::String, ::String];To;;I"í*Deprecated in v2.2.0*. This method will be removed in a future release.

Sets a specific *section* name with a Hash *pairs*.

Given the following configuration being created:

    config = OpenSSL::Config.new
      #=> #<OpenSSL::Config sections=[]>
    config['default'] = {"foo"=>"bar","baz"=>"buz"}
      #=> {"foo"=>"bar", "baz"=>"buz"}
    puts config.to_s
      #=> [ default ]
      #   foo=bar
      #   baz=buz

It's important to note that this will essentially merge any of the keys in
*pairs* with the existing *section*. For example:

    config['default']
      #=> {"foo"=>"bar", "baz"=>"buz"}
    config['default'] = {"foo" => "changed"}
      #=> {"foo"=>"changed"}
    config['default']
      #=> {"foo"=>"changed", "baz"=>"buz"}

;T;0;;;I"[]=;F;I"OpenSSL::Config;T;[o;;I"<::String section, ::_Each[[ ::String, ::String ]] pairs;T;I""_Each[[ ::String, ::String ]];To;;I"/*Deprecated in v2.2.0*. This method will be removed in a future release.

Set the target *key* with a given *value* under a specific *section*.

Given the following configurating file being loaded:

    config = OpenSSL::Config.load('foo.cnf')
      #=> #<OpenSSL::Config sections=["default"]>
    puts config.to_s
      #=> [ default ]
      #   foo=bar

You can set the value of *foo* under the *default* section to a new value:

    config.add_value('default', 'foo', 'buzz')
      #=> "buzz"
    puts config.to_s
      #=> [ default ]
      #   foo=buzz

;T;0;;;I"add_value;F;I"OpenSSL::Config;T;[o;;I"1::String section, untyped key, untyped value;T;I"untyped;To;;I"‚Retrieves the section and its pairs for the current configuration.

    config.each do |section, key, value|
      # ...
    end

;T;0;;;I"	each;F;I"OpenSSL::Config;T;[o;;I" ;F;I"	self;To;;I"˜Gets the value of *key* from the given *section*.

Given the following configurating file being loaded:

    config = OpenSSL::Config.load('foo.cnf')
      #=> #<OpenSSL::Config sections=["default"]>
    puts config.to_s
      #=> [ default ]
      #   foo=bar

You can get a specific value from the config if you know the *section* and
*key* like so:

    config.get_value('default','foo')
      #=> "bar"

;T;0;;;I"get_value;F;I"OpenSSL::Config;T;[o;;I"#::String section, ::String key;T;I"String?;To;;I"eString representation of this configuration object, including the class name
and its sections.

;T;0;;;I"inspect;F;I"OpenSSL::Config;T;[o;;I" ;F;I"String;To;;0;0;;;I"section;F;I"OpenSSL::Config;T;[o;;I"::String name;T;I"Hash[::String, ::String];To;;I"BGet the names of all sections in the current configuration.

;T;0;;;I"sections;F;I"OpenSSL::Config;T;[o;;I" ;F;I"Array[::String];To;;I"¥Gets the parsable form of the current configuration.

Given the following configuration being created:

    config = OpenSSL::Config.new
      #=> #<OpenSSL::Config sections=[]>
    config['default'] = {"foo"=>"bar","baz"=>"buz"}
      #=> {"foo"=>"bar", "baz"=>"buz"}
    puts config.to_s
      #=> [ default ]
      #   foo=bar
      #   baz=buz

You can parse get the serialized configuration using #to_s and then parse it
later:

    serialized_config = config.to_s
    # much later...
    new_config = OpenSSL::Config.parse(serialized_config)
      #=> #<OpenSSL::Config sections=["default"]>
    puts new_config
      #=> [ default ]
          foo=bar
          baz=buz

;T;0;;;I"	to_s;F;I"OpenSSL::Config;T;[o;;I" ;F;I"String;To;;I"WCreates an instance of OpenSSL::Config from the content of the file specified
by *filename*.

This can be used in contexts like OpenSSL::X509::ExtensionFactory.config=

This can raise IO exceptions based on the access, or availability of the file.
A ConfigError exception may be raised depending on the validity of the data
being configured.

;T;0;;;I"initialize;F;I"OpenSSL::Config;T;[o;;I"?::_ToS filename;T;I"	void;To;;I" ;T;0;;;I"initialize_copy;F;I"OpenSSL::Config;T;[o;;I"instance other;T;I"	void;To; ;I"hGeneral error for openssl library configuration files. Including formatting,
parsing errors, etc.

;T;0;	I"OpenSSL::ConfigError;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::OpenSSLError;To; ;I"oOpenSSL::Digest allows you to compute message digests (sometimes
interchangeably called "hashes") of arbitrary data that are cryptographically
secure, i.e. a Digest implements a secure one-way function.

One-way functions offer some useful properties. E.g. given two distinct inputs
the probability that both yield the same output is highly unlikely. Combined
with the fact that every message digest algorithm has a fixed-length output of
just a few bytes, digests are often used to create unique identifiers for
arbitrary data. A common example is the creation of a unique id for binary
documents that are stored in a database.

Another useful characteristic of one-way functions (and thus the name) is that
given a digest there is no indication about the original data that produced
it, i.e. the only way to identify the original input is to "brute-force"
through every possible combination of inputs.

These characteristics make one-way functions also ideal companions for public
key signature algorithms: instead of signing an entire document, first a hash
of the document is produced with a considerably faster message digest
algorithm and only the few bytes of its output need to be signed using the
slower public key algorithm. To validate the integrity of a signed document,
it suffices to re-compute the hash and verify that it is equal to that in the
signature.

You can get a list of all digest algorithms supported on your system by
running this command in your terminal:

    openssl list -digest-algorithms

Among the OpenSSL 1.1.1 supported message digest algorithms are:
*   SHA224, SHA256, SHA384, SHA512, SHA512-224 and SHA512-256
*   SHA3-224, SHA3-256, SHA3-384 and SHA3-512
*   BLAKE2s256 and BLAKE2b512


Each of these algorithms can be instantiated using the name:

    digest = OpenSSL::Digest.new('SHA256')

"Breaking" a message digest algorithm means defying its one-way function
characteristics, i.e. producing a collision or finding a way to get to the
original data by means that are more efficient than brute-forcing etc. Most of
the supported digest algorithms can be considered broken in this sense, even
the very popular MD5 and SHA1 algorithms. Should security be your highest
concern, then you should probably rely on SHA224, SHA256, SHA384 or SHA512.

### Hashing a file

    data = File.binread('document')
    sha256 = OpenSSL::Digest.new('SHA256')
    digest = sha256.digest(data)

### Hashing several pieces of data at once

    data1 = File.binread('file1')
    data2 = File.binread('file2')
    data3 = File.binread('file3')
    sha256 = OpenSSL::Digest.new('SHA256')
    sha256 << data1
    sha256 << data2
    sha256 << data3
    digest = sha256.digest

### Reuse a Digest instance

    data1 = File.binread('file1')
    sha256 = OpenSSL::Digest.new('SHA256')
    digest1 = sha256.digest(data1)

    data2 = File.binread('file2')
    sha256.reset
    digest2 = sha256.digest(data2)

;T;0;	I"OpenSSL::Digest;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"Return the hash value computed with *name* Digest. *name* is either the long
name or short name of a supported digest algorithm.

### Examples

    OpenSSL::Digest.digest("SHA256", "abc")

which is equivalent to:

    OpenSSL::Digest.digest('SHA256', "abc")

;T;0;;;I"digest;F;I"OpenSSL::Digest;T;[o;;I"!::String name, ::String data;T;I"String;To;;I"?Returns the block length of the digest algorithm, i.e. the length in bytes of
an individual block. Most modern algorithms partition a message to be digested
into a sequence of fix-sized blocks that are processed consecutively.

### Example
    digest = OpenSSL::Digest.new('SHA1')
    puts digest.block_length # => 64

;T;0;;;I"block_length;F;I"OpenSSL::Digest;T;[o;;I" ;F;I"Integer;To;;0;0;;;I"digest;F;I"OpenSSL::Digest;T;[o;;I"?::String data;T;I"String;To;;I"ÁReturns the output size of the digest, i.e. the length in bytes of the final
message digest result.

### Example
    digest = OpenSSL::Digest.new('SHA1')
    puts digest.digest_length # => 20

;T;0;;;I"digest_length;F;I"OpenSSL::Digest;T;[o;;I" ;F;I"Integer;To;;0;0;;;I"hexdigest;F;I"OpenSSL::Digest;T;[o;;I" ;F;I"String;To;;I"ƒReturns the sn of this Digest algorithm.

### Example
    digest = OpenSSL::Digest.new('SHA512')
    puts digest.name # => SHA512

;T;0;;;I"	name;F;I"OpenSSL::Digest;T;[o;;I" ;F;I"String;To;;I"ŽResets the Digest in the sense that any Digest#update that has been performed
is abandoned and the Digest is set to its initial state again.

;T;0;;;I"
reset;F;I"OpenSSL::Digest;T;[o;;I" ;F;I"	self;To;;I"Not every message digest can be computed in one single pass. If a message
digest is to be computed from several subsequent sources, then each may be
passed individually to the Digest instance.

### Example
    digest = OpenSSL::Digest.new('SHA256')
    digest.update('First input')
    digest << 'Second input' # equivalent to digest.update('Second input')
    result = digest.digest

;T;0;;;I"update;F;I"OpenSSL::Digest;T;[o;;I"::String data;T;I"	self;To;;I" ;T;0;;;I"finish;F;I"OpenSSL::Digest;T;[o;;I"*untyped;T;I"untyped;To;;I"zCreates a Digest instance based on *string*, which is either the ln (long
name) or sn (short name) of a supported digest algorithm.

If *data* (a String) is given, it is used as the initial input to the Digest
instance, i.e.

    digest = OpenSSL::Digest.new('sha256', 'digestdata')

is equivalent to

    digest = OpenSSL::Digest.new('sha256')
    digest.update('digestdata')

;T;0;;;I"initialize;F;I"OpenSSL::Digest;T;[o;;I""::String name, ?::String data;T;I"	void;To;;I" ;T;0;;;I"initialize_copy;F;I"OpenSSL::Digest;T;[o;;I"instance;T;I"	void;To; ;0;0;	I"OpenSSL::Digest::Digest;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::Digest;To; ;I"[Generic Exception class that is raised if an error occurs during a Digest
operation.

;T;0;	I"!OpenSSL::Digest::DigestError;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::OpenSSLError;To; ;0;0;	I"OpenSSL::Digest::MD4;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::Digest;To;;0;0;;;I"digest;F;I"OpenSSL::Digest::MD4;T;[o;;I"::String data;T;I"String;To;;0;0;;;I"hexdigest;F;I"OpenSSL::Digest::MD4;T;[o;;I"::String data;T;I"String;To;;0;0;;;I"initialize;F;I"OpenSSL::Digest::MD4;T;[o;;I"?::String data;T;I"	void;To; ;0;0;	I"OpenSSL::Digest::MD5;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::Digest;To;;0;0;;;I"digest;F;I"OpenSSL::Digest::MD5;T;[o;;I"::String data;T;I"String;To;;0;0;;;I"hexdigest;F;I"OpenSSL::Digest::MD5;T;[o;;I"::String data;T;I"String;To;;0;0;;;I"initialize;F;I"OpenSSL::Digest::MD5;T;[o;;I"?::String data;T;I"	void;To; ;0;0;	I"OpenSSL::Digest::RIPEMD160;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::Digest;To;;0;0;;;I"digest;F;I"OpenSSL::Digest::RIPEMD160;T;[o;;I"::String data;T;I"String;To;;0;0;;;I"hexdigest;F;I"OpenSSL::Digest::RIPEMD160;T;[o;;I"::String data;T;I"String;To;;0;0;;;I"initialize;F;I"OpenSSL::Digest::RIPEMD160;T;[o;;I"?::String data;T;I"	void;To; ;0;0;	I"OpenSSL::Digest::SHA1;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::Digest;To;;0;0;;;I"digest;F;I"OpenSSL::Digest::SHA1;T;[o;;I"::String data;T;I"String;To;;0;0;;;I"hexdigest;F;I"OpenSSL::Digest::SHA1;T;[o;;I"::String data;T;I"String;To;;0;0;;;I"initialize;F;I"OpenSSL::Digest::SHA1;T;[o;;I"?::String data;T;I"	void;To; ;0;0;	I"OpenSSL::Digest::SHA224;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::Digest;To;;0;0;;;I"digest;F;I"OpenSSL::Digest::SHA224;T;[o;;I"::String data;T;I"String;To;;0;0;;;I"hexdigest;F;I"OpenSSL::Digest::SHA224;T;[o;;I"::String data;T;I"String;To;;0;0;;;I"initialize;F;I"OpenSSL::Digest::SHA224;T;[o;;I"?::String data;T;I"	void;To; ;0;0;	I"OpenSSL::Digest::SHA256;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::Digest;To;;0;0;;;I"digest;F;I"OpenSSL::Digest::SHA256;T;[o;;I"::String data;T;I"String;To;;0;0;;;I"hexdigest;F;I"OpenSSL::Digest::SHA256;T;[o;;I"::String data;T;I"String;To;;0;0;;;I"initialize;F;I"OpenSSL::Digest::SHA256;T;[o;;I"?::String data;T;I"	void;To; ;0;0;	I"OpenSSL::Digest::SHA384;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::Digest;To;;0;0;;;I"digest;F;I"OpenSSL::Digest::SHA384;T;[o;;I"::String data;T;I"String;To;;0;0;;;I"hexdigest;F;I"OpenSSL::Digest::SHA384;T;[o;;I"::String data;T;I"String;To;;0;0;;;I"initialize;F;I"OpenSSL::Digest::SHA384;T;[o;;I"?::String data;T;I"	void;To; ;0;0;	I"OpenSSL::Digest::SHA512;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::Digest;To;;0;0;;;I"digest;F;I"OpenSSL::Digest::SHA512;T;[o;;I"::String data;T;I"String;To;;0;0;;;I"hexdigest;F;I"OpenSSL::Digest::SHA512;T;[o;;I"::String data;T;I"String;To;;0;0;;;I"initialize;F;I"OpenSSL::Digest::SHA512;T;[o;;I"?::String data;T;I"	void;To; ;I"ŽThis class is the access to openssl's ENGINE cryptographic module
implementation.

See also, https://www.openssl.org/docs/crypto/engine.html

;T;0;	I"OpenSSL::Engine;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"áFetches the engine as specified by the *id* String.

    OpenSSL::Engine.by_id("openssl")
     => #<OpenSSL::Engine id="openssl" name="Software engine support">

See OpenSSL::Engine.engines for the currently loaded engines.

;T;0;;;I"
by_id;F;I"OpenSSL::Engine;T;[o;;I"::String name;T;I"instance;To;;I"ÉIt is only necessary to run cleanup when engines are loaded via
OpenSSL::Engine.load. However, running cleanup before exit is recommended.

Note that this is needed and works only in OpenSSL < 1.1.0.

;T;0;;;I"cleanup;F;I"OpenSSL::Engine;T;[o;;I" ;F;I"	void;To;;I"4Returns an array of currently loaded engines.

;T;0;;;I"engines;F;I"OpenSSL::Engine;T;[o;;I" ;F;I"Array[instance];To;;I"æThis method loads engines. If *name* is nil, then all builtin engines are
loaded. Otherwise, the given *name*, as a String,  is loaded if available to
your runtime, and returns true. If *name* is not found, then nil is returned.

;T;0;;;I"	load;F;I"OpenSSL::Engine;T;[o;;I"?::String name;T;I"true | nil;Fo;;I"GReturns a new instance of OpenSSL::Cipher by *name*, if it is available in
this engine.

An EngineError will be raised if the cipher is unavailable.

    e = OpenSSL::Engine.by_id("openssl")
     => #<OpenSSL::Engine id="openssl" name="Software engine support">
    e.cipher("RC4")
     => #<OpenSSL::Cipher:0x007fc5cacc3048>

;T;0;;;I"cipher;F;I"OpenSSL::Engine;T;[o;;I"::String cipher;T;I"OpenSSL::Cipher;To;;I"EReturns an array of command definitions for the current engine

;T;0;;;I"	cmds;F;I"OpenSSL::Engine;T;[o;;I" ;F;I",Array[[ ::String, ::String, ::String ]];To;;I"]Sends the given *command* to this engine.

Raises an EngineError if the command fails.

;T;0;;;I"ctrl_cmd;F;I"OpenSSL::Engine;T;[o;;I""::String cmd, ?::String value;T;I"	self;To;;I"‘Returns a new instance of OpenSSL::Digest by *name*.

Will raise an EngineError if the digest is unavailable.

    e = OpenSSL::Engine.by_id("openssl")
      #=> #<OpenSSL::Engine id="openssl" name="Software engine support">
    e.digest("SHA1")
      #=> #<OpenSSL::Digest: da39a3ee5e6b4b0d3255bfef95601890afd80709>
    e.digest("zomg")
      #=> OpenSSL::Engine::EngineError: no such digest `zomg'

;T;0;;;I"digest;F;I"OpenSSL::Engine;T;[o;;I"::String digest;T;I"OpenSSL::Digest;To;;I"zReleases all internal structural references for this engine.

May raise an EngineError if the engine is unavailable

;T;0;;;I"finish;F;I"OpenSSL::Engine;T;[o;;I" ;F;I"nil;To;;I"©Gets the id for this engine.

    OpenSSL::Engine.load
    OpenSSL::Engine.engines #=> [#<OpenSSL::Engine#>, ...]
    OpenSSL::Engine.engines.first.id
      #=> "rsax"

;T;0;;;I"id;F;I"OpenSSL::Engine;T;[o;;I" ;F;I"String;To;;I"!Pretty prints this engine.

;T;0;;;I"inspect;F;I"OpenSSL::Engine;T;[o;;I" ;F;I"String;To;;I"{Loads the given private key identified by *id* and *data*.

An EngineError is raised of the OpenSSL::PKey is unavailable.

;T;0;;;I"load_private_key;F;I"OpenSSL::Engine;T;[o;;I"!?::String id, ?::String data;T;I"OpenSSL::PKey::PKey;To;;I"Loads the given public key identified by *id* and *data*.

An EngineError is raised of the OpenSSL::PKey is unavailable.

;T;0;;;I"load_public_key;F;I"OpenSSL::Engine;T;[o;;I"!?::String id, ?::String data;T;I"OpenSSL::PKey::PKey;To;;I"ÇGet the descriptive name for this engine.

    OpenSSL::Engine.load
    OpenSSL::Engine.engines #=> [#<OpenSSL::Engine#>, ...]
    OpenSSL::Engine.engines.first.name
      #=> "RSAX engine support"

;T;0;;;I"	name;F;I"OpenSSL::Engine;T;[o;;I" ;F;I"String;To;;I"Set the defaults for this engine with the given *flag*.

These flags are used to control combinations of algorithm methods.

*flag* can be one of the following, other flags are available depending on
your OS.

All flags
:   0xFFFF
No flags
:   0x0000


See also <openssl/engine.h>

;T;0;;;I"set_default;F;I"OpenSSL::Engine;T;[o;;I"::Integer flag;T;I"	bool;To; ;I"GThis is the generic exception for OpenSSL::Engine related errors

;T;0;	I"!OpenSSL::Engine::EngineError;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::OpenSSLError;To;;I"2This module contains configuration information about the SSL extension, for
example if socket support is enabled, or the host name TLS extension is
enabled.  Constants in this module will always be defined, but contain `true`
or `false` values depending on the configuration of your OpenSSL installation.

;T;0;	I"OpenSSL::ExtConfig;T;
[ ;[ ;0;[ ;[ o; ;I"OpenSSL::HMAC allows computing Hash-based Message Authentication Code (HMAC).
It is a type of message authentication code (MAC) involving a hash function in
combination with a key. HMAC can be used to verify the integrity of a message
as well as the authenticity.

OpenSSL::HMAC has a similar interface to OpenSSL::Digest.

### HMAC-SHA256 using one-shot interface

    key = "key"
    data = "message-to-be-authenticated"
    mac = OpenSSL::HMAC.hexdigest("SHA256", key, data)
    #=> "cddb0db23f469c8bf072b21fd837149bd6ace9ab771cceef14c9e517cc93282e"

### HMAC-SHA256 using incremental interface

    data1 = File.binread("file1")
    data2 = File.binread("file2")
    key = "key"
    hmac = OpenSSL::HMAC.new(key, 'SHA256')
    hmac << data1
    hmac << data2
    mac = hmac.digest

;T;0;	I"OpenSSL::HMAC;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"¢Returns the authentication code as a binary string. The *digest* parameter
specifies the digest algorithm to use. This may be a String representing the
algorithm name or an instance of OpenSSL::Digest.

### Example
    key = 'key'
    data = 'The quick brown fox jumps over the lazy dog'

    hmac = OpenSSL::HMAC.digest('SHA1', key, data)
    #=> "\xDE|\x9B\x85\xB8\xB7\x8A\xA6\xBC\x8Az6\xF7\n\x90p\x1C\x9D\xB4\xD9"

;T;0;;;I"digest;F;I"OpenSSL::HMAC;T;[o;;I"C::String | ::OpenSSL::Digest algo, ::String key, ::String data;T;I"String;To;;I"Returns the authentication code as a hex-encoded string. The *digest*
parameter specifies the digest algorithm to use. This may be a String
representing the algorithm name or an instance of OpenSSL::Digest.

### Example
    key = 'key'
    data = 'The quick brown fox jumps over the lazy dog'

    hmac = OpenSSL::HMAC.hexdigest('SHA1', key, data)
    #=> "de7c9b85b8b78aa6bc8a7a36f70a90701c9db4d9"

;T;0;;;I"hexdigest;F;I"OpenSSL::HMAC;T;[o;;I"C::String | ::OpenSSL::Digest algo, ::String key, ::String data;T;I"String;To;;I"DSecurely compare with another HMAC instance in constant time.

;T;0;;;I"==;F;I"OpenSSL::HMAC;T;[o;;I"instance other;T;I"	bool;To;;I"Returns the authentication code an instance represents as a binary string.

### Example
    instance = OpenSSL::HMAC.new('key', 'SHA1')
    #=> f42bb0eeb018ebbd4597ae7213711ec60760843f
    instance.digest
    #=> "\xF4+\xB0\xEE\xB0\x18\xEB\xBDE\x97\xAEr\x13q\x1E\xC6\a`\x84?"

;T;0;;;I"digest;F;I"OpenSSL::HMAC;T;[o;;I" ;F;I"String;To;;I"VReturns the authentication code an instance represents as a hex-encoded
string.

;T;0;;;I"hexdigest;F;I"OpenSSL::HMAC;T;[o;;I" ;F;I"String;To;;I"šReturns *hmac* as it was when it was first initialized, with all processed
data cleared from it.

### Example

    data = "The quick brown fox jumps over the lazy dog"
    instance = OpenSSL::HMAC.new('key', 'SHA1')
    #=> f42bb0eeb018ebbd4597ae7213711ec60760843f

    instance.update(data)
    #=> de7c9b85b8b78aa6bc8a7a36f70a90701c9db4d9
    instance.reset
    #=> f42bb0eeb018ebbd4597ae7213711ec60760843f

;T;0;;;I"
reset;F;I"OpenSSL::HMAC;T;[o;;I" ;F;I"	self;To;;I"}Returns *hmac* updated with the message to be authenticated. Can be called
repeatedly with chunks of the message.

### Example

    first_chunk = 'The quick brown fox jumps '
    second_chunk = 'over the lazy dog'

    instance.update(first_chunk)
    #=> 5b9a8038a65d571076d97fe783989e52278a492a
    instance.update(second_chunk)
    #=> de7c9b85b8b78aa6bc8a7a36f70a90701c9db4d9

;T;0;;;I"update;F;I"OpenSSL::HMAC;T;[o;;I"::String data;T;I"	self;To;;I"ÀReturns an instance of OpenSSL::HMAC set with the key and digest algorithm to
be used. The instance represents the initial state of the message
authentication code before any data has been processed. To process data with
it, use the instance method #update with your data as an argument.

### Example

    key = 'key'
    instance = OpenSSL::HMAC.new(key, 'SHA1')
    #=> f42bb0eeb018ebbd4597ae7213711ec60760843f
    instance.class
    #=> OpenSSL::HMAC

### A note about comparisons

Two instances can be securely compared with #== in constant time:

        other_instance = OpenSSL::HMAC.new('key', 'SHA1')
    #=> f42bb0eeb018ebbd4597ae7213711ec60760843f
    instance == other_instance
    #=> true

;T;0;;;I"initialize;F;I"OpenSSL::HMAC;T;[o;;I"6::String key, ::String | ::OpenSSL::Digest digest;T;I"	void;To;;I" ;T;0;;;I"initialize_copy;F;I"OpenSSL::HMAC;T;[o;;I"instance;T;I"	void;To; ;I"1Document-class: OpenSSL::HMAC

OpenSSL::HMAC allows computing Hash-based Message Authentication Code (HMAC).
It is a type of message authentication code (MAC) involving a hash function in
combination with a key. HMAC can be used to verify the integrity of a message
as well as the authenticity.

OpenSSL::HMAC has a similar interface to OpenSSL::Digest.

### HMAC-SHA256 using one-shot interface

    key = "key"
    data = "message-to-be-authenticated"
    mac = OpenSSL::HMAC.hexdigest("SHA256", key, data)
    #=> "cddb0db23f469c8bf072b21fd837149bd6ace9ab771cceef14c9e517cc93282e"

### HMAC-SHA256 using incremental interface

    data1 = File.binread("file1")
    data2 = File.binread("file2")
    key = "key"
    hmac = OpenSSL::HMAC.new(key, 'SHA256')
    hmac << data1
    hmac << data2
    mac = hmac.digest

;T;0;	I"OpenSSL::HMACError;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::OpenSSLError;To;;I"öProvides functionality of various KDFs (key derivation function).

KDF is typically used for securely deriving arbitrary length symmetric keys to
be used with an OpenSSL::Cipher from passwords. Another use case is for
storing passwords: Due to the ability to tweak the effort of computation by
increasing the iteration count, computation can be slowed down artificially in
order to render possible attacks infeasible.

Currently, OpenSSL::KDF provides implementations for the following KDF:

*   PKCS #5 PBKDF2 (Password-Based Key Derivation Function 2) in combination
    with HMAC
*   scrypt
*   HKDF


## Examples
### Generating a 128 bit key for a Cipher (e.g. AES)
    pass = "secret"
    salt = OpenSSL::Random.random_bytes(16)
    iter = 20_000
    key_len = 16
    key = OpenSSL::KDF.pbkdf2_hmac(pass, salt: salt, iterations: iter,
                                   length: key_len, hash: "sha1")

### Storing Passwords
    pass = "secret"
    # store this with the generated value
    salt = OpenSSL::Random.random_bytes(16)
    iter = 20_000
    hash = OpenSSL::Digest.new('SHA256')
    len = hash.digest_length
    # the final value to be stored
    value = OpenSSL::KDF.pbkdf2_hmac(pass, salt: salt, iterations: iter,
                                     length: len, hash: hash)

## Important Note on Checking Passwords
When comparing passwords provided by the user with previously stored values, a
common mistake made is comparing the two values using "==". Typically, "=="
short-circuits on evaluation, and is therefore vulnerable to timing attacks.
The proper way is to use a method that always takes the same amount of time
when comparing two values, thus not leaking any information to potential
attackers. To do this, use `OpenSSL.fixed_length_secure_compare`.

;T;0;	I"OpenSSL::KDF;T;
[ ;[ ;0;[ ;[ o;;I"HMAC-based Extract-and-Expand Key Derivation Function (HKDF) as specified in
[RFC 5869](https://tools.ietf.org/html/rfc5869).

New in OpenSSL 1.1.0.

### Parameters
*ikm*
:   The input keying material.
*salt*
:   The salt.
*info*
:   The context and application specific information.
*length*
:   The output length in octets. Must be <= `255 * HashLen`, where HashLen is
    the length of the hash function output in octets.
*hash*
:   The hash function.


### Example
    # The values from https://datatracker.ietf.org/doc/html/rfc5869#appendix-A.1
    ikm = ["0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b"].pack("H*")
    salt = ["000102030405060708090a0b0c"].pack("H*")
    info = ["f0f1f2f3f4f5f6f7f8f9"].pack("H*")
    p OpenSSL::KDF.hkdf(ikm, salt: salt, info: info, length: 42, hash: "SHA256").unpack1("H*")
    # => "3cb25f25faacd57a90434f64d0362f2a2d2d0a90cf1a5a4c5db02d56ecc4c5bf34007208d5b887185865"

;T;0;;;I"	hkdf;F;I"OpenSSL::KDF;T;[o;;I"T::String ikm, salt: ::String, info: ::String, length: ::Integer, hash: ::String;T;I"String;To;;I"ÏPKCS #5 PBKDF2 (Password-Based Key Derivation Function 2) in combination with
HMAC. Takes *pass*, *salt* and *iterations*, and then derives a key of
*length* bytes.

For more information about PBKDF2, see RFC 2898 Section 5.2
(https://tools.ietf.org/html/rfc2898#section-5.2).

### Parameters
pass
:   The passphrase.
salt
:   The salt. Salts prevent attacks based on dictionaries of common passwords
    and attacks based on rainbow tables. It is a public value that can be
    safely stored along with the password (e.g. if the derived value is used
    for password storage).
iterations
:   The iteration count. This provides the ability to tune the algorithm. It
    is better to use the highest count possible for the maximum resistance to
    brute-force attacks.
length
:   The desired length of the derived key in octets.
hash
:   The hash algorithm used with HMAC for the PRF. May be a String
    representing the algorithm name, or an instance of OpenSSL::Digest.

;T;0;;;I"pbkdf2_hmac;F;I"OpenSSL::KDF;T;[o;;I"p::String pass, salt: ::String, iterations: ::Integer, length: ::Integer, hash: ::String | ::OpenSSL::Digest;T;I"String;To;;I"øDerives a key from *pass* using given parameters with the scrypt
password-based key derivation function. The result can be used for password
storage.

scrypt is designed to be memory-hard and more secure against brute-force
attacks using custom hardwares than alternative KDFs such as PBKDF2 or bcrypt.

The keyword arguments *N*, *r* and *p* can be used to tune scrypt. RFC 7914
(published on 2016-08, https://tools.ietf.org/html/rfc7914#section-2) states
that using values r=8 and p=1 appears to yield good results.

See RFC 7914 (https://tools.ietf.org/html/rfc7914) for more information.

### Parameters
pass
:   Passphrase.
salt
:   Salt.
N
:   CPU/memory cost parameter. This must be a power of 2.
r
:   Block size parameter.
p
:   Parallelization parameter.
length
:   Length in octets of the derived key.


### Example
    pass = "password"
    salt = SecureRandom.random_bytes(16)
    dk = OpenSSL::KDF.scrypt(pass, salt: salt, N: 2**14, r: 8, p: 1, length: 32)
    p dk #=> "\xDA\xE4\xE2...\x7F\xA1\x01T"

;T;0;;;I"scrypt;F;I"OpenSSL::KDF;T;[o;;I"_::String pass, salt: ::String, N: ::Integer, r: ::Integer, p: ::Integer, length: ::Integer;T;I"String;To;;0;0;;;I"	hkdf;F;I"OpenSSL::KDF;T;[o;;I"*untyped;T;I"untyped;To;;0;0;;;I"pbkdf2_hmac;F;I"OpenSSL::KDF;T;[o;;I"*untyped;T;I"untyped;To;;0;0;;;I"scrypt;F;I"OpenSSL::KDF;T;[o;;I"*untyped;T;I"untyped;To; ;I"PGeneric exception class raised if an error occurs in OpenSSL::KDF module.

;T;0;	I"OpenSSL::KDF::KDFError;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::OpenSSLError;To;;0;0;	I"OpenSSL::Marshal;T;
[ ;[ ;0;[ ;[ o;;I" ;T;0;;;I"included;F;I"OpenSSL::Marshal;T;[o;;I"untyped base;T;I"untyped;To;;I" ;T;0;;;I"
_dump;F;I"OpenSSL::Marshal;T;[o;;I"untyped _level;T;I"untyped;To;;0;0;	I"#OpenSSL::Marshal::ClassMethods;T;
[ ;[ ;0;[ ;[ o;;I" ;T;0;;;I"
_load;F;I"#OpenSSL::Marshal::ClassMethods;T;[o;;I"untyped string;T;I"untyped;To;;I"óOpenSSL::Netscape is a namespace for SPKI (Simple Public Key Infrastructure)
which implements Signed Public Key and Challenge. See [RFC
2692](http://tools.ietf.org/html/rfc2692) and [RFC
2693](http://tools.ietf.org/html/rfc2692) for details.

;T;0;	I"OpenSSL::Netscape;T;
[ ;[ ;0;[ ;[ o; ;I"gA Simple Public Key Infrastructure implementation (pronounced "spooky"). The
structure is defined as
    PublicKeyAndChallenge ::= SEQUENCE {
      spki SubjectPublicKeyInfo,
      challenge IA5STRING
    }

    SignedPublicKeyAndChallenge ::= SEQUENCE {
      publicKeyAndChallenge PublicKeyAndChallenge,
      signatureAlgorithm AlgorithmIdentifier,
      signature BIT STRING
    }

where the definitions of SubjectPublicKeyInfo and AlgorithmIdentifier can be
found in RFC5280. SPKI is typically used in browsers for generating a
public/private key pair and a subsequent certificate request, using the HTML
<keygen> element.

## Examples

### Creating an SPKI
    key = OpenSSL::PKey::RSA.new 2048
    spki = OpenSSL::Netscape::SPKI.new
    spki.challenge = "RandomChallenge"
    spki.public_key = key.public_key
    spki.sign(key, OpenSSL::Digest.new('SHA256'))
    #send a request containing this to a server generating a certificate

### Verifying an SPKI request
    request = #...
    spki = OpenSSL::Netscape::SPKI.new request
    unless spki.verify(spki.public_key)
      # signature is invalid
    end
    #proceed

;T;0;	I"OpenSSL::Netscape::SPKI;T;
[ ;[ ;0;[ ;[ ;0;0o;;I">Returns the challenge string associated with this SPKI.

;T;0;;;I"challenge;F;I"OpenSSL::Netscape::SPKI;T;[o;;I" ;F;I"String;To;;I"µ### Parameters
*   *str* - the challenge string to be set for this instance


Sets the challenge to be associated with the SPKI. May be used by the server,
e.g. to prevent replay.

;T;0;;;I"challenge=;F;I"OpenSSL::Netscape::SPKI;T;[o;;I"::String;T;I"String;To;;I"UReturns the public key associated with the SPKI, an instance of OpenSSL::PKey.

;T;0;;;I"public_key;F;I"OpenSSL::Netscape::SPKI;T;[o;;I" ;F;I"OpenSSL::PKey::PKey;To;;I"õ### Parameters
*   *pub* - the public key to be set for this instance


Sets the public key to be associated with the SPKI, an instance of
OpenSSL::PKey. This should be the public key corresponding to the private key
used for signing the SPKI.

;T;0;;;I"public_key=;F;I"OpenSSL::Netscape::SPKI;T;[o;;I"::OpenSSL::PKey::PKey;T;I"OpenSSL::PKey::PKey;To;;I"v### Parameters
*   *key* - the private key to be used for signing this instance
*   *digest* - the digest to be used for signing this instance


To sign an SPKI, the private key corresponding to the public key set for this
instance should be used, in addition to a digest algorithm in the form of an
OpenSSL::Digest. The private key should be an instance of OpenSSL::PKey.

;T;0;;;I"	sign;F;I"OpenSSL::Netscape::SPKI;T;[o;;I"8::OpenSSL::PKey::PKey key, ::OpenSSL::Digest digest;T;I"instance;To;;I"-Returns the DER encoding of this SPKI.

;T;0;;;I"to_der;F;I"OpenSSL::Netscape::SPKI;T;[o;;I" ;F;I"String;To;;I"-Returns the PEM encoding of this SPKI.

;T;0;;;I"to_pem;F;I"OpenSSL::Netscape::SPKI;T;[o;;I" ;F;I"String;To;;I"TReturns a textual representation of this SPKI, useful for debugging purposes.

;T;0;;;I"to_text;F;I"OpenSSL::Netscape::SPKI;T;[o;;I" ;F;I"String;To;;I"â### Parameters
*   *key* - the public key to be used for verifying the SPKI signature


Returns `true` if the signature is valid, `false` otherwise. To verify an
SPKI, the public key contained within the SPKI should be used.

;T;0;;;I"verify;F;I"OpenSSL::Netscape::SPKI;T;[o;;I"::OpenSSL::PKey::PKey key;T;I"	bool;To;;I"X### Parameters
*   *request* - optional raw request, either in PEM or DER format.

;T;0;;;I"initialize;F;I"OpenSSL::Netscape::SPKI;T;[o;;I"?::String request;T;I"	void;To; ;I"Generic Exception class that is raised if an error occurs during an operation
on an instance of OpenSSL::Netscape::SPKI.

;T;0;	I"!OpenSSL::Netscape::SPKIError;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::OpenSSLError;To;;I"OpenSSL::OCSP implements Online Certificate Status Protocol requests and
responses.

Creating and sending an OCSP request requires a subject certificate that
contains an OCSP URL in an authorityInfoAccess extension and the issuer
certificate for the subject certificate.  First, load the issuer and subject
certificates:

    subject = OpenSSL::X509::Certificate.new subject_pem
    issuer  = OpenSSL::X509::Certificate.new issuer_pem

To create the request we need to create a certificate ID for the subject
certificate so the CA knows which certificate we are asking about:

    digest = OpenSSL::Digest.new('SHA1')
    certificate_id =
      OpenSSL::OCSP::CertificateId.new subject, issuer, digest

Then create a request and add the certificate ID to it:

    request = OpenSSL::OCSP::Request.new
    request.add_certid certificate_id

Adding a nonce to the request protects against replay attacks but not all CA
process the nonce.

    request.add_nonce

To submit the request to the CA for verification we need to extract the OCSP
URI from the subject certificate:

    ocsp_uris = subject.ocsp_uris

    require 'uri'

    ocsp_uri = URI ocsp_uris[0]

To submit the request we'll POST the request to the OCSP URI (per RFC 2560).
Note that we only handle HTTP requests and don't handle any redirects in this
example, so this is insufficient for serious use.

    require 'net/http'

    http_response =
      Net::HTTP.start ocsp_uri.hostname, ocsp.port do |http|
        http.post ocsp_uri.path, request.to_der,
                  'content-type' => 'application/ocsp-request'
    end

    response = OpenSSL::OCSP::Response.new http_response.body
    response_basic = response.basic

First we check if the response has a valid signature.  Without a valid
signature we cannot trust it.  If you get a failure here you may be missing a
system certificate store or may be missing the intermediate certificates.

    store = OpenSSL::X509::Store.new
    store.set_default_paths

    unless response_basic.verify [], store then
      raise 'response is not signed by a trusted certificate'
    end

The response contains the status information (success/fail).  We can display
the status as a string:

    puts response.status_string #=> successful

Next we need to know the response details to determine if the response matches
our request.  First we check the nonce.  Again, not all CAs support a nonce.
See Request#check_nonce for the meanings of the return values.

    p request.check_nonce basic_response #=> value from -1 to 3

Then extract the status information for the certificate from the basic
response.

    single_response = basic_response.find_response(certificate_id)

    unless single_response
      raise 'basic_response does not have the status for the certificate'
    end

Then check the validity. A status issued in the future must be rejected.

    unless single_response.check_validity
      raise 'this_update is in the future or next_update time has passed'
    end

    case single_response.cert_status
    when OpenSSL::OCSP::V_CERTSTATUS_GOOD
      puts 'certificate is still valid'
    when OpenSSL::OCSP::V_CERTSTATUS_REVOKED
      puts "certificate has been revoked at #{single_response.revocation_time}"
    when OpenSSL::OCSP::V_CERTSTATUS_UNKNOWN
      puts 'responder doesn't know about the certificate'
    end

;T;0;	I"OpenSSL::OCSP;T;
[ ;[ ;0;[ ;[ o; ;I"°An OpenSSL::OCSP::BasicResponse contains the status of a certificate check
which is created from an OpenSSL::OCSP::Request.  A BasicResponse is more
detailed than a Response.

;T;0;	I"!OpenSSL::OCSP::BasicResponse;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"]Adds *nonce* to this response.  If no nonce was provided a random nonce will
be added.

;T;0;;;I"add_nonce;F;I"!OpenSSL::OCSP::BasicResponse;T;[o;;I"?::String nonce;T;I"	self;To;;I"Adds a certificate status for *certificate_id*. *status* is the status, and
must be one of these:

*   OpenSSL::OCSP::V_CERTSTATUS_GOOD
*   OpenSSL::OCSP::V_CERTSTATUS_REVOKED
*   OpenSSL::OCSP::V_CERTSTATUS_UNKNOWN


*reason* and *revocation_time* can be given only when *status* is
OpenSSL::OCSP::V_CERTSTATUS_REVOKED. *reason* describes the reason for the
revocation, and must be one of OpenSSL::OCSP::REVOKED_STATUS_* constants.
*revocation_time* is the time when the certificate is revoked.

*this_update* and *next_update* indicate the time at which the status is
verified to be correct and the time at or before which newer information will
be available, respectively. *next_update* is optional.

*extensions* is an Array of OpenSSL::X509::Extension to be included in the
SingleResponse. This is also optional.

Note that the times, *revocation_time*, *this_update* and *next_update* can be
specified in either of Integer or Time object. If they are Integer, it is
treated as the relative seconds from the current time.

;T;0;;;I"add_status;F;I"!OpenSSL::OCSP::BasicResponse;T;[o;;I"ô::OpenSSL::OCSP::CertificateId certificate_id, ::OpenSSL::OCSP::ocsp_status status, ::Integer? reason, ::Integer? revocation_time, ?::Integer | ::Time this_update, ?::Integer | ::Time next_update, ?::Array[::OpenSSL::X509::Extension] extensions;T;I"	self;To;;I"bCopies the nonce from *request* into this response.  Returns 1 on success and
0 on failure.

;T;0;;;I"copy_nonce;F;I"!OpenSSL::OCSP::BasicResponse;T;[o;;I"%::OpenSSL::OCSP::Request request;T;I"Integer;To;;I"Returns a SingleResponse whose CertId matches with *certificate_id*, or `nil`
if this BasicResponse does not contain it.

;T;0;;;I"find_response;F;I"!OpenSSL::OCSP::BasicResponse;T;[o;;I"2::OpenSSL::OCSP::CertificateId certificate_id;T;I"#OpenSSL::OCSP::SingleResponse?;To;;I"AReturns an Array of SingleResponse for this BasicResponse.

;T;0;;;I"responses;F;I"!OpenSSL::OCSP::BasicResponse;T;[o;;I" ;F;I"+Array[::OpenSSL::OCSP::SingleResponse];To;;I"NSigns this OCSP response using the *cert*, *key* and optional *digest*. This
behaves in the similar way as OpenSSL::OCSP::Request#sign.

*flags* can include:
OpenSSL::OCSP::NOCERTS
:   don't include certificates
OpenSSL::OCSP::NOTIME
:   don't set producedAt
OpenSSL::OCSP::RESPID_KEY
:   use signer's public key hash as responderID

;T;0;;;I"	sign;F;I"!OpenSSL::OCSP::BasicResponse;T;[o;;I"—::OpenSSL::X509::Certificate cert, ::OpenSSL::PKey::PKey key, ?::Array[::OpenSSL::X509::Certificate] certs, ?::Integer flags, ?::OpenSSL::Digest digest;T;I"	self;To;;I"‚Returns an Array of statuses for this response.  Each status contains a
CertificateId, the status (0 for good, 1 for revoked, 2 for unknown), the
reason for the status, the revocation time, the time of this update, the time
for the next update and a list of OpenSSL::X509::Extension.

This should be superseded by BasicResponse#responses and #find_response that
return SingleResponse.

;T;0;;;I"status;F;I"!OpenSSL::OCSP::BasicResponse;T;[o;;I" ;F;I"Integer;To;;I"=Encodes this basic response into a DER-encoded string.

;T;0;;;I"to_der;F;I"!OpenSSL::OCSP::BasicResponse;T;[o;;I" ;F;I"String;To;;I"”Verifies the signature of the response using the given *certificates* and
*store*. This works in the similar way as OpenSSL::OCSP::Request#verify.

;T;0;;;I"verify;F;I"!OpenSSL::OCSP::BasicResponse;T;[o;;I"`::Array[::OpenSSL::X509::Certificate] certs, ::OpenSSL::X509::Store store, ?::Integer flags;T;I"	bool;To;;I"ZCreates a new BasicResponse. If *der_string* is given, decodes *der_string* as
DER.

;T;0;;;I"initialize;F;I"!OpenSSL::OCSP::BasicResponse;T;[o;;I"?::String der;T;I"	void;To;;I" ;T;0;;;I"initialize_copy;F;I"!OpenSSL::OCSP::BasicResponse;T;[o;;I"instance;T;I"	void;To; ;I"rAn OpenSSL::OCSP::CertificateId identifies a certificate to the CA so that a
status check can be performed.

;T;0;	I"!OpenSSL::OCSP::CertificateId;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"YCompares this certificate id with *other* and returns `true` if they are the
same.

;T;0;;;I"cmp;F;I"!OpenSSL::OCSP::CertificateId;T;[o;;I"instance other;T;I"	bool;To;;I"bCompares this certificate id's issuer with *other* and returns `true` if they
are the same.

;T;0;;;I"cmp_issuer;F;I"!OpenSSL::OCSP::CertificateId;T;[o;;I"instance other;T;I"	bool;To;;I"yReturns the ln (long name) of the hash algorithm used to generate the
issuerNameHash and the issuerKeyHash values.

;T;0;;;I"hash_algorithm;F;I"!OpenSSL::OCSP::CertificateId;T;[o;;I" ;F;I"String;To;;I"]Returns the issuerKeyHash of this certificate ID, the hash of the issuer's
public key.

;T;0;;;I"issuer_key_hash;F;I"!OpenSSL::OCSP::CertificateId;T;[o;;I" ;F;I"String;To;;I"ƒReturns the issuerNameHash of this certificate ID, the hash of the issuer's
distinguished name calculated with the hashAlgorithm.

;T;0;;;I"issuer_name_hash;F;I"!OpenSSL::OCSP::CertificateId;T;[o;;I" ;F;I"String;To;;I"XReturns the serial number of the certificate for which status is being
requested.

;T;0;;;I"serial;F;I"!OpenSSL::OCSP::CertificateId;T;[o;;I" ;F;I"Integer;To;;I"EEncodes this certificate identifier into a DER-encoded string.

;T;0;;;I"to_der;F;I"!OpenSSL::OCSP::CertificateId;T;[o;;I" ;F;I"String;To;;I"nCreates a new OpenSSL::OCSP::CertificateId for the given *subject* and
*issuer* X509 certificates.  The *digest* is a digest algorithm that is used
to compute the hash values. This defaults to SHA-1.

If only one argument is given, decodes it as DER representation of a
certificate ID or generates certificate ID from the object that responds to
the to_der method.

;T;0;;;I"initialize;F;I"!OpenSSL::OCSP::CertificateId;T;[o;;I"+::String | ::OpenSSL::ASN1::_ToDer der;T;I"	void;To;;I"i::OpenSSL::X509::Certificate subject, ::OpenSSL::X509::Certificate issuer, ?::OpenSSL::Digest digest;T;I"	void;To;;I" ;T;0;;;I"initialize_copy;F;I"!OpenSSL::OCSP::CertificateId;T;[o;;I"instance;T;I"	void;To; ;I"OCSP error class.

;T;0;	I"OpenSSL::OCSP::OCSPError;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::OpenSSLError;To; ;I"×An OpenSSL::OCSP::Request contains the certificate information for determining
if a certificate has been revoked or not.  A Request can be created for a
certificate or from a DER-encoded request created elsewhere.

;T;0;	I"OpenSSL::OCSP::Request;T;
[ ;[ ;0;[ ;[ ;0;0o;;I",Adds *certificate_id* to the request.

;T;0;;;I"add_certid;F;I"OpenSSL::OCSP::Request;T;[o;;I"2::OpenSSL::OCSP::CertificateId certificate_id;T;I"	self;To;;I"¬Adds a *nonce* to the OCSP request.  If no nonce is given a random one will be
generated.

The nonce is used to prevent replay attacks but some servers do not support
it.

;T;0;;;I"add_nonce;F;I"OpenSSL::OCSP::Request;T;[o;;I"?::String nonce;T;I"	self;To;;I"3Returns all certificate IDs in this request.

;T;0;;;I"certid;F;I"OpenSSL::OCSP::Request;T;[o;;I" ;F;I"*Array[::OpenSSL::OCSP::CertificateId];To;;I"´Checks the nonce validity for this request and *response*.

The return value is one of the following:

-1
:   nonce in request only.
0
:   nonces both present and not equal.
1
:   nonces present and equal.
2
:   nonces both absent.
3
:   nonce present in response only.


For most responses, clients can check *result* > 0.  If a responder doesn't
handle nonces `result.nonzero?` may be necessary.  A result of `0` is always
an error.

;T;0;;;I"check_nonce;F;I"OpenSSL::OCSP::Request;T;[o;;I"'::OpenSSL::OCSP::Response response;T;I"-1 | 0 | 1 | 2 | 3;Fo;;I"Signs this OCSP request using *cert*, *key* and optional *digest*. If *digest*
is not specified, SHA-1 is used. *certs* is an optional Array of additional
certificates which are included in the request in addition to the signer
certificate. Note that if *certs* is `nil` or not given, flag
OpenSSL::OCSP::NOCERTS is enabled. Pass an empty array to include only the
signer certificate.

*flags* is a bitwise OR of the following constants:

OpenSSL::OCSP::NOCERTS
:   Don't include any certificates in the request. *certs* will be ignored.

;T;0;;;I"	sign;F;I"OpenSSL::OCSP::Request;T;[o;;I"—::OpenSSL::X509::Certificate cert, ::OpenSSL::PKey::PKey key, ?::Array[::OpenSSL::X509::Certificate] certs, ?::Integer flags, ?::OpenSSL::Digest digest;T;I"	self;To;;I"•Returns `true` if the request is signed, `false` otherwise. Note that the
validity of the signature is **not** checked. Use #verify to verify that.

;T;0;;;I"signed?;F;I"OpenSSL::OCSP::Request;T;[o;;I" ;F;I"	bool;To;;I"3Returns this request as a DER-encoded string

;T;0;;;I"to_der;F;I"OpenSSL::OCSP::Request;T;[o;;I" ;F;I"String;To;;I"&Verifies this request using the given *certificates* and *store*.
*certificates* is an array of OpenSSL::X509::Certificate, *store* is an
OpenSSL::X509::Store.

Note that `false` is returned if the request does not have a signature. Use
#signed? to check whether the request is signed or not.

;T;0;;;I"verify;F;I"OpenSSL::OCSP::Request;T;[o;;I"`::Array[::OpenSSL::X509::Certificate] certs, ::OpenSSL::X509::Store store, ?::Integer flags;T;I"	bool;To;;I"nCreates a new OpenSSL::OCSP::Request.  The request may be created empty or
from a *request_der* string.

;T;0;;;I"initialize;F;I"OpenSSL::OCSP::Request;T;[o;;I"?::String der;T;I"	void;To;;I" ;T;0;;;I"initialize_copy;F;I"OpenSSL::OCSP::Request;T;[o;;I"instance;T;I"	void;To; ;I"}An OpenSSL::OCSP::Response contains the status of a certificate check which is
created from an OpenSSL::OCSP::Request.

;T;0;	I"OpenSSL::OCSP::Response;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"MCreates an OpenSSL::OCSP::Response from *status* and *basic_response*.

;T;0;;;I"create;F;I"OpenSSL::OCSP::Response;T;[o;;I"?::Integer status, ?::OpenSSL::OCSP::BasicResponse response;T;I"instance;To;;I"0Returns a BasicResponse for this response

;T;0;;;I"
basic;F;I"OpenSSL::OCSP::Response;T;[o;;I" ;F;I""OpenSSL::OCSP::BasicResponse?;To;;I"*Returns the status of the response.

;T;0;;;I"status;F;I"OpenSSL::OCSP::Response;T;[o;;I" ;F;I"Integer;To;;I"0Returns a status string for the response.

;T;0;;;I"status_string;F;I"OpenSSL::OCSP::Response;T;[o;;I" ;F;I"String;To;;I"5Returns this response as a DER-encoded string.

;T;0;;;I"to_der;F;I"OpenSSL::OCSP::Response;T;[o;;I" ;F;I"String;To;;I"qCreates a new OpenSSL::OCSP::Response.  The response may be created empty or
from a *response_der* string.

;T;0;;;I"initialize;F;I"OpenSSL::OCSP::Response;T;[o;;I"?::String der;T;I"	void;To;;I" ;T;0;;;I"initialize_copy;F;I"OpenSSL::OCSP::Response;T;[o;;I"instance;T;I"	void;To; ;I"–An OpenSSL::OCSP::SingleResponse represents an OCSP SingleResponse structure,
which contains the basic information of the status of the certificate.

;T;0;	I""OpenSSL::OCSP::SingleResponse;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"8Returns the status of the certificate identified by the certid. The return
value may be one of these constant:

*   V_CERTSTATUS_GOOD
*   V_CERTSTATUS_REVOKED
*   V_CERTSTATUS_UNKNOWN


When the status is V_CERTSTATUS_REVOKED, the time at which the certificate was
revoked can be retrieved by #revocation_time.

;T;0;;;I"cert_status;F;I""OpenSSL::OCSP::SingleResponse;T;[o;;I" ;F;I"OpenSSL::OCSP::ocsp_status;To;;I"BReturns the CertificateId for which this SingleResponse is.

;T;0;;;I"certid;F;I""OpenSSL::OCSP::SingleResponse;T;[o;;I" ;F;I"!OpenSSL::OCSP::CertificateId;To;;I"Checks the validity of thisUpdate and nextUpdate fields of this
SingleResponse. This checks the current time is within the range thisUpdate to
nextUpdate.

It is possible that the OCSP request takes a few seconds or the time is not
accurate. To avoid rejecting a valid response, this method allows the times to
be within *nsec* seconds of the current time.

Some responders don't set the nextUpdate field. This may cause a very old
response to be considered valid. The *maxsec* parameter can be used to limit
the age of responses.

;T;0;;;I"check_validity;F;I""OpenSSL::OCSP::SingleResponse;T;[o;;I"'?::Integer nsec, ?::Integer maxsec;T;I"	bool;To;;I" ;T;0;;;I"extensions;F;I""OpenSSL::OCSP::SingleResponse;T;[o;;I" ;F;I"(Array[::OpenSSL::X509::Certificate];To;;I" ;T;0;;;I"next_update;F;I""OpenSSL::OCSP::SingleResponse;T;[o;;I" ;F;I"
Time?;To;;I" ;T;0;;;I"revocation_reason;F;I""OpenSSL::OCSP::SingleResponse;T;[o;;I" ;F;I"Integer?;To;;I" ;T;0;;;I"revocation_time;F;I""OpenSSL::OCSP::SingleResponse;T;[o;;I" ;F;I"
Time?;To;;I" ;T;0;;;I"this_update;F;I""OpenSSL::OCSP::SingleResponse;T;[o;;I" ;F;I"	Time;To;;I"=Encodes this SingleResponse into a DER-encoded string.

;T;0;;;I"to_der;F;I""OpenSSL::OCSP::SingleResponse;T;[o;;I" ;F;I"String;To;;I"6Creates a new SingleResponse from *der_string*.

;T;0;;;I"initialize;F;I""OpenSSL::OCSP::SingleResponse;T;[o;;I"::String der;T;I"	void;To;;I" ;T;0;;;I"initialize_copy;F;I""OpenSSL::OCSP::SingleResponse;T;[o;;I"instance;T;I"	void;To; ;I"AGeneric error, common for all classes under OpenSSL module

;T;0;	I"OpenSSL::OpenSSLError;T;
[ ;[ ;0;[ ;[ ;0;I"StandardError;To; ;I"•Defines a file format commonly used to store private keys with accompanying
public key certificates, protected with a password-based symmetric key.

;T;0;	I"OpenSSL::PKCS12;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"ƒ### Parameters
*   *pass* - string
*   *name* - A string describing the key.
*   *key* - Any PKey.
*   *cert* - A X509::Certificate.
    *   The public_key portion of the certificate must contain a valid public
        key.
    *   The not_before and not_after fields must be filled in.

*   *ca* - An optional array of X509::Certificate's.
*   *key_pbe* - string
*   *cert_pbe* - string
*   *key_iter* - integer
*   *mac_iter* - integer
*   *keytype* - An integer representing an MSIE specific extension.


Any optional arguments may be supplied as `nil` to preserve the OpenSSL
defaults.

See the OpenSSL documentation for PKCS12_create().

;T;0;;;I"create;F;I"OpenSSL::PKCS12;T;[o;;I"ð::String pass, ::String name, ::OpenSSL::PKey::PKey key, ::OpenSSL::X509::Certificate cert, ?::Array[::OpenSSL::X509::Certificate]? ca, ?::String? key_pbe, ?::String? cert_pbe, ?::Integer? key_iter, ?::Integer? mac_iter, ?::Integer? keytype;T;I"instance;To;;0;0;;;I"ca_certs;F;I"OpenSSL::PKCS12;T;[o;;I" ;F;I")Array[::OpenSSL::X509::Certificate]?;To;;0;0;;;I"certificate;F;I"OpenSSL::PKCS12;T;[o;;I" ;F;I"OpenSSL::X509::Certificate;To;;0;0;;;I"key;F;I"OpenSSL::PKCS12;T;[o;;I" ;F;I"OpenSSL::PKey::PKey;To;;I" ;T;0;;;I"to_der;F;I"OpenSSL::PKCS12;T;[o;;I" ;F;I"String;To;;I"Z### Parameters
*   *str* - Must be a DER encoded PKCS12 string.
*   *pass* - string

;T;0;;;I"initialize;F;I"OpenSSL::PKCS12;T;[o;;I""?::String der, ?::String pass;T;I"	void;To;;I" ;T;0;;;I"initialize_copy;F;I"OpenSSL::PKCS12;T;[o;;I"instance;T;I"	void;To; ;0;0;	I"!OpenSSL::PKCS12::PKCS12Error;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::OpenSSLError;To;;0;0;	I"OpenSSL::PKCS5;T;
[ ;[ ;0;[ ;[ o;;0;0;;;I"pbkdf2_hmac;F;I"OpenSSL::PKCS5;T;[o;;I"h::String pass, ::String salt, ::Integer iter, ::Integer keylen, ::String | ::OpenSSL::Digest digest;T;I"String;To;;0;0;;;I"pbkdf2_hmac_sha1;F;I"OpenSSL::PKCS5;T;[o;;I"C::String pass, ::String salt, ::Integer iter, ::Integer keylen;T;I"String;To;;I"OpenSSL::PKCS5.pbkdf2_hmac has been renamed to OpenSSL::KDF.pbkdf2_hmac. This
method is provided for backwards compatibility.

;T;0;;;I"pbkdf2_hmac;F;I"OpenSSL::PKCS5;T;[o;;I"Muntyped pass, untyped salt, untyped iter, untyped keylen, untyped digest;T;I"untyped;To;;I" ;T;0;;;I"pbkdf2_hmac_sha1;F;I"OpenSSL::PKCS5;T;[o;;I"=untyped pass, untyped salt, untyped iter, untyped keylen;T;I"untyped;To; ;0;0;	I"OpenSSL::PKCS7;T;
[ ;[ ;0;[ ;[ ;0;0o;;I" ;T;0;;;I"encrypt;F;I"OpenSSL::PKCS7;T;[o;;I"c::OpenSSL::X509::Certificate certs, ::String data, ?::OpenSSL::Cipher cipher, ?::Integer flags;T;I"instance;To;;I" ;T;0;;;I"read_smime;F;I"OpenSSL::PKCS7;T;[o;;I"::String;T;I"instance;To;;I" ;T;0;;;I"	sign;F;I"OpenSSL::PKCS7;T;[o;;I"~::OpenSSL::X509::Certificate certs, ::OpenSSL::PKey::PKey key, ::String data, ?::OpenSSL::Cipher cipher, ?::Integer flags;T;I"instance;To;;I" ;T;0;;;I"write_smime;F;I"OpenSSL::PKCS7;T;[o;;I"5instance pkcs7, ?::String data, ?::Integer flags;T;I"String;To;;I" ;T;0;;;I"add_certificate;F;I"OpenSSL::PKCS7;T;[o;;I"&::OpenSSL::X509::Certificate cert;T;I"	self;To;;I" ;T;0;;;I"add_crl;F;I"OpenSSL::PKCS7;T;[o;;I"::OpenSSL::X509::CRL crl;T;I"	self;To;;I" ;T;0;;;I"add_data;F;I"OpenSSL::PKCS7;T;[o;;I"::String data;T;I"	self;To;;I" ;T;0;;;I"add_recipient;F;I"OpenSSL::PKCS7;T;[o;;I".::OpenSSL::PKCS7::RecipientInfo recipient;T;I"	self;To;;I" ;T;0;;;I"add_signer;F;I"OpenSSL::PKCS7;T;[o;;I"(::OpenSSL::PKCS7::SignerInfo signer;T;I"	self;To;;I" ;T;0;;;I"certificates;F;I"OpenSSL::PKCS7;T;[o;;I" ;F;I")Array[::OpenSSL::X509::Certificate]?;To;;I" ;T;0;;;I"certificates=;F;I"OpenSSL::PKCS7;T;[o;;I"*::Array[::OpenSSL::X509::Certificate];T;I"	self;To;;I" ;T;0;;;I"cipher=;F;I"OpenSSL::PKCS7;T;[o;;I"::OpenSSL::Cipher cipher;T;I"	self;To;;I" ;T;0;;;I"	crls;F;I"OpenSSL::PKCS7;T;[o;;I" ;F;I"!Array[::OpenSSL::X509::CRL]?;To;;I" ;T;0;;;I"
crls=;F;I"OpenSSL::PKCS7;T;[o;;I""::Array[::OpenSSL::X509::CRL];T;I"	self;To;;0;0;;;I"	data;F;I"OpenSSL::PKCS7;T;[o;;I" ;F;I"String?;To;;I" ;T;0;;;I"decrypt;F;I"OpenSSL::PKCS7;T;[o;;I"S::OpenSSL::PKey::PKey p1, ?::OpenSSL::PKey::PKey p2, ?::OpenSSL::PKey::PKey p3;T;I"String;To;;I" ;T;0;;;I"detached;F;I"OpenSSL::PKCS7;T;[o;;I" ;F;I"	bool;To;;I" ;T;0;;;I"detached=;F;I"OpenSSL::PKCS7;T;[o;;I"::boolish;T;I"U;Fo;;I" ;T;0;;;I"detached?;F;I"OpenSSL::PKCS7;T;[o;;I" ;F;I"	bool;To;;0;0;;;I"error_string;F;I"OpenSSL::PKCS7;T;[o;;I" ;F;I"String?;To;;0;0;;;I"error_string=;F;I"OpenSSL::PKCS7;T;[o;;I"::String;T;I"String;To;;I" ;T;0;;;I"recipients;F;I"OpenSSL::PKCS7;T;[o;;I" ;F;I"+Array[::OpenSSL::PKCS7::RecipientInfo];To;;I" ;T;0;;;I"signers;F;I"OpenSSL::PKCS7;T;[o;;I" ;F;I"(Array[::OpenSSL::PKCS7::SignerInfo];To;;I" ;T;0;;;I"to_der;F;I"OpenSSL::PKCS7;T;[o;;I" ;F;I"String;To;;I" ;T;0;;;I"to_pem;F;I"OpenSSL::PKCS7;T;[o;;I" ;F;I"String;To;;I" ;T;0;;;I"	type;F;I"OpenSSL::PKCS7;T;[o;;I" ;F;I"String?;To;;I" ;T;0;;;I"
type=;F;I"OpenSSL::PKCS7;T;[o;;I"::String;T;I"String;To;;I" ;T;0;;;I"verify;F;I"OpenSSL::PKCS7;T;[o;;I"m::OpenSSL::PKey::PKey p1, ::OpenSSL::PKey::PKey p2, ?::OpenSSL::PKey::PKey p3, ?::OpenSSL::PKey::PKey p4;T;I"	bool;To;;I"4Many methods in this class aren't documented.

;T;0;;;I"initialize;F;I"OpenSSL::PKCS7;T;[o;;I"?::String der;T;I"	void;To;;I" ;T;0;;;I"initialize_copy;F;I"OpenSSL::PKCS7;T;[o;;I"instance;T;I"untyped;To; ;0;0;	I"OpenSSL::PKCS7::PKCS7Error;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::OpenSSLError;To; ;0;0;	I""OpenSSL::PKCS7::RecipientInfo;T;
[ ;[ ;0;[ ;[ ;0;0o;;I" ;T;0;;;I"enc_key;F;I""OpenSSL::PKCS7::RecipientInfo;T;[o;;I" ;F;I"OpenSSL::PKey::PKey;To;;I" ;T;0;;;I"issuer;F;I""OpenSSL::PKCS7::RecipientInfo;T;[o;;I" ;F;I"OpenSSL::X509::Name;To;;I" ;T;0;;;I"serial;F;I""OpenSSL::PKCS7::RecipientInfo;T;[o;;I" ;F;I"Integer;To;;I" ;T;0;;;I"initialize;F;I""OpenSSL::PKCS7::RecipientInfo;T;[o;;I"-::OpenSSL::X509::Certificate certificate;T;I"	void;To; ;0;0;	I"OpenSSL::PKCS7::SignerInfo;T;
[ ;[ ;0;[ ;[ ;0;0o;;I" ;T;0;;;I"issuer;F;I"OpenSSL::PKCS7::SignerInfo;T;[o;;I" ;F;I"OpenSSL::X509::Name;To;;I" ;T;0;;;I"serial;F;I"OpenSSL::PKCS7::SignerInfo;T;[o;;I" ;F;I"Integer;To;;I" ;T;0;;;I"signed_time;F;I"OpenSSL::PKCS7::SignerInfo;T;[o;;I" ;F;I"
Time?;To;;I" ;T;0;;;I"initialize;F;I"OpenSSL::PKCS7::SignerInfo;T;[o;;I"b::OpenSSL::X509::Certificate certificate, ::OpenSSL::PKey::PKey key, ::OpenSSL::Digest digest;T;I"	void;To;;I"‰	## Asymmetric Public Key Algorithms

Asymmetric public key algorithms solve the problem of establishing and sharing
secret keys to en-/decrypt messages. The key in such an algorithm consists of
two parts: a public key that may be distributed to others and a private key
that needs to remain secret.

Messages encrypted with a public key can only be decrypted by recipients that
are in possession of the associated private key. Since public key algorithms
are considerably slower than symmetric key algorithms (cf. OpenSSL::Cipher)
they are often used to establish a symmetric key shared between two parties
that are in possession of each other's public key.

Asymmetric algorithms offer a lot of nice features that are used in a lot of
different areas. A very common application is the creation and validation of
digital signatures. To sign a document, the signatory generally uses a message
digest algorithm (cf. OpenSSL::Digest) to compute a digest of the document
that is then encrypted (i.e. signed) using the private key. Anyone in
possession of the public key may then verify the signature by computing the
message digest of the original document on their own, decrypting the signature
using the signatory's public key and comparing the result to the message
digest they previously computed. The signature is valid if and only if the
decrypted signature is equal to this message digest.

The PKey module offers support for three popular public/private key
algorithms:
*   RSA (OpenSSL::PKey::RSA)
*   DSA (OpenSSL::PKey::DSA)
*   Elliptic Curve Cryptography (OpenSSL::PKey::EC)

Each of these implementations is in fact a sub-class of the abstract PKey
class which offers the interface for supporting digital signatures in the form
of PKey#sign and PKey#verify.

## Diffie-Hellman Key Exchange

Finally PKey also features OpenSSL::PKey::DH, an implementation of the
Diffie-Hellman key exchange protocol based on discrete logarithms in finite
fields, the same basis that DSA is built on. The Diffie-Hellman protocol can
be used to exchange (symmetric) keys over insecure channels without needing
any prior joint knowledge between the participating parties. As the security
of DH demands relatively long "public keys" (i.e. the part that is overtly
transmitted between participants) DH tends to be quite slow. If security or
speed is your primary concern, OpenSSL::PKey::EC offers another implementation
of the Diffie-Hellman protocol.

;T;0;	I"OpenSSL::PKey;T;
[ ;[ ;0;[ ;[ o;;I"¡Reads a DER or PEM encoded string from *string* or *io* and returns an
instance of the appropriate PKey class.

### Parameters
*   *string* is a DER- or PEM-encoded string containing an arbitrary private
    or public key.
*   *io* is an instance of IO containing a DER- or PEM-encoded arbitrary
    private or public key.
*   *pwd* is an optional password in case *string* or *io* is an encrypted PEM
    resource.

;T;0;;;I"	read;F;I"OpenSSL::PKey;T;[o;;I",::String | ::IO pem, ?::String password;T;I"OpenSSL::PKey::PKey;To; ;I"An implementation of the Diffie-Hellman key exchange protocol based on
discrete logarithms in finite fields, the same basis that DSA is built on.

### Accessor methods for the Diffie-Hellman parameters
DH#p
:   The prime (an OpenSSL::BN) of the Diffie-Hellman parameters.
DH#g
:   The generator (an OpenSSL::BN) g of the Diffie-Hellman parameters.
DH#pub_key
:   The per-session public key (an OpenSSL::BN) matching the private key. This
    needs to be passed to DH#compute_key.
DH#priv_key
:   The per-session private key, an OpenSSL::BN.


### Example of a key exchange
    # you may send the parameters (der) and own public key (pub1) publicly
    # to the participating party
    dh1 = OpenSSL::PKey::DH.new(2048)
    der = dh1.to_der
    pub1 = dh1.pub_key

    # the other party generates its per-session key pair
    dhparams = OpenSSL::PKey::DH.new(der)
    dh2 = OpenSSL::PKey.generate_key(dhparams)
    pub2 = dh2.pub_key

    symm_key1 = dh1.compute_key(pub2)
    symm_key2 = dh2.compute_key(pub1)
    puts symm_key1 == symm_key2 # => true

;T;0;	I"OpenSSL::PKey::DH;T;
[ ;[I"OpenSSL::Marshal;T;0;[ ;[ ;0;I"OpenSSL::PKey::PKey;To;;I"íCreates a new DH instance from scratch by generating random parameters and a
key pair.

See also OpenSSL::PKey.generate_parameters and OpenSSL::PKey.generate_key.

`size`
:   The desired key size in bits.
`generator`
:   The generator.

;T;0;;;I"generate;F;I"OpenSSL::PKey::DH;T;[o;;I")::Integer size, ?::Integer generator;T;I"instance;To;;I"=Returns a String containing a shared secret computed from the other party's
public value.

This method is provided for backwards compatibility, and calls #derive
internally.

### Parameters
*   *pub_bn* is a OpenSSL::BN, **not** the DH instance returned by
    DH#public_key as that contains the DH parameters only.

;T;0;;;I"compute_key;F;I"OpenSSL::PKey::DH;T;[o;;I"::OpenSSL::bn pub_bn;T;I"String;To;;I"«Encodes this DH to its PEM encoding. Note that any existing per-session
public/private keys will **not** get encoded, just the Diffie-Hellman
parameters will be encoded.

;T;0;;;I"export;F;I"OpenSSL::PKey::DH;T;[o;;I" ;F;I"String;To;;0;0;;;I"g;F;I"OpenSSL::PKey::DH;T;[o;;I" ;F;I"OpenSSL::BN?;To;;I"…Generates a private and public key unless a private key already exists. If
this DH instance was generated from public DH parameters (e.g. by encoding the
result of DH#public_key), then this method needs to be called first in order
to generate the per-session keys before performing the actual key exchange.

**Deprecated in version 3.0**. This method is incompatible with OpenSSL 3.0.0
or later.

See also OpenSSL::PKey.generate_key.

Example:
    # DEPRECATED USAGE: This will not work on OpenSSL 3.0 or later
    dh0 = OpenSSL::PKey::DH.new(2048)
    dh = dh0.public_key # #public_key only copies the DH parameters (contrary to the name)
    dh.generate_key!
    puts dh.private? # => true
    puts dh0.pub_key == dh.pub_key #=> false

    # With OpenSSL::PKey.generate_key
    dh0 = OpenSSL::PKey::DH.new(2048)
    dh = OpenSSL::PKey.generate_key(dh0)
    puts dh0.pub_key == dh.pub_key #=> false

;T;0;;;I"generate_key!;F;I"OpenSSL::PKey::DH;T;[o;;I" ;F;I"	self;To;;0;0;;;I"p;F;I"OpenSSL::PKey::DH;T;[o;;I" ;F;I"OpenSSL::BN;To;;I"}Stores all parameters of key to the hash INSECURE: PRIVATE INFORMATIONS CAN
LEAK OUT!!! Don't use :-)) (I's up to you)

;T;0;;;I"params;F;I"OpenSSL::PKey::DH;T;[o;;I" ;F;I""Hash[::String, ::OpenSSL::BN];To;;I"èValidates the Diffie-Hellman parameters associated with this instance. It
checks whether a safe prime and a suitable generator are used. If this is not
the case, `false` is returned.

See also the man page EVP_PKEY_param_check(3).

;T;0;;;I"params_ok?;F;I"OpenSSL::PKey::DH;T;[o;;I" ;F;I"	bool;To;;0;0;;;I"priv_key;F;I"OpenSSL::PKey::DH;T;[o;;I" ;F;I"OpenSSL::BN;To;;I"„Indicates whether this DH instance has a private key associated with it or
not. The private key may be retrieved with DH#priv_key.

;T;0;;;I"private?;F;I"OpenSSL::PKey::DH;T;[o;;I" ;F;I"	bool;To;;0;0;;;I"pub_key;F;I"OpenSSL::PKey::DH;T;[o;;I" ;F;I"OpenSSL::BN;To;;I"Indicates whether this DH instance has a public key associated with it or not.
The public key may be retrieved with DH#pub_key.

;T;0;;;I"public?;F;I"OpenSSL::PKey::DH;T;[o;;I" ;F;I"	bool;To;;I"hReturns a new DH instance that carries just the DH parameters.

Contrary to the method name, the returned DH object contains only parameters
and not the public key.

This method is provided for backwards compatibility. In most cases, there is
no need to call this method.

For the purpose of re-generating the key pair while keeping the parameters,
check OpenSSL::PKey.generate_key.

Example:
    # OpenSSL::PKey::DH.generate by default generates a random key pair
    dh1 = OpenSSL::PKey::DH.generate(2048)
    p dh1.priv_key #=> #<OpenSSL::BN 1288347...>
    dhcopy = dh1.public_key
    p dhcopy.priv_key #=> nil

;T;0;;;I"public_key;F;I"OpenSSL::PKey::DH;T;[o;;I" ;F;I"instance;To;;0;0;;;I"q;F;I"OpenSSL::PKey::DH;T;[o;;I" ;F;I"OpenSSL::BN;To;;I"RSets *pub_key* and *priv_key* for the DH instance. *priv_key* may be `nil`.

;T;0;;;I"set_key;F;I"OpenSSL::PKey::DH;T;[o;;I"3::OpenSSL::bn pub_key, ::OpenSSL::bn? priv_key;T;I"	self;To;;I"-Sets *p*, *q*, *g* to the DH instance.

;T;0;;;I"set_pqg;F;I"OpenSSL::PKey::DH;T;[o;;I"6::OpenSSL::bn p, ::OpenSSL::bn q, ::OpenSSL::bn g;T;I"	self;To;;I"«Encodes this DH to its DER encoding. Note that any existing per-session
public/private keys will **not** get encoded, just the Diffie-Hellman
parameters will be encoded.

;T;0;;;I"to_der;F;I"OpenSSL::PKey::DH;T;[o;;I" ;F;I"String;To;;I"{Prints all parameters of key to buffer INSECURE: PRIVATE INFORMATIONS CAN LEAK
OUT!!! Don't use :-)) (I's up to you)

;T;0;;;I"to_text;F;I"OpenSSL::PKey::DH;T;[o;;I" ;F;I"String;To;;I"[Creates a new instance of OpenSSL::PKey::DH.

If called without arguments, an empty instance without any parameter or key
components is created. Use #set_pqg to manually set the parameters afterwards
(and optionally #set_key to set private and public key components).

If a String is given, tries to parse it as a DER- or PEM- encoded parameters.
See also OpenSSL::PKey.read which can parse keys of any kinds.

The DH.new(size [, generator]) form is an alias of DH.generate.

`string`
:   A String that contains the DER or PEM encoded key.
`size`
:   See DH.generate.
`generator`
:   See DH.generate.


Examples:
    # Creating an instance from scratch
    # Note that this is deprecated and will not work on OpenSSL 3.0 or later.
    dh = OpenSSL::PKey::DH.new
    dh.set_pqg(bn_p, nil, bn_g)

    # Generating a parameters and a key pair
    dh = OpenSSL::PKey::DH.new(2048) # An alias of OpenSSL::PKey::DH.generate(2048)

    # Reading DH parameters
    dh_params = OpenSSL::PKey::DH.new(File.read('parameters.pem')) # loads parameters only
    dh = OpenSSL::PKey.generate_key(dh_params) # generates a key pair

;T;0;;;I"initialize;F;I"OpenSSL::PKey::DH;T;[o;;I")::Integer size, ?::Integer generator;T;I"	void;To;;I"::String pem;T;I"	void;To;;I" ;F;I"	void;To;;I" ;T;0;;;I"initialize_copy;F;I"OpenSSL::PKey::DH;T;[o;;I"instance;T;I"	void;To; ;I"«Generic exception that is raised if an operation on a DH PKey fails
unexpectedly or in case an instantiation of an instance of DH fails due to
non-conformant input data.

;T;0;	I"OpenSSL::PKey::DHError;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::PKey::PKeyError;To; ;I"™DSA, the Digital Signature Algorithm, is specified in NIST's FIPS 186-3. It is
an asymmetric public key algorithm that may be used similar to e.g. RSA.

;T;0;	I"OpenSSL::PKey::DSA;T;
[ ;[I"OpenSSL::Marshal;T;0;[ ;[ ;0;I"OpenSSL::PKey::PKey;To;;I"ÈCreates a new DSA instance by generating a private/public key pair from
scratch.

See also OpenSSL::PKey.generate_parameters and OpenSSL::PKey.generate_key.

`size`
:   The desired key size in bits.

;T;0;;;I"generate;F;I"OpenSSL::PKey::DSA;T;[o;;I"::Integer size;T;I"instance;To;;I"éEncodes this DSA to its PEM encoding.

### Parameters
*   *cipher* is an OpenSSL::Cipher.
*   *password* is a string containing your password.


### Examples
    DSA.to_pem -> aString
    DSA.to_pem(cipher, 'mypassword') -> aString

;T;0;;;I"export;F;I"OpenSSL::PKey::DSA;T;[o;;I"'::String cipher, ::String password;T;I"String;To;;I" ;F;I"String;To;;0;0;;;I"g;F;I"OpenSSL::PKey::DSA;T;[o;;I" ;F;I"OpenSSL::BN;To;;0;0;;;I"p;F;I"OpenSSL::PKey::DSA;T;[o;;I" ;F;I"OpenSSL::BN;To;;I"}Stores all parameters of key to the hash INSECURE: PRIVATE INFORMATIONS CAN
LEAK OUT!!! Don't use :-)) (I's up to you)

;T;0;;;I"params;F;I"OpenSSL::PKey::DSA;T;[o;;I" ;F;I""Hash[::String, ::OpenSSL::BN];To;;0;0;;;I"priv_key;F;I"OpenSSL::PKey::DSA;T;[o;;I" ;F;I"OpenSSL::BN;To;;I"‰Indicates whether this DSA instance has a private key associated with it or
not. The private key may be retrieved with DSA#private_key.

;T;0;;;I"private?;F;I"OpenSSL::PKey::DSA;T;[o;;I" ;F;I"	bool;To;;0;0;;;I"pub_key;F;I"OpenSSL::PKey::DSA;T;[o;;I" ;F;I"OpenSSL::BN;To;;I"†Indicates whether this DSA instance has a public key associated with it or
not. The public key may be retrieved with DSA#public_key.

;T;0;;;I"public?;F;I"OpenSSL::PKey::DSA;T;[o;;I" ;F;I"	bool;To;;I"^Returns a new DSA instance that carries just the DSA parameters and the public
key.

This method is provided for backwards compatibility. In most cases, there is
no need to call this method.

For the purpose of serializing the public key, to PEM or DER encoding of X.509
SubjectPublicKeyInfo format, check PKey#public_to_pem and PKey#public_to_der.

;T;0;;;I"public_key;F;I"OpenSSL::PKey::DSA;T;[o;;I" ;F;I"instance;To;;0;0;;;I"q;F;I"OpenSSL::PKey::DSA;T;[o;;I" ;F;I"OpenSSL::BN;To;;I"SSets *pub_key* and *priv_key* for the DSA instance. *priv_key* may be `nil`.

;T;0;;;I"set_key;F;I"OpenSSL::PKey::DSA;T;[o;;I"3::OpenSSL::bn pub_key, ::OpenSSL::bn? priv_key;T;I"	self;To;;I".Sets *p*, *q*, *g* to the DSA instance.

;T;0;;;I"set_pqg;F;I"OpenSSL::PKey::DSA;T;[o;;I"6::OpenSSL::bn p, ::OpenSSL::bn q, ::OpenSSL::bn g;T;I"	self;To;;I"íComputes and returns the DSA signature of `string`, where `string` is expected
to be an already-computed message digest of the original input data. The
signature is issued using the private key of this DSA instance.

**Deprecated in version 3.0**. Consider using PKey::PKey#sign_raw and
PKey::PKey#verify_raw instead.

`string`
:   A message digest of the original input data to be signed.


Example:
    dsa = OpenSSL::PKey::DSA.new(2048)
    doc = "Sign me"
    digest = OpenSSL::Digest.digest('SHA1', doc)

    # With legacy #syssign and #sysverify:
    sig = dsa.syssign(digest)
    p dsa.sysverify(digest, sig) #=> true

    # With #sign_raw and #verify_raw:
    sig = dsa.sign_raw(nil, digest)
    p dsa.verify_raw(nil, sig, digest) #=> true

;T;0;;;I"syssign;F;I"OpenSSL::PKey::DSA;T;[o;;I"::String digest;T;I"String;To;;I"bVerifies whether the signature is valid given the message digest input. It
does so by validating `sig` using the public key of this DSA instance.

**Deprecated in version 3.0**. Consider using PKey::PKey#sign_raw and
PKey::PKey#verify_raw instead.

`digest`
:   A message digest of the original input data to be signed.
`sig`
:   A DSA signature value.

;T;0;;;I"sysverify;F;I"OpenSSL::PKey::DSA;T;[o;;I"#::String digest, ::String data;T;I"	bool;To;;I",Encodes this DSA to its DER encoding.

;T;0;;;I"to_der;F;I"OpenSSL::PKey::DSA;T;[o;;I" ;F;I"String;To;;I"{Prints all parameters of key to buffer INSECURE: PRIVATE INFORMATIONS CAN LEAK
OUT!!! Don't use :-)) (I's up to you)

;T;0;;;I"to_text;F;I"OpenSSL::PKey::DSA;T;[o;;I" ;F;I"String;To;;I"²Creates a new DSA instance by reading an existing key from *string*.

If called without arguments, creates a new instance with no key components
set. They can be set individually by #set_pqg and #set_key.

If called with a String, tries to parse as DER or PEM encoding of a DSA key.
See also OpenSSL::PKey.read which can parse keys of any kinds.

If called with a number, generates random parameters and a key pair. This form
works as an alias of DSA.generate.

`string`
:   A String that contains a DER or PEM encoded key.
`pass`
:   A String that contains an optional password.
`size`
:   See DSA.generate.


Examples:
    p OpenSSL::PKey::DSA.new(1024)
    #=> #<OpenSSL::PKey::DSA:0x000055a8d6025bf0 oid=DSA>

    p OpenSSL::PKey::DSA.new(File.read('dsa.pem'))
    #=> #<OpenSSL::PKey::DSA:0x000055555d6b8110 oid=DSA>

    p OpenSSL::PKey::DSA.new(File.read('dsa.pem'), 'mypassword')
    #=> #<OpenSSL::PKey::DSA:0x0000556f973c40b8 oid=DSA>

;T;0;;;I"initialize;F;I"OpenSSL::PKey::DSA;T;[o;;I"!::String pem, ?::String pass;T;I"	void;To;;I"?::Integer size;T;I"	void;To;;I" ;T;0;;;I"initialize_copy;F;I"OpenSSL::PKey::DSA;T;[o;;I"instance;T;I"	void;To; ;I"­Generic exception that is raised if an operation on a DSA PKey fails
unexpectedly or in case an instantiation of an instance of DSA fails due to
non-conformant input data.

;T;0;	I"OpenSSL::PKey::DSAError;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::PKey::PKeyError;To; ;I"ÄOpenSSL::PKey::EC provides access to Elliptic Curve Digital Signature
Algorithm (ECDSA) and Elliptic Curve Diffie-Hellman (ECDH).

### Key exchange
    ec1 = OpenSSL::PKey::EC.generate("prime256v1")
    ec2 = OpenSSL::PKey::EC.generate("prime256v1")
    # ec1 and ec2 have own private key respectively
    shared_key1 = ec1.dh_compute_key(ec2.public_key)
    shared_key2 = ec2.dh_compute_key(ec1.public_key)

    p shared_key1 == shared_key2 #=> true

;T;0;	I"OpenSSL::PKey::EC;T;
[ ;[I"OpenSSL::Marshal;T;0;[ ;[ ;0;I"OpenSSL::PKey::PKey;To;;I"•Obtains a list of all predefined curves by the OpenSSL. Curve names are
returned as sn.

See the OpenSSL documentation for EC_get_builtin_curves().

;T;0;;;I"builtin_curves;F;I"OpenSSL::PKey::EC;T;[o;;I" ;F;I""Array[[ ::String, ::String ]];To;;I"JCreates a new EC instance with a new random private and public key.

;T;0;;;I"generate;F;I"OpenSSL::PKey::EC;T;[o;;I"L::String | ::OpenSSL::PKey::EC::Group pem_or_der_or_group_or_curve_name;T;I"instance;To;;I"bRaises an exception if the key is invalid.

See also the man page EVP_PKEY_public_check(3).

;T;0;;;I"check_key;F;I"OpenSSL::PKey::EC;T;[o;;I" ;F;I"	true;Fo;;I"ÒDerives a shared secret by ECDH. *pubkey* must be an instance of
OpenSSL::PKey::EC::Point and must belong to the same group.

This method is provided for backwards compatibility, and calls #derive
internally.

;T;0;;;I"dh_compute_key;F;I"OpenSSL::PKey::EC;T;[o;;I"*::OpenSSL::PKey::EC::Point public_key;T;I"String;To;;I"k**Deprecated in version 3.0**. Consider using PKey::PKey#sign_raw and
PKey::PKey#verify_raw instead.

;T;0;;;I"dsa_sign_asn1;F;I"OpenSSL::PKey::EC;T;[o;;I"::String digest;T;I"String;To;;I"k**Deprecated in version 3.0**. Consider using PKey::PKey#sign_raw and
PKey::PKey#verify_raw instead.

;T;0;;;I"dsa_verify_asn1;F;I"OpenSSL::PKey::EC;T;[o;;I"(::String digest, ::String signature;T;I"	bool;To;;I"Outputs the EC key in PEM encoding.  If *cipher* and *pass_phrase* are given
they will be used to encrypt the key.  *cipher* must be an OpenSSL::Cipher
instance. Note that encryption will only be effective for a private key,
public keys will always be encoded in plain text.

;T;0;;;I"export;F;I"OpenSSL::PKey::EC;T;[o;;I"'::String cipher, ::String password;T;I"String;To;;I" ;F;I"String;To;;I"Generates a new random private and public key.

See also the OpenSSL documentation for EC_KEY_generate_key()

### Example
    ec = OpenSSL::PKey::EC.new("prime256v1")
    p ec.private_key # => nil
    ec.generate_key!
    p ec.private_key # => #<OpenSSL::BN XXXXXX>

;T;0;;;I"generate_key!;F;I"OpenSSL::PKey::EC;T;[o;;I" ;F;I"	self;To;;I"qReturns the EC::Group that the key is associated with. Modifying the returned
group does not affect *key*.

;T;0;;;I"
group;F;I"OpenSSL::PKey::EC;T;[o;;I" ;F;I"OpenSSL::PKey::EC::Group?;To;;I"˜Sets the EC::Group for the key. The group structure is internally copied so
modification to *group* after assigning to a key has no effect on the key.

;T;0;;;I"group=;F;I"OpenSSL::PKey::EC;T;[o;;I"::OpenSSL::PKey::EC::Group;T;I"OpenSSL::PKey::EC::Group;To;;I"uReturns whether this EC instance has a private key. The private key (BN) can
be retrieved with EC#private_key.

;T;0;;;I"private?;F;I"OpenSSL::PKey::EC;T;[o;;I" ;F;I"	bool;To;;I"BSee the OpenSSL documentation for EC_KEY_get0_private_key()

;T;0;;;I"private_key;F;I"OpenSSL::PKey::EC;T;[o;;I" ;F;I"OpenSSL::BN?;To;;I"ASee the OpenSSL documentation for EC_KEY_set_private_key()

;T;0;;;I"private_key=;F;I"OpenSSL::PKey::EC;T;[o;;I"::OpenSSL::bn priv_key;T;I"	self;To;;I"yReturns whether this EC instance has a public key. The public key (EC::Point)
can be retrieved with EC#public_key.

;T;0;;;I"public?;F;I"OpenSSL::PKey::EC;T;[o;;I" ;F;I"	bool;To;;I"ASee the OpenSSL documentation for EC_KEY_get0_public_key()

;T;0;;;I"public_key;F;I"OpenSSL::PKey::EC;T;[o;;I" ;F;I"OpenSSL::PKey::EC::Point?;To;;I"@See the OpenSSL documentation for EC_KEY_set_public_key()

;T;0;;;I"public_key=;F;I"OpenSSL::PKey::EC;T;[o;;I"::OpenSSL::bn priv_key;T;I"	self;To;;I"?See the OpenSSL documentation for i2d_ECPrivateKey_bio()

;T;0;;;I"to_der;F;I"OpenSSL::PKey::EC;T;[o;;I" ;F;I"String;To;;I"7See the OpenSSL documentation for EC_KEY_print()

;T;0;;;I"to_text;F;I"OpenSSL::PKey::EC;T;[o;;I" ;F;I"String;To;;I"4Creates a new EC object from given arguments.

;T;0;;;I"initialize;F;I"OpenSSL::PKey::EC;T;[	o;;I" ;F;I"	void;To;;I"instance ec_key;T;I"	void;To;;I"%::OpenSSL::PKey::EC::Group group;T;I"	void;To;;I"1::String pem_or_der_or_curve, ?::String pass;T;I"	void;To;;I" ;T;0;;;I"initialize_copy;F;I"OpenSSL::PKey::EC;T;[o;;I"instance;T;I"	void;To; ;0;0;	I"OpenSSL::PKey::EC::Group;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"AReturns the flags set on the group.

See also #asn1_flag=.

;T;0;;;I"asn1_flag;F;I"OpenSSL::PKey::EC::Group;T;[o;;I" ;F;I"Integer;To;;I"Sets flags on the group. The flag value is used to determine how to encode the
group: encode explicit parameters or named curve using an OID.

The flag value can be either of:

*   EC::NAMED_CURVE
*   EC::EXPLICIT_CURVE


See the OpenSSL documentation for EC_GROUP_set_asn1_flag().

;T;0;;;I"asn1_flag=;F;I"OpenSSL::PKey::EC::Group;T;[o;;I"::Integer;T;I"Integer;To;;I"dReturns the cofactor of the group.

See the OpenSSL documentation for EC_GROUP_get_cofactor()

;T;0;;;I"cofactor;F;I"OpenSSL::PKey::EC::Group;T;[o;;I" ;F;I"OpenSSL::BN;To;;I"`Returns the curve name (sn).

See the OpenSSL documentation for EC_GROUP_get_curve_name()

;T;0;;;I"curve_name;F;I"OpenSSL::PKey::EC::Group;T;[o;;I" ;F;I"String;To;;I">See the OpenSSL documentation for EC_GROUP_get_degree()

;T;0;;;I"degree;F;I"OpenSSL::PKey::EC::Group;T;[o;;I" ;F;I"Integer;To;;I"kReturns `true` if the two groups use the same curve and have the same
parameters, `false` otherwise.

;T;0;;;I"	eql?;F;I"OpenSSL::PKey::EC::Group;T;[o;;I"instance other;T;I"	bool;To;;I"gReturns the generator of the group.

See the OpenSSL documentation for EC_GROUP_get0_generator()

;T;0;;;I"generator;F;I"OpenSSL::PKey::EC::Group;T;[o;;I" ;F;I"OpenSSL::PKey::EC::Point?;To;;I"^Returns the order of the group.

See the OpenSSL documentation for EC_GROUP_get_order()

;T;0;;;I"
order;F;I"OpenSSL::PKey::EC::Group;T;[o;;I" ;F;I"OpenSSL::BN;To;;I"bReturns the form how EC::Point data is encoded as ASN.1.

See also #point_conversion_form=.

;T;0;;;I"point_conversion_form;F;I"OpenSSL::PKey::EC::Group;T;[o;;I" ;F;I"/OpenSSL::PKey::EC::point_conversion_format;To;;I"ûSets the form how EC::Point data is encoded as ASN.1 as defined in X9.62.

*format* can be one of these:

`:compressed`
:   Encoded as z||x, where z is an octet indicating which solution of the
    equation y is. z will be 0x02 or 0x03.
`:uncompressed`
:   Encoded as z||x||y, where z is an octet 0x04.
`:hybrid`
:   Encodes as z||x||y, where z is an octet indicating which solution of the
    equation y is. z will be 0x06 or 0x07.


See the OpenSSL documentation for EC_GROUP_set_point_conversion_form()

;T;0;;;I"point_conversion_form=;F;I"OpenSSL::PKey::EC::Group;T;[o;;I"8::OpenSSL::PKey::EC::point_conversion_format format;T;I"/OpenSSL::PKey::EC::point_conversion_format;To;;I"=See the OpenSSL documentation for EC_GROUP_get0_seed()

;T;0;;;I"	seed;F;I"OpenSSL::PKey::EC::Group;T;[o;;I" ;F;I"String?;To;;I"<See the OpenSSL documentation for EC_GROUP_set_seed()

;T;0;;;I"
seed=;F;I"OpenSSL::PKey::EC::Group;T;[o;;I"::String seed;T;I"String;To;;I"ÀSets the curve parameters. *generator* must be an instance of EC::Point that
is on the curve. *order* and *cofactor* are integers.

See the OpenSSL documentation for EC_GROUP_set_generator()

;T;0;;;I"set_generator;F;I"OpenSSL::PKey::EC::Group;T;[o;;I"N::OpenSSL::PKey::EC::Point generator, ::Integer order, ::Integer cofactor;T;I"	self;To;;I"ASee the OpenSSL documentation for i2d_ECPKParameters_bio()

;T;0;;;I"to_der;F;I"OpenSSL::PKey::EC::Group;T;[o;;I" ;F;I"String;To;;I"GSee the OpenSSL documentation for PEM_write_bio_ECPKParameters()

;T;0;;;I"to_pem;F;I"OpenSSL::PKey::EC::Group;T;[o;;I" ;F;I"String;To;;I"?See the OpenSSL documentation for ECPKParameters_print()

;T;0;;;I"to_text;F;I"OpenSSL::PKey::EC::Group;T;[o;;I" ;F;I"String;To;;I"zCreates a new EC::Group object.

If the first argument is :GFp or :GF2m, creates a new curve with given
parameters.

;T;0;;;I"initialize;F;I"OpenSSL::PKey::EC::Group;T;[	o;;I"instance group;T;I"	void;To;;I" ::String pem_or_der_encoded;T;I"	void;To;;I"-::OpenSSL::PKey::EC::ec_method ec_method;T;I"	void;To;;I"W:GFp | :GF2m ec_method, ::Integer bignum_p, ::Integer bignum_a, ::Integer bignum_b;T;I"	void;To;;I" ;T;0;;;I"initialize_copy;F;I"OpenSSL::PKey::EC::Group;T;[o;;I"instance;T;I"	void;To; ;0;0;	I"$OpenSSL::PKey::EC::Group::Error;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::OpenSSLError;To; ;0;0;	I"OpenSSL::PKey::EC::Point;T;
[ ;[ ;0;[ ;[ ;0;0o;;I".Performs elliptic curve point addition.

;T;0;;;I"add;F;I"OpenSSL::PKey::EC::Point;T;[o;;I"instance point;T;I"instance;To;;I" ;T;0;;;I"	eql?;F;I"OpenSSL::PKey::EC::Point;T;[o;;I"instance other;T;I"	bool;To;;0;0;;;I"
group;F;I"OpenSSL::PKey::EC::Point;T;[o;;I" ;F;I"OpenSSL::PKey::EC::Group;To;;I" ;T;0;;;I"infinity?;F;I"OpenSSL::PKey::EC::Point;T;[o;;I" ;F;I"	bool;To;;I" ;T;0;;;I"invert!;F;I"OpenSSL::PKey::EC::Point;T;[o;;I" ;F;I"	self;To;;I"IThis method is deprecated and should not be used. This is a no-op.

;T;0;;;I"make_affine!;F;I"OpenSSL::PKey::EC::Point;T;[o;;I" ;F;I"	self;To;;I"	Performs elliptic curve point multiplication.

The first form calculates `bn1 * point + bn2 * G`, where `G` is the generator
of the group of *point*. *bn2* may be omitted, and in that case, the result is
just `bn1 * point`.

The second form calculates `bns[0] * point + bns[1] * points[0] + ... +
bns[-1] * points[-1] + bn2 * G`. *bn2* may be omitted. *bns* must be an array
of OpenSSL::BN. *points* must be an array of OpenSSL::PKey::EC::Point. Please
note that `points[0]` is not multiplied by `bns[0]`, but `bns[1]`.

;T;0;;;I"mul;F;I"OpenSSL::PKey::EC::Point;T;[o;;I"*::OpenSSL::bn bn1, ?::OpenSSL::bn bn2;T;I"instance;To;;I"F::Array[::OpenSSL::bn] bns, ::Array[instance], ?::OpenSSL::bn bn2;T;I"instance;To;;I" ;T;0;;;I"on_curve?;F;I"OpenSSL::PKey::EC::Point;T;[o;;I" ;F;I"	bool;To;;I" ;T;0;;;I"set_to_infinity!;F;I"OpenSSL::PKey::EC::Point;T;[o;;I" ;F;I"	self;To;;I"èReturns the octet string representation of the EC point as an instance of
OpenSSL::BN.

If *conversion_form* is not given, the *point_conversion_form* attribute set
to the group is used.

See #to_octet_string for more information.

;T;0;;;I"
to_bn;F;I"OpenSSL::PKey::EC::Point;T;[o;;I"B?::OpenSSL::PKey::EC::point_conversion_format conversion_form;T;I"OpenSSL::BN;To;;I"ÉReturns the octet string representation of the elliptic curve point.

*conversion_form* specifies how the point is converted. Possible values are:

*   `:compressed`
*   `:uncompressed`
*   `:hybrid`

;T;0;;;I"to_octet_string;F;I"OpenSSL::PKey::EC::Point;T;[o;;I"1::OpenSSL::PKey::EC::point_conversion_format;T;I"String;To;;I"!Creates a new instance of OpenSSL::PKey::EC::Point. If the only argument is an
instance of EC::Point, a copy is returned. Otherwise, creates a point that
belongs to *group*.

*encoded_point* is the octet string representation of the point. This must be
either a String or an OpenSSL::BN.

;T;0;;;I"initialize;F;I"OpenSSL::PKey::EC::Point;T;[o;;I"instance point;T;I"	void;To;;I"N::OpenSSL::PKey::EC::Group group, ?::String | ::OpenSSL::BN encoded_point;T;I"	void;To;;I" ;T;0;;;I"initialize_copy;F;I"OpenSSL::PKey::EC::Point;T;[o;;I"instance;T;I"	void;To; ;0;0;	I"$OpenSSL::PKey::EC::Point::Error;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::OpenSSLError;To; ;0;0;	I"OpenSSL::PKey::ECError;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::PKey::PKeyError;To; ;I"ßAn abstract class that bundles signature creation (PKey#sign) and validation
(PKey#verify) that is common to all implementations except OpenSSL::PKey::DH
*   OpenSSL::PKey::RSA
*   OpenSSL::PKey::DSA
*   OpenSSL::PKey::EC

;T;0;	I"OpenSSL::PKey::PKey;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"3Returns a string describing the PKey object.

;T;0;;;I"inspect;F;I"OpenSSL::PKey::PKey;T;[o;;I" ;F;I"String;To;;I"@Returns the short name of the OID associated with *pkey*.

;T;0;;;I"oid;F;I"OpenSSL::PKey::PKey;T;[o;;I" ;F;I"String;To;;I"Serializes the private key to DER-encoded PKCS #8 format. If called without
arguments, unencrypted PKCS #8 PrivateKeyInfo format is used. If called with a
cipher name and a password, PKCS #8 EncryptedPrivateKeyInfo format with PBES2
encryption scheme is used.

;T;0;;;I"private_to_der;F;I"OpenSSL::PKey::PKey;T;[o;;I"'::String cipher, ::String password;T;I"String;To;;I" ;F;I"String;To;;I"fSerializes the private key to PEM-encoded PKCS #8 format. See #private_to_der
for more details.

;T;0;;;I"private_to_pem;F;I"OpenSSL::PKey::PKey;T;[o;;I"'::String cipher, ::String password;T;I"String;To;;I" ;F;I"String;To;;I"RSerializes the public key to DER-encoded X.509 SubjectPublicKeyInfo format.

;T;0;;;I"public_to_der;F;I"OpenSSL::PKey::PKey;T;[o;;I" ;F;I"String;To;;I"RSerializes the public key to PEM-encoded X.509 SubjectPublicKeyInfo format.

;T;0;;;I"public_to_pem;F;I"OpenSSL::PKey::PKey;T;[o;;I" ;F;I"String;To;;I".Hashes and signs the `data` using a message digest algorithm `digest` and a
private key `pkey`.

See #verify for the verification operation.

See also the man page EVP_DigestSign(3).

`digest`
:   A String that represents the message digest algorithm name, or `nil` if
    the PKey type requires no digest algorithm. For backwards compatibility,
    this can be an instance of OpenSSL::Digest. Its state will not affect the
    signature.
`data`
:   A String. The data to be hashed and signed.
`options`
:   A Hash that contains algorithm specific control operations to OpenSSL. See
    OpenSSL's man page EVP_PKEY_CTX_ctrl_str(3) for details. `options`
    parameter was added in version 3.0.


Example:
    data = "Sign me!"
    pkey = OpenSSL::PKey.generate_key("RSA", rsa_keygen_bits: 2048)
    signopts = { rsa_padding_mode: "pss" }
    signature = pkey.sign("SHA256", data, signopts)

    # Creates a copy of the RSA key pkey, but without the private components
    pub_key = pkey.public_key
    puts pub_key.verify("SHA256", signature, data, signopts) # => true

;T;0;;;I"	sign;F;I"OpenSSL::PKey::PKey;T;[o;;I",::OpenSSL::Digest digest, ::String data;T;I"String;To;;I"ûVerifies the `signature` for the `data` using a message digest algorithm
`digest` and a public key `pkey`.

Returns `true` if the signature is successfully verified, `false` otherwise.
The caller must check the return value.

See #sign for the signing operation and an example.

See also the man page EVP_DigestVerify(3).

`digest`
:   See #sign.
`signature`
:   A String containing the signature to be verified.
`data`
:   See #sign.
`options`
:   See #sign. `options` parameter was added in version 3.0.

;T;0;;;I"verify;F;I"OpenSSL::PKey::PKey;T;[o;;I"@::OpenSSL::Digest digest, ::String signature, ::String data;T;I"	bool;To;;I"sBecause PKey is an abstract class, actually calling this method explicitly
will raise a NotImplementedError.

;T;0;;;I"initialize;F;I"OpenSSL::PKey::PKey;T;[o;;I" ;F;I"	void;To; ;I"@Raised when errors occur during PKey#sign or PKey#verify.

;T;0;	I"OpenSSL::PKey::PKeyError;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::OpenSSLError;To; ;I"ÀRSA is an asymmetric public key algorithm that has been formalized in RFC
3447. It is in widespread use in public key infrastructures (PKI) where
certificates (cf. OpenSSL::X509::Certificate) often are issued on the basis of
a public/private RSA key pair. RSA is used in a wide field of applications
such as secure (symmetric) key exchange, e.g. when establishing a secure
TLS/SSL connection. It is also used in various digital signature schemes.

;T;0;	I"OpenSSL::PKey::RSA;T;
[ ;[I"OpenSSL::Marshal;T;0;[ ;[ ;0;I"OpenSSL::PKey::PKey;To;;I"¤Generates an RSA keypair.

See also OpenSSL::PKey.generate_key.

`size`
:   The desired key size in bits.
`exponent`
:   An odd Integer, normally 3, 17, or 65537.

;T;0;;;I"generate;F;I"OpenSSL::PKey::RSA;T;[o;;I"(::Integer size, ?::Integer exponent;T;I"instance;To;;0;0;;;I"d;F;I"OpenSSL::PKey::RSA;T;[o;;I" ;F;I"OpenSSL::BN?;To;;0;0;;;I"	dmp1;F;I"OpenSSL::PKey::RSA;T;[o;;I" ;F;I"OpenSSL::BN?;To;;0;0;;;I"	dmq1;F;I"OpenSSL::PKey::RSA;T;[o;;I" ;F;I"OpenSSL::BN?;To;;0;0;;;I"e;F;I"OpenSSL::PKey::RSA;T;[o;;I" ;F;I"OpenSSL::BN?;To;;I"¥Outputs this keypair in PEM encoding.  If *cipher* and *pass_phrase* are given
they will be used to encrypt the key.  *cipher* must be an OpenSSL::Cipher
instance.

;T;0;;;I"export;F;I"OpenSSL::PKey::RSA;T;[o;;I"'::String cipher, ::String password;T;I"String;To;;I" ;F;I"String;To;;0;0;;;I"	iqmp;F;I"OpenSSL::PKey::RSA;T;[o;;I" ;F;I"OpenSSL::BN?;To;;0;0;;;I"n;F;I"OpenSSL::PKey::RSA;T;[o;;I" ;F;I"OpenSSL::BN?;To;;0;0;;;I"p;F;I"OpenSSL::PKey::RSA;T;[o;;I" ;F;I"OpenSSL::BN?;To;;I"ÎTHIS METHOD IS INSECURE, PRIVATE INFORMATION CAN LEAK OUT!!!

Stores all parameters of key to the hash.  The hash has keys 'n', 'e', 'd',
'p', 'q', 'dmp1', 'dmq1', 'iqmp'.

Don't use :-)) (It's up to you)

;T;0;;;I"params;F;I"OpenSSL::PKey::RSA;T;[o;;I" ;F;I""Hash[::String, ::OpenSSL::BN];To;;I"/Does this keypair contain a private key?

;T;0;;;I"private?;F;I"OpenSSL::PKey::RSA;T;[o;;I" ;F;I"	bool;To;;I"ÞDecrypt `string`, which has been encrypted with the public key, with the
private key. `padding` defaults to PKCS1_PADDING.

**Deprecated in version 3.0**. Consider using PKey::PKey#encrypt and
PKey::PKey#decrypt instead.

;T;0;;;I"private_decrypt;F;I"OpenSSL::PKey::RSA;T;[o;;I"&::String data, ?::Integer padding;T;I"String;To;;I"Encrypt `string` with the private key.  `padding` defaults to PKCS1_PADDING.
The encrypted string output can be decrypted using #public_decrypt.

**Deprecated in version 3.0**. Consider using PKey::PKey#sign_raw and
PKey::PKey#verify_raw, and PKey::PKey#verify_recover instead.

;T;0;;;I"private_encrypt;F;I"OpenSSL::PKey::RSA;T;[o;;I"&::String data, ?::Integer padding;T;I"String;To;;I"VThe return value is always `true` since every private key is also a public
key.

;T;0;;;I"public?;F;I"OpenSSL::PKey::RSA;T;[o;;I" ;F;I"	bool;To;;I"Decrypt `string`, which has been encrypted with the private key, with the
public key.  `padding` defaults to PKCS1_PADDING.

**Deprecated in version 3.0**. Consider using PKey::PKey#sign_raw and
PKey::PKey#verify_raw, and PKey::PKey#verify_recover instead.

;T;0;;;I"public_decrypt;F;I"OpenSSL::PKey::RSA;T;[o;;I"&::String data, ?::Integer padding;T;I"String;To;;I"ôEncrypt `string` with the public key.  `padding` defaults to PKCS1_PADDING.
The encrypted string output can be decrypted using #private_decrypt.

**Deprecated in version 3.0**. Consider using PKey::PKey#encrypt and
PKey::PKey#decrypt instead.

;T;0;;;I"public_encrypt;F;I"OpenSSL::PKey::RSA;T;[o;;I"&::String data, ?::Integer padding;T;I"String;To;;I"RReturns a new RSA instance that carries just the public key components.

This method is provided for backwards compatibility. In most cases, there is
no need to call this method.

For the purpose of serializing the public key, to PEM or DER encoding of X.509
SubjectPublicKeyInfo format, check PKey#public_to_pem and PKey#public_to_der.

;T;0;;;I"public_key;F;I"OpenSSL::PKey::RSA;T;[o;;I" ;F;I"instance;To;;0;0;;;I"q;F;I"OpenSSL::PKey::RSA;T;[o;;I" ;F;I"OpenSSL::BN?;To;;I"ŒSets *dmp1*, *dmq1*, *iqmp* for the RSA instance. They are calculated by `d
mod (p - 1)`, `d mod (q - 1)` and `q^(-1) mod p` respectively.

;T;0;;;I"set_crt_params;F;I"OpenSSL::PKey::RSA;T;[o;;I"?::OpenSSL::bn dmp1, ::OpenSSL::bn dmq1, ::OpenSSL::bn iqmp;T;I"	self;To;;I"*Sets *p*, *q* for the RSA instance.

;T;0;;;I"set_factors;F;I"OpenSSL::PKey::RSA;T;[o;;I"%::OpenSSL::bn p, ::OpenSSL::bn q;T;I"	self;To;;I"/Sets *n*, *e*, *d* for the RSA instance.

;T;0;;;I"set_key;F;I"OpenSSL::PKey::RSA;T;[o;;I"6::OpenSSL::bn n, ::OpenSSL::bn e, ::OpenSSL::bn d;T;I"	self;To;;I"Signs *data* using the Probabilistic Signature Scheme (RSA-PSS) and returns
the calculated signature.

RSAError will be raised if an error occurs.

See #verify_pss for the verification operation.

### Parameters
*digest*
:   A String containing the message digest algorithm name.
*data*
:   A String. The data to be signed.
*salt_length*
:   The length in octets of the salt. Two special values are reserved:
    `:digest` means the digest length, and `:max` means the maximum possible
    length for the combination of the private key and the selected message
    digest algorithm.
*mgf1_hash*
:   The hash algorithm used in MGF1 (the currently supported mask generation
    function (MGF)).


### Example
    data = "Sign me!"
    pkey = OpenSSL::PKey::RSA.new(2048)
    signature = pkey.sign_pss("SHA256", data, salt_length: :max, mgf1_hash: "SHA256")
    pub_key = OpenSSL::PKey.read(pkey.public_to_der)
    puts pub_key.verify_pss("SHA256", signature, data,
                            salt_length: :auto, mgf1_hash: "SHA256") # => true

;T;0;;;I"sign_pss;F;I"OpenSSL::PKey::RSA;T;[o;;I"a::String digest, ::String data, salt_length: :digest | :max | ::Integer, mgf1_hash: ::String;T;I"String;To;;I",Outputs this keypair in DER encoding.

;T;0;;;I"to_der;F;I"OpenSSL::PKey::RSA;T;[o;;I" ;F;I"String;To;;I"ŽTHIS METHOD IS INSECURE, PRIVATE INFORMATION CAN LEAK OUT!!!

Dumps all parameters of a keypair to a String

Don't use :-)) (It's up to you)

;T;0;;;I"to_text;F;I"OpenSSL::PKey::RSA;T;[o;;I" ;F;I"String;To;;I"yVerifies *data* using the Probabilistic Signature Scheme (RSA-PSS).

The return value is `true` if the signature is valid, `false` otherwise.
RSAError will be raised if an error occurs.

See #sign_pss for the signing operation and an example code.

### Parameters
*digest*
:   A String containing the message digest algorithm name.
*data*
:   A String. The data to be signed.
*salt_length*
:   The length in octets of the salt. Two special values are reserved:
    `:digest` means the digest length, and `:auto` means automatically
    determining the length based on the signature.
*mgf1_hash*
:   The hash algorithm used in MGF1.

;T;0;;;I"verify_pss;F;I"OpenSSL::PKey::RSA;T;[o;;I"v::String digest, ::String signature, ::String data, salt_length: :auto | :digest | ::Integer, mgf1_hash: ::String;T;I"	bool;To;;I"ÁGenerates or loads an RSA keypair.

If called without arguments, creates a new instance with no key components
set. They can be set individually by #set_key, #set_factors, and
#set_crt_params.

If called with a String, tries to parse as DER or PEM encoding of an RSA key.
Note that, if *passphrase* is not specified but the key is encrypted with a
passphrase, OpenSSL will prompt for it. See also OpenSSL::PKey.read which can
parse keys of any kinds.

If called with a number, generates a new key pair. This form works as an alias
of RSA.generate.

Examples:
    OpenSSL::PKey::RSA.new 2048
    OpenSSL::PKey::RSA.new File.read 'rsa.pem'
    OpenSSL::PKey::RSA.new File.read('rsa.pem'), 'my pass phrase'

;T;0;;;I"initialize;F;I"OpenSSL::PKey::RSA;T;[o;;I" ;F;I"	void;To;;I"::Integer key_size;T;I"	void;To;;I"0::String encoded_key, ?::String pass_phrase;T;I"	void;To;;I" ;T;0;;;I"initialize_copy;F;I"OpenSSL::PKey::RSA;T;[o;;I"instance;T;I"	void;To; ;I"®Generic exception that is raised if an operation on an RSA PKey fails
unexpectedly or in case an instantiation of an instance of RSA fails due to
non-conformant input data.

;T;0;	I"OpenSSL::PKey::RSAError;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::PKey::PKeyError;To;;0;0;	I"OpenSSL::Random;T;
[ ;[ ;0;[ ;[ o;;I"=Reads bytes from *filename* and adds them to the PRNG.

;T;0;;;I"load_random_file;F;I"OpenSSL::Random;T;[o;;I"::String filename;T;I"	true;Fo;;I"Mixes the bytes from *str* into the Pseudo Random Number Generator(PRNG)
state.

Thus, if the data from *str* are unpredictable to an adversary, this increases
the uncertainty about the state and makes the PRNG output less predictable.

The *entropy* argument is (the lower bound of) an estimate of how much
randomness is contained in *str*, measured in bytes.

### Example

    pid = $$
    now = Time.now
    ary = [now.to_i, now.nsec, 1000, pid]
    OpenSSL::Random.add(ary.join, 0.0)
    OpenSSL::Random.seed(ary.join)

;T;0;;;I"random_add;F;I"OpenSSL::Random;T;[o;;I"$::String str, ::Numeric entropy;T;I"	self;To;;I"›Generates a String with *length* number of cryptographically strong
pseudo-random bytes.

### Example

    OpenSSL::Random.random_bytes(12)
    #=> "..."

;T;0;;;I"random_bytes;F;I"OpenSSL::Random;T;[o;;I"::Integer length;T;I"String;To;;I"H::seed is equivalent to ::add where *entropy* is length of *str*.

;T;0;;;I"	seed;F;I"OpenSSL::Random;T;[o;;I"::String seed;T;I"String;To;;I"UReturn `true` if the PRNG has been seeded with enough data, `false` otherwise.

;T;0;;;I"status?;F;I"OpenSSL::Random;T;[o;;I" ;F;I"	bool;To;;I"¥Writes a number of random generated bytes (currently 1024) to *filename* which
can be used to initialize the PRNG by calling ::load_random_file in a later
session.

;T;0;;;I"write_random_file;F;I"OpenSSL::Random;T;[o;;I"::String filename;T;I"	true;Fo; ;0;0;	I"!OpenSSL::Random::RandomError;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::OpenSSLError;To;;I"ëUse SSLContext to set up the parameters for a TLS (former SSL) connection.
Both client and server TLS connections are supported, SSLSocket and SSLServer
may be used in conjunction with an instance of SSLContext to set up
connections.

;T;0;	I"OpenSSL::SSL;T;
[ ;[ ;0;[ ;[ o;;I" ;T;0;;;I" verify_certificate_identity;F;I"OpenSSL::SSL;T;[o;;I"9::OpenSSL::X509::Certificate cert, ::String hostname;T;I"	bool;To;;0;0;;;I"verify_hostname;F;I"OpenSSL::SSL;T;[o;;I"$::String hostname, ::String san;T;I"	bool;To;;0;0;;;I"verify_wildcard;F;I"OpenSSL::SSL;T;[o;;I"6::String domain_component, ::String san_component;T;I"	bool;To; ;I"An SSLContext is used to set various options regarding certificates,
algorithms, verification, session caching, etc.  The SSLContext is used to
create an SSLSocket.

All attributes must be set before creating an SSLSocket as the SSLContext will
be frozen afterward.

;T;0;	I"OpenSSL::SSL::SSLContext;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"Adds a certificate to the context. *pkey* must be a corresponding private key
with *certificate*.

Multiple certificates with different public key type can be added by repeated
calls of this method, and OpenSSL will choose the most appropriate certificate
during the handshake.

#cert=, #key=, and #extra_chain_cert= are old accessor methods for setting
certificate and internally call this method.

### Parameters
*certificate*
:   A certificate. An instance of OpenSSL::X509::Certificate.
*pkey*
:   The private key for *certificate*. An instance of OpenSSL::PKey::PKey.
*extra_certs*
:   Optional. An array of OpenSSL::X509::Certificate. When sending a
    certificate chain, the certificates specified by this are sent following
    *certificate*, in the order in the array.


### Example
    rsa_cert = OpenSSL::X509::Certificate.new(...)
    rsa_pkey = OpenSSL::PKey.read(...)
    ca_intermediate_cert = OpenSSL::X509::Certificate.new(...)
    ctx.add_certificate(rsa_cert, rsa_pkey, [ca_intermediate_cert])

    ecdsa_cert = ...
    ecdsa_pkey = ...
    another_ca_cert = ...
    ctx.add_certificate(ecdsa_cert, ecdsa_pkey, [another_ca_cert])

;T;0;;;I"add_certificate;F;I"OpenSSL::SSL::SSLContext;T;[o;;I"}::OpenSSL::X509::Certificate certificate, ::OpenSSL::PKey::PKey pkey, ?::Array[::OpenSSL::X509::Certificate] extra_certs;T;I"	self;To;;I"{An Enumerable of Strings. Each String represents a protocol to be advertised
as the list of supported protocols for Application-Layer Protocol Negotiation.
Supported in OpenSSL 1.0.2 and higher. Has no effect on the server side. If
not set explicitly, the ALPN extension will not be included in the handshake.

### Example

    ctx.alpn_protocols = ["http/1.1", "spdy/2", "h2"]

;T;0;;;I"alpn_protocols;F;I"OpenSSL::SSL::SSLContext;T;[o;;I" ;F;I"Array[::String]?;To;;I"{An Enumerable of Strings. Each String represents a protocol to be advertised
as the list of supported protocols for Application-Layer Protocol Negotiation.
Supported in OpenSSL 1.0.2 and higher. Has no effect on the server side. If
not set explicitly, the ALPN extension will not be included in the handshake.

### Example

    ctx.alpn_protocols = ["http/1.1", "spdy/2", "h2"]

;T;0;;;I"alpn_protocols=;F;I"OpenSSL::SSL::SSLContext;T;[o;;I"::Array[::String];T;I"Array[::String];To;;I"YA callback invoked on the server side when the server needs to select a
protocol from the list sent by the client. Supported in OpenSSL 1.0.2 and
higher. The callback must return a protocol of those advertised by the client.
If none is acceptable, raising an error in the callback will cause the
handshake to fail. Not setting this callback explicitly means not supporting
the ALPN extension on the server - any protocols advertised by the client will
be ignored.

### Example

    ctx.alpn_select_cb = lambda do |protocols|
      # inspect the protocols and select one
      protocols.first
    end

;T;0;;;I"alpn_select_cb;F;I"OpenSSL::SSL::SSLContext;T;[o;;I" ;F;I",^(::Array[::String]) -> ::String? | nil;To;;I"YA callback invoked on the server side when the server needs to select a
protocol from the list sent by the client. Supported in OpenSSL 1.0.2 and
higher. The callback must return a protocol of those advertised by the client.
If none is acceptable, raising an error in the callback will cause the
handshake to fail. Not setting this callback explicitly means not supporting
the ALPN extension on the server - any protocols advertised by the client will
be ignored.

### Example

    ctx.alpn_select_cb = lambda do |protocols|
      # inspect the protocols and select one
      protocols.first
    end

;T;0;;;I"alpn_select_cb=;F;I"OpenSSL::SSL::SSLContext;T;[o;;I";^(::Array[::String]) -> ::String? alpn_select_callback;T;I"	void;To;;I"@The path to a file containing a PEM-format CA certificate

;T;0;;;I"ca_file;F;I"OpenSSL::SSL::SSLContext;T;[o;;I" ;F;I"String;To;;I"@The path to a file containing a PEM-format CA certificate

;T;0;;;I"ca_file=;F;I"OpenSSL::SSL::SSLContext;T;[o;;I"::String ca_file;T;I"String;To;;I"}The path to a directory containing CA certificates in PEM format.

Files are looked up by subject's X509 name's hash value.

;T;0;;;I"ca_path;F;I"OpenSSL::SSL::SSLContext;T;[o;;I" ;F;I"String?;To;;I"}The path to a directory containing CA certificates in PEM format.

Files are looked up by subject's X509 name's hash value.

;T;0;;;I"ca_path=;F;I"OpenSSL::SSL::SSLContext;T;[o;;I"::String ca_path;T;I"String;To;;I"ŽContext certificate

The *cert*, *key*, and *extra_chain_cert* attributes are deprecated. It is
recommended to use #add_certificate instead.

;T;0;;;I"	cert;F;I"OpenSSL::SSL::SSLContext;T;[o;;I" ;F;I" OpenSSL::X509::Certificate?;To;;I"ŽContext certificate

The *cert*, *key*, and *extra_chain_cert* attributes are deprecated. It is
recommended to use #add_certificate instead.

;T;0;;;I"
cert=;F;I"OpenSSL::SSL::SSLContext;T;[o;;I"&::OpenSSL::X509::Certificate cert;T;I"OpenSSL::X509::Certificate;To;;I"AAn OpenSSL::X509::Store used for certificate verification.

;T;0;;;I"cert_store;F;I"OpenSSL::SSL::SSLContext;T;[o;;I" ;F;I"OpenSSL::X509::Store?;To;;I"AAn OpenSSL::X509::Store used for certificate verification.

;T;0;;;I"cert_store=;F;I"OpenSSL::SSL::SSLContext;T;[o;;I"!::OpenSSL::X509::Store store;T;I"OpenSSL::X509::Store;To;;I"=The list of cipher suites configured for this context.

;T;0;;;I"ciphers;F;I"OpenSSL::SSL::SSLContext;T;[o;;I" ;F;I"8Array[[ ::String, ::String, ::Integer, ::Integer ]];To;;I"äSets the list of available cipher suites for this context.  Note in a server
context some ciphers require the appropriate certificates.  For example, an
RSA cipher suite can only be chosen when an RSA certificate is available.

;T;0;;;I"ciphers=;F;I"OpenSSL::SSL::SSLContext;T;[o;;I"B::Array[[ ::String, ::String, ::Integer, ::Integer ]] ciphers;T;I"	void;To;;I"::Array[::String] ciphers;T;I"	void;To;;I"::String colon_sep_ciphers;T;I"	void;To;;I"NA certificate or Array of certificates that will be sent to the client.

;T;0;;;I"client_ca;F;I"OpenSSL::SSL::SSLContext;T;[o;;I" ;F;I"GArray[::OpenSSL::X509::Certificate] | ::OpenSSL::X509::Certificate;To;;I"NA certificate or Array of certificates that will be sent to the client.

;T;0;;;I"client_ca=;F;I"OpenSSL::SSL::SSLContext;T;[o;;I"S::Array[::OpenSSL::X509::Certificate] | ::OpenSSL::X509::Certificate client_ca;T;I"	void;To;;I"$A callback invoked when a client certificate is requested by a server and no
certificate has been set.

The callback is invoked with a Session and must return an Array containing an
OpenSSL::X509::Certificate and an OpenSSL::PKey.  If any other value is
returned the handshake is suspended.

;T;0;;;I"client_cert_cb;F;I"OpenSSL::SSL::SSLContext;T;[o;;I" ;F;I"a^(::OpenSSL::SSL::Session) -> [ ::OpenSSL::X509::Certificate, ::OpenSSL::PKey::PKey ]? | nil;To;;I"$A callback invoked when a client certificate is requested by a server and no
certificate has been set.

The callback is invoked with a Session and must return an Array containing an
OpenSSL::X509::Certificate and an OpenSSL::PKey.  If any other value is
returned the handshake is suspended.

;T;0;;;I"client_cert_cb=;F;I"OpenSSL::SSL::SSLContext;T;[o;;I"j^(::OpenSSL::SSL::Session) -> [ ::OpenSSL::X509::Certificate, ::OpenSSL::PKey::PKey ]? client_cert_cb;T;I"	void;To;;I"·Sets the list of "supported elliptic curves" for this context.

For a TLS client, the list is directly used in the Supported Elliptic Curves
Extension. For a server, the list is used by OpenSSL to determine the set of
shared curves. OpenSSL will pick the most appropriate one from it.

### Example
    ctx1 = OpenSSL::SSL::SSLContext.new
    ctx1.ecdh_curves = "X25519:P-256:P-224"
    svr = OpenSSL::SSL::SSLServer.new(tcp_svr, ctx1)
    Thread.new { svr.accept }

    ctx2 = OpenSSL::SSL::SSLContext.new
    ctx2.ecdh_curves = "P-256"
    cli = OpenSSL::SSL::SSLSocket.new(tcp_sock, ctx2)
    cli.connect

    p cli.tmp_key.group.curve_name
    # => "prime256v1" (is an alias for NIST P-256)

;T;0;;;I"ecdh_curves=;F;I"OpenSSL::SSL::SSLContext;T;[o;;I"::String ecdh_curves;T;I"String;To;;I"AActivate TLS_FALLBACK_SCSV for this context. See RFC 7507.

;T;0;;;I"enable_fallback_scsv;F;I"OpenSSL::SSL::SSLContext;T;[o;;I" ;F;I"nil;To;;I"ÄAn Array of extra X509 certificates to be added to the certificate chain.

The *cert*, *key*, and *extra_chain_cert* attributes are deprecated. It is
recommended to use #add_certificate instead.

;T;0;;;I"extra_chain_cert;F;I"OpenSSL::SSL::SSLContext;T;[o;;I" ;F;I")Array[::OpenSSL::X509::Certificate]?;To;;I"ÄAn Array of extra X509 certificates to be added to the certificate chain.

The *cert*, *key*, and *extra_chain_cert* attributes are deprecated. It is
recommended to use #add_certificate instead.

;T;0;;;I"extra_chain_cert=;F;I"OpenSSL::SSL::SSLContext;T;[o;;I"6::Array[::OpenSSL::X509::Certificate] extra_certs;T;I"(Array[::OpenSSL::X509::Certificate];To;;I"JRemoves sessions in the internal cache that have expired at *time*.

;T;0;;;I"flush_sessions;F;I"OpenSSL::SSL::SSLContext;T;[o;;I"::Time time;T;I"	self;To;;I"ŽContext private key

The *cert*, *key*, and *extra_chain_cert* attributes are deprecated. It is
recommended to use #add_certificate instead.

;T;0;;;I"key;F;I"OpenSSL::SSL::SSLContext;T;[o;;I" ;F;I"OpenSSL::PKey::PKey?;To;;I"ŽContext private key

The *cert*, *key*, and *extra_chain_cert* attributes are deprecated. It is
recommended to use #add_certificate instead.

;T;0;;;I"	key=;F;I"OpenSSL::SSL::SSLContext;T;[o;;I"::OpenSSL::PKey::PKey;T;I"OpenSSL::PKey::PKey;To;;I"qSets the upper bound of the supported SSL/TLS protocol version. See
#min_version= for the possible values.

;T;0;;;I"max_version=;F;I"OpenSSL::SSL::SSLContext;T;[o;;I"(::OpenSSL::SSL::tls_version version;T;I"OpenSSL::SSL::tls_version;To;;I"lSets the lower bound on the supported SSL/TLS protocol version. The version
may be specified by an integer constant named OpenSSL::SSL::*_VERSION, a
Symbol, or `nil` which means "any version".

Be careful that you don't overwrite OpenSSL::SSL::OP_NO_{SSL,TLS}v* options by
#options= once you have called #min_version= or #max_version=.

### Example
    ctx = OpenSSL::SSL::SSLContext.new
    ctx.min_version = OpenSSL::SSL::TLS1_1_VERSION
    ctx.max_version = OpenSSL::SSL::TLS1_2_VERSION

    sock = OpenSSL::SSL::SSLSocket.new(tcp_sock, ctx)
    sock.connect # Initiates a connection using either TLS 1.1 or TLS 1.2

;T;0;;;I"min_version=;F;I"OpenSSL::SSL::SSLContext;T;[o;;I"(::OpenSSL::SSL::tls_version version;T;I"OpenSSL::SSL::tls_version;To;;I"pAn Enumerable of Strings. Each String represents a protocol to be advertised
as the list of supported protocols for Next Protocol Negotiation. Supported in
OpenSSL 1.0.1 and higher. Has no effect on the client side. If not set
explicitly, the NPN extension will not be sent by the server in the handshake.

### Example

    ctx.npn_protocols = ["http/1.1", "spdy/2"]

;T;0;;;I"npn_protocols;F;I"OpenSSL::SSL::SSLContext;T;[o;;I" ;F;I"untyped;To;;I"pAn Enumerable of Strings. Each String represents a protocol to be advertised
as the list of supported protocols for Next Protocol Negotiation. Supported in
OpenSSL 1.0.1 and higher. Has no effect on the client side. If not set
explicitly, the NPN extension will not be sent by the server in the handshake.

### Example

    ctx.npn_protocols = ["http/1.1", "spdy/2"]

;T;0;;;I"npn_protocols=;F;I"OpenSSL::SSL::SSLContext;T;[o;;I"untyped;T;I"untyped;To;;I"UA callback invoked on the client side when the client needs to select a
protocol from the list sent by the server. Supported in OpenSSL 1.0.1 and
higher. The client MUST select a protocol of those advertised by the server.
If none is acceptable, raising an error in the callback will cause the
handshake to fail. Not setting this callback explicitly means not supporting
the NPN extension on the client - any protocols advertised by the server will
be ignored.

### Example

    ctx.npn_select_cb = lambda do |protocols|
      # inspect the protocols and select one
      protocols.first
    end

;T;0;;;I"npn_select_cb;F;I"OpenSSL::SSL::SSLContext;T;[o;;I" ;F;I"untyped;To;;I"UA callback invoked on the client side when the client needs to select a
protocol from the list sent by the server. Supported in OpenSSL 1.0.1 and
higher. The client MUST select a protocol of those advertised by the server.
If none is acceptable, raising an error in the callback will cause the
handshake to fail. Not setting this callback explicitly means not supporting
the NPN extension on the client - any protocols advertised by the server will
be ignored.

### Example

    ctx.npn_select_cb = lambda do |protocols|
      # inspect the protocols and select one
      protocols.first
    end

;T;0;;;I"npn_select_cb=;F;I"OpenSSL::SSL::SSLContext;T;[o;;I"untyped;T;I"untyped;To;;I"$Gets various OpenSSL options.

;T;0;;;I"options;F;I"OpenSSL::SSL::SSLContext;T;[o;;I" ;F;I"Integer;To;;I"$Sets various OpenSSL options.

;T;0;;;I"options=;F;I"OpenSSL::SSL::SSLContext;T;[o;;I"::Integer ssl_options;T;I"Integer;To;;I"¼A callback invoked whenever a new handshake is initiated on an established
connection. May be used to disable renegotiation entirely.

The callback is invoked with the active SSLSocket. The callback's return value
is ignored. A normal return indicates "approval" of the renegotiation and will
continue the process. To forbid renegotiation and to cancel the process, raise
an exception within the callback.

### Disable client renegotiation

When running a server, it is often desirable to disable client renegotiation
entirely. You may use a callback as follows to implement this feature:

    ctx.renegotiation_cb = lambda do |ssl|
      raise RuntimeError, "Client renegotiation disabled"
    end

;T;0;;;I"renegotiation_cb;F;I"OpenSSL::SSL::SSLContext;T;[o;;I" ;F;I"/^(::OpenSSL::SSL::SSLSocket) -> void | nil;To;;I"¼A callback invoked whenever a new handshake is initiated on an established
connection. May be used to disable renegotiation entirely.

The callback is invoked with the active SSLSocket. The callback's return value
is ignored. A normal return indicates "approval" of the renegotiation and will
continue the process. To forbid renegotiation and to cancel the process, raise
an exception within the callback.

### Disable client renegotiation

When running a server, it is often desirable to disable client renegotiation
entirely. You may use a callback as follows to implement this feature:

    ctx.renegotiation_cb = lambda do |ssl|
      raise RuntimeError, "Client renegotiation disabled"
    end

;T;0;;;I"renegotiation_cb=;F;I"OpenSSL::SSL::SSLContext;T;[o;;I")^(::OpenSSL::SSL::SSLSocket) -> void;T;I"	void;To;;I"fReturns the security level for the context.

See also OpenSSL::SSL::SSLContext#security_level=.

;T;0;;;I"security_level;F;I"OpenSSL::SSL::SSLContext;T;[o;;I" ;F;I"Integer;To;;I"ýSets the security level for the context. OpenSSL limits parameters according
to the level. The "parameters" include: ciphersuites, curves, key sizes,
certificate signature algorithms, protocol version and so on. For example,
level 1 rejects parameters offering below 80 bits of security, such as
ciphersuites using MD5 for the MAC or RSA keys shorter than 1024 bits.

Note that attempts to set such parameters with insufficient security are also
blocked. You need to lower the level first.

This feature is not supported in OpenSSL < 1.1.0, and setting the level to
other than 0 will raise NotImplementedError. Level 0 means everything is
permitted, the same behavior as previous versions of OpenSSL.

See the manpage of SSL_CTX_set_security_level(3) for details.

;T;0;;;I"security_level=;F;I"OpenSSL::SSL::SSLContext;T;[o;;I"::Integer sec_level;T;I"Integer;To;;I"ÔA callback invoked at connect time to distinguish between multiple server
names.

The callback is invoked with an SSLSocket and a server name.  The callback
must return an SSLContext for the server name or nil.

;T;0;;;I"servername_cb;F;I"OpenSSL::SSL::SSLContext;T;[o;;I" ;F;I"P^(::OpenSSL::SSL::SSLSocket, ::String) -> ::OpenSSL::SSL::SSLContext? | nil;To;;I"ÔA callback invoked at connect time to distinguish between multiple server
names.

The callback is invoked with an SSLSocket and a server name.  The callback
must return an SSLContext for the server name or nil.

;T;0;;;I"servername_cb=;F;I"OpenSSL::SSL::SSLContext;T;[o;;I"J^(::OpenSSL::SSL::SSLSocket, ::String) -> ::OpenSSL::SSL::SSLContext?;T;I"J^(::OpenSSL::SSL::SSLSocket, ::String) -> ::OpenSSL::SSL::SSLContext?;To;;I"+Adds *session* to the session cache.

;T;0;;;I"session_add;F;I"OpenSSL::SSL::SSLContext;T;[o;;I"::OpenSSL::SSL::Session;T;I"	bool;To;;I"&The current session cache mode.

;T;0;;;I"session_cache_mode;F;I"OpenSSL::SSL::SSLContext;T;[o;;I" ;F;I"Integer;To;;I"™Sets the SSL session cache mode.  Bitwise-or together the desired
SESSION_CACHE_* constants to set.  See SSL_CTX_set_session_cache_mode(3) for
details.

;T;0;;;I"session_cache_mode=;F;I"OpenSSL::SSL::SSLContext;T;[o;;I"::Integer;T;I"Integer;To;;I"bReturns the current session cache size.  Zero is used to represent an
unlimited cache size.

;T;0;;;I"session_cache_size;F;I"OpenSSL::SSL::SSLContext;T;[o;;I" ;F;I"Integer;To;;I"ŒSets the session cache size.  Returns the previously valid session cache size.
 Zero is used to represent an unlimited session cache size.

;T;0;;;I"session_cache_size=;F;I"OpenSSL::SSL::SSLContext;T;[o;;I"::Integer;T;I"Integer;To;;I"³Returns a Hash containing the following keys:

:accept
:   Number of started SSL/TLS handshakes in server mode
:accept_good
:   Number of established SSL/TLS sessions in server mode
:accept_renegotiate
:   Number of start renegotiations in server mode
:cache_full
:   Number of sessions that were removed due to cache overflow
:cache_hits
:   Number of successfully reused connections
:cache_misses
:   Number of sessions proposed by clients that were not found in the cache
:cache_num
:   Number of sessions in the internal session cache
:cb_hits
:   Number of sessions retrieved from the external cache in server mode
:connect
:   Number of started SSL/TLS handshakes in client mode
:connect_good
:   Number of established SSL/TLS sessions in client mode
:connect_renegotiate
:   Number of start renegotiations in client mode
:timeouts
:   Number of sessions proposed by clients that were found in the cache but
    had expired due to timeouts

;T;0;;;I"session_cache_stats;F;I"OpenSSL::SSL::SSLContext;T;[o;;I" ;F;I"Hash[::Symbol, ::Integer];To;;I"A callback invoked on a server when a session is proposed by the client but
the session could not be found in the server's internal cache.

The callback is invoked with the SSLSocket and session id.  The callback may
return a Session from an external cache.

;T;0;;;I"session_get_cb;F;I"OpenSSL::SSL::SSLContext;T;[o;;I" ;F;I"N^(::OpenSSL::SSL::SSLSocket, ::Integer) -> ::OpenSSL::SSL::Session? | nil;To;;I"A callback invoked on a server when a session is proposed by the client but
the session could not be found in the server's internal cache.

The callback is invoked with the SSLSocket and session id.  The callback may
return a Session from an external cache.

;T;0;;;I"session_get_cb=;F;I"OpenSSL::SSL::SSLContext;T;[o;;I"H^(::OpenSSL::SSL::SSLSocket, ::Integer) -> ::OpenSSL::SSL::Session?;T;I"	void;To;;I"Sets the context in which a session can be reused.  This allows sessions for
multiple applications to be distinguished, for example, by name.

;T;0;;;I"session_id_context;F;I"OpenSSL::SSL::SSLContext;T;[o;;I" ;F;I"Integer?;To;;I"Sets the context in which a session can be reused.  This allows sessions for
multiple applications to be distinguished, for example, by name.

;T;0;;;I"session_id_context=;F;I"OpenSSL::SSL::SSLContext;T;[o;;I"::Integer;T;I"Integer;To;;I"°A callback invoked when a new session was negotiated.

The callback is invoked with an SSLSocket.  If `false` is returned the session
will be removed from the internal cache.

;T;0;;;I"session_new_cb;F;I"OpenSSL::SSL::SSLContext;T;[o;;I" ;F;I"2^(::OpenSSL::SSL::SSLSocket) -> untyped | nil;To;;I"°A callback invoked when a new session was negotiated.

The callback is invoked with an SSLSocket.  If `false` is returned the session
will be removed from the internal cache.

;T;0;;;I"session_new_cb=;F;I"OpenSSL::SSL::SSLContext;T;[o;;I",^(::OpenSSL::SSL::SSLSocket) -> untyped;T;I",^(::OpenSSL::SSL::SSLSocket) -> untyped;To;;I"0Removes *session* from the session cache.

;T;0;;;I"session_remove;F;I"OpenSSL::SSL::SSLContext;T;[o;;I"$::OpenSSL::SSL::Session session;T;I"	bool;To;;I"MA callback invoked when a session is removed from the internal cache.

The callback is invoked with an SSLContext and a Session.

IMPORTANT NOTE: It is currently not possible to use this safely in a
multi-threaded application. The callback is called inside a global lock and it
can randomly cause deadlock on Ruby thread switching.

;T;0;;;I"session_remove_cb;F;I"OpenSSL::SSL::SSLContext;T;[o;;I" ;F;I"I^(::OpenSSL::SSL::SSLContext, ::OpenSSL::SSL::Session) -> void | nil;To;;I"MA callback invoked when a session is removed from the internal cache.

The callback is invoked with an SSLContext and a Session.

IMPORTANT NOTE: It is currently not possible to use this safely in a
multi-threaded application. The callback is called inside a global lock and it
can randomly cause deadlock on Ruby thread switching.

;T;0;;;I"session_remove_cb=;F;I"OpenSSL::SSL::SSLContext;T;[o;;I"C^(::OpenSSL::SSL::SSLContext, ::OpenSSL::SSL::Session) -> void;T;I"	void;To;;I"SSets saner defaults optimized for the use with HTTP-like protocols.

If a Hash *params* is given, the parameters are overridden with it. The keys
in *params* must be assignment methods on SSLContext.

If the verify_mode is not VERIFY_NONE and ca_file, ca_path and cert_store are
not set then the system default certificate store is used.

;T;0;;;I"set_params;F;I"OpenSSL::SSL::SSLContext;T;[o;;I"?untyped params;T;I"untyped;To;;I"·This method is called automatically when a new SSLSocket is created. However,
it is not thread-safe and must be called before creating SSLSocket objects in
a multi-threaded program.

;T;0;;;I"
setup;F;I"OpenSSL::SSL::SSLContext;T;[o;;I" ;F;I"untyped;To;;I"öSets the SSL/TLS protocol version for the context. This forces connections to
use only the specified protocol version. This is deprecated and only provided
for backwards compatibility. Use #min_version= and #max_version= instead.

### History
As the name hints, this used to call the SSL_CTX_set_ssl_version() function
which sets the SSL method used for connections created from the context. As of
Ruby/OpenSSL 2.1, this accessor method is implemented to call #min_version=
and #max_version= instead.

;T;0;;;I"ssl_version=;F;I"OpenSSL::SSL::SSLContext;T;[o;;I"%::OpenSSL::SSL::tls_version meth;T;I"OpenSSL::SSL::tls_version;To;;I"+Maximum session lifetime in seconds.

;T;0;;;I"timeout;F;I"OpenSSL::SSL::SSLContext;T;[o;;I" ;F;I"Integer?;To;;I"+Maximum session lifetime in seconds.

;T;0;;;I"timeout=;F;I"OpenSSL::SSL::SSLContext;T;[o;;I"::Integer;T;I"Integer;To;;I"SA callback invoked when DH parameters are required for ephemeral DH key
exchange.

The callback is invoked with the SSLSocket, a flag indicating the use of an
export cipher and the keylength required.

The callback must return an OpenSSL::PKey::DH instance of the correct key
length.

**Deprecated in version 3.0.** Use #tmp_dh= instead.

;T;0;;;I"tmp_dh_callback;F;I"OpenSSL::SSL::SSLContext;T;[o;;I" ;F;I"R^(::OpenSSL::SSL::Session, ::Integer, ::Integer) -> ::OpenSSL::PKey::DH | nil;To;;I"SA callback invoked when DH parameters are required for ephemeral DH key
exchange.

The callback is invoked with the SSLSocket, a flag indicating the use of an
export cipher and the keylength required.

The callback must return an OpenSSL::PKey::DH instance of the correct key
length.

**Deprecated in version 3.0.** Use #tmp_dh= instead.

;T;0;;;I"tmp_dh_callback=;F;I"OpenSSL::SSL::SSLContext;T;[o;;I"L^(::OpenSSL::SSL::Session, ::Integer, ::Integer) -> ::OpenSSL::PKey::DH;T;I"	void;To;;I"ßA callback for additional certificate verification.  The callback is invoked
for each certificate in the chain.

The callback is invoked with two values.  *preverify_ok* indicates indicates
if the verification was passed (`true`) or not (`false`). *store_context* is
an OpenSSL::X509::StoreContext containing the context used for certificate
verification.

If the callback returns `false`, the chain verification is immediately stopped
and a bad_certificate alert is then sent.

;T;0;;;I"verify_callback;F;I"OpenSSL::SSL::SSLContext;T;[o;;I" ;F;I"<^(bool, ::OpenSSL::X509::StoreContext) -> untyped | nil;To;;I"ßA callback for additional certificate verification.  The callback is invoked
for each certificate in the chain.

The callback is invoked with two values.  *preverify_ok* indicates indicates
if the verification was passed (`true`) or not (`false`). *store_context* is
an OpenSSL::X509::StoreContext containing the context used for certificate
verification.

If the callback returns `false`, the chain verification is immediately stopped
and a bad_certificate alert is then sent.

;T;0;;;I"verify_callback=;F;I"OpenSSL::SSL::SSLContext;T;[o;;I"6^(bool, ::OpenSSL::X509::StoreContext) -> untyped;T;I"	void;To;;I"LNumber of CA certificates to walk when verifying a certificate chain.

;T;0;;;I"verify_depth;F;I"OpenSSL::SSL::SSLContext;T;[o;;I" ;F;I"Integer?;To;;I"LNumber of CA certificates to walk when verifying a certificate chain.

;T;0;;;I"verify_depth=;F;I"OpenSSL::SSL::SSLContext;T;[o;;I"::Integer;T;I"Integer;To;;I"ÔWhether to check the server certificate is valid for the hostname.

In order to make this work, verify_mode must be set to VERIFY_PEER and the
server hostname must be given by OpenSSL::SSL::SSLSocket#hostname=.

;T;0;;;I"verify_hostname;F;I"OpenSSL::SSL::SSLContext;T;[o;;I" ;F;I"
bool?;To;;I"ÔWhether to check the server certificate is valid for the hostname.

In order to make this work, verify_mode must be set to VERIFY_PEER and the
server hostname must be given by OpenSSL::SSL::SSLSocket#hostname=.

;T;0;;;I"verify_hostname=;F;I"OpenSSL::SSL::SSLContext;T;[o;;I"::boolish;T;I"U;Fo;;I"Session verification mode.

Valid modes are VERIFY_NONE, VERIFY_PEER, VERIFY_CLIENT_ONCE,
VERIFY_FAIL_IF_NO_PEER_CERT and defined on OpenSSL::SSL

The default mode is VERIFY_NONE, which does not perform any verification at
all.

See SSL_CTX_set_verify(3) for details.

;T;0;;;I"verify_mode;F;I"OpenSSL::SSL::SSLContext;T;[o;;I" ;F;I"OpenSSL::SSL::verify_mode?;To;;I"Session verification mode.

Valid modes are VERIFY_NONE, VERIFY_PEER, VERIFY_CLIENT_ONCE,
VERIFY_FAIL_IF_NO_PEER_CERT and defined on OpenSSL::SSL

The default mode is VERIFY_NONE, which does not perform any verification at
all.

See SSL_CTX_set_verify(3) for details.

;T;0;;;I"verify_mode=;F;I"OpenSSL::SSL::SSLContext;T;[o;;I" ::OpenSSL::SSL::verify_mode;T;I"OpenSSL::SSL::verify_mode;To;;I"ËCreates a new SSL context.

If an argument is given, #ssl_version= is called with the value. Note that
this form is deprecated. New applications should use #min_version= and
#max_version= as necessary.

;T;0;;;I"initialize;F;I"OpenSSL::SSL::SSLContext;T;[o;;I")?::OpenSSL::SSL::tls_version version;T;I"	void;To;;I"eSets the minimum and maximum supported protocol versions. See #min_version=
and #max_version=.

;T;0;;;I"set_minmax_proto_version;F;I"OpenSSL::SSL::SSLContext;T;[o;;I"untyped, untyped;T;I"untyped;To; ;I">Generic error class raised by SSLSocket and SSLContext.

;T;0;	I"OpenSSL::SSL::SSLError;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::OpenSSLError;To; ;0;0;	I"'OpenSSL::SSL::SSLErrorWaitReadable;T;
[ ;[I"IO::WaitReadable;T;0;[ ;[ ;0;I"OpenSSL::SSL::SSLError;To; ;0;0;	I"'OpenSSL::SSL::SSLErrorWaitWritable;T;
[ ;[I"IO::WaitWritable;T;0;[ ;[ ;0;I"OpenSSL::SSL::SSLError;To; ;I"MSSLServer represents a TCP/IP server socket with Secure Sockets Layer.

;T;0;	I"OpenSSL::SSL::SSLServer;T;
[ ;[I""OpenSSL::SSL::SocketForwarder;T;0;[ ;[ ;0;0o;;I")Works similar to TCPServer#accept.

;T;0;;;I"accept;F;I"OpenSSL::SSL::SSLServer;T;[o;;I" ;F;I"OpenSSL::SSL::SSLSocket;To;;I" See IO#close for details.

;T;0;;;I"
close;F;I"OpenSSL::SSL::SSLServer;T;[o;;I" ;F;I"nil;To;;I"(See TCPServer#listen for details.

;T;0;;;I"listen;F;I"OpenSSL::SSL::SSLServer;T;[o;;I"::Integer backlog;T;I"	void;To;;I",See BasicSocket#shutdown for details.

;T;0;;;I"shutdown;F;I"OpenSSL::SSL::SSLServer;T;[o;;I"(::Symbol | ::String | ::Integer how;T;I"	void;To;;I"HWhen true then #accept works exactly the same as TCPServer#accept

;T;0;;;I"start_immediately;F;I"OpenSSL::SSL::SSLServer;T;[o;;I" ;F;I"	bool;To;;I"HWhen true then #accept works exactly the same as TCPServer#accept

;T;0;;;I"start_immediately=;F;I"OpenSSL::SSL::SSLServer;T;[o;;I"::boolish;T;I"U;Fo;;I"FReturns the TCPServer passed to the SSLServer when initialized.

;T;0;;;I"
to_io;F;I"OpenSSL::SSL::SSLServer;T;[o;;I" ;F;I"TCPServer | ::UNIXServer;To;;I"ƒCreates a new instance of SSLServer.
*   *srv* is an instance of TCPServer.
*   *ctx* is an instance of OpenSSL::SSL::SSLContext.

;T;0;;;I"initialize;F;I"OpenSSL::SSL::SSLServer;T;[o;;I"0::TCPServer | ::UNIXServer svr, untyped ctx;T;I"	void;To; ;0;0;	I"OpenSSL::SSL::SSLSocket;T;
[ ;[I""OpenSSL::SSL::SocketForwarder;TI"OpenSSL::Buffering;T;0;[ ;[ ;0;0o;;I"‰Creates a new instance of SSLSocket. *remote*host_ and *remote*port_ are used
to open TCPSocket. If *local*host_ and *local*port_ are specified, then those
parameters are used on the local end to establish the connection. If *context*
is provided, the SSL Sockets initial params will be taken from the context.

### Examples

    sock = OpenSSL::SSL::SSLSocket.open('localhost', 443)
    sock.connect # Initiates a connection to localhost:443

with SSLContext:

    ctx = OpenSSL::SSL::SSLContext.new
    sock = OpenSSL::SSL::SSLSocket.open('localhost', 443, context: ctx)
    sock.connect # Initiates a connection to localhost:443 with SSLContext

;T;0;;;I"	open;F;I"OpenSSL::SSL::SSLSocket;T;[o;;I"juntyped remote_host, untyped remote_port, ?untyped local_host, ?untyped local_port, ?context: untyped;T;I"untyped;To;;I":Waits for a SSL/TLS client to initiate a handshake.

;T;0;;;I"accept;F;I"OpenSSL::SSL::SSLSocket;T;[o;;I" ;F;I"	self;To;;I"úInitiates the SSL/TLS handshake as a server in non-blocking manner.

    # emulates blocking accept
    begin
      ssl.accept_nonblock
    rescue IO::WaitReadable
      IO.select([s2])
      retry
    rescue IO::WaitWritable
      IO.select(nil, [s2])
      retry
    end

By specifying a keyword argument *exception* to `false`, you can indicate that
accept_nonblock should not raise an IO::WaitReadable or IO::WaitWritable
exception, but return the symbol `:wait_readable` or `:wait_writable` instead.

;T;0;;;I"accept_nonblock;F;I"OpenSSL::SSL::SSLSocket;T;[o;;I"?exception: true;T;I"	self;To;;I"exception: false;T;I"+self | :wait_readable | :wait_writable;To;;I"eReturns the ALPN protocol string that was finally selected by the server
during the handshake.

;T;0;;;I"alpn_protocol;F;I"OpenSSL::SSL::SSLSocket;T;[o;;I" ;F;I"String?;To;;I"5The X509 certificate for this socket endpoint.

;T;0;;;I"	cert;F;I"OpenSSL::SSL::SSLSocket;T;[o;;I" ;F;I" OpenSSL::X509::Certificate?;To;;I"pReturns the cipher suite actually used in the current session, or nil if no
session has been established.

;T;0;;;I"cipher;F;I"OpenSSL::SSL::SSLSocket;T;[o;;I" ;F;I"2[ ::String, ::String, ::Integer, ::Integer ]?;To;;I"GReturns the list of client CAs. Please note that in contrast to
SSLContext#client_ca= no array of X509::Certificate is returned but X509::Name
instances of the CA's subject distinguished name.

In server mode, returns the list set by SSLContext#client_ca=. In client mode,
returns the list of client CAs sent from the server.

;T;0;;;I"client_ca;F;I"OpenSSL::SSL::SSLSocket;T;[o;;I" ;F;I"hArray[::OpenSSL::X509::Name] | ::Array[::OpenSSL::X509::Certificate] | ::OpenSSL::X509::Certificate;To;;I"4Initiates an SSL/TLS handshake with a server.

;T;0;;;I"connect;F;I"OpenSSL::SSL::SSLSocket;T;[o;;I" ;F;I"	self;To;;I"ýInitiates the SSL/TLS handshake as a client in non-blocking manner.

    # emulates blocking connect
    begin
      ssl.connect_nonblock
    rescue IO::WaitReadable
      IO.select([s2])
      retry
    rescue IO::WaitWritable
      IO.select(nil, [s2])
      retry
    end

By specifying a keyword argument *exception* to `false`, you can indicate that
connect_nonblock should not raise an IO::WaitReadable or IO::WaitWritable
exception, but return the symbol `:wait_readable` or `:wait_writable` instead.

;T;0;;;I"connect_nonblock;F;I"OpenSSL::SSL::SSLSocket;T;[o;;I"?exception: true;T;I"	self;To;;I"exception: false;T;I"+self | :wait_readable | :wait_writable;To;;I"5The SSLContext object used in this connection.

;T;0;;;I"context;F;I"OpenSSL::SSL::SSLSocket;T;[o;;I" ;F;I"OpenSSL::SSL::SSLContext;To;;I"1Returns the last **Finished** message sent

;T;0;;;I"finished_message;F;I"OpenSSL::SSL::SSLSocket;T;[o;;I" ;F;I"String?;To;;0;0;;;I"hostname;F;I"OpenSSL::SSL::SSLSocket;T;[o;;I" ;F;I"String?;To;;I"\Sets the server hostname used for SNI. This needs to be set before
SSLSocket#connect.

;T;0;;;I"hostname=;F;I"OpenSSL::SSL::SSLSocket;T;[o;;I"::String;T;I"String;To;;I" The underlying IO object.

;T;0;;;I"io;F;I"OpenSSL::SSL::SSLSocket;T;[o;;I" ;F;I"BasicSocket;To;;I"`Returns the protocol string that was finally selected by the client during the
handshake.

;T;0;;;I"npn_protocol;F;I"OpenSSL::SSL::SSLSocket;T;[o;;I" ;F;I"String?;To;;I"3The X509 certificate for this socket's peer.

;T;0;;;I"peer_cert;F;I"OpenSSL::SSL::SSLSocket;T;[o;;I" ;F;I" OpenSSL::X509::Certificate?;To;;I"9The X509 certificate chain for this socket's peer.

;T;0;;;I"peer_cert_chain;F;I"OpenSSL::SSL::SSLSocket;T;[o;;I" ;F;I")Array[::OpenSSL::X509::Certificate]?;To;;I"5Returns the last **Finished** message received

;T;0;;;I"peer_finished_message;F;I"OpenSSL::SSL::SSLSocket;T;[o;;I" ;F;I"String?;To;;I"FThe number of bytes that are immediately available for reading.

;T;0;;;I"pending;F;I"OpenSSL::SSL::SSLSocket;T;[o;;I" ;F;I"Integer;To;;I"¦Perform hostname verification following RFC 6125.

This method MUST be called after calling #connect to ensure that the hostname
of a remote peer has been verified.

;T;0;;;I"post_connection_check;F;I"OpenSSL::SSL::SSLSocket;T;[o;;I"::String hostname;T;I"	true;Fo;;I"^Returns the SSLSession object currently used, or nil if the session is not
established.

;T;0;;;I"session;F;I"OpenSSL::SSL::SSLSocket;T;[o;;I" ;F;I"OpenSSL::SSL::Session?;To;;I"FSets the Session to be used when the connection is established.

;T;0;;;I"session=;F;I"OpenSSL::SSL::SSLSocket;T;[o;;I"::OpenSSL::SSL::Session;T;I"OpenSSL::SSL::Session;To;;I"NReturns `true` if a reused session was negotiated during the handshake.

;T;0;;;I"session_reused?;F;I"OpenSSL::SSL::SSLSocket;T;[o;;I" ;F;I"	bool;To;;I"wReturns a String representing the SSL/TLS version that was negotiated for the
connection, for example "TLSv1.2".

;T;0;;;I"ssl_version;F;I"OpenSSL::SSL::SSLSocket;T;[o;;I" ;F;I"OpenSSL::SSL::tls_version;To;;I"[A description of the current connection state. This is for diagnostic purposes
only.

;T;0;;;I"
state;F;I"OpenSSL::SSL::SSLSocket;T;[o;;I" ;F;I"String;To;;I"zWhether to close the underlying socket as well, when the SSL/TLS connection is
shut down. This defaults to `false`.

;T;0;;;I"sync_close;F;I"OpenSSL::SSL::SSLSocket;T;[o;;I" ;F;I"	bool;To;;I"zWhether to close the underlying socket as well, when the SSL/TLS connection is
shut down. This defaults to `false`.

;T;0;;;I"sync_close=;F;I"OpenSSL::SSL::SSLSocket;T;[o;;I"::boolish;T;I"U;Fo;;I"›Sends "close notify" to the peer and tries to shut down the SSL connection
gracefully.

If sync_close is set to `true`, the underlying IO is also closed.

;T;0;;;I"sysclose;F;I"OpenSSL::SSL::SSLSocket;T;[o;;I" ;F;I"nil;To;;I"Reads *length* bytes from the SSL connection.  If a pre-allocated *buffer* is
provided the data will be written into it.

;T;0;;;I"sysread;F;I"OpenSSL::SSL::SSLSocket;T;[o;;I"'::Integer length, ?::String buffer;T;I"String;To;;I"-Writes *string* to the SSL connection.

;T;0;;;I"syswrite;F;I"OpenSSL::SSL::SSLSocket;T;[o;;I"::String data;T;I"Integer;To;;I"HReturns the ephemeral key used in case of forward secrecy cipher.

;T;0;;;I"tmp_key;F;I"OpenSSL::SSL::SSLSocket;T;[o;;I" ;F;I"OpenSSL::PKey::PKey?;To;;I"ªReturns the result of the peer certificates verification.  See verify(1) for
error values and descriptions.

If no peer certificate was presented X509_V_OK is returned.

;T;0;;;I"verify_result;F;I"OpenSSL::SSL::SSLSocket;T;[o;;I" ;F;I"Integer;To;;I" ;T;0;;;I"client_cert_cb;F;I"OpenSSL::SSL::SSLSocket;T;[o;;I" ;F;I"untyped;To;;I"Creates a new SSL socket from *io* which must be a real IO object (not an
IO-like object that responds to read/write).

If *ctx* is provided the SSL Sockets initial params will be taken from the
context.

The OpenSSL::Buffering module provides additional IO methods.

This method will freeze the SSLContext if one is provided; however, session
management is still allowed in the frozen SSLContext.

;T;0;;;I"initialize;F;I"OpenSSL::SSL::SSLSocket;T;[o;;I"*untyped;T;I"	void;To;;I" ;T;0;;;I"session_get_cb;F;I"OpenSSL::SSL::SSLSocket;T;[o;;I" ;F;I"untyped;To;;I" ;T;0;;;I"session_new_cb;F;I"OpenSSL::SSL::SSLSocket;T;[o;;I" ;F;I"untyped;To;;I"]Sends "close notify" to the peer and tries to shut down the SSL connection
gracefully.

;T;0;;;I"	stop;F;I"OpenSSL::SSL::SSLSocket;T;[o;;I" ;F;I"untyped;To;;I"WA non-blocking version of #sysread.  Raises an SSLError if reading would
block.  If "exception: false" is passed, this method returns a symbol of
:wait_readable, :wait_writable, or nil, rather than raising an exception.

Reads *length* bytes from the SSL connection.  If a pre-allocated *buffer* is
provided the data will be written into it.

;T;0;;;I"sysread_nonblock;F;I"OpenSSL::SSL::SSLSocket;T;[o;;I"*untyped;T;I"untyped;To;;I"rWrites *string* to the SSL connection in a non-blocking manner.  Raises an
SSLError if writing would block.

;T;0;;;I"syswrite_nonblock;F;I"OpenSSL::SSL::SSLSocket;T;[o;;I"*untyped;T;I"untyped;To;;I" ;T;0;;;I"tmp_dh_callback;F;I"OpenSSL::SSL::SSLSocket;T;[o;;I" ;F;I"untyped;To;;I" ;T;0;;;I"tmp_ecdh_callback;F;I"OpenSSL::SSL::SSLSocket;T;[o;;I" ;F;I"untyped;To;;I" ;T;0;;;I"using_anon_cipher?;F;I"OpenSSL::SSL::SSLSocket;T;[o;;I" ;F;I"untyped;To; ;0;0;	I"OpenSSL::SSL::Session;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"EReturns `true` if the two Session is the same, `false` if not.

;T;0;;;I"==;F;I"OpenSSL::SSL::Session;T;[o;;I"instance other;T;I"	bool;To;;I"Returns the Session ID.

;T;0;;;I"id;F;I"OpenSSL::SSL::Session;T;[o;;I" ;F;I"String;To;;I"=Returns the time at which the session was established.

;T;0;;;I"	time;F;I"OpenSSL::SSL::Session;T;[o;;I" ;F;I"	Time;To;;I"ESets start time of the session. Time resolution is in seconds.

;T;0;;;I"
time=;F;I"OpenSSL::SSL::Session;T;[o;;I""::Time | ::Integer start_time;T;I"	Time;To;;I"[Returns the timeout value set for the session, in seconds from the established
time.

;T;0;;;I"timeout;F;I"OpenSSL::SSL::Session;T;[o;;I" ;F;I"Integer;To;;I":Sets how long until the session expires in seconds.

;T;0;;;I"timeout=;F;I"OpenSSL::SSL::Session;T;[o;;I"::Integer timeout;T;I"Integer;To;;I"GReturns an ASN1 encoded String that contains the Session object.

;T;0;;;I"to_der;F;I"OpenSSL::SSL::Session;T;[o;;I" ;F;I"String;To;;I"EReturns a PEM encoded String that contains the Session object.

;T;0;;;I"to_pem;F;I"OpenSSL::SSL::Session;T;[o;;I" ;F;I"String;To;;I"OShows everything in the Session object. This is for diagnostic purposes.

;T;0;;;I"to_text;F;I"OpenSSL::SSL::Session;T;[o;;I" ;F;I"String;To;;I"\Creates a new Session object from an instance of SSLSocket or DER/PEM encoded
String.

;T;0;;;I"initialize;F;I"OpenSSL::SSL::Session;T;[o;;I"5::OpenSSL::SSL::SSLSocket | ::String sock_or_str;T;I"	void;To;;I" ;T;0;;;I"initialize_copy;F;I"OpenSSL::SSL::Session;T;[o;;I"instance;T;I"	void;To; ;0;0;	I"(OpenSSL::SSL::Session::SessionError;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::OpenSSLError;To;;0;0;	I""OpenSSL::SSL::SocketForwarder;T;
[ ;[ ;0;[ ;[ o;;I" ;T;0;;;I"	addr;F;I""OpenSSL::SSL::SocketForwarder;T;[o;;I" ;F;I"Addrinfo?;To;;I" ;T;0;;;I"closed?;F;I""OpenSSL::SSL::SocketForwarder;T;[o;;I" ;F;I"untyped;To;;I" ;T;0;;;I"do_not_reverse_lookup=;F;I""OpenSSL::SSL::SocketForwarder;T;[o;;I"::boolish flag;T;I"boolish;To;;I" ;T;0;;;I"
fcntl;F;I""OpenSSL::SSL::SocketForwarder;T;[o;;I"*untyped args;T;I"untyped;To;;I"*The file descriptor for the socket.

;T;0;;;I"fileno;F;I""OpenSSL::SSL::SocketForwarder;T;[o;;I" ;F;I"Integer;To;;I" ;T;0;;;I"getsockopt;F;I""OpenSSL::SSL::SocketForwarder;T;[o;;I"=::Symbol | ::Integer level, ::Symbol | ::Integer optname;T;I"#Integer | ::boolish | ::String;To;;I" ;T;0;;;I"peeraddr;F;I""OpenSSL::SSL::SocketForwarder;T;[o;;I" ;F;I"untyped;To;;I" ;T;0;;;I"setsockopt;F;I""OpenSSL::SSL::SocketForwarder;T;[o;;I"3untyped level, untyped optname, untyped optval;T;I"untyped;To;;I"ºProvides classes and methods to request, create and validate
[RFC3161-compliant](http://www.ietf.org/rfc/rfc3161.txt) timestamps. Request
may be used to either create requests from scratch or to parse existing
requests that again can be used to request timestamps from a timestamp server,
e.g. via the net/http. The resulting timestamp response may be parsed using
Response.

Please note that Response is read-only and immutable. To create a Response, an
instance of Factory as well as a valid Request are needed.

### Create a Response:
    #Assumes ts.p12 is a PKCS#12-compatible file with a private key
    #and a certificate that has an extended key usage of 'timeStamping'
    p12 = OpenSSL::PKCS12.new(File.binread('ts.p12'), 'pwd')
    md = OpenSSL::Digest.new('SHA1')
    hash = md.digest(data) #some binary data to be timestamped
    req = OpenSSL::Timestamp::Request.new
    req.algorithm = 'SHA1'
    req.message_imprint = hash
    req.policy_id = "1.2.3.4.5"
    req.nonce = 42
    fac = OpenSSL::Timestamp::Factory.new
    fac.gen_time = Time.now
    fac.serial_number = 1
    timestamp = fac.create_timestamp(p12.key, p12.certificate, req)

### Verify a timestamp response:
    #Assume we have a timestamp token in a file called ts.der
    ts = OpenSSL::Timestamp::Response.new(File.binread('ts.der'))
    #Assume we have the Request for this token in a file called req.der
    req = OpenSSL::Timestamp::Request.new(File.binread('req.der'))
    # Assume the associated root CA certificate is contained in a
    # DER-encoded file named root.cer
    root = OpenSSL::X509::Certificate.new(File.binread('root.cer'))
    # get the necessary intermediate certificates, available in
    # DER-encoded form in inter1.cer and inter2.cer
    inter1 = OpenSSL::X509::Certificate.new(File.binread('inter1.cer'))
    inter2 = OpenSSL::X509::Certificate.new(File.binread('inter2.cer'))
    ts.verify(req, root, inter1, inter2) -> ts or raises an exception if validation fails

;T;0;	I"OpenSSL::Timestamp;T;
[ ;[ ;0;[ ;[ o; ;I"iUsed to generate a Response from scratch.

Please bear in mind that the implementation will always apply and prefer the
policy object identifier given in the request over the default policy id
specified in the Factory. As a consequence, `default_policy_id` will only be
applied if no Request#policy_id was given. But this also means that one needs
to check the policy identifier in the request manually before creating the
Response, e.g. to check whether it complies to a specific set of acceptable
policies.

There exists also the possibility to add certificates (instances of
OpenSSL::X509::Certificate) besides the timestamping certificate that will be
included in the resulting timestamp token if Request#cert_requested? is
`true`. Ideally, one would also include any intermediate certificates (the
root certificate can be left out - in order to trust it any verifying party
will have to be in its possession anyway). This simplifies validation of the
timestamp since these intermediate certificates are "already there" and need
not be passed as external parameters to Response#verify anymore, thus
minimizing external resources needed for verification.

### Example: Inclusion of (untrusted) intermediate certificates

Assume we received a timestamp request that has set Request#policy_id to `nil`
and Request#cert_requested? to true. The raw request bytes are stored in a
variable called `req_raw`. We'd still like to integrate the necessary
intermediate certificates (in `inter1.cer` and `inter2.cer`) to simplify
validation of the resulting Response. `ts.p12` is a PKCS#12-compatible file
including the private key and the timestamping certificate.

    req = OpenSSL::Timestamp::Request.new(raw_bytes)
    p12 = OpenSSL::PKCS12.new(File.binread('ts.p12'), 'pwd')
    inter1 = OpenSSL::X509::Certificate.new(File.binread('inter1.cer'))
    inter2 = OpenSSL::X509::Certificate.new(File.binread('inter2.cer'))
    fac = OpenSSL::Timestamp::Factory.new
    fac.gen_time = Time.now
    fac.serial_number = 1
    fac.allowed_digests = ["sha256", "sha384", "sha512"]
    #needed because the Request contained no policy identifier
    fac.default_policy_id = '1.2.3.4.5'
    fac.additional_certificates = [ inter1, inter2 ]
    timestamp = fac.create_timestamp(p12.key, p12.certificate, req)

## Attributes

### default_policy_id

Request#policy_id will always be preferred over this if present in the
Request, only if Request#policy_id is nil default_policy will be used. If none
of both is present, a TimestampError will be raised when trying to create a
Response.

call-seq:
    factory.default_policy_id = "string" -> string
    factory.default_policy_id            -> string or nil

### serial_number

Sets or retrieves the serial number to be used for timestamp creation. Must be
present for timestamp creation.

call-seq:
    factory.serial_number = number -> number
    factory.serial_number          -> number or nil

### gen_time

Sets or retrieves the Time value to be used in the Response. Must be present
for timestamp creation.

call-seq:
    factory.gen_time = Time -> Time
    factory.gen_time        -> Time or nil

### additional_certs

Sets or retrieves additional certificates apart from the timestamp certificate
(e.g. intermediate certificates) to be added to the Response. Must be an Array
of OpenSSL::X509::Certificate.

call-seq:
    factory.additional_certs = [cert1, cert2] -> [ cert1, cert2 ]
    factory.additional_certs                  -> array or nil

### allowed_digests

Sets or retrieves the digest algorithms that the factory is allowed create
timestamps for. Known vulnerable or weak algorithms should not be allowed
where possible. Must be an Array of String or OpenSSL::Digest subclass
instances.

call-seq:
    factory.allowed_digests = ["sha1", OpenSSL::Digest.new('SHA256').new] -> [ "sha1", OpenSSL::Digest) ]
    factory.allowed_digests                                               -> array or nil

;T;0;	I" OpenSSL::Timestamp::Factory;T;
[ ;[ ;0;[ ;[ ;0;0o;;0;0;;;I"additional_certs;F;I" OpenSSL::Timestamp::Factory;T;[o;;I" ;F;I")Array[::OpenSSL::X509::Certificate]?;To;;0;0;;;I"additional_certs=;F;I" OpenSSL::Timestamp::Factory;T;[o;;I"1::Array[::OpenSSL::X509::Certificate]? certs;T;I")Array[::OpenSSL::X509::Certificate]?;To;;0;0;;;I"allowed_digests;F;I" OpenSSL::Timestamp::Factory;T;[o;;I" ;F;I")Array[::String | ::OpenSSL::Digest]?;To;;0;0;;;I"allowed_digests=;F;I" OpenSSL::Timestamp::Factory;T;[o;;I"*::Array[::String | ::OpenSSL::Digest];T;I"(Array[::String | ::OpenSSL::Digest];To;;I"/Creates a Response with the help of an OpenSSL::PKey, an
OpenSSL::X509::Certificate and a Request.

Mandatory parameters for timestamp creation that need to be set in the
Request:

*   Request#algorithm
*   Request#message_imprint


Mandatory parameters that need to be set in the Factory:
*   Factory#serial_number
*   Factory#gen_time
*   Factory#allowed_digests


In addition one of either Request#policy_id or Factory#default_policy_id must
be set.

Raises a TimestampError if creation fails, though successfully created error
responses may be returned.

;T;0;;;I"create_timestamp;F;I" OpenSSL::Timestamp::Factory;T;[o;;I"h::OpenSSL::PKey::PKey key, ::OpenSSL::X509::Certificate cert, ::OpenSSL::Timestamp::Request request;T;I"!OpenSSL::Timestamp::Response;To;;0;0;;;I"default_policy_id;F;I" OpenSSL::Timestamp::Factory;T;[o;;I" ;F;I"String?;To;;0;0;;;I"default_policy_id=;F;I" OpenSSL::Timestamp::Factory;T;[o;;I"::String;T;I"String;To;;0;0;;;I"gen_time;F;I" OpenSSL::Timestamp::Factory;T;[o;;I" ;F;I"
Time?;To;;0;0;;;I"gen_time=;F;I" OpenSSL::Timestamp::Factory;T;[o;;I"::Time;T;I"	Time;To;;0;0;;;I"serial_number;F;I" OpenSSL::Timestamp::Factory;T;[o;;I" ;F;I"Integer?;To;;0;0;;;I"serial_number=;F;I" OpenSSL::Timestamp::Factory;T;[o;;I"::Integer;T;I"Integer;To; ;I"GAllows to create timestamp requests or parse existing ones. A Request is also
needed for creating timestamps from scratch with Factory. When created from
scratch, some default values are set:
*   version is set to `1`
*   cert_requested is set to `true`
*   algorithm, message_imprint, policy_id, and nonce are set to `false`

;T;0;	I" OpenSSL::Timestamp::Request;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"…Returns the 'short name' of the object identifier that represents the
algorithm that was used to create the message imprint digest.

;T;0;;;I"algorithm;F;I" OpenSSL::Timestamp::Request;T;[o;;I" ;F;I"String;To;;I"¬Allows to set the object identifier  or the 'short name' of the algorithm that
was used to create the message imprint digest.

### Example:
    request.algorithm = "SHA1"

;T;0;;;I"algorithm=;F;I" OpenSSL::Timestamp::Request;T;[o;;I"::String;T;I"String;To;;I"|Specify whether the response shall contain the timestamp authority's
certificate or not. The default value is `true`.

;T;0;;;I"cert_requested=;F;I" OpenSSL::Timestamp::Request;T;[o;;I"::boolish;T;I"U;Fo;;I"aIndicates whether the response shall contain the timestamp authority's
certificate or not.

;T;0;;;I"cert_requested?;F;I" OpenSSL::Timestamp::Request;T;[o;;I" ;F;I"	bool;To;;I"JReturns the message imprint (digest) of the data to be timestamped.

;T;0;;;I"message_imprint;F;I" OpenSSL::Timestamp::Request;T;[o;;I" ;F;I"String?;To;;I"&Set the message imprint digest.

;T;0;;;I"message_imprint=;F;I" OpenSSL::Timestamp::Request;T;[o;;I"::String;T;I"String;To;;I"ZReturns the nonce (number used once) that the server shall include in its
response.

;T;0;;;I"
nonce;F;I" OpenSSL::Timestamp::Request;T;[o;;I" ;F;I"OpenSSL::BN?;To;;I"¨Sets the nonce (number used once) that the server shall include in its
response. If the nonce is set, the server must return the same nonce value in
a valid Response.

;T;0;;;I"nonce=;F;I" OpenSSL::Timestamp::Request;T;[o;;I"::OpenSSL::bn nonce;T;I"OpenSSL::BN;To;;I"‹Returns the 'short name' of the object identifier that represents the
timestamp policy under which the server shall create the timestamp.

;T;0;;;I"policy_id;F;I" OpenSSL::Timestamp::Request;T;[o;;I" ;F;I"String?;To;;I"Allows to set the object identifier that represents the timestamp policy under
which the server shall create the timestamp. This may be left `nil`, implying
that the timestamp server will issue the timestamp using some default policy.

### Example:
    request.policy_id = "1.2.3.4.5"

;T;0;;;I"policy_id=;F;I" OpenSSL::Timestamp::Request;T;[o;;I"::String policy_id;T;I"String;To;;I" DER-encodes this Request.

;T;0;;;I"to_der;F;I" OpenSSL::Timestamp::Request;T;[o;;I" ;F;I"String;To;;I"EReturns the version of this request. `1` is the default value.

;T;0;;;I"version;F;I" OpenSSL::Timestamp::Request;T;[o;;I" ;F;I"Integer;To;;I"ZSets the version number for this Request. This should be `1` for compliant
servers.

;T;0;;;I"version=;F;I" OpenSSL::Timestamp::Request;T;[o;;I"::Integer;T;I"Integer;To;;I"When creating a Request with the `File` or `string` parameter, the
corresponding `File` or `string` must be DER-encoded.

;T;0;;;I"initialize;F;I" OpenSSL::Timestamp::Request;T;[o;;I"#?::File | ::String request_der;T;I"	void;To; ;I"éImmutable and read-only representation of a timestamp response returned from a
timestamp server after receiving an associated Request. Allows access to
specific information about the response but also allows to verify the
Response.

;T;0;	I"!OpenSSL::Timestamp::Response;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"ˆIn cases no timestamp token has been created, this field contains further info
about the reason why response creation failed. The method returns either nil
(the request was successful and a timestamp token was created) or one of the
following:
*   :BAD_ALG - Indicates that the timestamp server rejects the message imprint
    algorithm used in the Request
*   :BAD_REQUEST - Indicates that the timestamp server was not able to process
    the Request properly
*   :BAD_DATA_FORMAT - Indicates that the timestamp server was not able to
    parse certain data in the Request
*   :TIME_NOT_AVAILABLE - Indicates that the server could not access its time
    source
*   :UNACCEPTED_POLICY - Indicates that the requested policy identifier is not
    recognized or supported by the timestamp server
*   :UNACCEPTED_EXTENSIION - Indicates that an extension in the Request is not
    supported by the timestamp server
*   :ADD_INFO_NOT_AVAILABLE -Indicates that additional information requested
    is either not understood or currently not available
*   :SYSTEM_FAILURE - Timestamp creation failed due to an internal error that
    occurred on the timestamp server

;T;0;;;I"failure_info;F;I"!OpenSSL::Timestamp::Response;T;[o;;I" ;F;I"Symbol?;To;;I"ÒReturns one of GRANTED, GRANTED_WITH_MODS, REJECTION, WAITING,
REVOCATION_WARNING or REVOCATION_NOTIFICATION. A timestamp token has been
created only in case `status` is equal to GRANTED or GRANTED_WITH_MODS.

;T;0;;;I"status;F;I"!OpenSSL::Timestamp::Response;T;[o;;I" ;F;I"OpenSSL::BN;To;;I"sIn cases of failure this field may contain an array of strings further
describing the origin of the failure.

;T;0;;;I"status_text;F;I"!OpenSSL::Timestamp::Response;T;[o;;I" ;F;I"Array[::String]?;To;;I"0Returns the Response in DER-encoded form.

;T;0;;;I"to_der;F;I"!OpenSSL::Timestamp::Response;T;[o;;I" ;F;I"String;To;;I"XIf a timestamp token is present, this returns it in the form of a
OpenSSL::PKCS7.

;T;0;;;I"
token;F;I"!OpenSSL::Timestamp::Response;T;[o;;I" ;F;I"OpenSSL::PKCS7?;To;;I"0Get the response's token info if present.

;T;0;;;I"token_info;F;I"!OpenSSL::Timestamp::Response;T;[o;;I" ;F;I"#OpenSSL::Timestamp::TokenInfo?;To;;I"ŸIf the Request specified to request the TSA certificate
(Request#cert_requested = true), then this field contains the certificate of
the timestamp authority.

;T;0;;;I"tsa_certificate;F;I"!OpenSSL::Timestamp::Response;T;[o;;I" ;F;I" OpenSSL::X509::Certificate?;To;;I"ÙVerifies a timestamp token by checking the signature, validating the
certificate chain implied by tsa_certificate and by checking conformance to a
given Request. Mandatory parameters are the Request associated to this
Response, and an OpenSSL::X509::Store of trusted roots.

Intermediate certificates can optionally be supplied for creating the
certificate chain. These intermediate certificates must all be instances of
OpenSSL::X509::Certificate.

If validation fails, several kinds of exceptions can be raised:
*   TypeError if types don't fit
*   TimestampError if something is wrong with the timestamp token itself, if
    it is not conformant to the Request, or if validation of the timestamp
    certificate chain fails.

;T;0;;;I"verify;F;I"!OpenSSL::Timestamp::Response;T;[o;;I"y::OpenSSL::Timestamp::Request request, ::OpenSSL::X509::Store store, ?::OpenSSL::X509::Certificate intermediate_cert;T;I"instance;To;;I"òCreates a Response from a `File` or `string` parameter, the corresponding
`File` or `string` must be DER-encoded. Please note that Response is an
immutable read-only class. If you'd like to create timestamps please refer to
Factory instead.

;T;0;;;I"initialize;F;I"!OpenSSL::Timestamp::Response;T;[o;;I"#::File | ::String response_der;T;I"	void;To; ;I"7Generic exception class of the Timestamp module.

;T;0;	I"'OpenSSL::Timestamp::TimestampError;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::OpenSSLError;To; ;I"XImmutable and read-only representation of a timestamp token info from a
Response.

;T;0;	I""OpenSSL::Timestamp::TokenInfo;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"kReturns the 'short name' of the object identifier representing the algorithm
that was used to derive the message imprint digest. For valid timestamps, this
is the same value that was already given in the Request. If status is GRANTED
or GRANTED_WITH_MODS, this is never `nil`.

### Example:
    algo = token_info.algorithm
    puts algo                -> "SHA1"

;T;0;;;I"algorithm;F;I""OpenSSL::Timestamp::TokenInfo;T;[o;;I" ;F;I"String?;To;;I"zReturns time when this timestamp token was created. If status is GRANTED or
GRANTED_WITH_MODS, this is never `nil`.

;T;0;;;I"gen_time;F;I""OpenSSL::Timestamp::TokenInfo;T;[o;;I" ;F;I"	Time;To;;I"Returns the message imprint digest. For valid timestamps, this is the same
value that was already given in the Request. If status is GRANTED or
GRANTED_WITH_MODS, this is never `nil`.

### Example:
    mi = token_info.msg_imprint
    puts mi                -> "DEADBEEF"

;T;0;;;I"message_imprint;F;I""OpenSSL::Timestamp::TokenInfo;T;[o;;I" ;F;I"String;To;;I"‰If the timestamp token is valid then this field contains the same nonce that
was passed to the timestamp server in the initial Request.

;T;0;;;I"
nonce;F;I""OpenSSL::Timestamp::TokenInfo;T;[o;;I" ;F;I"OpenSSL::BN?;To;;I"«If the ordering field is missing, or if the ordering field is present and set
to false, then the genTime field only indicates the time at which the
time-stamp token has been created by the TSA.  In such a case, the ordering of
time-stamp tokens issued by the same TSA or different TSAs is only possible
when the difference between the genTime of the first time-stamp token and the
genTime of the second time-stamp token is greater than the sum of the
accuracies of the genTime for each time-stamp token.

If the ordering field is present and set to true, every time-stamp token from
the same TSA can always be ordered based on the genTime field, regardless of
the genTime accuracy.

;T;0;;;I"ordering;F;I""OpenSSL::Timestamp::TokenInfo;T;[o;;I" ;F;I"
bool?;To;;I"÷Returns the timestamp policy object identifier of the policy this timestamp
was created under. If status is GRANTED or GRANTED_WITH_MODS, this is never
`nil`.

### Example:
    id = token_info.policy_id
    puts id                 -> "1.2.3.4.5"

;T;0;;;I"policy_id;F;I""OpenSSL::Timestamp::TokenInfo;T;[o;;I" ;F;I"String?;To;;I"ÖReturns serial number of the timestamp token. This value shall never be the
same for two timestamp tokens issued by a dedicated timestamp authority. If
status is GRANTED or GRANTED_WITH_MODS, this is never `nil`.

;T;0;;;I"serial_number;F;I""OpenSSL::Timestamp::TokenInfo;T;[o;;I" ;F;I"OpenSSL::BN?;To;;I"1Returns the TokenInfo in DER-encoded form.

;T;0;;;I"to_der;F;I""OpenSSL::Timestamp::TokenInfo;T;[o;;I" ;F;I"String;To;;I"—Returns the version number of the token info. With compliant servers, this
value should be `1` if present. If status is GRANTED or GRANTED_WITH_MODS.

;T;0;;;I"version;F;I""OpenSSL::Timestamp::TokenInfo;T;[o;;I" ;F;I"Integer;To;;I"ôCreates a TokenInfo from a `File` or `string` parameter, the corresponding
`File` or `string` must be DER-encoded. Please note that TokenInfo is an
immutable read-only class. If you'd like to create timestamps please refer to
Factory instead.

;T;0;;;I"initialize;F;I""OpenSSL::Timestamp::TokenInfo;T;[o;;I" ::File | ::String token_der;T;I"	void;To;;0;0;	I"OpenSSL::X509;T;
[ ;[ ;0;[ ;[ o; ;0;0;	I"OpenSSL::X509::Attribute;T;
[ ;[I"OpenSSL::Marshal;T;0;[ ;[ ;0;0o;;I" ;T;0;;;I"==;F;I"OpenSSL::X509::Attribute;T;[o;;I"instance other;T;I"	bool;To;;I" ;T;0;;;I"oid;F;I"OpenSSL::X509::Attribute;T;[o;;I" ;F;I"String;To;;I" ;T;0;;;I"	oid=;F;I"OpenSSL::X509::Attribute;T;[o;;I"::String;T;I"String;To;;I" ;T;0;;;I"to_der;F;I"OpenSSL::X509::Attribute;T;[o;;I" ;F;I"String;To;;I" ;T;0;;;I"
value;F;I"OpenSSL::X509::Attribute;T;[o;;I" ;F;I"OpenSSL::ASN1::Set;To;;I" ;T;0;;;I"value=;F;I"OpenSSL::X509::Attribute;T;[o;;I"::OpenSSL::ASN1::ASN1Data;T;I"OpenSSL::ASN1::Set;To;;I" ;T;0;;;I"initialize;F;I"OpenSSL::X509::Attribute;T;[o;;I"::String der;T;I"	void;To;;I"2::String oid, ::OpenSSL::ASN1::ASN1Data value;T;I"	void;To;;I" ;T;0;;;I"initialize_copy;F;I"OpenSSL::X509::Attribute;T;[o;;I"instance;T;I"	void;To; ;0;0;	I""OpenSSL::X509::AttributeError;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::OpenSSLError;To; ;0;0;	I"OpenSSL::X509::CRL;T;
[ ;[I"5OpenSSL::X509::Extension::AuthorityKeyIdentifier;TI"OpenSSL::Marshal;T;0;[ ;[ ;0;0o;;I" ;T;0;;;I"==;F;I"OpenSSL::X509::CRL;T;[o;;I"instance other;T;I"	bool;To;;I" ;T;0;;;I"add_extension;F;I"OpenSSL::X509::CRL;T;[o;;I"#::OpenSSL::X509::Extension ext;T;I"OpenSSL::X509::Extension;To;;I" ;T;0;;;I"add_revoked;F;I"OpenSSL::X509::CRL;T;[o;;I"%::OpenSSL::X509::Revoked revoked;T;I"OpenSSL::X509::Revoked;To;;I"9Gets X509v3 extensions as array of X509Ext objects

;T;0;;;I"extensions;F;I"OpenSSL::X509::CRL;T;[o;;I" ;F;I"&Array[::OpenSSL::X509::Extension];To;;I"Sets X509_EXTENSIONs

;T;0;;;I"extensions=;F;I"OpenSSL::X509::CRL;T;[o;;I"3::Array[::OpenSSL::X509::Extension] extensions;T;I"&Array[::OpenSSL::X509::Extension];To;;I" ;T;0;;;I"issuer;F;I"OpenSSL::X509::CRL;T;[o;;I" ;F;I"OpenSSL::X509::Name;To;;I" ;T;0;;;I"issuer=;F;I"OpenSSL::X509::CRL;T;[o;;I"!::OpenSSL::X509::Name issuer;T;I"OpenSSL::X509::Name;To;;I" ;T;0;;;I"last_update;F;I"OpenSSL::X509::CRL;T;[o;;I" ;F;I"
Time?;To;;I" ;T;0;;;I"last_update=;F;I"OpenSSL::X509::CRL;T;[o;;I"::Time last_update;T;I"	Time;To;;I" ;T;0;;;I"next_update;F;I"OpenSSL::X509::CRL;T;[o;;I" ;F;I"
Time?;To;;I" ;T;0;;;I"next_update=;F;I"OpenSSL::X509::CRL;T;[o;;I"::Time next_update;T;I"	Time;To;;I" ;T;0;;;I"revoked;F;I"OpenSSL::X509::CRL;T;[o;;I" ;F;I"$Array[::OpenSSL::X509::Revoked];To;;I" ;T;0;;;I"revoked=;F;I"OpenSSL::X509::CRL;T;[o;;I"&::Array[::OpenSSL::X509::Revoked];T;I"$Array[::OpenSSL::X509::Revoked];To;;I" ;T;0;;;I"	sign;F;I"OpenSSL::X509::CRL;T;[o;;I"8::OpenSSL::PKey::PKey key, ::OpenSSL::Digest digest;T;I"String;To;;I" ;T;0;;;I"signature_algorithm;F;I"OpenSSL::X509::CRL;T;[o;;I" ;F;I"String;To;;I" ;T;0;;;I"to_der;F;I"OpenSSL::X509::CRL;T;[o;;I" ;F;I"String;To;;I" ;T;0;;;I"to_pem;F;I"OpenSSL::X509::CRL;T;[o;;I" ;F;I"String;To;;I" ;T;0;;;I"to_text;F;I"OpenSSL::X509::CRL;T;[o;;I" ;F;I"String;To;;I" ;T;0;;;I"verify;F;I"OpenSSL::X509::CRL;T;[o;;I"::OpenSSL::PKey::PKey key;T;I"	bool;To;;I" ;T;0;;;I"version;F;I"OpenSSL::X509::CRL;T;[o;;I" ;F;I"Integer;To;;I" ;T;0;;;I"version=;F;I"OpenSSL::X509::CRL;T;[o;;I"::Integer;T;I"Integer;To;;I" ;T;0;;;I"initialize;F;I"OpenSSL::X509::CRL;T;[o;;I"?::String der;T;I"	void;To;;I" ;T;0;;;I"initialize_copy;F;I"OpenSSL::X509::CRL;T;[o;;I"instance;T;I"	void;To; ;0;0;	I"OpenSSL::X509::CRLError;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::OpenSSLError;To; ;I"°Implementation of an X.509 certificate as specified in RFC 5280. Provides
access to a certificate's attributes and allows certificates to be read from a
string, but also supports the creation of new certificates from scratch.

### Reading a certificate from a file

Certificate is capable of handling DER-encoded certificates and certificates
encoded in OpenSSL's PEM format.

    raw = File.binread "cert.cer" # DER- or PEM-encoded
    certificate = OpenSSL::X509::Certificate.new raw

### Saving a certificate to a file

A certificate may be encoded in DER format

    cert = ...
    File.open("cert.cer", "wb") { |f| f.print cert.to_der }

or in PEM format

    cert = ...
    File.open("cert.pem", "wb") { |f| f.print cert.to_pem }

X.509 certificates are associated with a private/public key pair, typically a
RSA, DSA or ECC key (see also OpenSSL::PKey::RSA, OpenSSL::PKey::DSA and
OpenSSL::PKey::EC), the public key itself is stored within the certificate and
can be accessed in form of an OpenSSL::PKey. Certificates are typically used
to be able to associate some form of identity with a key pair, for example web
servers serving pages over HTTPs use certificates to authenticate themselves
to the user.

The public key infrastructure (PKI) model relies on trusted certificate
authorities ("root CAs") that issue these certificates, so that end users need
to base their trust just on a selected few authorities that themselves again
vouch for subordinate CAs issuing their certificates to end users.

The OpenSSL::X509 module provides the tools to set up an independent PKI,
similar to scenarios where the 'openssl' command line tool is used for issuing
certificates in a private PKI.

### Creating a root CA certificate and an end-entity certificate

First, we need to create a "self-signed" root certificate. To do so, we need
to generate a key first. Please note that the choice of "1" as a serial number
is considered a security flaw for real certificates. Secure choices are
integers in the two-digit byte range and ideally not sequential but secure
random numbers, steps omitted here to keep the example concise.

    root_key = OpenSSL::PKey::RSA.new 2048 # the CA's public/private key
    root_ca = OpenSSL::X509::Certificate.new
    root_ca.version = 2 # cf. RFC 5280 - to make it a "v3" certificate
    root_ca.serial = 1
    root_ca.subject = OpenSSL::X509::Name.parse "/DC=org/DC=ruby-lang/CN=Ruby CA"
    root_ca.issuer = root_ca.subject # root CA's are "self-signed"
    root_ca.public_key = root_key.public_key
    root_ca.not_before = Time.now
    root_ca.not_after = root_ca.not_before + 2 * 365 * 24 * 60 * 60 # 2 years validity
    ef = OpenSSL::X509::ExtensionFactory.new
    ef.subject_certificate = root_ca
    ef.issuer_certificate = root_ca
    root_ca.add_extension(ef.create_extension("basicConstraints","CA:TRUE",true))
    root_ca.add_extension(ef.create_extension("keyUsage","keyCertSign, cRLSign", true))
    root_ca.add_extension(ef.create_extension("subjectKeyIdentifier","hash",false))
    root_ca.add_extension(ef.create_extension("authorityKeyIdentifier","keyid:always",false))
    root_ca.sign(root_key, OpenSSL::Digest.new('SHA256'))

The next step is to create the end-entity certificate using the root CA
certificate.

    key = OpenSSL::PKey::RSA.new 2048
    cert = OpenSSL::X509::Certificate.new
    cert.version = 2
    cert.serial = 2
    cert.subject = OpenSSL::X509::Name.parse "/DC=org/DC=ruby-lang/CN=Ruby certificate"
    cert.issuer = root_ca.subject # root CA is the issuer
    cert.public_key = key.public_key
    cert.not_before = Time.now
    cert.not_after = cert.not_before + 1 * 365 * 24 * 60 * 60 # 1 years validity
    ef = OpenSSL::X509::ExtensionFactory.new
    ef.subject_certificate = cert
    ef.issuer_certificate = root_ca
    cert.add_extension(ef.create_extension("keyUsage","digitalSignature", true))
    cert.add_extension(ef.create_extension("subjectKeyIdentifier","hash",false))
    cert.sign(root_key, OpenSSL::Digest.new('SHA256'))

;T;0;	I"OpenSSL::X509::Certificate;T;
[ ;[
I"2OpenSSL::X509::Extension::AuthorityInfoAccess;TI"4OpenSSL::X509::Extension::CRLDistributionPoints;TI"5OpenSSL::X509::Extension::AuthorityKeyIdentifier;TI"3OpenSSL::X509::Extension::SubjectKeyIdentifier;TI"OpenSSL::Marshal;T;0;[ ;[ ;0;0o;;I"~Compares the two certificates. Note that this takes into account all fields,
not just the issuer name and the serial number.

;T;0;;;I"==;F;I"OpenSSL::X509::Certificate;T;[o;;I"instance other;T;I"	bool;To;;I" ;T;0;;;I"add_extension;F;I"OpenSSL::X509::Certificate;T;[o;;I"#::OpenSSL::X509::Extension ext;T;I"OpenSSL::X509::Extension;To;;I"yReturns `true` if *key* is the corresponding private key to the Subject Public
Key Information, `false` otherwise.

;T;0;;;I"check_private_key;F;I"OpenSSL::X509::Certificate;T;[o;;I"::OpenSSL::PKey::PKey key;T;I"	bool;To;;I" ;T;0;;;I"extensions;F;I"OpenSSL::X509::Certificate;T;[o;;I" ;F;I"&Array[::OpenSSL::X509::Extension];To;;I" ;T;0;;;I"extensions=;F;I"OpenSSL::X509::Certificate;T;[o;;I"(::Array[::OpenSSL::X509::Extension];T;I"&Array[::OpenSSL::X509::Extension];To;;I" ;T;0;;;I"inspect;F;I"OpenSSL::X509::Certificate;T;[o;;I" ;F;I"String;To;;I" ;T;0;;;I"issuer;F;I"OpenSSL::X509::Certificate;T;[o;;I" ;F;I"OpenSSL::X509::Name;To;;I" ;T;0;;;I"issuer=;F;I"OpenSSL::X509::Certificate;T;[o;;I"::OpenSSL::X509::Name;T;I"OpenSSL::X509::Name;To;;I" ;T;0;;;I"not_after;F;I"OpenSSL::X509::Certificate;T;[o;;I" ;F;I"
Time?;To;;I" ;T;0;;;I"not_after=;F;I"OpenSSL::X509::Certificate;T;[o;;I"::Time;T;I"	Time;To;;I" ;T;0;;;I"not_before;F;I"OpenSSL::X509::Certificate;T;[o;;I" ;F;I"
Time?;To;;I" ;T;0;;;I"not_before=;F;I"OpenSSL::X509::Certificate;T;[o;;I"::Time;T;I"	Time;To;;I" ;T;0;;;I"pretty_print;F;I"OpenSSL::X509::Certificate;T;[o;;I"untyped q;T;I"untyped;To;;I" ;T;0;;;I"public_key;F;I"OpenSSL::X509::Certificate;T;[o;;I" ;F;I"OpenSSL::PKey::PKey;To;;I" ;T;0;;;I"public_key=;F;I"OpenSSL::X509::Certificate;T;[o;;I"::OpenSSL::PKey::PKey pkey;T;I"OpenSSL::PKey::PKey;To;;I" ;T;0;;;I"serial;F;I"OpenSSL::X509::Certificate;T;[o;;I" ;F;I"OpenSSL::BN;To;;I" ;T;0;;;I"serial=;F;I"OpenSSL::X509::Certificate;T;[o;;I"::OpenSSL::bn serial;T;I"OpenSSL::bn;To;;I" ;T;0;;;I"	sign;F;I"OpenSSL::X509::Certificate;T;[o;;I"/::OpenSSL::PKey::PKey key, ::String digest;T;I"String;To;;I" ;T;0;;;I"signature_algorithm;F;I"OpenSSL::X509::Certificate;T;[o;;I" ;F;I"String;To;;I" ;T;0;;;I"subject;F;I"OpenSSL::X509::Certificate;T;[o;;I" ;F;I"OpenSSL::X509::Name;To;;I" ;T;0;;;I"subject=;F;I"OpenSSL::X509::Certificate;T;[o;;I"::OpenSSL::X509::Name;T;I"OpenSSL::X509::Name;To;;I" ;T;0;;;I"to_der;F;I"OpenSSL::X509::Certificate;T;[o;;I" ;F;I"String;To;;I" ;T;0;;;I"to_pem;F;I"OpenSSL::X509::Certificate;T;[o;;I" ;F;I"String;To;;I" ;T;0;;;I"to_text;F;I"OpenSSL::X509::Certificate;T;[o;;I" ;F;I"String;To;;I"xVerifies the signature of the certificate, with the public key *key*. *key*
must be an instance of OpenSSL::PKey.

;T;0;;;I"verify;F;I"OpenSSL::X509::Certificate;T;[o;;I"::OpenSSL::PKey::PKey key;T;I"	bool;To;;I" ;T;0;;;I"version;F;I"OpenSSL::X509::Certificate;T;[o;;I" ;F;I"Integer;To;;I" ;T;0;;;I"version=;F;I"OpenSSL::X509::Certificate;T;[o;;I"::Integer;T;I"Integer;To;;I" ;T;0;;;I"initialize;F;I"OpenSSL::X509::Certificate;T;[o;;I"?::String pem;T;I"	void;To;;I" ;T;0;;;I"initialize_copy;F;I"OpenSSL::X509::Certificate;T;[o;;I"instance;T;I"	void;To; ;0;0;	I"$OpenSSL::X509::CertificateError;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::OpenSSLError;To; ;0;0;	I"OpenSSL::X509::Extension;T;
[ ;[I"OpenSSL::Marshal;T;0;[ ;[ ;0;0o;;I" ;T;0;;;I"==;F;I"OpenSSL::X509::Extension;T;[o;;I"instance other;T;I"	bool;To;;I" ;T;0;;;I"critical=;F;I"OpenSSL::X509::Extension;T;[o;;I"::boolish;T;I"U;Fo;;I" ;T;0;;;I"critical?;F;I"OpenSSL::X509::Extension;T;[o;;I" ;F;I"	bool;To;;I" ;T;0;;;I"oid;F;I"OpenSSL::X509::Extension;T;[o;;I" ;F;I"String;To;;I" ;T;0;;;I"	oid=;F;I"OpenSSL::X509::Extension;T;[o;;I"::String oid;T;I"String;To;;I" ;T;0;;;I"	to_a;F;I"OpenSSL::X509::Extension;T;[o;;I" ;F;I"![ ::String, ::String, bool ];To;;I" ;T;0;;;I"to_der;F;I"OpenSSL::X509::Extension;T;[o;;I" ;F;I"String;To;;I" ;T;0;;;I"	to_h;F;I"OpenSSL::X509::Extension;T;[o;;I" ;F;I"Hash[::String, untyped];To;;I" ;T;0;;;I"	to_s;F;I"OpenSSL::X509::Extension;T;[o;;I" ;F;I"String;To;;I" ;T;0;;;I"
value;F;I"OpenSSL::X509::Extension;T;[o;;I" ;F;I"String;To;;I" ;T;0;;;I"value=;F;I"OpenSSL::X509::Extension;T;[o;;I",::String | ::OpenSSL::ASN1::_ToDer data;T;I"String;To;;I" ;T;0;;;I"value_der;F;I"OpenSSL::X509::Extension;T;[o;;I" ;F;I"String;To;;I"ãCreates an X509 extension.

The extension may be created from *der* data or from an extension *oid* and
*value*.  The *oid* may be either an OID or an extension name.  If *critical*
is `true` the extension is marked critical.

;T;0;;;I"initialize;F;I"OpenSSL::X509::Extension;T;[o;;I"::String der;T;I"	void;To;;I"6::String oid, ::String value, ?::boolish critical;T;I"	void;To;;I" ;T;0;;;I"initialize_copy;F;I"OpenSSL::X509::Extension;T;[o;;I"instance;T;I"	void;To;;0;0;	I"2OpenSSL::X509::Extension::AuthorityInfoAccess;T;
[ ;[ ;0;[ ;[ o;;I"ãGet the information and services for the issuer from the certificate's
authority information access extension exteension, as described in RFC5280
Section 4.2.2.1.

Returns an array of strings or nil or raises ASN1::ASN1Error.

;T;0;;;I"ca_issuer_uris;F;I"2OpenSSL::X509::Extension::AuthorityInfoAccess;T;[o;;I" ;F;I"Array[::String]?;To;;I"ÉGet the URIs for OCSP from the certificate's authority information access
extension exteension, as described in RFC5280 Section 4.2.2.1.

Returns an array of strings or nil or raises ASN1::ASN1Error.

;T;0;;;I"ocsp_uris;F;I"2OpenSSL::X509::Extension::AuthorityInfoAccess;T;[o;;I" ;F;I"Array[::String]?;To;;I" ;T;0;;;I"parse_aia_asn1;F;I"2OpenSSL::X509::Extension::AuthorityInfoAccess;T;[o;;I" ;F;I"untyped;To;;0;0;	I"5OpenSSL::X509::Extension::AuthorityKeyIdentifier;T;
[ ;[ ;0;[ ;[ o;;I"ÌGet the issuing certificate's key identifier from the authorityKeyIdentifier
extension, as described in RFC5280 Section 4.2.1.1

Returns the binary String keyIdentifier or nil or raises ASN1::ASN1Error.

;T;0;;;I"authority_key_identifier;F;I"5OpenSSL::X509::Extension::AuthorityKeyIdentifier;T;[o;;I" ;F;I"String?;To;;0;0;	I"4OpenSSL::X509::Extension::CRLDistributionPoints;T;
[ ;[ ;0;[ ;[ o;;I"ÊGet the distributionPoint fullName URI from the certificate's CRL distribution
points extension, as described in RFC5280 Section 4.2.1.13

Returns an array of strings or nil or raises ASN1::ASN1Error.

;T;0;;;I"crl_uris;F;I"4OpenSSL::X509::Extension::CRLDistributionPoints;T;[o;;I" ;F;I"Array[::String]?;To;;0;0;	I"&OpenSSL::X509::Extension::Helpers;T;
[ ;[ ;0;[ ;[ o;;I" ;T;0;;;I"find_extension;F;I"&OpenSSL::X509::Extension::Helpers;T;[o;;I"::String oid;T;I"OpenSSL::X509::Extension?;To;;0;0;	I"3OpenSSL::X509::Extension::SubjectKeyIdentifier;T;
[ ;[ ;0;[ ;[ o;;I"ÁGet the subject's key identifier from the subjectKeyIdentifier exteension, as
described in RFC5280 Section 4.2.1.2.

Returns the binary String key identifier or nil or raises ASN1::ASN1Error.

;T;0;;;I"subject_key_identifier;F;I"3OpenSSL::X509::Extension::SubjectKeyIdentifier;T;[o;;I" ;F;I"String?;To; ;0;0;	I""OpenSSL::X509::ExtensionError;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::OpenSSLError;To; ;0;0;	I"$OpenSSL::X509::ExtensionFactory;T;
[ ;[ ;0;[ ;[ ;0;0o;;0;0;;;I"config;F;I"$OpenSSL::X509::ExtensionFactory;T;[o;;I" ;F;I"OpenSSL::Config?;To;;0;0;;;I"config=;F;I"$OpenSSL::X509::ExtensionFactory;T;[o;;I"::OpenSSL::Config config;T;I"OpenSSL::Config;To;;I"SCreates a new X509::Extension with passed values. See also x509v3_config(5).

;T;0;;;I"create_ext;F;I"$OpenSSL::X509::ExtensionFactory;T;[o;;I"6::String oid, ::String value, ?::boolish critical;T;I"OpenSSL::X509::Extension;To;;I" ;T;0;;;I"create_ext_from_array;F;I"$OpenSSL::X509::ExtensionFactory;T;[o;;I"C[ ::String, ::String ] | [ ::String, ::String, ::boolish ] ary;T;I"OpenSSL::X509::Extension;To;;I" ;T;0;;;I"create_ext_from_hash;F;I"$OpenSSL::X509::ExtensionFactory;T;[o;;I"0::Hash[::String, ::String | ::boolish] hash;T;I"OpenSSL::X509::Extension;To;;I" ;T;0;;;I"create_ext_from_string;F;I"$OpenSSL::X509::ExtensionFactory;T;[o;;I"::String str;T;I"OpenSSL::X509::Extension;To;;I" ;T;0;;;I"create_extension;F;I"$OpenSSL::X509::ExtensionFactory;T;[o;;I"6::String oid, ::String value, ?::boolish critical;T;I"OpenSSL::X509::Extension;To;;0;0;;;I"crl;F;I"$OpenSSL::X509::ExtensionFactory;T;[o;;I" ;F;I"OpenSSL::X509::CRL?;To;;I" ;T;0;;;I"	crl=;F;I"$OpenSSL::X509::ExtensionFactory;T;[o;;I"::OpenSSL::X509::CRL crl;T;I"OpenSSL::X509::CRL;To;;0;0;;;I"issuer_certificate;F;I"$OpenSSL::X509::ExtensionFactory;T;[o;;I" ;F;I" OpenSSL::X509::Certificate?;To;;I" ;T;0;;;I"issuer_certificate=;F;I"$OpenSSL::X509::ExtensionFactory;T;[o;;I"&::OpenSSL::X509::Certificate cert;T;I"OpenSSL::X509::Certificate;To;;0;0;;;I"subject_certificate;F;I"$OpenSSL::X509::ExtensionFactory;T;[o;;I" ;F;I" OpenSSL::X509::Certificate?;To;;I" ;T;0;;;I"subject_certificate=;F;I"$OpenSSL::X509::ExtensionFactory;T;[o;;I"&::OpenSSL::X509::Certificate cert;T;I"OpenSSL::X509::Certificate;To;;0;0;;;I"subject_request;F;I"$OpenSSL::X509::ExtensionFactory;T;[o;;I" ;F;I"OpenSSL::X509::Request?;To;;I" ;T;0;;;I"subject_request=;F;I"$OpenSSL::X509::ExtensionFactory;T;[o;;I"%::OpenSSL::X509::Request request;T;I"OpenSSL::X509::Request;To;;I" ;T;0;;;I"initialize;F;I"$OpenSSL::X509::ExtensionFactory;T;[o;;I"—?::OpenSSL::X509::Certificate? issuer_cert, ?::OpenSSL::X509::Certificate? subject_cert, ?::OpenSSL::X509::Request? request, ?::OpenSSL::X509::CRL? crl;T;I"	void;To; ;I"cAn X.509 name represents a hostname, email address or other entity associated
with a public key.

You can create a Name by parsing a distinguished name String or by supplying
the distinguished name as an Array.

    name = OpenSSL::X509::Name.parse_rfc2253 'DC=example,CN=nobody'

    name = OpenSSL::X509::Name.new [['CN', 'nobody'], ['DC', 'example']]

;T;0;	I"OpenSSL::X509::Name;T;
[ ;[I"OpenSSL::Marshal;TI"Comparable;T;0;[ ;[ ;0;0o;;I"EParses the string representation of a distinguished name. Two different forms
are supported:

*   OpenSSL format (`X509_NAME_oneline()`) used by `#to_s`. For example:
    `/DC=com/DC=example/CN=nobody`
*   OpenSSL format (`X509_NAME_print()`) used by
    `#to_s(OpenSSL::X509::Name::COMPAT)`. For example: `DC=com, DC=example,
    CN=nobody`


Neither of them is standardized and has quirks and inconsistencies in handling
of escaped characters or multi-valued RDNs.

Use of this method is discouraged in new applications. See Name.parse_rfc2253
and #to_utf8 for the alternative.

;T;0;;;I"parse_openssl;F;I"OpenSSL::X509::Name;T;[o;;I"<::String str, ?::OpenSSL::X509::Name::template template;T;I"instance;To;;I"‡Parses the UTF-8 string representation of a distinguished name, according to
RFC 2253.

See also #to_utf8 for the opposite operation.

;T;0;;;I"parse_rfc2253;F;I"OpenSSL::X509::Name;T;[o;;I"<::String str, ?::OpenSSL::X509::Name::template template;T;I"instance;To;;I"Adds a new entry with the given *oid* and *value* to this name.  The *oid* is
an object identifier defined in ASN.1.  Some common OIDs are:

C
:   Country Name
CN
:   Common Name
DC
:   Domain Component
O
:   Organization Name
OU
:   Organizational Unit Name
ST
:   State or Province Name


The optional keyword parameters *loc* and *set* specify where to insert the
new attribute. Refer to the manpage of X509_NAME_add_entry(3) for details.
*loc* defaults to -1 and *set* defaults to 0. This appends a single-valued RDN
to the end.

;T;0;;;I"add_entry;F;I"OpenSSL::X509::Name;T;[o;;I"C::String oid, ::String value, ?loc: ::Integer, ?set: ::Integer;T;I"	self;To;;I"ÒCompares this Name with *other* and returns `0` if they are the same and `-1`
or `+1` if they are greater or less than each other respectively. Returns
`nil` if they are not comparable (i.e. different types).

;T;0;;;I"cmp;F;I"OpenSSL::X509::Name;T;[o;;I"untyped other;T;I"Integer?;To;;I"EReturns true if *name* and *other* refer to the same hash key.

;T;0;;;I"	eql?;F;I"OpenSSL::X509::Name;T;[o;;I"instance other;T;I"	bool;To;;I"\The hash value returned is suitable for use as a certificate's filename in a
CA path.

;T;0;;;I"	hash;F;I"OpenSSL::X509::Name;T;[o;;I" ;F;I"Integer;To;;I"7Returns an MD5 based hash used in OpenSSL 0.9.X.

;T;0;;;I"hash_old;F;I"OpenSSL::X509::Name;T;[o;;I" ;F;I"Integer;To;;0;0;;;I"inspect;F;I"OpenSSL::X509::Name;T;[o;;I" ;F;I"String;To;;I" ;T;0;;;I"pretty_print;F;I"OpenSSL::X509::Name;T;[o;;I"untyped q;T;I"untyped;To;;I"^Returns an Array representation of the distinguished name suitable for passing
to ::new

;T;0;;;I"	to_a;F;I"OpenSSL::X509::Name;T;[o;;I" ;F;I"-Array[[ ::String, ::String, ::Integer ]];To;;I"(Converts the name to DER encoding

;T;0;;;I"to_der;F;I"OpenSSL::X509::Name;T;[o;;I" ;F;I"String;To;;I"ŽReturns a String representation of the Distinguished Name. *format* is one of:

*   OpenSSL::X509::Name::COMPAT
*   OpenSSL::X509::Name::RFC2253
*   OpenSSL::X509::Name::ONELINE
*   OpenSSL::X509::Name::MULTILINE


If *format* is omitted, the largely broken and traditional OpenSSL format
(`X509_NAME_oneline()` format) is chosen.

**Use of this method is discouraged.** None of the formats other than
OpenSSL::X509::Name::RFC2253 is standardized and may show an inconsistent
behavior through OpenSSL versions.

It is recommended to use #to_utf8 instead, which is equivalent to calling
`name.to_s(OpenSSL::X509::Name::RFC2253).force_encoding("UTF-8")`.

;T;0;;;I"	to_s;F;I"OpenSSL::X509::Name;T;[o;;I"*?::OpenSSL::X509::Name::format format;T;I"String;To;;I"~Returns an UTF-8 representation of the distinguished name, as specified in
[RFC 2253](https://www.ietf.org/rfc/rfc2253.txt).

;T;0;;;I"to_utf8;F;I"OpenSSL::X509::Name;T;[o;;I" ;F;I"String;To;;I"uCreates a new Name.

A name may be created from a DER encoded string *der*, an Array representing a
*distinguished_name* or a *distinguished_name* along with a *template*.

    name = OpenSSL::X509::Name.new [['CN', 'nobody'], ['DC', 'example']]

    name = OpenSSL::X509::Name.new name.to_der

See add_entry for a description of the *distinguished_name* Array's contents

;T;0;;;I"initialize;F;I"OpenSSL::X509::Name;T;[o;;I"]::OpenSSL::X509::Name::distinguished_name name, ::OpenSSL::X509::Name::template template;T;I"	void;To;;I"=::Array[::OpenSSL::X509::Name::distinguished_name] names;T;I"	void;To;;I"?::String der;T;I"	void;To;;I" ;T;0;;;I"initialize_copy;F;I"OpenSSL::X509::Name;T;[o;;I"instance;T;I"	void;To;;0;0;	I"#OpenSSL::X509::Name::RFC2253DN;T;
[ ;[ ;0;[ ;[ o;;0;0;;;I"expand_hexstring;F;I"#OpenSSL::X509::Name::RFC2253DN;T;[o;;I"untyped str;T;I"untyped;To;;0;0;;;I"expand_pair;F;I"#OpenSSL::X509::Name::RFC2253DN;T;[o;;I"untyped str;T;I"untyped;To;;0;0;;;I"expand_value;F;I"#OpenSSL::X509::Name::RFC2253DN;T;[o;;I"-untyped str1, untyped str2, untyped str3;T;I"untyped;To;;0;0;;;I"	scan;F;I"#OpenSSL::X509::Name::RFC2253DN;T;[o;;I"untyped dn;T;I"untyped;To;;I" ;T;0;;;I"expand_hexstring;F;I"#OpenSSL::X509::Name::RFC2253DN;T;[o;;I"untyped str;T;I"untyped;To;;I" ;T;0;;;I"expand_pair;F;I"#OpenSSL::X509::Name::RFC2253DN;T;[o;;I"untyped str;T;I"untyped;To;;I" ;T;0;;;I"expand_value;F;I"#OpenSSL::X509::Name::RFC2253DN;T;[o;;I"-untyped str1, untyped str2, untyped str3;T;I"untyped;To;;I" ;T;0;;;I"	scan;F;I"#OpenSSL::X509::Name::RFC2253DN;T;[o;;I"::String dn;T;I"5Array[::OpenSSL::X509::Name::distinguished_name];To; ;0;0;	I"OpenSSL::X509::NameError;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::OpenSSLError;To; ;0;0;	I"OpenSSL::X509::Request;T;
[ ;[I"OpenSSL::Marshal;T;0;[ ;[ ;0;0o;;I" ;T;0;;;I"==;F;I"OpenSSL::X509::Request;T;[o;;I"untyped other;T;I"	bool;To;;I" ;T;0;;;I"add_attribute;F;I"OpenSSL::X509::Request;T;[o;;I")::OpenSSL::X509::Attribute attribute;T;I"OpenSSL::X509::Attribute;To;;I" ;T;0;;;I"attributes;F;I"OpenSSL::X509::Request;T;[o;;I" ;F;I"&Array[::OpenSSL::X509::Attribute];To;;I" ;T;0;;;I"attributes=;F;I"OpenSSL::X509::Request;T;[o;;I"3::Array[::OpenSSL::X509::Attribute] attributes;T;I"&Array[::OpenSSL::X509::Attribute];To;;I" ;T;0;;;I"public_key;F;I"OpenSSL::X509::Request;T;[o;;I" ;F;I"OpenSSL::PKey::PKey;To;;I" ;T;0;;;I"public_key=;F;I"OpenSSL::X509::Request;T;[o;;I"%::OpenSSL::PKey::PKey public_key;T;I"OpenSSL::PKey::PKey;To;;I" ;T;0;;;I"	sign;F;I"OpenSSL::X509::Request;T;[o;;I"C::OpenSSL::PKey::PKey key, ::OpenSSL::Digest | ::String digest;T;I"String;To;;I" ;T;0;;;I"signature_algorithm;F;I"OpenSSL::X509::Request;T;[o;;I" ;F;I"String;To;;I" ;T;0;;;I"subject;F;I"OpenSSL::X509::Request;T;[o;;I" ;F;I"OpenSSL::X509::Name;To;;I" ;T;0;;;I"subject=;F;I"OpenSSL::X509::Request;T;[o;;I""::OpenSSL::X509::Name subject;T;I"OpenSSL::X509::Name;To;;I" ;T;0;;;I"to_der;F;I"OpenSSL::X509::Request;T;[o;;I" ;F;I"String;To;;I" ;T;0;;;I"to_pem;F;I"OpenSSL::X509::Request;T;[o;;I" ;F;I"String;To;;I" ;T;0;;;I"to_text;F;I"OpenSSL::X509::Request;T;[o;;I" ;F;I"String;To;;I"OChecks that cert signature is made with PRIVversion of this PUBLIC 'key'

;T;0;;;I"verify;F;I"OpenSSL::X509::Request;T;[o;;I"::OpenSSL::PKey::PKey key;T;I"	bool;To;;I" ;T;0;;;I"version;F;I"OpenSSL::X509::Request;T;[o;;I" ;F;I"Integer;To;;I" ;T;0;;;I"version=;F;I"OpenSSL::X509::Request;T;[o;;I"::Integer version;T;I"Integer;To;;I" ;T;0;;;I"initialize;F;I"OpenSSL::X509::Request;T;[o;;I"?::String der;T;I"	void;To;;I" ;T;0;;;I"initialize_copy;F;I"OpenSSL::X509::Request;T;[o;;I"instance;T;I"	void;To; ;0;0;	I" OpenSSL::X509::RequestError;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::OpenSSLError;To; ;0;0;	I"OpenSSL::X509::Revoked;T;
[ ;[ ;0;[ ;[ ;0;0o;;I" ;T;0;;;I"==;F;I"OpenSSL::X509::Revoked;T;[o;;I"untyped other;T;I"	bool;To;;I" ;T;0;;;I"add_extension;F;I"OpenSSL::X509::Revoked;T;[o;;I"#::OpenSSL::X509::Extension ext;T;I"OpenSSL::X509::Extension;To;;I"9Gets X509v3 extensions as array of X509Ext objects

;T;0;;;I"extensions;F;I"OpenSSL::X509::Revoked;T;[o;;I" ;F;I"&Array[::OpenSSL::X509::Extension];To;;I"Sets X509_EXTENSIONs

;T;0;;;I"extensions=;F;I"OpenSSL::X509::Revoked;T;[o;;I"3::Array[::OpenSSL::X509::Extension] extensions;T;I"&Array[::OpenSSL::X509::Extension];To;;I" ;T;0;;;I"serial;F;I"OpenSSL::X509::Revoked;T;[o;;I" ;F;I"Integer;To;;I" ;T;0;;;I"serial=;F;I"OpenSSL::X509::Revoked;T;[o;;I"::Integer integer;T;I"Integer;To;;I" ;T;0;;;I"	time;F;I"OpenSSL::X509::Revoked;T;[o;;I" ;F;I"
Time?;To;;I" ;T;0;;;I"
time=;F;I"OpenSSL::X509::Revoked;T;[o;;I"::Time time;T;I"	Time;To;;I" ;T;0;;;I"to_der;F;I"OpenSSL::X509::Revoked;T;[o;;I" ;F;I"String;To;;I" ;T;0;;;I"initialize;F;I"OpenSSL::X509::Revoked;T;[o;;I"*untyped;T;I"	void;To;;I" ;T;0;;;I"initialize_copy;F;I"OpenSSL::X509::Revoked;T;[o;;I"instance;T;I"	void;To; ;0;0;	I" OpenSSL::X509::RevokedError;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::OpenSSLError;To; ;I"zThe X509 certificate store holds trusted CA certificates used to verify peer
certificates.

The easiest way to create a useful certificate store is:

    cert_store = OpenSSL::X509::Store.new
    cert_store.set_default_paths

This will use your system's built-in certificates.

If your system does not have a default set of certificates you can obtain a
set extracted from Mozilla CA certificate store by cURL maintainers here:
https://curl.haxx.se/docs/caextract.html (You may wish to use the
firefox-db2pem.sh script to extract the certificates from a local install to
avoid man-in-the-middle attacks.)

After downloading or generating a cacert.pem from the above link you can
create a certificate store from the pem file like this:

    cert_store = OpenSSL::X509::Store.new
    cert_store.add_file 'cacert.pem'

The certificate store can be used with an SSLSocket like this:

    ssl_context = OpenSSL::SSL::SSLContext.new
    ssl_context.verify_mode = OpenSSL::SSL::VERIFY_PEER
    ssl_context.cert_store = cert_store

    tcp_socket = TCPSocket.open 'example.com', 443

    ssl_socket = OpenSSL::SSL::SSLSocket.new tcp_socket, ssl_context

;T;0;	I"OpenSSL::X509::Store;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"zAdds the OpenSSL::X509::Certificate *cert* to the certificate store.

See also the man page X509_STORE_add_cert(3).

;T;0;;;I"add_cert;F;I"OpenSSL::X509::Store;T;[o;;I"-::OpenSSL::X509::Certificate certificate;T;I"	self;To;;I"dAdds the OpenSSL::X509::CRL *crl* to the store.

See also the man page X509_STORE_add_crl(3).

;T;0;;;I"add_crl;F;I"OpenSSL::X509::Store;T;[o;;I"::OpenSSL::X509::CRL crl;T;I"	self;To;;I"ÛAdds the certificates in *file* to the certificate store. *file* is the path
to the file, and the file contains one or more certificates in PEM format
concatenated together.

See also the man page X509_LOOKUP_file(3).

;T;0;;;I"add_file;F;I"OpenSSL::X509::Store;T;[o;;I"::String file;T;I"	self;To;;I"pAdds *path* as the hash dir to be looked up by the store.

See also the man page X509_LOOKUP_hash_dir(3).

;T;0;;;I"add_path;F;I"OpenSSL::X509::Store;T;[o;;I"::String path;T;I"	self;To;;I"cThe certificate chain constructed by the last call of #verify.

See also StoreContext#chain.

;T;0;;;I"
chain;F;I"OpenSSL::X509::Store;T;[o;;I" ;F;I")Array[::OpenSSL::X509::Certificate]?;To;;I"TThe error code set by the last call of #verify.

See also StoreContext#error.

;T;0;;;I"
error;F;I"OpenSSL::X509::Store;T;[o;;I" ;F;I"Integer?;To;;I"oThe description for the error code set by the last call of #verify.

See also StoreContext#error_string.

;T;0;;;I"error_string;F;I"OpenSSL::X509::Store;T;[o;;I" ;F;I"String?;To;;I"hSets the default flags used by certificate chain verification performed with
the Store.

*flags* consists of zero or more of the constants defined in OpenSSL::X509
with name V_FLAG_* or'ed together.

OpenSSL::X509::StoreContext#flags= can be used to change the flags for a
single verification operation.

See also the man page X509_VERIFY_PARAM_set_flags(3).

;T;0;;;I"flags=;F;I"OpenSSL::X509::Store;T;[o;;I"::Integer flags;T;I"Integer;To;;I"|Sets the store's default verification purpose. If specified, the verifications
on the store will check every certificate's extensions are consistent with the
purpose. The purpose is specified by constants:

*   X509::PURPOSE_SSL_CLIENT
*   X509::PURPOSE_SSL_SERVER
*   X509::PURPOSE_NS_SSL_SERVER
*   X509::PURPOSE_SMIME_SIGN
*   X509::PURPOSE_SMIME_ENCRYPT
*   X509::PURPOSE_CRL_SIGN
*   X509::PURPOSE_ANY
*   X509::PURPOSE_OCSP_HELPER
*   X509::PURPOSE_TIMESTAMP_SIGN


OpenSSL::X509::StoreContext#purpose= can be used to change the value for a
single verification operation.

See also the man page X509_VERIFY_PARAM_set_purpose(3).

;T;0;;;I"purpose=;F;I"OpenSSL::X509::Store;T;[o;;I"::Integer purpose;T;I"Integer;To;;I"%Configures *store* to look up CA certificates from the system default
certificate store as needed basis. The location of the store can usually be
determined by:

*   OpenSSL::X509::DEFAULT_CERT_FILE
*   OpenSSL::X509::DEFAULT_CERT_DIR


See also the man page X509_STORE_set_default_paths(3).

;T;0;;;I"set_default_paths;F;I"OpenSSL::X509::Store;T;[o;;I" ;F;I"nil;To;;I"(Sets the time to be used in the certificate verifications with the store. By
default, if not specified, the current system time is used.

OpenSSL::X509::StoreContext#time= can be used to change the value for a single
verification operation.

See also the man page X509_VERIFY_PARAM_set_time(3).

;T;0;;;I"
time=;F;I"OpenSSL::X509::Store;T;[o;;I"::Time time;T;I"	Time;To;;I"öSets the default trust settings used by the certificate verification with the
store.

OpenSSL::X509::StoreContext#trust= can be used to change the value for a
single verification operation.

See also the man page X509_VERIFY_PARAM_set_trust(3).

;T;0;;;I"trust=;F;I"OpenSSL::X509::Store;T;[o;;I"::Integer trust;T;I"Integer;To;;I"®Performs a certificate verification on the OpenSSL::X509::Certificate *cert*.

*chain* can be an array of OpenSSL::X509::Certificate that is used to
construct the certificate chain.

If a block is given, it overrides the callback set by #verify_callback=.

After finishing the verification, the error information can be retrieved by
#error, #error_string, and the resulting complete certificate chain can be
retrieved by #chain.

;T;0;;;I"verify;F;I"OpenSSL::X509::Store;T;[o;;I"[::OpenSSL::X509::Certificate certificate, ?::Array[::OpenSSL::X509::Certificate] chain;T;I"boolish;To;;I"?The callback for additional certificate verification. It is invoked for each
certificate in the chain and can be used to implement custom certificate
verification conditions.

The callback is invoked with two values, a boolean that indicates if the
pre-verification by OpenSSL has succeeded or not, and the StoreContext in use.

The callback can use StoreContext#error= to change the error code as needed.
The callback must return either true or false.

NOTE: any exception raised within the callback will be ignored.

See also the man page X509_STORE_CTX_set_verify_cb(3).

;T;0;;;I"verify_callback;F;I"OpenSSL::X509::Store;T;[o;;I" ;F;I"U^(bool preverify_ok, ::OpenSSL::X509::StoreContext store_ctx) -> ::boolish | nil;To;;I"*General callback for OpenSSL verify

;T;0;;;I"verify_callback=;F;I"OpenSSL::X509::Store;T;[o;;I"O^(bool preverify_ok, ::OpenSSL::X509::StoreContext store_ctx) -> ::boolish;T;I"U;Fo;;I"!Creates a new X509::Store.

;T;0;;;I"initialize;F;I"OpenSSL::X509::Store;T;[o;;I" ;F;I"	void;To; ;I"bA StoreContext is used while validating a single certificate and holds the
status involved.

;T;0;	I" OpenSSL::X509::StoreContext;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"`Returns the verified chain.

See also the man page X509_STORE_CTX_set0_verified_chain(3).

;T;0;;;I"
chain;F;I" OpenSSL::X509::StoreContext;T;[o;;I" ;F;I")Array[::OpenSSL::X509::Certificate]?;To;;I" ;T;0;;;I"cleanup;F;I" OpenSSL::X509::StoreContext;T;[o;;I" ;F;I"	void;To;;I"qReturns the certificate which caused the error.

See also the man page X509_STORE_CTX_get_current_cert(3).

;T;0;;;I"current_cert;F;I" OpenSSL::X509::StoreContext;T;[o;;I" ;F;I"OpenSSL::X509::Certificate;To;;I"hReturns the CRL which caused the error.

See also the man page X509_STORE_CTX_get_current_crl(3).

;T;0;;;I"current_crl;F;I" OpenSSL::X509::StoreContext;T;[o;;I" ;F;I"OpenSSL::X509::CRL;To;;I"ØReturns the error code of *stctx*. This is typically called after #verify is
done, or from the verification callback set to
OpenSSL::X509::Store#verify_callback=.

See also the man page X509_STORE_CTX_get_error(3).

;T;0;;;I"
error;F;I" OpenSSL::X509::StoreContext;T;[o;;I" ;F;I"Integer?;To;;I"­Sets the error code of *stctx*. This is used by the verification callback set
to OpenSSL::X509::Store#verify_callback=.

See also the man page X509_STORE_CTX_set_error(3).

;T;0;;;I"error=;F;I" OpenSSL::X509::StoreContext;T;[o;;I"::Integer error;T;I"Integer;To;;I"„Returns the depth of the chain. This is used in combination with #error.

See also the man page X509_STORE_CTX_get_error_depth(3).

;T;0;;;I"error_depth;F;I" OpenSSL::X509::StoreContext;T;[o;;I" ;F;I"Integer;To;;I"—Returns the human readable error string corresponding to the error code
retrieved by #error.

See also the man page X509_verify_cert_error_string(3).

;T;0;;;I"error_string;F;I" OpenSSL::X509::StoreContext;T;[o;;I" ;F;I"String?;To;;I"šSets the verification flags to the context. This overrides the default value
set by Store#flags=.

See also the man page X509_VERIFY_PARAM_set_flags(3).

;T;0;;;I"flags=;F;I" OpenSSL::X509::StoreContext;T;[o;;I"::Integer flags;T;I"Integer;To;;I"“Sets the purpose of the context. This overrides the default value set by
Store#purpose=.

See also the man page X509_VERIFY_PARAM_set_purpose(3).

;T;0;;;I"purpose=;F;I" OpenSSL::X509::StoreContext;T;[o;;I"::Integer purpose;T;I"Integer;To;;I"…Sets the time used in the verification. If not set, the current time is used.

See also the man page X509_VERIFY_PARAM_set_time(3).

;T;0;;;I"
time=;F;I" OpenSSL::X509::StoreContext;T;[o;;I"::Time time;T;I"	Time;To;;I"–Sets the trust settings of the context. This overrides the default value set
by Store#trust=.

See also the man page X509_VERIFY_PARAM_set_trust(3).

;T;0;;;I"trust=;F;I" OpenSSL::X509::StoreContext;T;[o;;I"::Integer trust;T;I"Integer;To;;I"}Performs the certificate verification using the parameters set to *stctx*.

See also the man page X509_verify_cert(3).

;T;0;;;I"verify;F;I" OpenSSL::X509::StoreContext;T;[o;;I" ;F;I"	bool;To;;I"QSets up a StoreContext for a verification of the X.509 certificate *cert*.

;T;0;;;I"initialize;F;I" OpenSSL::X509::StoreContext;T;[o;;I"s::OpenSSL::X509::Store store, ?::OpenSSL::X509::Certificate cert, ?::Array[::OpenSSL::X509::Certificate] chain;T;I"	void;To; ;0;0;	I"OpenSSL::X509::StoreError;T;
[ ;[ ;0;[ ;[ ;0;I"OpenSSL::OpenSSLError;To; ;I"p,## OptionParser

### New to OptionParser?

See the [Tutorial](optparse/tutorial.rdoc).

### Introduction

OptionParser is a class for command-line option analysis.  It is much more
advanced, yet also easier to use, than GetoptLong, and is a more Ruby-oriented
solution.

### Features

1.  The argument specification and the code to handle it are written in the
    same place.
2.  It can output an option summary; you don't need to maintain this string
    separately.
3.  Optional and mandatory arguments are specified very gracefully.
4.  Arguments can be automatically converted to a specified class.
5.  Arguments can be restricted to a certain set.


All of these features are demonstrated in the examples below.  See
#make_switch for full documentation.

### Minimal example

    require 'optparse'

    options = {}
    OptionParser.new do |parser|
      parser.banner = "Usage: example.rb [options]"

      parser.on("-v", "--[no-]verbose", "Run verbosely") do |v|
        options[:verbose] = v
      end
    end.parse!

    p options
    p ARGV

### Generating Help

OptionParser can be used to automatically generate help for the commands you
write:

    require 'optparse'

    Options = Struct.new(:name)

    class Parser
      def self.parse(options)
        args = Options.new("world")

        opt_parser = OptionParser.new do |parser|
          parser.banner = "Usage: example.rb [options]"

          parser.on("-nNAME", "--name=NAME", "Name to say hello to") do |n|
            args.name = n
          end

          parser.on("-h", "--help", "Prints this help") do
            puts parser
            exit
          end
        end

        opt_parser.parse!(options)
        return args
      end
    end
    options = Parser.parse %w[--help]

    #=>
       # Usage: example.rb [options]
       #     -n, --name=NAME                  Name to say hello to
       #     -h, --help                       Prints this help

### Required Arguments

For options that require an argument, option specification strings may include
an option name in all caps. If an option is used without the required
argument, an exception will be raised.

    require 'optparse'

    options = {}
    OptionParser.new do |parser|
      parser.on("-r", "--require LIBRARY",
                "Require the LIBRARY before executing your script") do |lib|
        puts "You required #{lib}!"
      end
    end.parse!

Used:

    $ ruby optparse-test.rb -r
    optparse-test.rb:9:in `<main>': missing argument: -r (OptionParser::MissingArgument)
    $ ruby optparse-test.rb -r my-library
    You required my-library!

### Type Coercion

OptionParser supports the ability to coerce command line arguments into
objects for us.

OptionParser comes with a few ready-to-use kinds of  type coercion. They are:

*   Date  -- Anything accepted by `Date.parse`
*   DateTime -- Anything accepted by `DateTime.parse`
*   Time -- Anything accepted by `Time.httpdate` or `Time.parse`
*   URI  -- Anything accepted by `URI.parse`
*   Shellwords -- Anything accepted by `Shellwords.shellwords`
*   String -- Any non-empty string
*   Integer -- Any integer. Will convert octal. (e.g. 124, -3, 040)
*   Float -- Any float. (e.g. 10, 3.14, -100E+13)
*   Numeric -- Any integer, float, or rational (1, 3.4, 1/3)
*   DecimalInteger -- Like `Integer`, but no octal format.
*   OctalInteger -- Like `Integer`, but no decimal format.
*   DecimalNumeric -- Decimal integer or float.
*   TrueClass --  Accepts '+, yes, true, -, no, false' and defaults as `true`
*   FalseClass -- Same as `TrueClass`, but defaults to `false`
*   Array -- Strings separated by ',' (e.g. 1,2,3)
*   Regexp -- Regular expressions. Also includes options.


We can also add our own coercions, which we will cover below.

#### Using Built-in Conversions

As an example, the built-in `Time` conversion is used. The other built-in
conversions behave in the same way. OptionParser will attempt to parse the
argument as a `Time`. If it succeeds, that time will be passed to the handler
block. Otherwise, an exception will be raised.

    require 'optparse'
    require 'optparse/time'
    OptionParser.new do |parser|
      parser.on("-t", "--time [TIME]", Time, "Begin execution at given time") do |time|
        p time
      end
    end.parse!

Used:

    $ ruby optparse-test.rb  -t nonsense
    ... invalid argument: -t nonsense (OptionParser::InvalidArgument)
    $ ruby optparse-test.rb  -t 10-11-12
    2010-11-12 00:00:00 -0500
    $ ruby optparse-test.rb  -t 9:30
    2014-08-13 09:30:00 -0400

#### Creating Custom Conversions

The `accept` method on OptionParser may be used to create converters. It
specifies which conversion block to call whenever a class is specified. The
example below uses it to fetch a `User` object before the `on` handler
receives it.

    require 'optparse'

    User = Struct.new(:id, :name)

    def find_user id
      not_found = ->{ raise "No User Found for id #{id}" }
      [ User.new(1, "Sam"),
        User.new(2, "Gandalf") ].find(not_found) do |u|
        u.id == id
      end
    end

    op = OptionParser.new
    op.accept(User) do |user_id|
      find_user user_id.to_i
    end

    op.on("--user ID", User) do |user|
      puts user
    end

    op.parse!

Used:

    $ ruby optparse-test.rb --user 1
    #<struct User id=1, name="Sam">
    $ ruby optparse-test.rb --user 2
    #<struct User id=2, name="Gandalf">
    $ ruby optparse-test.rb --user 3
    optparse-test.rb:15:in `block in find_user': No User Found for id 3 (RuntimeError)

### Store options to a Hash

The `into` option of `order`, `parse` and so on methods stores command line
options into a Hash.

    require 'optparse'

    options = {}
    OptionParser.new do |parser|
      parser.on('-a')
      parser.on('-b NUM', Integer)
      parser.on('-v', '--verbose')
    end.parse!(into: options)

    p options

Used:

    $ ruby optparse-test.rb -a
    {:a=>true}
    $ ruby optparse-test.rb -a -v
    {:a=>true, :verbose=>true}
    $ ruby optparse-test.rb -a -b 100
    {:a=>true, :b=>100}

### Complete example

The following example is a complete Ruby program.  You can run it and see the
effect of specifying various options.  This is probably the best way to learn
the features of `optparse`.

    require 'optparse'
    require 'optparse/time'
    require 'ostruct'
    require 'pp'

    class OptparseExample
      Version = '1.0.0'

      CODES = %w[iso-2022-jp shift_jis euc-jp utf8 binary]
      CODE_ALIASES = { "jis" => "iso-2022-jp", "sjis" => "shift_jis" }

      class ScriptOptions
        attr_accessor :library, :inplace, :encoding, :transfer_type,
                      :verbose, :extension, :delay, :time, :record_separator,
                      :list

        def initialize
          self.library = []
          self.inplace = false
          self.encoding = "utf8"
          self.transfer_type = :auto
          self.verbose = false
        end

        def define_options(parser)
          parser.banner = "Usage: example.rb [options]"
          parser.separator ""
          parser.separator "Specific options:"

          # add additional options
          perform_inplace_option(parser)
          delay_execution_option(parser)
          execute_at_time_option(parser)
          specify_record_separator_option(parser)
          list_example_option(parser)
          specify_encoding_option(parser)
          optional_option_argument_with_keyword_completion_option(parser)
          boolean_verbose_option(parser)

          parser.separator ""
          parser.separator "Common options:"
          # No argument, shows at tail.  This will print an options summary.
          # Try it and see!
          parser.on_tail("-h", "--help", "Show this message") do
            puts parser
            exit
          end
          # Another typical switch to print the version.
          parser.on_tail("--version", "Show version") do
            puts Version
            exit
          end
        end

        def perform_inplace_option(parser)
          # Specifies an optional option argument
          parser.on("-i", "--inplace [EXTENSION]",
                    "Edit ARGV files in place",
                    "(make backup if EXTENSION supplied)") do |ext|
            self.inplace = true
            self.extension = ext || ''
            self.extension.sub!(/\A\.?(?=.)/, ".")  # Ensure extension begins with dot.
          end
        end

        def delay_execution_option(parser)
          # Cast 'delay' argument to a Float.
          parser.on("--delay N", Float, "Delay N seconds before executing") do |n|
            self.delay = n
          end
        end

        def execute_at_time_option(parser)
          # Cast 'time' argument to a Time object.
          parser.on("-t", "--time [TIME]", Time, "Begin execution at given time") do |time|
            self.time = time
          end
        end

        def specify_record_separator_option(parser)
          # Cast to octal integer.
          parser.on("-F", "--irs [OCTAL]", OptionParser::OctalInteger,
                    "Specify record separator (default \\0)") do |rs|
            self.record_separator = rs
          end
        end

        def list_example_option(parser)
          # List of arguments.
          parser.on("--list x,y,z", Array, "Example 'list' of arguments") do |list|
            self.list = list
          end
        end

        def specify_encoding_option(parser)
          # Keyword completion.  We are specifying a specific set of arguments (CODES
          # and CODE_ALIASES - notice the latter is a Hash), and the user may provide
          # the shortest unambiguous text.
          code_list = (CODE_ALIASES.keys + CODES).join(', ')
          parser.on("--code CODE", CODES, CODE_ALIASES, "Select encoding",
                    "(#{code_list})") do |encoding|
            self.encoding = encoding
          end
        end

        def optional_option_argument_with_keyword_completion_option(parser)
          # Optional '--type' option argument with keyword completion.
          parser.on("--type [TYPE]", [:text, :binary, :auto],
                    "Select transfer type (text, binary, auto)") do |t|
            self.transfer_type = t
          end
        end

        def boolean_verbose_option(parser)
          # Boolean switch.
          parser.on("-v", "--[no-]verbose", "Run verbosely") do |v|
            self.verbose = v
          end
        end
      end

      #
      # Return a structure describing the options.
      #
      def parse(args)
        # The options specified on the command line will be collected in
        # *options*.

        @options = ScriptOptions.new
        @args = OptionParser.new do |parser|
          @options.define_options(parser)
          parser.parse!(args)
        end
        @options
      end

      attr_reader :parser, :options
    end  # class OptparseExample

    example = OptparseExample.new
    options = example.parse(ARGV)
    pp options # example.options
    pp ARGV

### Shell Completion

For modern shells (e.g. bash, zsh, etc.), you can use shell completion for
command line options.

### Further documentation

The above examples, along with the accompanying
[Tutorial](optparse/tutorial.rdoc), should be enough to learn how to use this
class. If you have any questions, file a ticket at http://bugs.ruby-lang.org.

;T;0;	I"OptionParser;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"See #accept.

;T;0;;;I"accept;F;I"OptionParser;T;[o;;I"-::Class t, ?::OptionParser::_Pattern pat;T;I"	void;To;;I"See #getopts.

;T;0;;;I"getopts;F;I"OptionParser;T;[o;;I"*::String options;T;I"Hash[::String, untyped];To;;I".::Array[::String] args, *::String options;T;I"Hash[::String, untyped];To;;I"DReturns an incremented value of `default` according to `arg`.

;T;0;;;I"inc;F;I"OptionParser;T;[o;;I"!untyped arg, ?::_ToI default;T;I"Integer?;To;;I"See #reject.

;T;0;;;I"reject;F;I"OptionParser;T;[o;;I"::Class t;T;I"	void;To;;I" ;T;0;;;I"terminate;F;I"OptionParser;T;[o;;I"?::String arg;T;I"bot;To;;I" ;T;0;;;I"top;F;I"OptionParser;T;[o;;I" ;F;I"OptionParser::List;To;;I"úInitializes a new instance and evaluates the optional block in context of the
instance. Arguments `args` are passed to #new, see there for description of
parameters.

This method is **deprecated**, its behavior corresponds to the older #new
method.

;T;0;;;I"	with;F;I"OptionParser;T;[o;;I"9?::String banner, ?::Integer width, ?::String indent;T;I"instance;To;;I" ;T;0;;;I"
abort;F;I"OptionParser;T;[o;;I"?::_ToS mesg;T;I"bot;To;;I".Directs to accept specified class `t`. The argument string is passed to the
block in which it should be converted to the desired class.

`t`
:   Argument class specifier, any object including Class.
`pat`
:   Pattern for argument, defaults to `t` if it responds to match.


    accept(t, pat, &block)

;T;0;;;I"accept;F;I"OptionParser;T;[o;;I"-::Class t, ?::OptionParser::_Pattern pat;T;I"	void;To;;0;0;;;I"add_officious;F;I"OptionParser;T;[o;;I" ;F;I"	void;To;;I"Returns additional info.

;T;0;;;I"additional_message;F;I"OptionParser;T;[o;;I"untyped typ, untyped opt;T;I"String?;To;;I"Subject of #on_tail.

;T;0;;;I"	base;F;I"OptionParser;T;[o;;I" ;F;I"OptionParser::List;To;;I" ;T;0;;;I"candidate;F;I"OptionParser;T;[o;;I"::String word;T;I"Array[untyped];To;;0;0;;;I"compsys;F;I"OptionParser;T;[o;;I"untyped to, ?untyped name;T;I"untyped;To;;I"oCreates an option from the given parameters `params`. See [Parameters for New
Options](./option_params.rdoc).

The block, if given, is the handler for the created option. When the option is
encountered during command-line parsing, the block is called with the argument
given for the option, if any. See [Option
Handlers](./option_params.rdoc#label-Option+Handlers).

;T;0;;;I"define;F;I"OptionParser;T;[	o;;I"*::String params;T;I"untyped;To;;I"l::String params, ::Class | ::Array[::String] | ::Hash[::Symbol, untyped] | ::Regexp obj, ?::String desc;T;I"untyped;To;;I"0*::String params, ::Proc | ::Method handler;T;I"untyped;To;;I"‚::String params, ::Class | ::Array[::String] | ::Hash[::Symbol, untyped] | ::Regexp obj, ?::String desc, ::Proc | ::Method handler;T;I"untyped;To;;I"oCreates an option from the given parameters `params`. See [Parameters for New
Options](./option_params.rdoc).

The block, if given, is the handler for the created option. When the option is
encountered during command-line parsing, the block is called with the argument
given for the option, if any. See [Option
Handlers](./option_params.rdoc#label-Option+Handlers).

;T;0;;;I"define_head;F;I"OptionParser;T;[	o;;I"*::String params;T;I"untyped;To;;I"l::String params, ::Class | ::Array[::String] | ::Hash[::Symbol, untyped] | ::Regexp obj, ?::String desc;T;I"untyped;To;;I"0*::String params, ::Proc | ::Method handler;T;I"untyped;To;;I"‚::String params, ::Class | ::Array[::String] | ::Hash[::Symbol, untyped] | ::Regexp obj, ?::String desc, ::Proc | ::Method handler;T;I"untyped;To;;I"oCreates an option from the given parameters `params`. See [Parameters for New
Options](./option_params.rdoc).

The block, if given, is the handler for the created option. When the option is
encountered during command-line parsing, the block is called with the argument
given for the option, if any. See [Option
Handlers](./option_params.rdoc#label-Option+Handlers).

;T;0;;;I"define_tail;F;I"OptionParser;T;[	o;;I"*::String params;T;I"untyped;To;;I"l::String params, ::Class | ::Array[::String] | ::Hash[::Symbol, untyped] | ::Regexp obj, ?::String desc;T;I"untyped;To;;I"0*::String params, ::Proc | ::Method handler;T;I"untyped;To;;I"‚::String params, ::Class | ::Array[::String] | ::Hash[::Symbol, untyped] | ::Regexp obj, ?::String desc, ::Proc | ::Method handler;T;I"untyped;To;;I"Parses environment variable `env` or its uppercase with splitting like a
shell.

`env` defaults to the basename of the program.

;T;0;;;I"environment;F;I"OptionParser;T;[o;;I"?::String env;T;I"Array[::String]?;To;;I"Wrapper method for getopts.rb.

    params = ARGV.getopts("ab:", "foo", "bar:", "zot:Z;zot option")
    # params["a"] = true   # -a
    # params["b"] = "1"    # -b1
    # params["foo"] = "1"  # --foo
    # params["bar"] = "x"  # --bar x
    # params["zot"] = "z"  # --zot Z

;T;0;;;I"getopts;F;I"OptionParser;T;[o;;I"*::String options;T;I"Hash[::String, untyped];To;;I".::Array[::String] args, *::String options;T;I"Hash[::String, untyped];To;;I"%Returns option summary string.

;T;0;;;I"	help;F;I"OptionParser;T;[o;;I" ;F;I"String;To;;I" ;T;0;;;I"inc;F;I"OptionParser;T;[o;;I"*untyped args;T;I"untyped;To;;I"&Loads options from file names as `filename`. Does nothing when the file is not
present. Returns whether successfully loaded.

`filename` defaults to basename of the program without suffix in a directory
~/.options, then the basename with '.options' suffix under XDG and Haiku
standard places.

;T;0;;;I"	load;F;I"OptionParser;T;[o;;I"?::String filename;T;I"	bool;To;;I"oCreates an option from the given parameters `params`. See [Parameters for New
Options](./option_params.rdoc).

The block, if given, is the handler for the created option. When the option is
encountered during command-line parsing, the block is called with the argument
given for the option, if any. See [Option
Handlers](./option_params.rdoc#label-Option+Handlers).

;T;0;;;I"make_switch;F;I"OptionParser;T;[o;;I")::Array[untyped] opts, ?::Proc block;T;I"4[ untyped, untyped, untyped, untyped, untyped ];To;;I"Pushes a new List.

;T;0;;;I"new;F;I"OptionParser;T;[o;;I" ;F;I"	self;To;;I" ;F;I"T;Fo;;I"oCreates an option from the given parameters `params`. See [Parameters for New
Options](./option_params.rdoc).

The block, if given, is the handler for the created option. When the option is
encountered during command-line parsing, the block is called with the argument
given for the option, if any. See [Option
Handlers](./option_params.rdoc#label-Option+Handlers).

;T;0;;;I"on;F;I"OptionParser;T;[	o;;I"*::String params;T;I"	self;To;;I"l::String params, ::Class | ::Array[::String] | ::Hash[::Symbol, untyped] | ::Regexp obj, ?::String desc;T;I"	self;To;;I"0*::String params, ::Proc | ::Method handler;T;I"	self;To;;I"‚::String params, ::Class | ::Array[::String] | ::Hash[::Symbol, untyped] | ::Regexp obj, ?::String desc, ::Proc | ::Method handler;T;I"	self;To;;I"¤Creates an option from the given parameters `params`. See [Parameters for New
Options](./option_params.rdoc).

The block, if given, is the handler for the created option. When the option is
encountered during command-line parsing, the block is called with the argument
given for the option, if any. See [Option
Handlers](./option_params.rdoc#label-Option+Handlers).

The new option is added at the head of the summary.

;T;0;;;I"on_head;F;I"OptionParser;T;[	o;;I"*::String params;T;I"	self;To;;I"l::String params, ::Class | ::Array[::String] | ::Hash[::Symbol, untyped] | ::Regexp obj, ?::String desc;T;I"	self;To;;I"0*::String params, ::Proc | ::Method handler;T;I"	self;To;;I"‚::String params, ::Class | ::Array[::String] | ::Hash[::Symbol, untyped] | ::Regexp obj, ?::String desc, ::Proc | ::Method handler;T;I"	self;To;;I"¤Creates an option from the given parameters `params`. See [Parameters for New
Options](./option_params.rdoc).

The block, if given, is the handler for the created option. When the option is
encountered during command-line parsing, the block is called with the argument
given for the option, if any. See [Option
Handlers](./option_params.rdoc#label-Option+Handlers).

The new option is added at the tail of the summary.

;T;0;;;I"on_tail;F;I"OptionParser;T;[	o;;I"*::String params;T;I"	self;To;;I"l::String params, ::Class | ::Array[::String] | ::Hash[::Symbol, untyped] | ::Regexp obj, ?::String desc;T;I"	self;To;;I"0*::String params, ::Proc | ::Method handler;T;I"	self;To;;I"‚::String params, ::Class | ::Array[::String] | ::Hash[::Symbol, untyped] | ::Regexp obj, ?::String desc, ::Proc | ::Method handler;T;I"	self;To;;I"BParses command line arguments `argv` in order. When a block is given, each
non-option argument is yielded. When optional `into` keyword argument is
provided, the parsed option values are stored there via `[]=` method (so it
can be Hash, or OpenStruct, or other similar object).

Returns the rest of `argv` left unparsed.

;T;0;;;I"
order;F;I"OptionParser;T;[o;;I"5*::String argv, ?into: ::OptionParser::_Intoable;T;I"Array[::String];To;;I"=::Array[::String] argv, ?into: ::OptionParser::_Intoable;T;I"Array[::String];To;;I"aSame as #order, but removes switches destructively. Non-option arguments
remain in `argv`.

;T;0;;;I"order!;F;I"OptionParser;T;[o;;I">?::Array[::String] argv, ?into: ::OptionParser::_Intoable;T;I"Array[::String];To;;I"/Parses command line arguments `argv` in order when environment variable
POSIXLY_CORRECT is set, and in permutation mode otherwise. When optional
`into` keyword argument is provided, the parsed option values are stored there
via `[]=` method (so it can be Hash, or OpenStruct, or other similar object).

;T;0;;;I"
parse;F;I"OptionParser;T;[o;;I"5*::String argv, ?into: ::OptionParser::_Intoable;T;I"Array[::String];To;;I"=::Array[::String] argv, ?into: ::OptionParser::_Intoable;T;I"Array[::String];To;;I"aSame as #parse, but removes switches destructively. Non-option arguments
remain in `argv`.

;T;0;;;I"parse!;F;I"OptionParser;T;[o;;I">?::Array[::String] argv, ?into: ::OptionParser::_Intoable;T;I"Array[::String];To;;I"Parses command line arguments `argv` in permutation mode and returns list of
non-option arguments. When optional `into` keyword argument is provided, the
parsed option values are stored there via `[]=` method (so it can be Hash, or
OpenStruct, or other similar object).

;T;0;;;I"permute;F;I"OptionParser;T;[o;;I"5*::String argv, ?into: ::OptionParser::_Intoable;T;I"Array[::String];To;;I"=::Array[::String] argv, ?into: ::OptionParser::_Intoable;T;I"Array[::String];To;;I"cSame as #permute, but removes switches destructively. Non-option arguments
remain in `argv`.

;T;0;;;I"permute!;F;I"OptionParser;T;[o;;I">?::Array[::String] argv, ?into: ::OptionParser::_Intoable;T;I"Array[::String];To;;I"|Directs to reject specified class argument.

`t`
:   Argument class specifier, any object including Class.


    reject(t)

;T;0;;;I"reject;F;I"OptionParser;T;[o;;I"::Class t;T;I"	void;To;;I"Release code

;T;0;;;I"release;F;I"OptionParser;T;[o;;I" ;F;I"untyped;To;;I"Release code

;T;0;;;I"release=;F;I"OptionParser;T;[o;;I"untyped;T;I"untyped;To;;I"Removes the last List.

;T;0;;;I"remove;F;I"OptionParser;T;[o;;I" ;F;I"OptionParser::List?;To;;I" Add separator in summary.

;T;0;;;I"separator;F;I"OptionParser;T;[o;;I"::String string;T;I"	void;To;;I"\Puts option summary into `to` and returns `to`. Yields each line if a block is
given.

`to`
:   Output destination, which must have method <<. Defaults to [].
`width`
:   Width of left side, defaults to @summary_width.
`max`
:   Maximum length allowed for left side, defaults to `width` - 1.
`indent`
:   Indentation, defaults to @summary_indent.

;T;0;;;I"summarize;F;I"OptionParser;T;[o;;I"X?::OptionParser::_LtLtString to, ?::Integer width, ?::Integer max, ?::String indent;T;I"OptionParser::_LtLtString;To;;I"wTerminates option parsing. Optional parameter `arg` is a string pushed back to
be the first non-option argument.

;T;0;;;I"terminate;F;I"OptionParser;T;[o;;I"?::String arg;T;I"bot;To;;I"#Returns option summary list.

;T;0;;;I"	to_a;F;I"OptionParser;T;[o;;I" ;F;I"Array[::String];To;;I"3Subject of #on / #on_head, #accept / #reject

;T;0;;;I"top;F;I"OptionParser;T;[o;;I" ;F;I"OptionParser::List;To;;I"EReturns version string from program_name, version and release.

;T;0;;;I"ver;F;I"OptionParser;T;[o;;I" ;F;I"String?;To;;I" ;T;0;;;I"	warn;F;I"OptionParser;T;[o;;I"?::_ToS mesg;T;I"	void;To;;I"Completes shortened long style option switch and returns pair of canonical
switch and switch descriptor OptionParser::Switch.

`typ`
:   Searching table.
`opt`
:   Searching key.
`icase`
:   Search case insensitive if true.
`pat`
:   Optional pattern for completion.

;T;0;;;I"complete;F;I"OptionParser;T;[o;;I";untyped typ, untyped opt, ?untyped icase, *untyped pat;T;I"untyped;To;;I"šInitializes the instance and yields itself if called with a block.

`banner`
:   Banner message.
`width`
:   Summary width.
`indent`
:   Summary indent.

;T;0;;;I"initialize;F;I"OptionParser;T;[o;;I"9?::String banner, ?::Integer width, ?::String indent;T;I"	void;To;;I"ÖChecks if an argument is given twice, in which case an ArgumentError is
raised. Called from OptionParser#switch only.

`obj`
:   New argument.
`prv`
:   Previously specified argument.
`msg`
:   Exception message.

;T;0;;;I"notwice;F;I"OptionParser;T;[o;;I"*untyped obj, untyped prv, untyped msg;T;I"untyped;To;;0;0;;;I"parse_in_order;F;I"OptionParser;T;[o;;I"#?untyped argv, ?untyped setter;T;I"untyped;To;;I"OSearches `key` in @stack for `id` hash and returns or yields the result.

;T;0;;;I"search;F;I"OptionParser;T;[o;;I"untyped id, untyped key;T;I"untyped;To;;I"RTraverses @stack, sending each element method `id` with `args` and `block`.

;T;0;;;I"
visit;F;I"OptionParser;T;[o;;I"untyped id, *untyped args;T;I"untyped;To;;I"ŽAcceptable argument classes. Now contains DecimalInteger, OctalInteger and
DecimalNumeric. See Acceptable argument classes (in source code).

;T;0;	I"OptionParser::Acceptables;T;
[ ;[ ;0;[ ;[ o; ;I"GRaises when the given argument word can't be completed uniquely.

;T;0;	I"$OptionParser::AmbiguousArgument;T;
[ ;[ ;0;[ ;[ ;0;I""OptionParser::InvalidArgument;To; ;I"ARaises when ambiguously completable string is encountered.

;T;0;	I""OptionParser::AmbiguousOption;T;
[ ;[ ;0;[ ;[ ;0;I"OptionParser::ParseError;To;;I"CExtends command line arguments array (ARGV) to parse itself.

;T;0;	I"OptionParser::Arguable;T;
[ ;[ ;0;[ ;[ o;;I"%Initializes instance variable.

;T;0;;;I"extend_object;F;I"OptionParser::Arguable;T;[o;;I"untyped obj;T;I"untyped;To;;I"Substitution of getopts is possible as follows. Also see OptionParser#getopts.

    def getopts(*args)
      ($OPT = ARGV.getopts(*args)).each do |opt, val|
        eval "$OPT_#{opt.gsub(/[^A-Za-z0-9_]/, '_')} = val"
      end
    rescue OptionParser::ParseError
    end

;T;0;;;I"getopts;F;I"OptionParser::Arguable;T;[o;;I"*::String args;T;I"Hash[::String, untyped];To;;I"#Actual OptionParser object, automatically created if nonexistent.

If called with a block, yields the OptionParser object and returns the result
of the block. If an OptionParser::ParseError exception occurs in the block, it
is rescued, a error message printed to STDERR and `nil` returned.

;T;0;;;I"options;F;I"OptionParser::Arguable;T;[o;;I" ;F;I"OptionParser;To;;I" ;F;I"T?;To;;I"çSets OptionParser object, when `opt` is `false` or `nil`, methods
OptionParser::Arguable#options and OptionParser::Arguable#options= are
undefined. Thus, there is no ways to access the OptionParser object via the
receiver object.

;T;0;;;I"options=;F;I"OptionParser::Arguable;T;[o;;I"::OptionParser? opt;T;I"untyped;To;;I"kParses `self` destructively in order and returns `self` containing the rest
arguments left unparsed.

;T;0;;;I"order!;F;I"OptionParser::Arguable;T;[o;;I" ;F;I"Array[::String];To;;I"bParses `self` destructively and returns `self` containing the rest arguments
left unparsed.

;T;0;;;I"parse!;F;I"OptionParser::Arguable;T;[o;;I" ;F;I"Array[::String];To;;I"vParses `self` destructively in permutation mode and returns `self` containing
the rest arguments left unparsed.

;T;0;;;I"permute!;F;I"OptionParser::Arguable;T;[o;;I" ;F;I"Array[::String];To; ;I"IHash with completion search feature. See OptionParser::Completion.

;T;0;	I"!OptionParser::CompletingHash;T;
[ ;[I"OptionParser::Completion;T;0;[ ;[ ;0;I"	Hash;To;;I"Completion for hash key.

;T;0;;;I"
match;F;I"!OptionParser::CompletingHash;T;[o;;I"untyped key;T;I"untyped;To;;I"}Keyword completion module.  This allows partial arguments to be specified and
resolved against a list of acceptable values.

;T;0;	I"OptionParser::Completion;T;
[ ;[ ;0;[ ;[ o;;I" ;T;0;;;I"candidate;F;I"OptionParser::Completion;T;[o;;I".untyped key, ?untyped icase, ?untyped pat;T;I"untyped;To;;I" ;T;0;;;I"regexp;F;I"OptionParser::Completion;T;[o;;I"untyped key, untyped icase;T;I"untyped;To;;I" ;T;0;;;I"candidate;F;I"OptionParser::Completion;T;[o;;I".untyped key, ?untyped icase, ?untyped pat;T;I"untyped;To;;I" ;T;0;;;I"complete;F;I"OptionParser::Completion;T;[o;;I".untyped key, ?untyped icase, ?untyped pat;T;I"untyped;To;;I" ;T;0;;;I"convert;F;I"OptionParser::Completion;T;[o;;I")?untyped opt, ?untyped val, *untyped;T;I"untyped;To; ;I"ERaises when the given argument does not match required format.

;T;0;	I""OptionParser::InvalidArgument;T;
[ ;[ ;0;[ ;[ ;0;I"OptionParser::ParseError;To; ;I"'Raises when switch is undefined.

;T;0;	I" OptionParser::InvalidOption;T;
[ ;[ ;0;[ ;[ ;0;I"OptionParser::ParseError;To; ;I"ÏSimple option list providing mapping from short and/or long option string to
OptionParser::Switch and mapping from acceptable argument to matching pattern
and converter pair. Also provides summary feature.

;T;0;	I"OptionParser::List;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"See OptionParser.accept.

;T;0;;;I"accept;F;I"OptionParser::List;T;[o;;I"untyped t, ?untyped pat;T;I"untyped;To;;0;0;;;I"add_banner;F;I"OptionParser::List;T;[o;;I"untyped to;T;I"untyped;To;;I"~Appends `switch` at the tail of the list, and associates short, long and
negated long options. Arguments are:

`switch`
:   OptionParser::Switch instance to be inserted.
`short_opts`
:   List of short style options.
`long_opts`
:   List of long style options.
`nolong_opts`
:   List of long style options with "no-" prefix.


    append(switch, short_opts, long_opts, nolong_opts)

;T;0;;;I"append;F;I"OptionParser::List;T;[o;;I"*untyped args;T;I"untyped;To;;I"IMap from acceptable argument types to pattern and converter pairs.

;T;0;;;I"
atype;F;I"OptionParser::List;T;[o;;I" ;F;I"untyped;To;;I"ÝSearches list `id` for `opt` and the optional patterns for completion `pat`.
If `icase` is true, the search is case insensitive. The result is returned or
yielded if a block is given. If it isn't found, nil is returned.

;T;0;;;I"complete;F;I"OptionParser::List;T;[o;;I":untyped id, untyped opt, ?untyped icase, *untyped pat;T;I"untyped;To;;0;0;;;I"compsys;F;I"OptionParser::List;T;[o;;I"*untyped args;T;I"untyped;To;;I"DIterates over each option, passing the option to the `block`.

;T;0;;;I"each_option;F;I"OptionParser::List;T;[o;;I" ;F;I"untyped;To;;I" ;T;0;;;I"get_candidates;F;I"OptionParser::List;T;[o;;I"untyped id;T;I"untyped;To;;I"/List of all switches and summary string.

;T;0;;;I"	list;F;I"OptionParser::List;T;[o;;I" ;F;I"untyped;To;;I"DMap from long style option switches to actual switch objects.

;T;0;;;I"	long;F;I"OptionParser::List;T;[o;;I" ;F;I"untyped;To;;I"Inserts `switch` at the head of the list, and associates short, long and
negated long options. Arguments are:

`switch`
:   OptionParser::Switch instance to be inserted.
`short_opts`
:   List of short style options.
`long_opts`
:   List of long style options.
`nolong_opts`
:   List of long style options with "no-" prefix.


    prepend(switch, short_opts, long_opts, nolong_opts)

;T;0;;;I"prepend;F;I"OptionParser::List;T;[o;;I"*untyped args;T;I"untyped;To;;I"See OptionParser.reject.

;T;0;;;I"reject;F;I"OptionParser::List;T;[o;;I"untyped t;T;I"untyped;To;;I"~Searches `key` in `id` list. The result is returned or yielded if a block is
given. If it isn't found, nil is returned.

;T;0;;;I"search;F;I"OptionParser::List;T;[o;;I"untyped id, untyped key;T;I"untyped;To;;I"EMap from short style option switches to actual switch objects.

;T;0;;;I"
short;F;I"OptionParser::List;T;[o;;I" ;F;I"untyped;To;;I"¯Creates the summary table, passing each line to the `block` (without newline).
The arguments `args` are passed along to the summarize method which is called
on every option.

;T;0;;;I"summarize;F;I"OptionParser::List;T;[o;;I"*untyped args;T;I"untyped;To;;I"/Just initializes all instance variables.

;T;0;;;I"initialize;F;I"OptionParser::List;T;[o;;I" ;F;I"	void;To;;I"ãAdds `sw` according to `sopts`, `lopts` and `nlopts`.

`sw`
:   OptionParser::Switch instance to be added.
`sopts`
:   Short style option list.
`lopts`
:   Long style option list.
`nlopts`
:   Negated long style options list.

;T;0;;;I"update;F;I"OptionParser::List;T;[o;;I"Luntyped sw, untyped sopts, untyped lopts, ?untyped nsw, ?untyped nlopts;T;I"untyped;To; ;I"DRaises when a switch with mandatory argument has no argument.

;T;0;	I""OptionParser::MissingArgument;T;
[ ;[ ;0;[ ;[ ;0;I"OptionParser::ParseError;To; ;I"MRaises when there is an argument for a switch which takes no argument.

;T;0;	I"#OptionParser::NeedlessArgument;T;
[ ;[ ;0;[ ;[ ;0;I"OptionParser::ParseError;To; ;I"@Map from option/keyword string to object with completion.

;T;0;	I"OptionParser::OptionMap;T;
[ ;[I"OptionParser::Completion;T;0;[ ;[ ;0;I"	Hash;To; ;I"2Base class of exceptions from OptionParser.

;T;0;	I"OptionParser::ParseError;T;
[ ;[ ;0;[ ;[ ;0;I"RuntimeError;To;;I" ;T;0;;;I"filter_backtrace;F;I"OptionParser::ParseError;T;[o;;I"untyped array;T;I"untyped;To;;0;0;;;I"additional;F;I"OptionParser::ParseError;T;[o;;I" ;F;I"untyped;To;;0;0;;;I"additional=;F;I"OptionParser::ParseError;T;[o;;I"untyped;T;I"untyped;To;;0;0;;;I"	args;F;I"OptionParser::ParseError;T;[o;;I" ;F;I"untyped;To;;I" ;T;0;;;I"inspect;F;I"OptionParser::ParseError;T;[o;;I" ;F;I"untyped;To;;I"ADefault stringizing method to emit standard error message.

;T;0;;;I"message;F;I"OptionParser::ParseError;T;[o;;I" ;F;I"String;To;;I" ;T;0;;;I"reason;F;I"OptionParser::ParseError;T;[o;;I" ;F;I"untyped;To;;0;0;;;I"reason=;F;I"OptionParser::ParseError;T;[o;;I"untyped;T;I"untyped;To;;I"/Pushes back erred argument(s) to `argv`.

;T;0;;;I"recover;F;I"OptionParser::ParseError;T;[o;;I"untyped argv;T;I"untyped;To;;I" ;T;0;;;I"set_backtrace;F;I"OptionParser::ParseError;T;[o;;I"untyped array;T;I"untyped;To;;I" ;T;0;;;I"set_option;F;I"OptionParser::ParseError;T;[o;;I"untyped opt, untyped eq;T;I"untyped;To;;I" ;T;0;;;I"initialize;F;I"OptionParser::ParseError;T;[o;;I"(*untyped args, ?additional: untyped;T;I"	void;To; ;I"”Individual switch class.  Not important to the user.

Defined within Switch are several Switch-derived classes: NoArgument,
RequiredArgument, etc.

;T;0;	I"OptionParser::Switch;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"uGuesses argument style from `arg`.  Returns corresponding OptionParser::Switch
class (OptionalArgument, etc.).

;T;0;;;I"
guess;F;I"OptionParser::Switch;T;[o;;I"untyped arg;T;I"untyped;To;;I" ;T;0;;;I"!incompatible_argument_styles;F;I"OptionParser::Switch;T;[o;;I"untyped arg, untyped t;T;I"untyped;To;;I" ;T;0;;;I"pattern;F;I"OptionParser::Switch;T;[o;;I" ;F;I"untyped;To;;0;0;;;I"add_banner;F;I"OptionParser::Switch;T;[o;;I"untyped to;T;I"untyped;To;;0;0;;;I"arg;F;I"OptionParser::Switch;T;[o;;I" ;F;I"untyped;To;;0;0;;;I"
block;F;I"OptionParser::Switch;T;[o;;I" ;F;I"untyped;To;;0;0;;;I"compsys;F;I"OptionParser::Switch;T;[o;;I"!untyped sdone, untyped ldone;T;I"untyped;To;;0;0;;;I"	conv;F;I"OptionParser::Switch;T;[o;;I" ;F;I"untyped;To;;0;0;;;I"	desc;F;I"OptionParser::Switch;T;[o;;I" ;F;I"untyped;To;;0;0;;;I"	long;F;I"OptionParser::Switch;T;[o;;I" ;F;I"untyped;To;;0;0;;;I"match_nonswitch?;F;I"OptionParser::Switch;T;[o;;I"untyped str;T;I"untyped;To;;0;0;;;I"pattern;F;I"OptionParser::Switch;T;[o;;I" ;F;I"untyped;To;;0;0;;;I"
short;F;I"OptionParser::Switch;T;[o;;I" ;F;I"untyped;To;;I"îProduces the summary text. Each line of the summary is yielded to the block
(without newline).

`sdone`
:   Already summarized short style options keyed hash.
`ldone`
:   Already summarized long style options keyed hash.
`width`
:   Width of left side (option part). In other words, the right side
    (description part) starts after `width` columns.
`max`
:   Maximum width of left side -> the options are filled within `max` columns.
`indent`
:   Prefix string indents all summarized lines.

;T;0;;;I"summarize;F;I"OptionParser::Switch;T;[o;;I"R?untyped sdone, ?untyped ldone, ?untyped width, ?untyped max, ?untyped indent;T;I"untyped;To;;I"Main name of the switch.

;T;0;;;I"switch_name;F;I"OptionParser::Switch;T;[o;;I" ;F;I"untyped;To;;I"Parses argument, converts and returns `arg`, `block` and result of conversion.
Yields at semi-error condition instead of raising an exception.

;T;0;;;I"conv_arg;F;I"OptionParser::Switch;T;[o;;I"untyped arg, ?untyped val;T;I"untyped;To;;I" ;T;0;;;I"initialize;F;I"OptionParser::Switch;T;[o;;I"p?untyped pattern, ?untyped conv, ?untyped short, ?untyped long, ?untyped arg, ?untyped desc, ?untyped block;T;I"	void;To;;I"†Parses `arg` and returns rest of `arg` and matched portion to the argument
pattern. Yields when the pattern doesn't match substring.

;T;0;;;I"parse_arg;F;I"OptionParser::Switch;T;[o;;I"untyped arg;T;I"untyped;To; ;I"&Switch that takes no arguments.

;T;0;	I"%OptionParser::Switch::NoArgument;T;
[ ;[ ;0;[ ;[ ;0;I"OptionParser::Switch;To;;I" ;T;0;;;I"!incompatible_argument_styles;F;I"%OptionParser::Switch::NoArgument;T;[o;;I"*untyped;T;I"untyped;To;;I" ;T;0;;;I"pattern;F;I"%OptionParser::Switch::NoArgument;T;[o;;I" ;F;I"untyped;To;;I"2Raises an exception if any arguments given.

;T;0;;;I"
parse;F;I"%OptionParser::Switch::NoArgument;T;[o;;I"untyped arg, untyped argv;T;I"untyped;To; ;I"%Switch that can omit argument.

;T;0;	I"+OptionParser::Switch::OptionalArgument;T;
[ ;[ ;0;[ ;[ ;0;I"OptionParser::Switch;To;;I"7Parses argument if given, or uses default value.

;T;0;;;I"
parse;F;I"+OptionParser::Switch::OptionalArgument;T;[o;;I"untyped arg, untyped argv;T;I"untyped;To; ;I"DSwitch that takes an argument, which does not begin with '-'.

;T;0;	I")OptionParser::Switch::PlacedArgument;T;
[ ;[ ;0;[ ;[ ;0;I"OptionParser::Switch;To;;I"AReturns nil if argument is not present or begins with '-'.

;T;0;;;I"
parse;F;I")OptionParser::Switch::PlacedArgument;T;[o;;I"untyped arg, untyped argv;T;I"untyped;To; ;I"%Switch that takes an argument.

;T;0;	I"+OptionParser::Switch::RequiredArgument;T;
[ ;[ ;0;[ ;[ ;0;I"OptionParser::Switch;To;;I"6Raises an exception if argument is not present.

;T;0;;;I"
parse;F;I"+OptionParser::Switch::RequiredArgument;T;[o;;I"untyped arg, untyped argv;T;I"untyped;To; ;I"Pathname represents the name of a file or directory on the filesystem, but not
the file itself.

The pathname depends on the Operating System: Unix, Windows, etc. This library
works with pathnames of local OS, however non-Unix pathnames are supported
experimentally.

A Pathname can be relative or absolute.  It's not until you try to reference
the file that it even matters whether the file exists or not.

Pathname is immutable.  It has no method for destructive update.

The goal of this class is to manipulate file path information in a neater way
than standard Ruby provides.  The examples below demonstrate the difference.

**All** functionality from File, FileTest, and some from Dir and FileUtils is
included, in an unsurprising way.  It is essentially a facade for all of
these, and more.

## Examples

### Example 1: Using Pathname

    require 'pathname'
    pn = Pathname.new("/usr/bin/ruby")
    size = pn.size              # 27662
    isdir = pn.directory?       # false
    dir  = pn.dirname           # Pathname:/usr/bin
    base = pn.basename          # Pathname:ruby
    dir, base = pn.split        # [Pathname:/usr/bin, Pathname:ruby]
    data = pn.read
    pn.open { |f| _ }
    pn.each_line { |line| _ }

### Example 2: Using standard Ruby

    pn = "/usr/bin/ruby"
    size = File.size(pn)        # 27662
    isdir = File.directory?(pn) # false
    dir  = File.dirname(pn)     # "/usr/bin"
    base = File.basename(pn)    # "ruby"
    dir, base = File.split(pn)  # ["/usr/bin", "ruby"]
    data = File.read(pn)
    File.open(pn) { |f| _ }
    File.foreach(pn) { |line| _ }

### Example 3: Special features

    p1 = Pathname.new("/usr/lib")   # Pathname:/usr/lib
    p2 = p1 + "ruby/1.8"            # Pathname:/usr/lib/ruby/1.8
    p3 = p1.parent                  # Pathname:/usr
    p4 = p2.relative_path_from(p3)  # Pathname:lib/ruby/1.8
    pwd = Pathname.pwd              # Pathname:/home/gavin
    pwd.absolute?                   # true
    p5 = Pathname.new "."           # Pathname:.
    p5 = p5 + "music/../articles"   # Pathname:music/../articles
    p5.cleanpath                    # Pathname:articles
    p5.realpath                     # Pathname:/home/gavin/articles
    p5.children                     # [Pathname:/home/gavin/articles/linux, ...]

## Breakdown of functionality

### Core methods

These methods are effectively manipulating a String, because that's all a path
is.  None of these access the file system except for #mountpoint?, #children,
#each_child, #realdirpath and #realpath.

*   +
*   #join
*   #parent
*   #root?
*   #absolute?
*   #relative?
*   #relative_path_from
*   #each_filename
*   #cleanpath
*   #realpath
*   #realdirpath
*   #children
*   #each_child
*   #mountpoint?


### File status predicate methods

These methods are a facade for FileTest:
*   #blockdev?
*   #chardev?
*   #directory?
*   #executable?
*   #executable_real?
*   #exist?
*   #file?
*   #grpowned?
*   #owned?
*   #pipe?
*   #readable?
*   #world_readable?
*   #readable_real?
*   #setgid?
*   #setuid?
*   #size
*   #size?
*   #socket?
*   #sticky?
*   #symlink?
*   #writable?
*   #world_writable?
*   #writable_real?
*   #zero?


### File property and manipulation methods

These methods are a facade for File:
*   #atime
*   #birthtime
*   #ctime
*   #mtime
*   #chmod(mode)
*   #lchmod(mode)
*   #chown(owner, group)
*   #lchown(owner, group)
*   #fnmatch(pattern, *args)
*   #fnmatch?(pattern, *args)
*   #ftype
*   #make_link(old)
*   #open(*args, &block)
*   #readlink
*   #rename(to)
*   #stat
*   #lstat
*   #make_symlink(old)
*   #truncate(length)
*   #utime(atime, mtime)
*   #basename(*args)
*   #dirname
*   #extname
*   #expand_path(*args)
*   #split


### Directory methods

These methods are a facade for Dir:
*   Pathname.glob(*args)
*   Pathname.getwd / Pathname.pwd
*   #rmdir
*   #entries
*   #each_entry(&block)
*   #mkdir(*args)
*   #opendir(*args)


### IO

These methods are a facade for IO:
*   #each_line(*args, &block)
*   #read(*args)
*   #binread(*args)
*   #readlines(*args)
*   #sysopen(*args)
*   #write(*args)
*   #binwrite(*args)


### Utilities

These methods are a mixture of Find, FileUtils, and others:
*   #find(&block)
*   #mkpath
*   #rmtree
*   #unlink / #delete


## Method documentation

As the above section shows, most of the methods in Pathname are facades.  The
documentation for these methods generally just says, for instance, "See
FileTest.writable?", as you should be familiar with the original method
anyway, and its documentation (e.g. through `ri`) will contain more
information.  In some cases, a brief description will follow.

;T;0;	I"Pathname;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"‹Returns the current working directory as a Pathname.

    Pathname.getwd
        #=> #<Pathname:/home/zzak/projects/ruby>

See Dir.getwd.

;T;0;;;I"
getwd;F;I"Pathname;T;[o;;I" ;F;I"Pathname;To;;I"”Returns or yields Pathname objects.

    Pathname.glob("lib/i*.rb")
        #=> [#<Pathname:lib/ipaddr.rb>, #<Pathname:lib/irb.rb>]

See Dir.glob.

;T;0;;;I"	glob;F;I"Pathname;T;[o;;I";::String | ::Array[::String] pattern, ?::Integer flags;T;I"Array[::Pathname];To;;I";::String | ::Array[::String] pattern, ?::Integer flags;T;I"nil;To;;I"‹Returns the current working directory as a Pathname.

    Pathname.getwd
        #=> #<Pathname:/home/zzak/projects/ruby>

See Dir.getwd.

;T;0;;;I"pwd;F;I"Pathname;T;[o;;I" ;F;I"Pathname;To;;I"ÐAppends a pathname fragment to `self` to produce a new Pathname object.

    p1 = Pathname.new("/usr")      # Pathname:/usr
    p2 = p1 + "bin/ruby"           # Pathname:/usr/bin/ruby
    p3 = p1 + "/etc/passwd"        # Pathname:/etc/passwd

    # / is aliased to +.
    p4 = p1 / "bin/ruby"           # Pathname:/usr/bin/ruby
    p5 = p1 / "/etc/passwd"        # Pathname:/etc/passwd

This method doesn't access the file system; it is pure string manipulation.

;T;0;;;I"+;F;I"Pathname;T;[o;;I"+::Pathname | ::String | ::_ToStr other;T;I"Pathname;To;;I"¾Provides a case-sensitive comparison operator for pathnames.

    Pathname.new('/usr') <=> Pathname.new('/usr/bin')
        #=> -1
    Pathname.new('/usr/bin') <=> Pathname.new('/usr/bin')
        #=> 0
    Pathname.new('/usr/bin') <=> Pathname.new('/USR/BIN')
        #=> 1

It will return `-1`, `0` or `1` depending on the value of the left argument
relative to the right argument. Or it will return `nil` if the arguments are
not comparable.

;T;0;;;I"<=>;F;I"Pathname;T;[o;;I"::Pathname other;T;I"Integer;To;;I"untyped other;T;I"nil;To;;I" Compare this pathname with `other`.  The comparison is string-based. Be aware
that two different paths (`foo.txt` and `./foo.txt`) can refer to the same
file.

;T;0;;;I"==;F;I"Pathname;T;[o;;I"untyped;T;I"	bool;To;;I" Compare this pathname with `other`.  The comparison is string-based. Be aware
that two different paths (`foo.txt` and `./foo.txt`) can refer to the same
file.

;T;0;;;I"===;F;I"Pathname;T;[o;;I"untyped;T;I"	bool;To;;I"üPredicate method for testing whether a path is absolute.

It returns `true` if the pathname begins with a slash.

    p = Pathname.new('/im/sure')
    p.absolute?
        #=> true

    p = Pathname.new('not/so/sure')
    p.absolute?
        #=> false

;T;0;;;I"absolute?;F;I"Pathname;T;[o;;I" ;F;I"	bool;To;;I"áIterates over and yields a new Pathname object for each element in the given
path in ascending order.

    Pathname.new('/path/to/some/file.rb').ascend {|v| p v}
       #<Pathname:/path/to/some/file.rb>
       #<Pathname:/path/to/some>
       #<Pathname:/path/to>
       #<Pathname:/path>
       #<Pathname:/>

    Pathname.new('path/to/some/file.rb').ascend {|v| p v}
       #<Pathname:path/to/some/file.rb>
       #<Pathname:path/to/some>
       #<Pathname:path/to>
       #<Pathname:path>

Returns an Enumerator if no block was given.

    enum = Pathname.new("/usr/bin/ruby").ascend
      # ... do stuff ...
    enum.each { |e| ... }
      # yields Pathnames /usr/bin/ruby, /usr/bin, /usr, and /.

It doesn't access the filesystem.

;T;0;;;I"ascend;F;I"Pathname;T;[o;;I" ;F;I"nil;To;;I" ;F;I" Enumerator[::Pathname, nil];To;;I"BReturns the last access time for the file.

See File.atime.

;T;0;;;I"
atime;F;I"Pathname;T;[o;;I" ;F;I"	Time;To;;I"BReturns the last component of the path.

See File.basename.

;T;0;;;I"basename;F;I"Pathname;T;[o;;I" ?::String | ::_ToStr suffix;T;I"Pathname;To;;I"]Returns all the bytes from the file, or the first `N` if specified.

See File.binread.

;T;0;;;I"binread;F;I"Pathname;T;[o;;I")?::Integer length, ?::Integer offset;T;I"String;To;;I"TWrites `contents` to the file, opening it in binary mode.

See File.binwrite.

;T;0;;;I"binwrite;F;I"Pathname;T;[o;;I"´::String, ?::Integer offset, ?mode: ::Integer | ::String, ?flags: ::Integer, ?external_encoding: ::encoding, ?internal_encoding: ::encoding, ?encoding: ::encoding, ?textmode: ::boolish, ?binmode: ::boolish, ?autoclose: ::boolish, ?invalid: :replace ?, ?undef: :replace ?, ?replace: ::String, ?fallback: ::Hash[::String, ::String] | ::Proc | ::Method, ?xml: :text | :attr, ?universal_newline: true, ?cr_newline: true, ?crlf_newline: true;T;I"Integer;To;;I"Returns the birth time for the file. If the platform doesn't have birthtime,
raises NotImplementedError.

See File.birthtime.

;T;0;;;I"birthtime;F;I"Pathname;T;[o;;I" ;F;I"	Time;To;;I"See FileTest.blockdev?.

;T;0;;;I"blockdev?;F;I"Pathname;T;[o;;I" ;F;I"	bool;To;;I"See FileTest.chardev?.

;T;0;;;I"chardev?;F;I"Pathname;T;[o;;I" ;F;I"	bool;To;;I"èReturns the children of the directory (files and subdirectories, not
recursive) as an array of Pathname objects.

By default, the returned pathnames will have enough information to access the
files. If you set `with_directory` to `false`, then the returned pathnames
will contain the filename only.

For example:
    pn = Pathname("/usr/lib/ruby/1.8")
    pn.children
        # -> [ Pathname:/usr/lib/ruby/1.8/English.rb,
               Pathname:/usr/lib/ruby/1.8/Env.rb,
               Pathname:/usr/lib/ruby/1.8/abbrev.rb, ... ]
    pn.children(false)
        # -> [ Pathname:English.rb, Pathname:Env.rb, Pathname:abbrev.rb, ... ]

Note that the results never contain the entries `.` and `..` in the directory
because they are not children.

;T;0;;;I"children;F;I"Pathname;T;[o;;I"?::boolish with_directory;T;I"Array[::Pathname];To;;I"1Changes file permissions.

See File.chmod.

;T;0;;;I"
chmod;F;I"Pathname;T;[o;;I"::Integer mode_int;T;I"Integer;To;;I";Change owner and group of the file.

See File.chown.

;T;0;;;I"
chown;F;I"Pathname;T;[o;;I"%::Integer owner, ::Integer group;T;I"Integer;To;;I"{Returns clean pathname of `self` with consecutive slashes and useless dots
removed.  The filesystem is not accessed.

If `consider_symlink` is `true`, then a more conservative algorithm is used to
avoid breaking symbolic linkages.  This may retain more `..` entries than
absolutely necessary, but without accessing the filesystem, this can't be
avoided.

See Pathname#realpath.

;T;0;;;I"cleanpath;F;I"Pathname;T;[o;;I" ?::boolish consider_symlink;T;I"Pathname;To;;I"gReturns the last change time, using directory information, not the file
itself.

See File.ctime.

;T;0;;;I"
ctime;F;I"Pathname;T;[o;;I" ;F;I"	Time;To;;I"fRemoves a file or directory, using File.unlink if `self` is a file, or
Dir.unlink as necessary.

;T;0;;;I"delete;F;I"Pathname;T;[o;;I" ;F;I"Integer;To;;I"åIterates over and yields a new Pathname object for each element in the given
path in descending order.

    Pathname.new('/path/to/some/file.rb').descend {|v| p v}
       #<Pathname:/>
       #<Pathname:/path>
       #<Pathname:/path/to>
       #<Pathname:/path/to/some>
       #<Pathname:/path/to/some/file.rb>

    Pathname.new('path/to/some/file.rb').descend {|v| p v}
       #<Pathname:path>
       #<Pathname:path/to>
       #<Pathname:path/to/some>
       #<Pathname:path/to/some/file.rb>

Returns an Enumerator if no block was given.

    enum = Pathname.new("/usr/bin/ruby").descend
      # ... do stuff ...
    enum.each { |e| ... }
      # yields Pathnames /, /usr, /usr/bin, and /usr/bin/ruby.

It doesn't access the filesystem.

;T;0;;;I"descend;F;I"Pathname;T;[o;;I" ;F;I"nil;To;;I" ;F;I" Enumerator[::Pathname, nil];To;;I"See FileTest.directory?.

;T;0;;;I"directory?;F;I"Pathname;T;[o;;I" ;F;I"	bool;To;;I"IReturns all but the last component of the path.

See File.dirname.

;T;0;;;I"dirname;F;I"Pathname;T;[o;;I" ;F;I"Pathname;To;;I"Iterates over the children of the directory (files and subdirectories, not
recursive).

It yields Pathname object for each child.

By default, the yielded pathnames will have enough information to access the
files.

If you set `with_directory` to `false`, then the returned pathnames will
contain the filename only.

    Pathname("/usr/local").each_child {|f| p f }
    #=> #<Pathname:/usr/local/share>
    #   #<Pathname:/usr/local/bin>
    #   #<Pathname:/usr/local/games>
    #   #<Pathname:/usr/local/lib>
    #   #<Pathname:/usr/local/include>
    #   #<Pathname:/usr/local/sbin>
    #   #<Pathname:/usr/local/src>
    #   #<Pathname:/usr/local/man>

    Pathname("/usr/local").each_child(false) {|f| p f }
    #=> #<Pathname:share>
    #   #<Pathname:bin>
    #   #<Pathname:games>
    #   #<Pathname:lib>
    #   #<Pathname:include>
    #   #<Pathname:sbin>
    #   #<Pathname:src>
    #   #<Pathname:man>

Note that the results never contain the entries `.` and `..` in the directory
because they are not children.

See Pathname#children

;T;0;;;I"each_child;F;I"Pathname;T;[o;;I"?::boolish with_directory;T;I"Array[::Pathname];To;;I"?::boolish with_directory;T;I"0Enumerator[::Pathname, ::Array[::Pathname]];To;;I"xIterates over the entries (files and subdirectories) in the directory,
yielding a Pathname object for each entry.

;T;0;;;I"each_entry;F;I"Pathname;T;[o;;I" ;F;I"nil;To;;I"YIterates over each component of the path.

    Pathname.new("/usr/bin/ruby").each_filename {|filename| ... }
      # yields "usr", "bin", and "ruby".

Returns an Enumerator if no block was given.

    enum = Pathname.new("/usr/bin/ruby").each_filename
      # ... do stuff ...
    enum.each { |e| ... }
      # yields "usr", "bin", and "ruby".

;T;0;;;I"each_filename;F;I"Pathname;T;[o;;I" ;F;I"nil;To;;I" ;F;I"Enumerator[::String, nil];To;;I"OIterates over each line in the file and yields a String object for each.

;T;0;;;I"each_line;F;I"Pathname;T;[	o;;I"û?::String sep, ?::Integer limit, ?mode: ::Integer | ::String, ?flags: ::Integer, ?external_encoding: ::encoding, ?internal_encoding: ::encoding, ?encoding: ::encoding, ?textmode: ::boolish, ?binmode: ::boolish, ?autoclose: ::boolish, ?chomp: ::boolish;T;I"nil;To;;I"ë::Integer limit, ?mode: ::Integer | ::String, ?flags: ::Integer, ?external_encoding: ::encoding, ?internal_encoding: ::encoding, ?encoding: ::encoding, ?textmode: ::boolish, ?binmode: ::boolish, ?autoclose: ::boolish, ?chomp: ::boolish;T;I"nil;To;;I"û?::String sep, ?::Integer limit, ?mode: ::Integer | ::String, ?flags: ::Integer, ?external_encoding: ::encoding, ?internal_encoding: ::encoding, ?encoding: ::encoding, ?textmode: ::boolish, ?binmode: ::boolish, ?autoclose: ::boolish, ?chomp: ::boolish;T;I"Enumerator[::String, nil];To;;I"ë::Integer limit, ?mode: ::Integer | ::String, ?flags: ::Integer, ?external_encoding: ::encoding, ?internal_encoding: ::encoding, ?encoding: ::encoding, ?textmode: ::boolish, ?binmode: ::boolish, ?autoclose: ::boolish, ?chomp: ::boolish;T;I"Enumerator[::String, nil];To;;I"DTests the file is empty.

See Dir#empty? and FileTest.empty?.

;T;0;;;I"empty?;F;I"Pathname;T;[o;;I" ;F;I"	bool;To;;I"ÐReturn the entries (files and subdirectories) in the directory, each as a
Pathname object.

The results contains just the names in the directory, without any trailing
slashes or recursive look-up.

    pp Pathname.new('/usr/local').entries
    #=> [#<Pathname:share>,
    #    #<Pathname:lib>,
    #    #<Pathname:..>,
    #    #<Pathname:include>,
    #    #<Pathname:etc>,
    #    #<Pathname:bin>,
    #    #<Pathname:man>,
    #    #<Pathname:games>,
    #    #<Pathname:.>,
    #    #<Pathname:sbin>,
    #    #<Pathname:src>]

The result may contain the current directory `#<Pathname:.>` and the parent
directory `#<Pathname:..>`.

If you don't want `.` and `..` and want directories, consider
Pathname#children.

;T;0;;;I"entries;F;I"Pathname;T;[o;;I" ;F;I"Array[::Pathname];To;;I" Compare this pathname with `other`.  The comparison is string-based. Be aware
that two different paths (`foo.txt` and `./foo.txt`) can refer to the same
file.

;T;0;;;I"	eql?;F;I"Pathname;T;[o;;I"untyped;T;I"	bool;To;;I" See FileTest.executable?.

;T;0;;;I"executable?;F;I"Pathname;T;[o;;I" ;F;I"	bool;To;;I"%See FileTest.executable_real?.

;T;0;;;I"executable_real?;F;I"Pathname;T;[o;;I" ;F;I"	bool;To;;I"See FileTest.exist?.

;T;0;;;I"exist?;F;I"Pathname;T;[o;;I" ;F;I"	bool;To;;I"EReturns the absolute path for the file.

See File.expand_path.

;T;0;;;I"expand_path;F;I"Pathname;T;[o;;I"?::String dir;T;I"Pathname;To;;I"7Returns the file's extension.

See File.extname.

;T;0;;;I"extname;F;I"Pathname;T;[o;;I" ;F;I"String;To;;I"See FileTest.file?.

;T;0;;;I"
file?;F;I"Pathname;T;[o;;I" ;F;I"	bool;To;;I"Iterates over the directory tree in a depth first manner, yielding a Pathname
for each file under "this" directory.

Returns an Enumerator if no block is given.

Since it is implemented by the standard library module Find, Find.prune can be
used to control the traversal.

If `self` is `.`, yielded pathnames begin with a filename in the current
directory, not `./`.

See Find.find

;T;0;;;I"	find;F;I"Pathname;T;[o;;I"?ignore_error: ::boolish;T;I"nil;To;;I"?ignore_error: ::boolish;T;I" Enumerator[::Pathname, nil];To;;I"RReturn `true` if the receiver matches the given pattern.

See File.fnmatch.

;T;0;;;I"fnmatch;F;I"Pathname;T;[o;;I"'::String pattern, ?::Integer flags;T;I"	bool;To;;I"1Freezes this Pathname.

See Object.freeze.

;T;0;;;I"freeze;F;I"Pathname;T;[o;;I" ;F;I"Pathname;To;;I"JReturns "type" of file ("file", "directory", etc).

See File.ftype.

;T;0;;;I"
ftype;F;I"Pathname;T;[o;;I" ;F;I"String;To;;I"èReturns or yields Pathname objects.

    Pathname("ruby-2.4.2").glob("R*.md")
    #=> [#<Pathname:ruby-2.4.2/README.md>, #<Pathname:ruby-2.4.2/README.ja.md>]

See Dir.glob. This method uses the `base` keyword argument of Dir.glob.

;T;0;;;I"	glob;F;I"Pathname;T;[o;;I";::String | ::Array[::String] pattern, ?::Integer flags;T;I"Array[::Pathname];To;;I";::String | ::Array[::String] pattern, ?::Integer flags;T;I"nil;To;;I"See FileTest.grpowned?.

;T;0;;;I"grpowned?;F;I"Pathname;T;[o;;I" ;F;I"	bool;To;;0;0;;;I"	hash;F;I"Pathname;T;[o;;I" ;F;I"Integer;To;;0;0;;;I"inspect;F;I"Pathname;T;[o;;I" ;F;I"String;To;;I"XJoins the given pathnames onto `self` to create a new Pathname object.

    path0 = Pathname.new("/usr")                # Pathname:/usr
    path0 = path0.join("bin/ruby")              # Pathname:/usr/bin/ruby
        # is the same as
    path1 = Pathname.new("/usr") + "bin/ruby"   # Pathname:/usr/bin/ruby
    path0 == path1
        #=> true

;T;0;;;I"	join;F;I"Pathname;T;[o;;I"+*::String | ::_ToStr | ::Pathname args;T;I"Pathname;To;;I"TSame as Pathname.chmod, but does not follow symbolic links.

See File.lchmod.

;T;0;;;I"lchmod;F;I"Pathname;T;[o;;I"::Integer mode;T;I"Integer;To;;I"TSame as Pathname.chown, but does not follow symbolic links.

See File.lchown.

;T;0;;;I"lchown;F;I"Pathname;T;[o;;I"%::Integer owner, ::Integer group;T;I"Integer;To;;I"See File.lstat.

;T;0;;;I"
lstat;F;I"Pathname;T;[o;;I" ;F;I"File::Stat;To;;I"9Creates a hard link at *pathname*.

See File.link.

;T;0;;;I"make_link;F;I"Pathname;T;[o;;I")::String | ::Pathname | ::_ToStr old;T;I"Integer;To;;I"2Creates a symbolic link.

See File.symlink.

;T;0;;;I"make_symlink;F;I"Pathname;T;[o;;I")::String | ::Pathname | ::_ToStr old;T;I"Integer;To;;I"7Create the referenced directory.

See Dir.mkdir.

;T;0;;;I"
mkdir;F;I"Pathname;T;[o;;I"?::Integer perm;T;I"Integer;To;;I"Creates a full path, including any intermediate directories that don't yet
exist.

See FileUtils.mkpath and FileUtils.mkdir_p

;T;0;;;I"mkpath;F;I"Pathname;T;[o;;I" ;F;I"nil;To;;I"7Returns `true` if `self` points to a mountpoint.

;T;0;;;I"mountpoint?;F;I"Pathname;T;[o;;I" ;F;I"	bool;To;;I"CReturns the last modified time of the file.

See File.mtime.

;T;0;;;I"
mtime;F;I"Pathname;T;[o;;I" ;F;I"	Time;To;;I"=Opens the file for reading or writing.

See File.open.

;T;0;;;I"	open;F;I"Pathname;T;[o;;I"(?::string | ::int mode, ?::int perm;T;I"	File;To;;I"(?::string | ::int mode, ?::int perm;T;I"T;Fo;;I"5Opens the referenced directory.

See Dir.open.

;T;0;;;I"opendir;F;I"Pathname;T;[o;;I" ;F;I"Dir;To;;I" ;F;I"U;Fo;;I"See FileTest.owned?.

;T;0;;;I"owned?;F;I"Pathname;T;[o;;I" ;F;I"	bool;To;;I"DReturns the parent directory.

This is same as `self + '..'`.

;T;0;;;I"parent;F;I"Pathname;T;[o;;I" ;F;I"Pathname;To;;I"See FileTest.pipe?.

;T;0;;;I"
pipe?;F;I"Pathname;T;[o;;I" ;F;I"	bool;To;;I"[Returns all data from the file, or the first `N` bytes if specified.

See File.read.

;T;0;;;I"	read;F;I"Pathname;T;[o;;I"í?::Integer length, ?::Integer offset, ?mode: ::Integer | ::String, ?flags: ::Integer, ?external_encoding: ::encoding, ?internal_encoding: ::encoding, ?encoding: ::encoding, ?textmode: ::boolish, ?binmode: ::boolish, ?autoclose: ::boolish;T;I"String;To;;I"See FileTest.readable?.

;T;0;;;I"readable?;F;I"Pathname;T;[o;;I" ;F;I"	bool;To;;I"#See FileTest.readable_real?.

;T;0;;;I"readable_real?;F;I"Pathname;T;[o;;I" ;F;I"	bool;To;;I"@Returns all the lines from the file.

See File.readlines.

;T;0;;;I"readlines;F;I"Pathname;T;[o;;I"û?::String sep, ?::Integer limit, ?mode: ::Integer | ::String, ?flags: ::Integer, ?external_encoding: ::encoding, ?internal_encoding: ::encoding, ?encoding: ::encoding, ?textmode: ::boolish, ?binmode: ::boolish, ?autoclose: ::boolish, ?chomp: ::boolish;T;I"Array[::String];To;;I"ë::Integer limit, ?mode: ::Integer | ::String, ?flags: ::Integer, ?external_encoding: ::encoding, ?internal_encoding: ::encoding, ?encoding: ::encoding, ?textmode: ::boolish, ?binmode: ::boolish, ?autoclose: ::boolish, ?chomp: ::boolish;T;I"Array[::String];To;;I".Read symbolic link.

See File.readlink.

;T;0;;;I"readlink;F;I"Pathname;T;[o;;I" ;F;I"untyped;To;;I"ÁReturns the real (absolute) pathname of `self` in the actual filesystem.

Does not contain symlinks or useless dots, `..` and `.`.

The last component of the real pathname can be nonexistent.

;T;0;;;I"realdirpath;F;I"Pathname;T;[o;;I"$?::string | ::Pathname base_dir;T;I"Pathname;To;;I"ÌReturns the real (absolute) pathname for `self` in the actual filesystem.

Does not contain symlinks or useless dots, `..` and `.`.

All components of the pathname must exist when this method is called.

;T;0;;;I"realpath;F;I"Pathname;T;[o;;I"$?::string | ::Pathname base_dir;T;I"Pathname;To;;I"çThe opposite of Pathname#absolute?

It returns `false` if the pathname begins with a slash.

    p = Pathname.new('/im/sure')
    p.relative?
        #=> false

    p = Pathname.new('not/so/sure')
    p.relative?
        #=> true

;T;0;;;I"relative?;F;I"Pathname;T;[o;;I" ;F;I"	bool;To;;I"æReturns a relative path from the given `base_directory` to the receiver.

If `self` is absolute, then `base_directory` must be absolute too.

If `self` is relative, then `base_directory` must be relative too.

This method doesn't access the filesystem.  It assumes no symlinks.

ArgumentError is raised when it cannot find a relative path.

Note that this method does not handle situations where the case sensitivity of
the filesystem in use differs from the operating system default.

;T;0;;;I"relative_path_from;F;I"Pathname;T;[o;;I")::Pathname | ::string base_directory;T;I"Pathname;To;;I")Rename the file.

See File.rename.

;T;0;;;I"rename;F;I"Pathname;T;[o;;I"#::Pathname | ::string new_name;T;I"0;Fo;;I"7Remove the referenced directory.

See Dir.rmdir.

;T;0;;;I"
rmdir;F;I"Pathname;T;[o;;I" ;F;I"0;Fo;;I"aRecursively deletes a directory, including all directories beneath it.

See FileUtils.rm_r

;T;0;;;I"rmtree;F;I"Pathname;T;[o;;I" ;F;I"	void;To;;I"âPredicate method for root directories.  Returns `true` if the pathname
consists of consecutive slashes.

It doesn't access the filesystem.  So it may return `false` for some pathnames
which points to roots such as `/usr/..`.

;T;0;;;I"
root?;F;I"Pathname;T;[o;;I" ;F;I"	bool;To;;I"See FileTest.setgid?.

;T;0;;;I"setgid?;F;I"Pathname;T;[o;;I" ;F;I"	bool;To;;I"See FileTest.setuid?.

;T;0;;;I"setuid?;F;I"Pathname;T;[o;;I" ;F;I"	bool;To;;I"See FileTest.size.

;T;0;;;I"	size;F;I"Pathname;T;[o;;I" ;F;I"Integer;To;;I"See FileTest.size?.

;T;0;;;I"
size?;F;I"Pathname;T;[o;;I" ;F;I"Integer?;To;;I"See FileTest.socket?.

;T;0;;;I"socket?;F;I"Pathname;T;[o;;I" ;F;I"untyped;To;;I"KReturns the #dirname and the #basename in an Array.

See File.split.

;T;0;;;I"
split;F;I"Pathname;T;[o;;I" ;F;I"[ ::Pathname, ::Pathname ];To;;I"3Returns a File::Stat object.

See File.stat.

;T;0;;;I"	stat;F;I"Pathname;T;[o;;I" ;F;I"File::Stat;To;;I"See FileTest.sticky?.

;T;0;;;I"sticky?;F;I"Pathname;T;[o;;I" ;F;I"untyped;To;;I"¦Return a pathname which is substituted by String#sub.

    path1 = Pathname.new('/usr/bin/perl')
    path1.sub('perl', 'ruby')
        #=> #<Pathname:/usr/bin/ruby>

;T;0;;;I"sub;F;I"Pathname;T;[o;;I"S::Regexp | ::string pattern, ::string | ::Hash[::String, ::String] replacement;T;I"Pathname;To;;I" ::Regexp | ::string pattern;T;I"Pathname;To;;I"ÙReturn a pathname with `repl` added as a suffix to the basename.

If self has no extension part, `repl` is appended.

    Pathname.new('/usr/bin/shutdown').sub_ext('.rb')
        #=> #<Pathname:/usr/bin/shutdown.rb>

;T;0;;;I"sub_ext;F;I"Pathname;T;[o;;I"::string replacement;T;I"Pathname;To;;I"See FileTest.symlink?.

;T;0;;;I"symlink?;F;I"Pathname;T;[o;;I" ;F;I"untyped;To;;I"See IO.sysopen.

;T;0;;;I"sysopen;F;I"Pathname;T;[o;;I"$?::String mode, ?::Integer perm;T;I"Integer;To;;I"TReturns pathname.  This method is deprecated and will be removed in Ruby 3.2.

;T;0;;;I"
taint;F;I"Pathname;T;[o;;I" ;F;I"Pathname;To;;I"oReturn the path as a String.

to_path is implemented so Pathname objects are usable with File.open, etc.

;T;0;;;I"to_path;F;I"Pathname;T;[o;;I" ;F;I"String;To;;I"@Truncates the file to `length` bytes.

See File.truncate.

;T;0;;;I"truncate;F;I"Pathname;T;[o;;I"::Integer length;T;I"0;Fo;;I"fRemoves a file or directory, using File.unlink if `self` is a file, or
Dir.unlink as necessary.

;T;0;;;I"unlink;F;I"Pathname;T;[o;;I" ;F;I"Integer;To;;I"TReturns pathname.  This method is deprecated and will be removed in Ruby 3.2.

;T;0;;;I"untaint;F;I"Pathname;T;[o;;I" ;F;I"Pathname;To;;I"MUpdate the access and modification times of the file.

See File.utime.

;T;0;;;I"
utime;F;I"Pathname;T;[o;;I"7::Integer | ::Time atime, ::Integer | ::Time mtime;T;I"Integer;To;;I"$See FileTest.world_readable?.

;T;0;;;I"world_readable?;F;I"Pathname;T;[o;;I" ;F;I"Integer | nil;To;;I"$See FileTest.world_writable?.

;T;0;;;I"world_writable?;F;I"Pathname;T;[o;;I" ;F;I"Integer | nil;To;;I"See FileTest.writable?.

;T;0;;;I"writable?;F;I"Pathname;T;[o;;I" ;F;I"	bool;To;;I"#See FileTest.writable_real?.

;T;0;;;I"writable_real?;F;I"Pathname;T;[o;;I" ;F;I"	bool;To;;I"6Writes `contents` to the file.

See File.write.

;T;0;;;I"
write;F;I"Pathname;T;[o;;I"ì::String content, ?::Integer offset, ?mode: ::Integer | ::String, ?flags: ::Integer, ?external_encoding: ::encoding, ?internal_encoding: ::encoding, ?encoding: ::encoding, ?textmode: ::boolish, ?binmode: ::boolish, ?autoclose: ::boolish;T;I"Integer;To;;I"See FileTest.zero?.

;T;0;;;I"
zero?;F;I"Pathname;T;[o;;I" ;F;I"	bool;To;;0;0;;;I"add_trailing_separator;F;I"Pathname;T;[o;;I"untyped path;T;I"untyped;To;;0;0;;;I"chop_basename;F;I"Pathname;T;[o;;I"untyped path;T;I"untyped;To;;0;0;;;I"cleanpath_aggressive;F;I"Pathname;T;[o;;I" ;F;I"untyped;To;;0;0;;;I"cleanpath_conservative;F;I"Pathname;T;[o;;I" ;F;I"untyped;To;;0;0;;;I"del_trailing_separator;F;I"Pathname;T;[o;;I"untyped path;T;I"untyped;To;;0;0;;;I"has_trailing_separator?;F;I"Pathname;T;[o;;I"untyped path;T;I"untyped;To;;I"‘Create a Pathname object from the given String (or String-like object). If
`path` contains a NULL character (`\0`), an ArgumentError is raised.

;T;0;;;I"initialize;F;I"Pathname;T;[o;;I"::string | ::Pathname;T;I"	void;To;;0;0;;;I"	plus;F;I"Pathname;T;[o;;I"!untyped path1, untyped path2;T;I"untyped;To;;0;0;;;I"prepend_prefix;F;I"Pathname;T;[o;;I"$untyped prefix, untyped relpath;T;I"untyped;To;;0;0;;;I"split_names;F;I"Pathname;T;[o;;I"untyped path;T;I"untyped;To; ;I"This class implements a pretty printing algorithm. It finds line breaks and
nice indentations for grouped structure.

By default, the class assumes that primitive elements are strings and each
byte in the strings have single column in width. But it can be used for other
situations by giving suitable arguments for some methods:
*   newline object and space generation block for PrettyPrint.new
*   optional width argument for PrettyPrint#text
*   PrettyPrint#breakable


There are several candidate uses:
*   text formatting using proportional fonts
*   multibyte characters which has columns different to number of bytes
*   non-string formatting


## Bugs
*   Box based formatting?
*   Other (better) model/algorithm?


Report any bugs at http://bugs.ruby-lang.org

## References
Christian Lindig, Strictly Pretty, March 2000,
http://www.st.cs.uni-sb.de/~lindig/papers/#pretty

Philip Wadler, A prettier printer, March 1998,
http://homepages.inf.ed.ac.uk/wadler/topics/language-design.html#prettier

## Author
Tanaka Akira <akr@fsij.org>

;T;0;	I"PrettyPrint;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"°This is a convenience method which is same as follows:

    begin
      q = PrettyPrint.new(output, maxwidth, newline, &genspace)
      ...
      q.flush
      output
    end

;T;0;;;I"format;F;I"PrettyPrint;T;[o;;I"a?untyped output, ?::Integer maxwidth, ?::String newline, ?^(::Integer) -> ::Integer genspace;T;I"PrettyPrint::_Output;To;;I"êThis is similar to PrettyPrint::format but the result has no breaks.

`maxwidth`, `newline` and `genspace` are ignored.

The invocation of `breakable` in the block doesn't break a line and is treated
as just an invocation of `text`.

;T;0;;;I"singleline_format;F;I"PrettyPrint;T;[o;;I"d?untyped output, ?::Integer? maxwidth, ?::String? newline, ?^(::Integer) -> ::Integer? genspace;T;I"PrettyPrint::_Output;To;;I"©Creates a buffer for pretty printing.

`output` is an output target. If it is not specified, '' is assumed. It should
have a << method which accepts the first argument `obj` of PrettyPrint#text,
the first argument `sep` of PrettyPrint#breakable, the first argument
`newline` of PrettyPrint.new, and the result of a given block for
PrettyPrint.new.

`maxwidth` specifies maximum line length. If it is not specified, 79 is
assumed. However actual outputs may overflow `maxwidth` if long non-breakable
texts are provided.

`newline` is used for line breaks. "n" is used if it is not specified.

The block is used to generate spaces. {|width| ' ' * width} is used if it is
not given.

;T;0;;;I"initialize;F;I"PrettyPrint;T;[o;;I"a?untyped output, ?::Integer maxwidth, ?::String newline, ?^(::Integer) -> ::Integer genspace;T;I"	void;To;;I"JReturns the group most recently added to the stack.

Contrived example:
    out = ""
    => ""
    q = PrettyPrint.new(out)
    => #<PrettyPrint:0x82f85c0 @output="", @maxwidth=79, @newline="\n", @genspace=#<Proc:0x82f8368@/home/vbatts/.rvm/rubies/ruby-head/lib/ruby/2.0.0/prettyprint.rb:82 (lambda)>, @output_width=0, @buffer_width=0, @buffer=[], @group_stack=[#<PrettyPrint::Group:0x82f8138 @depth=0, @breakables=[], @break=false>], @group_queue=#<PrettyPrint::GroupQueue:0x82fb7c0 @queue=[[#<PrettyPrint::Group:0x82f8138 @depth=0, @breakables=[], @break=false>]]>, @indent=0>
    q.group {
      q.text q.current_group.inspect
      q.text q.newline
      q.group(q.current_group.depth + 1) {
        q.text q.current_group.inspect
        q.text q.newline
        q.group(q.current_group.depth + 1) {
          q.text q.current_group.inspect
          q.text q.newline
          q.group(q.current_group.depth + 1) {
            q.text q.current_group.inspect
            q.text q.newline
          }
        }
      }
    }
    => 284
     puts out
    #<PrettyPrint::Group:0x8354758 @depth=1, @breakables=[], @break=false>
    #<PrettyPrint::Group:0x8354550 @depth=2, @breakables=[], @break=false>
    #<PrettyPrint::Group:0x83541cc @depth=3, @breakables=[], @break=false>
    #<PrettyPrint::Group:0x8347e54 @depth=4, @breakables=[], @break=false>

;T;0;;;I"current_group;F;I"PrettyPrint;T;[o;;I" ;F;I"PrettyPrint::Group;To;;I"CBreaks the buffer into lines that are shorter than #maxwidth

;T;0;;;I"break_outmost_groups;F;I"PrettyPrint;T;[o;;I" ;F;I"untyped;To;;I"oThis adds `obj` as a text of `width` columns in width.

If `width` is not specified, obj.length is used.

;T;0;;;I"	text;F;I"PrettyPrint;T;[o;;I"#::String obj, ?::Integer width;T;I"	void;To;;I"SThis is similar to #breakable except the decision to break or not is
determined individually.

Two #fill_breakable under a group may cause 4 results: (break,break),
(break,non-break), (non-break,break), (non-break,non-break). This is different
to #breakable because two #breakable under a group may cause 2 results:
(break,break), (non-break,non-break).

The text `sep` is inserted if a line is not broken at this point.

If `sep` is not specified, " " is used.

If `width` is not specified, `sep.length` is used. You will have to specify
this when `sep` is a multibyte character, for example.

;T;0;;;I"fill_breakable;F;I"PrettyPrint;T;[o;;I"$?::String sep, ?::Integer width;T;I"	void;To;;I"4This says "you can break a line here if necessary", and a `width`-column text
`sep` is inserted if a line is not broken at the point.

If `sep` is not specified, " " is used.

If `width` is not specified, `sep.length` is used. You will have to specify
this when `sep` is a multibyte character, for example.

;T;0;;;I"breakable;F;I"PrettyPrint;T;[o;;I"$?::String sep, ?::Integer width;T;I"	void;To;;I"`Groups line break hints added in the block. The line break hints are all to be
used or not.

If `indent` is specified, the method call is regarded as nested by
nest(indent) { ... }.

If `open_obj` is specified, `text open_obj, open_width` is called before
grouping. If `close_obj` is specified, `text close_obj, close_width` is called
after grouping.

;T;0;;;I"
group;F;I"PrettyPrint;T;[o;;I"n?::Integer indent, ?::String open_obj, ?::String close_obj, ?::Integer open_width, ?::Integer close_width;T;I"Integer;To;;I"MTakes a block and queues a new group that is indented 1 level further.

;T;0;;;I"group_sub;F;I"PrettyPrint;T;[o;;I" ;F;I"untyped;To;;I"\Increases left margin after newline with `indent` for line breaks added in the
block.

;T;0;;;I"	nest;F;I"PrettyPrint;T;[o;;I"::Integer indent;T;I"	void;To;;I"outputs buffered data.

;T;0;;;I"
flush;F;I"PrettyPrint;T;[o;;I" ;F;I"Integer;To; ;0;0;	I"PrettyPrint::Text;T;
[ ;[ ;0;[ ;[ ;0;0o;;0;0;;;I"initialize;F;I"PrettyPrint::Text;T;[o;;I" ;F;I"	void;To;;0;0;;;I"output;F;I"PrettyPrint::Text;T;[o;;I"(untyped `out`, untyped output_width;T;I"untyped;To;;0;0;;;I"add;F;I"PrettyPrint::Text;T;[o;;I"!untyped obj, ::Integer width;T;I"	void;To; ;0;0;	I"PrettyPrint::Breakable;T;
[ ;[ ;0;[ ;[ ;0;0o;;0;0;;;I"initialize;F;I"PrettyPrint::Breakable;T;[o;;I"3::String sep, ::Integer width, ::PrettyPrint q;T;I"	void;To;;0;0;;;I"output;F;I"PrettyPrint::Breakable;T;[o;;I"*untyped `out`, ::Integer output_width;T;I"untyped;To; ;0;0;	I"PrettyPrint::Group;T;
[ ;[ ;0;[ ;[ ;0;0o;;0;0;;;I"initialize;F;I"PrettyPrint::Group;T;[o;;I"untyped depth;T;I"	void;To;;0;0;;;I"
break;F;I"PrettyPrint::Group;T;[o;;I" ;F;I"	bool;To;;0;0;;;I"break?;F;I"PrettyPrint::Group;T;[o;;I" ;F;I"	bool;To;;0;0;;;I"first?;F;I"PrettyPrint::Group;T;[o;;I" ;F;I"	bool;To; ;0;0;	I"PrettyPrint::GroupQueue;T;
[ ;[ ;0;[ ;[ ;0;0o;;0;0;;;I"initialize;F;I"PrettyPrint::GroupQueue;T;[o;;I"*untyped groups;T;I"	void;To;;0;0;;;I"enq;F;I"PrettyPrint::GroupQueue;T;[o;;I"untyped group;T;I"	void;To;;0;0;;;I"deq;F;I"PrettyPrint::GroupQueue;T;[o;;I" ;F;I"PrettyPrint::Group | nil;To;;0;0;;;I"delete;F;I"PrettyPrint::GroupQueue;T;[o;;I"::PrettyPrint::Group group;T;I"	void;To; ;I"PrettyPrint::SingleLine is used by PrettyPrint.singleline_format

It is passed to be similar to a PrettyPrint object itself, by responding to:
*   #text
*   #breakable
*   #nest
*   #group
*   #flush
*   #first?


but instead, the output has no line breaks

;T;0;	I"PrettyPrint::SingleLine;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"cCreate a PrettyPrint::SingleLine object

Arguments:
*   `output` - String (or similar) to store rendered text. Needs to respond to
    '<<'
*   `maxwidth` - Argument position expected to be here for compatibility.
        This argument is a noop.

*   `newline` - Argument position expected to be here for compatibility.
        This argument is a noop.

;T;0;;;I"initialize;F;I"PrettyPrint::SingleLine;T;[o;;I"H::String | untyped output, ?::Integer? maxwidth, ?::String? newline;T;I"	void;To;;I"nAdd `obj` to the text to be output.

`width` argument is here for compatibility. It is a noop argument.

;T;0;;;I"	text;F;I"PrettyPrint::SingleLine;T;[o;;I"$::String obj, ?::Integer? width;T;I"	void;To;;I"…Appends `sep` to the text to be output. By default `sep` is ' '

`width` argument is here for compatibility. It is a noop argument.

;T;0;;;I"breakable;F;I"PrettyPrint::SingleLine;T;[o;;I"%?::String sep, ?::Integer? width;T;I"	void;To;;0;0;;;I"	nest;F;I"PrettyPrint::SingleLine;T;[o;;I"untyped indent;T;I"	void;To;;I"xOpens a block for grouping objects to be pretty printed.

Arguments:
*   `indent` - noop argument. Present for compatibility.
*   `open_obj` - text appended before the &blok. Default is ''
*   `close_obj` - text appended after the &blok. Default is ''
*   `open_width` - noop argument. Present for compatibility.
*   `close_width` - noop argument. Present for compatibility.

;T;0;;;I"
group;F;I"PrettyPrint::SingleLine;T;[o;;I"q?::Integer? indent, ?::String open_obj, ?::String close_obj, ?::Integer? open_width, ?::Integer? close_width;T;I"untyped;To;;0;0;;;I"
flush;F;I"PrettyPrint::SingleLine;T;[o;;I" ;F;I"nil;To;;I"AThis is used as a predicate, and ought to be called first.

;T;0;;;I"first?;F;I"PrettyPrint::SingleLine;T;[o;;I" ;F;I"	bool;To; ;I"ôThe set of all prime numbers.

## Example

    Prime.each(100) do |prime|
      p prime  #=> 2, 3, 5, 7, 11, ...., 97
    end

Prime is Enumerable:

    Prime.first 5 # => [2, 3, 5, 7, 11]

## Retrieving the instance

For convenience, each instance method of `Prime`.instance can be accessed as a
class method of `Prime`.

e.g.
    Prime.instance.prime?(2)  #=> true
    Prime.prime?(2)           #=> true

## Generators

A "generator" provides an implementation of enumerating pseudo-prime numbers
and it remembers the position of enumeration and upper bound. Furthermore, it
is an external iterator of prime enumeration which is compatible with an
Enumerator.

`Prime`::`PseudoPrimeGenerator` is the base class for generators. There are
few implementations of generator.

`Prime`::`EratosthenesGenerator`
:   Uses Eratosthenes' sieve.
`Prime`::`TrialDivisionGenerator`
:   Uses the trial division method.
`Prime`::`Generator23`
:   Generates all positive integers which are not divisible by either 2 or 3.
    This sequence is very bad as a pseudo-prime sequence. But this is faster
    and uses much less memory than the other generators. So, it is suitable
    for factorizing an integer which is not large but has many prime factors.
    e.g. for Prime#prime? .

;T;0;	I"
Prime;T;
[ ;[I"Singleton;TI"Enumerable;T;0;[ ;[ ;0;0o;;I"ŒIterates the given block over all prime numbers.

## Parameters

`ubound`
:   Optional. An arbitrary positive number. The upper bound of enumeration.
    The method enumerates prime numbers infinitely if `ubound` is nil.
`generator`
:   Optional. An implementation of pseudo-prime generator.


## Return value

An evaluated value of the given block at the last time. Or an enumerator which
is compatible to an `Enumerator` if no block given.

## Description

Calls `block` once for each prime number, passing the prime as a parameter.

`ubound`
:   Upper bound of prime numbers. The iterator stops after it yields all prime
    numbers p <= `ubound`.

;T;0;;;I"	each;F;I"
Prime;T;[o;;I"A?::Integer? ubound, ?::Prime::PseudoPrimeGenerator generator;T;I"	void;To;;I"A?::Integer? ubound, ?::Prime::PseudoPrimeGenerator generator;T;I" Prime::PseudoPrimeGenerator;To;;I"ŒIterates the given block over all prime numbers.

## Parameters

`ubound`
:   Optional. An arbitrary positive number. The upper bound of enumeration.
    The method enumerates prime numbers infinitely if `ubound` is nil.
`generator`
:   Optional. An implementation of pseudo-prime generator.


## Return value

An evaluated value of the given block at the last time. Or an enumerator which
is compatible to an `Enumerator` if no block given.

## Description

Calls `block` once for each prime number, passing the prime as a parameter.

`ubound`
:   Upper bound of prime numbers. The iterator stops after it yields all prime
    numbers p <= `ubound`.

;T;0;;;I"	each;F;I"
Prime;T;[o;;I"A?::Integer? ubound, ?::Prime::PseudoPrimeGenerator generator;T;I"	void;To;;I"A?::Integer? ubound, ?::Prime::PseudoPrimeGenerator generator;T;I" Prime::PseudoPrimeGenerator;To;;I"èRe-composes a prime factorization and returns the product.

For the decomposition:

    [[p_1, e_1], [p_2, e_2], ..., [p_n, e_n]],

it returns:

    p_1**e_1 * p_2**e_2 * ... * p_n**e_n.

## Parameters
`pd`
:   Array of pairs of integers. Each pair consists of a prime number -- a
    prime factor -- and a natural number -- its exponent (multiplicity).


## Example
    Prime.int_from_prime_division([[3, 2], [5, 1]])  #=> 45
    3**2 * 5                                         #=> 45

;T;0;;;I"int_from_prime_division;F;I"
Prime;T;[o;;I"&::Array[[ ::Integer, ::Integer ]];T;I"Integer;To;;I"èRe-composes a prime factorization and returns the product.

For the decomposition:

    [[p_1, e_1], [p_2, e_2], ..., [p_n, e_n]],

it returns:

    p_1**e_1 * p_2**e_2 * ... * p_n**e_n.

## Parameters
`pd`
:   Array of pairs of integers. Each pair consists of a prime number -- a
    prime factor -- and a natural number -- its exponent (multiplicity).


## Example
    Prime.int_from_prime_division([[3, 2], [5, 1]])  #=> 45
    3**2 * 5                                         #=> 45

;T;0;;;I"int_from_prime_division;F;I"
Prime;T;[o;;I"&::Array[[ ::Integer, ::Integer ]];T;I"Integer;To;;I"ÜReturns true if `value` is a prime number, else returns false. Integer#prime?
is much more performant.

## Parameters

`value`
:   an arbitrary integer to be checked.
`generator`
:   optional. A pseudo-prime generator.

;T;0;;;I"prime?;F;I"
Prime;T;[o;;I">::Integer value, ?::Prime::PseudoPrimeGenerator generator;T;I"	bool;To;;I"ÜReturns true if `value` is a prime number, else returns false. Integer#prime?
is much more performant.

## Parameters

`value`
:   an arbitrary integer to be checked.
`generator`
:   optional. A pseudo-prime generator.

;T;0;;;I"prime?;F;I"
Prime;T;[o;;I">::Integer value, ?::Prime::PseudoPrimeGenerator generator;T;I"	bool;To;;I"öReturns the factorization of `value`.

For an arbitrary integer:

    p_1**e_1 * p_2**e_2 * ... * p_n**e_n,

prime_division returns an array of pairs of integers:

    [[p_1, e_1], [p_2, e_2], ..., [p_n, e_n]].

Each pair consists of a prime number -- a prime factor -- and a natural number
-- its exponent (multiplicity).

## Parameters
`value`
:   An arbitrary integer.
`generator`
:   Optional. A pseudo-prime generator. `generator`.succ must return the next
    pseudo-prime number in ascending order. It must generate all prime
    numbers, but may also generate non-prime numbers, too.


### Exceptions
`ZeroDivisionError`
:   when `value` is zero.


## Example

    Prime.prime_division(45)  #=> [[3, 2], [5, 1]]
    3**2 * 5                  #=> 45

;T;0;;;I"prime_division;F;I"
Prime;T;[o;;I"8::Integer, ?::Prime::PseudoPrimeGenerator generator;T;I"$Array[[ ::Integer, ::Integer ]];To;;I"öReturns the factorization of `value`.

For an arbitrary integer:

    p_1**e_1 * p_2**e_2 * ... * p_n**e_n,

prime_division returns an array of pairs of integers:

    [[p_1, e_1], [p_2, e_2], ..., [p_n, e_n]].

Each pair consists of a prime number -- a prime factor -- and a natural number
-- its exponent (multiplicity).

## Parameters
`value`
:   An arbitrary integer.
`generator`
:   Optional. A pseudo-prime generator. `generator`.succ must return the next
    pseudo-prime number in ascending order. It must generate all prime
    numbers, but may also generate non-prime numbers, too.


### Exceptions
`ZeroDivisionError`
:   when `value` is zero.


## Example

    Prime.prime_division(45)  #=> [[3, 2], [5, 1]]
    3**2 * 5                  #=> 45

;T;0;;;I"prime_division;F;I"
Prime;T;[o;;I"8::Integer, ?::Prime::PseudoPrimeGenerator generator;T;I"$Array[[ ::Integer, ::Integer ]];To;;I"&Returns the singleton instance.

;T;0;;;I"instance;F;I"
Prime;T;[o;;I" ;F;I"
Prime;To; ;I"wAn abstract class for enumerating pseudo-prime numbers.

Concrete subclasses should override succ, next, rewind.

;T;0;	I" Prime::PseudoPrimeGenerator;T;
[ ;[I"Enumerable;T;0;[ ;[ ;0;0o;;I" ;T;0;;;I"initialize;F;I" Prime::PseudoPrimeGenerator;T;[o;;I"?::Integer?;T;I"	void;To;;I"6Iterates the given block for each prime number.

;T;0;;;I"	each;F;I" Prime::PseudoPrimeGenerator;T;[o;;I" ;F;I"	void;To;;I"alias of `succ`.

;T;0;;;I"	next;F;I" Prime::PseudoPrimeGenerator;T;[o;;I" ;F;I"Integer;To;;I"ORewinds the internal position for enumeration.

See `Enumerator`#rewind.

;T;0;;;I"rewind;F;I" Prime::PseudoPrimeGenerator;T;[o;;I" ;F;I"	void;To;;I" ;T;0;;;I"	size;F;I" Prime::PseudoPrimeGenerator;T;[o;;I" ;F;I"
Float;To;;I"Šreturns the next pseudo-prime number, and move the internal position forward.

`PseudoPrimeGenerator`#succ raises `NotImplementedError`.

;T;0;;;I"	succ;F;I" Prime::PseudoPrimeGenerator;T;[o;;I" ;F;I"Integer;To; ;I"NAn implementation of `PseudoPrimeGenerator`.

Uses `EratosthenesSieve`.

;T;0;	I"!Prime::EratosthenesGenerator;T;
[ ;[ ;0;[ ;[ ;0;I" Prime::PseudoPrimeGenerator;To; ;I"hAn implementation of `PseudoPrimeGenerator` which uses a prime table generated
by trial division.

;T;0;	I""Prime::TrialDivisionGenerator;T;
[ ;[ ;0;[ ;[ ;0;I" Prime::PseudoPrimeGenerator;To; ;I"ÀGenerates all integers which are greater than 2 and are not divisible by
either 2 or 3.

This is a pseudo-prime generator, suitable on checking primality of an integer
by brute force method.

;T;0;	I"Prime::Generator23;T;
[ ;[ ;0;[ ;[ ;0;I" Prime::PseudoPrimeGenerator;To; ;I"4PStore implements a file based persistence mechanism based on a Hash.  User
code can store hierarchies of Ruby objects (values) into the data store file
by name (keys).  An object hierarchy may be just a single object.  User code
may later read values back from the data store or even update data, as needed.

The transactional behavior ensures that any changes succeed or fail together.
This can be used to ensure that the data store is not left in a transitory
state, where some values were updated but others were not.

Behind the scenes, Ruby objects are stored to the data store file with
Marshal.  That carries the usual limitations.  Proc objects cannot be
marshalled, for example.

## Usage example:

    require "pstore"

    # a mock wiki object...
    class WikiPage
      def initialize( page_name, author, contents )
        @page_name = page_name
        @revisions = Array.new

        add_revision(author, contents)
      end

      attr_reader :page_name

      def add_revision( author, contents )
        @revisions << { :created  => Time.now,
                        :author   => author,
                        :contents => contents }
      end

      def wiki_page_references
        [@page_name] + @revisions.last[:contents].scan(/\b(?:[A-Z]+[a-z]+){2,}/)
      end

      # ...
    end

    # create a new page...
    home_page = WikiPage.new( "HomePage", "James Edward Gray II",
                              "A page about the JoysOfDocumentation..." )

    # then we want to update page data and the index together, or not at all...
    wiki = PStore.new("wiki_pages.pstore")
    wiki.transaction do  # begin transaction; do all of this or none of it
      # store page...
      wiki[home_page.page_name] = home_page
      # ensure that an index has been created...
      wiki[:wiki_index] ||= Array.new
      # update wiki index...
      wiki[:wiki_index].push(*home_page.wiki_page_references)
    end                   # commit changes to wiki data store file

    ### Some time later... ###

    # read wiki data...
    wiki.transaction(true) do  # begin read-only transaction, no changes allowed
      wiki.roots.each do |data_root_name|
        p data_root_name
        p wiki[data_root_name]
      end
    end

## Transaction modes

By default, file integrity is only ensured as long as the operating system
(and the underlying hardware) doesn't raise any unexpected I/O errors. If an
I/O error occurs while PStore is writing to its file, then the file will
become corrupted.

You can prevent this by setting *pstore.ultra_safe = true*. However, this
results in a minor performance loss, and only works on platforms that support
atomic file renames. Please consult the documentation for `ultra_safe` for
details.

Needless to say, if you're storing valuable data with PStore, then you should
backup the PStore files from time to time.

;T;0;	I"PStore;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"Retrieves a value from the PStore file data, by *name*.  The hierarchy of Ruby
objects stored under that root *name* will be returned.

**WARNING**:  This method is only valid in a PStore#transaction.  It will
raise PStore::Error if called at any other time.

;T;0;;;I"[];F;I"PStore;T;[o;;I"untyped name;T;I"untyped;To;;I"÷Stores an individual Ruby object or a hierarchy of Ruby objects in the data
store file under the root *name*.  Assigning to a *name* already in the data
store clobbers the old data.

## Example:

    require "pstore"

    store = PStore.new("data_file.pstore")
    store.transaction do  # begin transaction
      # load some data into the store...
      store[:single_object] = "My data..."
      store[:obj_hierarchy] = { "Kev Jackson" => ["rational.rb", "pstore.rb"],
                                "James Gray"  => ["erb.rb", "pstore.rb"] }
    end                   # commit changes to data store file

**WARNING**:  This method is only valid in a PStore#transaction and it cannot
be read-only.  It will raise PStore::Error if called at any other time.

;T;0;;;I"[]=;F;I"PStore;T;[o;;I" untyped name, untyped value;T;I"untyped;To;;I"\Ends the current PStore#transaction, discarding any changes to the data store.

## Example:

    require "pstore"

    store = PStore.new("data_file.pstore")
    store.transaction do  # begin transaction
      store[:one] = 1     # this change is not applied, see below...
      store[:two] = 2     # this change is not applied, see below...

      store.abort         # end transaction here, discard all changes

      store[:three] = 3   # this change is never reached
    end

**WARNING**:  This method is only valid in a PStore#transaction.  It will
raise PStore::Error if called at any other time.

;T;0;;;I"
abort;F;I"PStore;T;[o;;I" ;F;I"untyped;To;;I"2Ends the current PStore#transaction, committing any changes to the data store
immediately.

## Example:

    require "pstore"

    store = PStore.new("data_file.pstore")
    store.transaction do  # begin transaction
      # load some data into the store...
      store[:one] = 1
      store[:two] = 2

      store.commit        # end transaction here, committing changes

      store[:three] = 3   # this change is never reached
    end

**WARNING**:  This method is only valid in a PStore#transaction.  It will
raise PStore::Error if called at any other time.

;T;0;;;I"commit;F;I"PStore;T;[o;;I" ;F;I"nil;To;;I"ÔRemoves an object hierarchy from the data store, by *name*.

**WARNING**:  This method is only valid in a PStore#transaction and it cannot
be read-only.  It will raise PStore::Error if called at any other time.

;T;0;;;I"delete;F;I"PStore;T;[o;;I"untyped name;T;I"untyped;To;;I"©This method is just like PStore#[], save that you may also provide a *default*
value for the object.  In the event the specified *name* is not found in the
data store, your *default* will be returned instead.  If you do not specify a
default, PStore::Error will be raised if the object is not found.

**WARNING**:  This method is only valid in a PStore#transaction.  It will
raise PStore::Error if called at any other time.

;T;0;;;I"
fetch;F;I"PStore;T;[o;;I"#untyped name, ?untyped default;T;I"untyped;To;;I"/Returns the path to the data store file.

;T;0;;;I"	path;F;I"PStore;T;[o;;I" ;F;I"untyped;To;;I"ÁReturns true if the supplied *name* is currently in the data store.

**WARNING**:  This method is only valid in a PStore#transaction.  It will
raise PStore::Error if called at any other time.

;T;0;;;I"
root?;F;I"PStore;T;[o;;I"untyped name;T;I"	bool;To;;I"ÁReturns the names of all object hierarchies currently in the store.

**WARNING**:  This method is only valid in a PStore#transaction.  It will
raise PStore::Error if called at any other time.

;T;0;;;I"
roots;F;I"PStore;T;[o;;I" ;F;I"Array[untyped];To;;I"»Opens a new transaction for the data store.  Code executed inside a block
passed to this method may read and write data to and from the data store file.

At the end of the block, changes are committed to the data store
automatically.  You may exit the transaction early with a call to either
PStore#commit or PStore#abort.  See those methods for details about how
changes are handled.  Raising an uncaught Exception in the block is equivalent
to calling PStore#abort.

If *read_only* is set to `true`, you will only be allowed to read from the
data store during the transaction and any attempts to change the data will
raise a PStore::Error.

Note that PStore does not support nested transactions.

;T;0;;;I"transaction;F;I"PStore;T;[o;;I"?untyped read_only;T;I"untyped;To;;I"¢Whether PStore should do its best to prevent file corruptions, even when under
unlikely-to-occur error conditions such as out-of-space conditions and other
unusual OS filesystem errors. Setting this flag comes at the price in the form
of a performance loss.

This flag only has effect on platforms on which file renames are atomic (e.g.
all POSIX platforms: Linux, MacOS X, FreeBSD, etc). The default value is
false.

;T;0;;;I"ultra_safe;F;I"PStore;T;[o;;I" ;F;I"untyped;To;;I"¢Whether PStore should do its best to prevent file corruptions, even when under
unlikely-to-occur error conditions such as out-of-space conditions and other
unusual OS filesystem errors. Setting this flag comes at the price in the form
of a performance loss.

This flag only has effect on platforms on which file renames are atomic (e.g.
all POSIX platforms: Linux, MacOS X, FreeBSD, etc). The default value is
false.

;T;0;;;I"ultra_safe=;F;I"PStore;T;[o;;I"untyped;T;I"untyped;To;;0;0;;;I"	dump;F;I"PStore;T;[o;;I"untyped table;T;I"untyped;To;;I" ;T;0;;;I"empty_marshal_checksum;F;I"PStore;T;[o;;I" ;F;I"untyped;To;;I" ;T;0;;;I"empty_marshal_data;F;I"PStore;T;[o;;I" ;F;I"untyped;To;;I"ORaises PStore::Error if the calling code is not in a PStore#transaction.

;T;0;;;I"in_transaction;F;I"PStore;T;[o;;I" ;F;I"untyped;To;;I"~Raises PStore::Error if the calling code is not in a PStore#transaction or if
the code is in a read-only PStore#transaction.

;T;0;;;I"in_transaction_wr;F;I"PStore;T;[o;;I" ;F;I"untyped;To;;I"öTo construct a PStore object, pass in the *file* path where you would like the
data to be stored.

PStore objects are always reentrant. But if *thread_safe* is set to true, then
it will become thread-safe at the cost of a minor performance hit.

;T;0;;;I"initialize;F;I"PStore;T;[o;;I")untyped file, ?::boolish thread_safe;T;I"untyped;To;;0;0;;;I"	load;F;I"PStore;T;[o;;I"untyped content;T;I"untyped;To;;I"ÛLoad the given PStore file. If `read_only` is true, the unmarshalled Hash will
be returned. If `read_only` is false, a 3-tuple will be returned: the
unmarshalled Hash, a checksum of the data, and the size of the data.

;T;0;;;I"load_data;F;I"PStore;T;[o;;I"$untyped file, untyped read_only;T;I"untyped;To;;I" ;T;0;;;I"on_windows?;F;I"PStore;T;[o;;I" ;F;I"	bool;To;;I"Open the specified filename (either in read-only mode or in read-write mode)
and lock it for reading or writing.

The opened File object will be returned. If *read_only* is true, and the file
does not exist, then nil will be returned.

All exceptions are propagated.

;T;0;;;I"open_and_lock_file;F;I"PStore;T;[o;;I"(untyped filename, untyped read_only;T;I"untyped;To;;I" ;T;0;;;I"save_data;F;I"PStore;T;[o;;I"Huntyped original_checksum, untyped original_file_size, untyped file;T;I"untyped;To;;I" ;T;0;;;I"/save_data_with_atomic_file_rename_strategy;F;I"PStore;T;[o;;I"untyped data, untyped file;T;I"untyped;To;;I" ;T;0;;;I"!save_data_with_fast_strategy;F;I"PStore;T;[o;;I"untyped data, untyped file;T;I"untyped;To;;I"ÞCreates and manages pseudo terminals (PTYs).  See also
https://en.wikipedia.org/wiki/Pseudo_terminal

PTY allows you to allocate new terminals using ::open or ::spawn a new
terminal with a specific command.

## Example

In this example we will change the buffering type in the `factor` command,
assuming that factor uses stdio for stdout buffering.

If IO.pipe is used instead of PTY.open, this code deadlocks because factor's
stdout is fully buffered.

    # start by requiring the standard library PTY
    require 'pty'

    master, slave = PTY.open
    read, write = IO.pipe
    pid = spawn("factor", :in=>read, :out=>slave)
    read.close     # we dont need the read
    slave.close    # or the slave

    # pipe "42" to the factor command
    write.puts "42"
    # output the response from factor
    p master.gets #=> "42: 2 3 7\n"

    # pipe "144" to factor and print out the response
    write.puts "144"
    p master.gets #=> "144: 2 2 2 2 3 3\n"
    write.close # close the pipe

    # The result of read operation when pty slave is closed is platform
    # dependent.
    ret = begin
            master.gets     # FreeBSD returns nil.
          rescue Errno::EIO # GNU/Linux raises EIO.
            nil
          end
    p ret #=> nil

## License

(c) Copyright 1998 by Akinori Ito.

This software may be redistributed freely for this purpose, in full or in
part, provided that this entire copyright notice is included on any copies of
this software and applications and derivations thereof.

This software is provided on an "as is" basis, without warranty of any kind,
either expressed or implied, as to any matter including, but not limited to
warranty of fitness of purpose, or merchantability, or results obtained from
use of this software.

;T;0;	I"PTY;T;
[ ;[ ;0;[ ;[ o;;I" Checks the status of the child process specified by `pid`. Returns `nil` if
the process is still alive.

If the process is not alive, and `raise` was true, a PTY::ChildExited
exception will be raised. Otherwise it will return a Process::Status instance.

`pid`
:   The process id of the process to check
`raise`
:   If `true` and the process identified by `pid` is no longer alive a
    PTY::ChildExited is raised.

;T;0;;;I"
check;F;I"PTY;T;[o;;I"$::Integer pid, ?::boolish raise;T;I"Process::Status?;To;;I"£Allocates a pty (pseudo-terminal).

In the block form, yields an array of two elements (`master_io, slave_file`)
and the value of the block is returned from `open`.

The IO and File are both closed after the block completes if they haven't been
already closed.

    PTY.open {|master, slave|
      p master      #=> #<IO:masterpty:/dev/pts/1>
      p slave      #=> #<File:/dev/pts/1>
      p slave.path #=> "/dev/pts/1"
    }

In the non-block form, returns a two element array, `[master_io, slave_file]`.

    master, slave = PTY.open
    # do something with master for IO, or the slave file

The arguments in both forms are:

`master_io`
:   the master of the pty, as an IO.
`slave_file`
:   the slave of the pty, as a File.  The path to the terminal device is
    available via `slave_file.path`


IO#raw! is usable to disable newline conversions:

    require 'io/console'
    PTY.open {|m, s|
      s.raw!
      # ...
    }

;T;0;;;I"	open;F;I"PTY;T;[o;;I" ;F;I"[ ::IO, ::File ];To;;I" ;F;I"A;Fo;;I"×Spawns the specified command on a newly allocated pty. You can also use the
alias ::getpty.

The command's controlling tty is set to the slave device of the pty and its
standard input/output/error is redirected to the slave device.

`command` and `command_line` are the full commands to run, given a String. Any
additional `arguments` will be passed to the command.

### Return values

In the non-block form this returns an array of size three, `[r, w, pid]`.

In the block form these same values will be yielded to the block:

`r`
:   A readable IO that contains the command's standard output and standard
    error
`w`
:   A writable IO that is the command's standard input
`pid`
:   The process identifier for the command.

;T;0;;;I"
spawn;F;I"PTY;T;[o;;I"*::String command;T;I"[ ::IO, ::IO, ::Integer ];To;;I"*::String command;T;I"	void;To; ;I"øResolv is a thread-aware DNS resolver library written in Ruby.  Resolv can
handle multiple DNS requests concurrently without blocking the entire Ruby
interpreter.

See also resolv-replace.rb to replace the libc resolver with Resolv.

Resolv can look up various DNS resources using the DNS module directly.

Examples:

    p Resolv.getaddress "www.ruby-lang.org"
    p Resolv.getname "210.251.121.214"

    Resolv::DNS.open do |dns|
      ress = dns.getresources "www.ruby-lang.org", Resolv::DNS::Resource::IN::A
      p ress.map(&:address)
      ress = dns.getresources "ruby-lang.org", Resolv::DNS::Resource::IN::MX
      p ress.map { |r| [r.exchange.to_s, r.preference] }
    end

## Bugs

*   NIS is not supported.
*   /etc/nsswitch.conf is not supported.

;T;0;	I"Resolv;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"1Iterates over all IP addresses for `name`.

;T;0;;;I"each_address;F;I"Resolv;T;[o;;I"::String name;T;I"	void;To;;I"1Iterates over all hostnames for `address`.

;T;0;;;I"each_name;F;I"Resolv;T;[o;;I"::String address;T;I"	void;To;;I"0Looks up the first IP address for `name`.

;T;0;;;I"getaddress;F;I"Resolv;T;[o;;I"::String name;T;I"String;To;;I"*Looks up all IP address for `name`.

;T;0;;;I"getaddresses;F;I"Resolv;T;[o;;I"::String name;T;I"Array[::String];To;;I"*Looks up the hostname of `address`.

;T;0;;;I"getname;F;I"Resolv;T;[o;;I"::String address;T;I"String;To;;I",Looks up all hostnames for `address`.

;T;0;;;I"getnames;F;I"Resolv;T;[o;;I"::String address;T;I"Array[::String];To;;I"1Iterates over all IP addresses for `name`.

;T;0;;;I"each_address;F;I"Resolv;T;[o;;I"::String name;T;I"	void;To;;I"1Iterates over all hostnames for `address`.

;T;0;;;I"each_name;F;I"Resolv;T;[o;;I"::String name;T;I"	void;To;;I"0Looks up the first IP address for `name`.

;T;0;;;I"getaddress;F;I"Resolv;T;[o;;I"::String name;T;I"String;To;;I"*Looks up all IP address for `name`.

;T;0;;;I"getaddresses;F;I"Resolv;T;[o;;I"::String name;T;I"Array[::String];To;;I"*Looks up the hostname of `address`.

;T;0;;;I"getname;F;I"Resolv;T;[o;;I"::String address;T;I"String;To;;I",Looks up all hostnames for `address`.

;T;0;;;I"getnames;F;I"Resolv;T;[o;;I"::String address;T;I"Array[::String];To;;I".Creates a new Resolv using `resolvers`.

;T;0;;;I"initialize;F;I"Resolv;T;[o;;I"/?::Resolv::Hosts | ::Resolv::DNS resolvers;T;I"untyped;To; ;I"µResolv::DNS is a DNS stub resolver.

Information taken from the following places:

*   STD0013
*   RFC 1035
*   ftp://ftp.isi.edu/in-notes/iana/assignments/dns-parameters
*   etc.

;T;0;	I"Resolv::DNS;T;
[ ;[ ;0;[ ;[ ;0;0o;;0;0;;;I"allocate_request_id;F;I"Resolv::DNS;T;[o;;I""::String host, ::Integer port;T;I"Integer;To;;0;0;;;I"bind_random_port;F;I"Resolv::DNS;T;[o;;I"-::UDPSocket udpsock, ?::String bind_host;T;I"	void;To;;0;0;;;I"free_request_id;F;I"Resolv::DNS;T;[o;;I"0::String host, ::Integer port, ::Integer id;T;I"	void;To;;I"—Creates a new DNS resolver.  See Resolv::DNS.new for argument details.

Yields the created DNS resolver to the block, if given, otherwise returns it.

;T;0;;;I"	open;F;I"Resolv::DNS;T;[o;;I"*untyped args;T;I"instance;To;;I"*untyped args;T;I"	void;To;;0;0;;;I"random;F;I"Resolv::DNS;T;[o;;I"::Integer arg;T;I"Integer | ::Float;To;;I"Closes the DNS resolver.

;T;0;;;I"
close;F;I"Resolv::DNS;T;[o;;I" ;F;I"untyped;To;;I"¸Iterates over all IP addresses for `name` retrieved from the DNS resolver.

`name` can be a Resolv::DNS::Name or a String.  Retrieved addresses will be a
Resolv::IPv4 or Resolv::IPv6

;T;0;;;I"each_address;F;I"Resolv::DNS;T;[o;;I"!::Resolv::DNS::dns_name name;T;I"	void;To;;I"¿Iterates over all hostnames for `address` retrieved from the DNS resolver.

`address` must be a Resolv::IPv4, Resolv::IPv6 or a String.  Retrieved names
will be Resolv::DNS::Name instances.

;T;0;;;I"each_name;F;I"Resolv::DNS;T;[o;;I"@::Resolv::DNS::ip_address | ::Resolv::DNS::dns_name address;T;I"	void;To;;I"fIterates over all `typeclass` DNS resources for `name`.  See #getresource for
argument details.

;T;0;;;I"each_resource;F;I"Resolv::DNS;T;[o;;I"L::Resolv::DNS::dns_name name, singleton(::Resolv::DNS::Query) typeclass;T;I"	void;To;;0;0;;;I"extract_resources;F;I"Resolv::DNS;T;[o;;I"h::Resolv::DNS::Message msg, ::Resolv::DNS::dns_name name, singleton(::Resolv::DNS::Query) typeclass;T;I"	void;To;;I" ;T;0;;;I"fetch_resource;F;I"Resolv::DNS;T;[o;;I"H::Resolv::DNS::Name name, singleton(::Resolv::DNS::Query) typeclass;T;I"	void;To;;I" Gets the IP address of `name` from the DNS resolver.

`name` can be a Resolv::DNS::Name or a String.  Retrieved address will be a
Resolv::IPv4 or Resolv::IPv6

;T;0;;;I"getaddress;F;I"Resolv::DNS;T;[o;;I"!::Resolv::DNS::dns_name name;T;I"Resolv::DNS::ip_address;To;;I"¥Gets all IP addresses for `name` from the DNS resolver.

`name` can be a Resolv::DNS::Name or a String.  Retrieved addresses will be a
Resolv::IPv4 or Resolv::IPv6

;T;0;;;I"getaddresses;F;I"Resolv::DNS;T;[o;;I"!::Resolv::DNS::dns_name name;T;I"%Array[::Resolv::DNS::ip_address];To;;I"¢Gets the hostname for `address` from the DNS resolver.

`address` must be a Resolv::IPv4, Resolv::IPv6 or a String.  Retrieved name
will be a Resolv::DNS::Name.

;T;0;;;I"getname;F;I"Resolv::DNS;T;[o;;I"@::Resolv::DNS::ip_address | ::Resolv::DNS::dns_name address;T;I"Resolv::DNS::Name;To;;I"¬Gets all hostnames for `address` from the DNS resolver.

`address` must be a Resolv::IPv4, Resolv::IPv6 or a String.  Retrieved names
will be Resolv::DNS::Name instances.

;T;0;;;I"getnames;F;I"Resolv::DNS;T;[o;;I"@::Resolv::DNS::ip_address | ::Resolv::DNS::dns_name address;T;I"Array[::Resolv::DNS::Name];To;;I"¢Look up the `typeclass` DNS resource of `name`.

`name` must be a Resolv::DNS::Name or a String.

`typeclass` should be one of the following:

*   Resolv::DNS::Resource::IN::A
*   Resolv::DNS::Resource::IN::AAAA
*   Resolv::DNS::Resource::IN::ANY
*   Resolv::DNS::Resource::IN::CNAME
*   Resolv::DNS::Resource::IN::HINFO
*   Resolv::DNS::Resource::IN::MINFO
*   Resolv::DNS::Resource::IN::MX
*   Resolv::DNS::Resource::IN::NS
*   Resolv::DNS::Resource::IN::PTR
*   Resolv::DNS::Resource::IN::SOA
*   Resolv::DNS::Resource::IN::TXT
*   Resolv::DNS::Resource::IN::WKS


Returned resource is represented as a Resolv::DNS::Resource instance, i.e.
Resolv::DNS::Resource::IN::A.

;T;0;;;I"getresource;F;I"Resolv::DNS;T;[o;;I"L::Resolv::DNS::dns_name name, singleton(::Resolv::DNS::Query) typeclass;T;I"Resolv::DNS::Resource;To;;I"aLooks up all `typeclass` DNS resources for `name`.  See #getresource for
argument details.

;T;0;;;I"getresources;F;I"Resolv::DNS;T;[o;;I"L::Resolv::DNS::dns_name name, singleton(::Resolv::DNS::Query) typeclass;T;I"#Array[::Resolv::DNS::Resource];To;;0;0;;;I"lazy_initialize;F;I"Resolv::DNS;T;[o;;I" ;F;I"untyped;To;;0;0;;;I"make_tcp_requester;F;I"Resolv::DNS;T;[o;;I""::String host, ::Integer port;T;I" Resolv::DNS::Requester::TCP;To;;0;0;;;I"make_udp_requester;F;I"Resolv::DNS;T;[o;;I" ;F;I"TResolv::DNS::Requester::ConnectedUDP | ::Resolv::DNS::Requester::UnconnectedUDP;To;;I"«Sets the resolver timeouts.  This may be a single positive number or an array
of positive numbers representing timeouts in seconds. If an array is
specified, a DNS request will retry and wait for each successive interval in
the array until a successful response is received.  Specifying `nil` reverts
to the default timeouts:
5, second = 5 * 2 / nameserver_count, 2 * second, 4 * second
:   Example:

        dns.timeouts = 3

;T;0;;;I"timeouts=;F;I"Resolv::DNS;T;[o;;I">::Integer | ::Float | ::Array[::Integer | ::Float] values;T;I"	void;To;;I"çCreates a new DNS resolver.

`config_info` can be:

nil
:   Uses /etc/resolv.conf.
String
:   Path to a file using /etc/resolv.conf's format.
Hash
:   Must contain :nameserver, :search and :ndots keys.

:nameserver_port can be used to specify port number of nameserver address.

The value of :nameserver should be an address string or an array of address
strings.
*   :nameserver => '8.8.8.8'
*   :nameserver => ['8.8.8.8', '8.8.4.4']


The value of :nameserver_port should be an array of pair of nameserver address
and port number.
*   :nameserver_port => [['8.8.8.8', 53], ['8.8.4.4', 53]]


Example:

    Resolv::DNS.new(:nameserver => ['210.251.121.21'],
                    :search => ['ruby-lang.org'],
                    :ndots => 1)

;T;0;;;I"initialize;F;I"Resolv::DNS;T;[o;;I"6?::String | ::Hash[::Symbol, untyped] config_info;T;I"untyped;To;;0;0;;;I"use_ipv6?;F;I"Resolv::DNS;T;[o;;I" ;F;I"untyped;To; ;0;0;	I"Resolv::DNS::Config;T;
[ ;[ ;0;[ ;[ ;0;0o;;0;0;;;I"default_config_hash;F;I"Resolv::DNS::Config;T;[o;;I"?::String filename;T;I"Hash[::Symbol, untyped];To;;0;0;;;I"parse_resolv_conf;F;I"Resolv::DNS::Config;T;[o;;I"::String filename;T;I"Hash[::Symbol, untyped];To;;0;0;;;I"generate_candidates;F;I"Resolv::DNS::Config;T;[o;;I"::String name;T;I"Array[::Resolv::DNS::Name];To;;0;0;;;I"generate_timeouts;F;I"Resolv::DNS::Config;T;[o;;I" ;F;I"Array[::Integer | ::Float];To;;0;0;;;I"lazy_initialize;F;I"Resolv::DNS::Config;T;[o;;I" ;F;I"	void;To;;0;0;;;I"nameserver_port;F;I"Resolv::DNS::Config;T;[o;;I" ;F;I"#Array[[ ::String, ::Integer ]];To;;0;0;;;I"resolv;F;I"Resolv::DNS::Config;T;[o;;I"::String name;T;I"	void;To;;0;0;;;I"single?;F;I"Resolv::DNS::Config;T;[o;;I" ;F;I"[ ::String, ::Integer ]?;To;;0;0;;;I"timeouts=;F;I"Resolv::DNS::Config;T;[o;;I">::Integer | ::Float | ::Array[::Integer | ::Float] values;T;I"	void;To;;0;0;;;I"initialize;F;I"Resolv::DNS::Config;T;[o;;I"6?::String | ::Hash[::Symbol, untyped] config_info;T;I"untyped;To; ;I"*Indicates no such domain was found.

;T;0;	I""Resolv::DNS::Config::NXDomain;T;
[ ;[ ;0;[ ;[ ;0;I"Resolv::ResolvError;To; ;I"EIndicates some other unhandled resolver error was encountered.

;T;0;	I"*Resolv::DNS::Config::OtherResolvError;T;
[ ;[ ;0;[ ;[ ;0;I"Resolv::ResolvError;To; ;I"@Indicates that the DNS response was unable to be decoded.

;T;0;	I"Resolv::DNS::DecodeError;T;
[ ;[ ;0;[ ;[ ;0;I"StandardError;To; ;I"?Indicates that the DNS request was unable to be encoded.

;T;0;	I"Resolv::DNS::EncodeError;T;
[ ;[ ;0;[ ;[ ;0;I"StandardError;To;;0;0;	I"Resolv::DNS::Label;T;
[ ;[ ;0;[ ;[ o;;0;0;;;I"
split;F;I"Resolv::DNS::Label;T;[o;;I"untyped arg;T;I"untyped;To; ;0;0;	I"Resolv::DNS::Label::Str;T;
[ ;[ ;0;[ ;[ ;0;0o;;0;0;;;I"	eql?;F;I"Resolv::DNS::Label::Str;T;[o;;I"$::Resolv::DNS::Label::Str other;T;I"	bool;To;;0;0;;;I"downcase;F;I"Resolv::DNS::Label::Str;T;[o;;I" ;F;I"String;To;;0;0;;;I"	hash;F;I"Resolv::DNS::Label::Str;T;[o;;I" ;F;I"Integer;To;;0;0;;;I"inspect;F;I"Resolv::DNS::Label::Str;T;[o;;I" ;F;I"String;To;;0;0;;;I"string;F;I"Resolv::DNS::Label::Str;T;[o;;I" ;F;I"String;To;;0;0;;;I"	to_s;F;I"Resolv::DNS::Label::Str;T;[o;;I" ;F;I"String;To;;0;0;;;I"initialize;F;I"Resolv::DNS::Label::Str;T;[o;;I"::String string;T;I"untyped;To; ;0;0;	I"Resolv::DNS::Message;T;
[ ;[ ;0;[ ;[ ;0;0o;;0;0;;;I"decode;F;I"Resolv::DNS::Message;T;[o;;I"::String m;T;I"instance;To;;0;0;;;I"==;F;I"Resolv::DNS::Message;T;[o;;I"instance other;T;I"	bool;To;;0;0;;;I"aa;F;I"Resolv::DNS::Message;T;[o;;I" ;F;I"Integer;To;;0;0;;;I"aa=;F;I"Resolv::DNS::Message;T;[o;;I"::Integer;T;I"	void;To;;0;0;;;I"add_additional;F;I"Resolv::DNS::Message;T;[o;;I"?::String name, ::Integer ttl, ::Resolv::DNS::Resource data;T;I"	void;To;;0;0;;;I"add_answer;F;I"Resolv::DNS::Message;T;[o;;I"?::String name, ::Integer ttl, ::Resolv::DNS::Resource data;T;I"	void;To;;0;0;;;I"add_authority;F;I"Resolv::DNS::Message;T;[o;;I"?::String name, ::Integer ttl, ::Resolv::DNS::Resource data;T;I"	void;To;;0;0;;;I"add_question;F;I"Resolv::DNS::Message;T;[o;;I"=::String name, singleton(::Resolv::DNS::Query) typeclass;T;I"	void;To;;0;0;;;I"additional;F;I"Resolv::DNS::Message;T;[o;;I" ;F;I"GArray[[ ::Resolv::DNS::Name, ::Integer, ::Resolv::DNS::Resource ]];To;;0;0;;;I"answer;F;I"Resolv::DNS::Message;T;[o;;I" ;F;I"GArray[[ ::Resolv::DNS::Name, ::Integer, ::Resolv::DNS::Resource ]];To;;0;0;;;I"authority;F;I"Resolv::DNS::Message;T;[o;;I" ;F;I"GArray[[ ::Resolv::DNS::Name, ::Integer, ::Resolv::DNS::Resource ]];To;;0;0;;;I"each_additional;F;I"Resolv::DNS::Message;T;[o;;I" ;F;I"	void;To;;0;0;;;I"each_answer;F;I"Resolv::DNS::Message;T;[o;;I" ;F;I"	void;To;;0;0;;;I"each_authority;F;I"Resolv::DNS::Message;T;[o;;I" ;F;I"	void;To;;0;0;;;I"each_question;F;I"Resolv::DNS::Message;T;[o;;I" ;F;I"	void;To;;0;0;;;I"each_resource;F;I"Resolv::DNS::Message;T;[o;;I" ;F;I"	void;To;;0;0;;;I"encode;F;I"Resolv::DNS::Message;T;[o;;I" ;F;I"String;To;;0;0;;;I"id;F;I"Resolv::DNS::Message;T;[o;;I" ;F;I"Integer;To;;0;0;;;I"id=;F;I"Resolv::DNS::Message;T;[o;;I"::Integer;T;I"	void;To;;0;0;;;I"opcode;F;I"Resolv::DNS::Message;T;[o;;I" ;F;I"Integer;To;;0;0;;;I"opcode=;F;I"Resolv::DNS::Message;T;[o;;I"::Integer;T;I"	void;To;;0;0;;;I"qr;F;I"Resolv::DNS::Message;T;[o;;I" ;F;I"Integer;To;;0;0;;;I"qr=;F;I"Resolv::DNS::Message;T;[o;;I"::Integer;T;I"	void;To;;0;0;;;I"question;F;I"Resolv::DNS::Message;T;[o;;I" ;F;I"GArray[[ ::Resolv::DNS::Name, singleton(::Resolv::DNS::Resource) ]];To;;0;0;;;I"ra;F;I"Resolv::DNS::Message;T;[o;;I" ;F;I"Integer;To;;0;0;;;I"ra=;F;I"Resolv::DNS::Message;T;[o;;I"::Integer;T;I"	void;To;;0;0;;;I"
rcode;F;I"Resolv::DNS::Message;T;[o;;I" ;F;I"Integer;To;;0;0;;;I"rcode=;F;I"Resolv::DNS::Message;T;[o;;I"::Integer;T;I"	void;To;;0;0;;;I"rd;F;I"Resolv::DNS::Message;T;[o;;I" ;F;I"Integer;To;;0;0;;;I"rd=;F;I"Resolv::DNS::Message;T;[o;;I"::Integer;T;I"	void;To;;0;0;;;I"tc;F;I"Resolv::DNS::Message;T;[o;;I" ;F;I"Integer;To;;0;0;;;I"tc=;F;I"Resolv::DNS::Message;T;[o;;I"::Integer;T;I"	void;To;;0;0;;;I"initialize;F;I"Resolv::DNS::Message;T;[o;;I"?::Integer id;T;I"untyped;To; ;0;0;	I")Resolv::DNS::Message::MessageDecoder;T;
[ ;[ ;0;[ ;[ ;0;0o;;0;0;;;I"get_bytes;F;I")Resolv::DNS::Message::MessageDecoder;T;[o;;I"?::Integer len;T;I"String;To;;0;0;;;I"get_label;F;I")Resolv::DNS::Message::MessageDecoder;T;[o;;I" ;F;I"Resolv::DNS::Label::Str;To;;0;0;;;I"get_labels;F;I")Resolv::DNS::Message::MessageDecoder;T;[o;;I" ;F;I"%Array[::Resolv::DNS::Label::Str];To;;0;0;;;I"get_length16;F;I")Resolv::DNS::Message::MessageDecoder;T;[o;;I" ;F;I"Integer;To;;0;0;;;I"get_name;F;I")Resolv::DNS::Message::MessageDecoder;T;[o;;I" ;F;I"Resolv::DNS::Name;To;;0;0;;;I"get_question;F;I")Resolv::DNS::Message::MessageDecoder;T;[o;;I" ;F;I"Resolv::DNS::Query;To;;0;0;;;I"get_rr;F;I")Resolv::DNS::Message::MessageDecoder;T;[o;;I" ;F;I"@[ ::Resolv::DNS::Name, ::Integer, ::Resolv::DNS::Resource ];To;;0;0;;;I"get_string;F;I")Resolv::DNS::Message::MessageDecoder;T;[o;;I" ;F;I"String;To;;0;0;;;I"get_string_list;F;I")Resolv::DNS::Message::MessageDecoder;T;[o;;I" ;F;I"Array[::String];To;;0;0;;;I"get_unpack;F;I")Resolv::DNS::Message::MessageDecoder;T;[o;;I"::String template;T;I"Array[untyped];To;;0;0;;;I"inspect;F;I")Resolv::DNS::Message::MessageDecoder;T;[o;;I" ;F;I"String;To;;0;0;;;I"initialize;F;I")Resolv::DNS::Message::MessageDecoder;T;[o;;I"::String data;T;I"untyped;To; ;0;0;	I")Resolv::DNS::Message::MessageEncoder;T;
[ ;[ ;0;[ ;[ ;0;0o;;0;0;;;I"put_bytes;F;I")Resolv::DNS::Message::MessageEncoder;T;[o;;I"::string d;T;I"	void;To;;0;0;;;I"put_label;F;I")Resolv::DNS::Message::MessageEncoder;T;[o;;I"::_ToS d;T;I"	void;To;;0;0;;;I"put_labels;F;I")Resolv::DNS::Message::MessageEncoder;T;[o;;I"::Array[::_ToS] d;T;I"	void;To;;0;0;;;I"put_length16;F;I")Resolv::DNS::Message::MessageEncoder;T;[o;;I" ;F;I"	void;To;;0;0;;;I"put_name;F;I")Resolv::DNS::Message::MessageEncoder;T;[o;;I"::Resolv::DNS::Name d;T;I"	void;To;;0;0;;;I"put_pack;F;I")Resolv::DNS::Message::MessageEncoder;T;[o;;I""::String template, *untyped d;T;I"	void;To;;0;0;;;I"put_string;F;I")Resolv::DNS::Message::MessageEncoder;T;[o;;I"::String d;T;I"	void;To;;0;0;;;I"put_string_list;F;I")Resolv::DNS::Message::MessageEncoder;T;[o;;I"::_Each[::String] ds;T;I"	void;To;;0;0;;;I"	to_s;F;I")Resolv::DNS::Message::MessageEncoder;T;[o;;I" ;F;I"untyped;To;;0;0;;;I"initialize;F;I")Resolv::DNS::Message::MessageEncoder;T;[o;;I" ;F;I"untyped;To; ;I"&A representation of a DNS name.

;T;0;	I"Resolv::DNS::Name;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"pCreates a new DNS name from `arg`.  `arg` can be:

Name
:   returns `arg`.
String
:   Creates a new Name.

;T;0;;;I"create;F;I"Resolv::DNS::Name;T;[o;;I" ::Resolv::DNS::dns_name arg;T;I"untyped;To;;0;0;;;I"==;F;I"Resolv::DNS::Name;T;[o;;I"instance other;T;I"	bool;To;;0;0;;;I"[];F;I"Resolv::DNS::Name;T;[o;;I"::Integer i;T;I"Resolv::DNS::Label::Str?;To;;I"%True if this name is absolute.

;T;0;;;I"absolute?;F;I"Resolv::DNS::Name;T;[o;;I" ;F;I"	bool;To;;0;0;;;I"	hash;F;I"Resolv::DNS::Name;T;[o;;I" ;F;I"Integer;To;;0;0;;;I"inspect;F;I"Resolv::DNS::Name;T;[o;;I" ;F;I"String;To;;0;0;;;I"length;F;I"Resolv::DNS::Name;T;[o;;I" ;F;I"Integer;To;;I"
Returns true if `other` is a subdomain.

Example:

    domain = Resolv::DNS::Name.create("y.z")
    p Resolv::DNS::Name.create("w.x.y.z").subdomain_of?(domain) #=> true
    p Resolv::DNS::Name.create("x.y.z").subdomain_of?(domain) #=> true
    p Resolv::DNS::Name.create("y.z").subdomain_of?(domain) #=> false
    p Resolv::DNS::Name.create("z").subdomain_of?(domain) #=> false
    p Resolv::DNS::Name.create("x.y.z.").subdomain_of?(domain) #=> false
    p Resolv::DNS::Name.create("w.z").subdomain_of?(domain) #=> false

;T;0;;;I"subdomain_of?;F;I"Resolv::DNS::Name;T;[o;;I"instance other;T;I"	bool;To;;0;0;;;I"	to_a;F;I"Resolv::DNS::Name;T;[o;;I" ;F;I"%Array[::Resolv::DNS::Label::Str];To;;I"öreturns the domain name as a string.

The domain name doesn't have a trailing dot even if the name object is
absolute.

Example:

    p Resolv::DNS::Name.create("x.y.z.").to_s #=> "x.y.z"
    p Resolv::DNS::Name.create("x.y.z").to_s #=> "x.y.z"

;T;0;;;I"	to_s;F;I"Resolv::DNS::Name;T;[o;;I" ;F;I"untyped;To;;0;0;;;I"initialize;F;I"Resolv::DNS::Name;T;[o;;I">::Array[::Resolv::DNS::Label::Str] labels, ?bool absolute;T;I"untyped;To;;0;0;	I"Resolv::DNS::OpCode;T;
[ ;[ ;0;[ ;[ o; ;I""A DNS query abstract class.

;T;0;	I"Resolv::DNS::Query;T;
[ ;[ ;0;[ ;[ ;0;0o;;0;0;;;I"decode_rdata;F;I"Resolv::DNS::Query;T;[o;;I"/::Resolv::DNS::Message::MessageDecoder msg;T;I"instance;To;;0;0;;;I"encode_rdata;F;I"Resolv::DNS::Query;T;[o;;I"/::Resolv::DNS::Message::MessageEncoder msg;T;I"	void;To;;0;0;	I"Resolv::DNS::RCode;T;
[ ;[ ;0;[ ;[ o; ;0;0;	I"Resolv::DNS::Requester;T;
[ ;[ ;0;[ ;[ ;0;0o;;0;0;;;I"
close;F;I"Resolv::DNS::Requester;T;[o;;I" ;F;I"	void;To;;0;0;;;I"request;F;I"Resolv::DNS::Requester;T;[o;;I"<::Resolv::DNS::Requester::Sender sender, ::Numeric tout;T;I")[ ::Resolv::DNS::Message, ::String ];To;;0;0;;;I"sender_for;F;I"Resolv::DNS::Requester;T;[o;;I".::String addr, ::Resolv::DNS::Message msg;T;I"#Resolv::DNS::Requester::Sender;To;;0;0;;;I"initialize;F;I"Resolv::DNS::Requester;T;[o;;I" ;F;I"untyped;To; ;0;0;	I")Resolv::DNS::Requester::ConnectedUDP;T;
[ ;[ ;0;[ ;[ ;0;I"Resolv::DNS::Requester;To;;0;0;;;I"
close;F;I")Resolv::DNS::Requester::ConnectedUDP;T;[o;;I" ;F;I"	void;To;;0;0;;;I"lazy_initialize;F;I")Resolv::DNS::Requester::ConnectedUDP;T;[o;;I" ;F;I"	void;To;;0;0;;;I"recv_reply;F;I")Resolv::DNS::Requester::ConnectedUDP;T;[o;;I"(::Array[::UDPSocket] readable_socks;T;I"[ ::String, ::String ];To;;0;0;;;I"sender;F;I")Resolv::DNS::Requester::ConnectedUDP;T;[o;;I"O::Resolv::DNS::Message msg, ::String data, ?::String host, ?::Integer port;T;I"#Resolv::DNS::Requester::Sender;To;;0;0;;;I"initialize;F;I")Resolv::DNS::Requester::ConnectedUDP;T;[o;;I"#::String host, ?::Integer port;T;I"untyped;To; ;0;0;	I"1Resolv::DNS::Requester::ConnectedUDP::Sender;T;
[ ;[ ;0;[ ;[ ;0;I"#Resolv::DNS::Requester::Sender;To;;0;0;;;I"	data;F;I"1Resolv::DNS::Requester::ConnectedUDP::Sender;T;[o;;I" ;F;I"String;To;;0;0;;;I"	send;F;I"1Resolv::DNS::Requester::ConnectedUDP::Sender;T;[o;;I" ;F;I"	void;To; ;0;0;	I"(Resolv::DNS::Requester::MDNSOneShot;T;
[ ;[ ;0;[ ;[ ;0;I"+Resolv::DNS::Requester::UnconnectedUDP;To;;0;0;;;I"sender;F;I"(Resolv::DNS::Requester::MDNSOneShot;T;[o;;I"O::Resolv::DNS::Message msg, ::String data, ?::String host, ?::Integer port;T;I"#Resolv::DNS::Requester::Sender;To;;0;0;;;I"recv_reply;F;I"(Resolv::DNS::Requester::MDNSOneShot;T;[o;;I"(::Array[::UDPSocket] readable_socks;T;I"[ ::String, ::String ];To; ;I"0Indicates a problem with the DNS request.

;T;0;	I")Resolv::DNS::Requester::RequestError;T;
[ ;[ ;0;[ ;[ ;0;I"StandardError;To; ;0;0;	I"#Resolv::DNS::Requester::Sender;T;
[ ;[ ;0;[ ;[ ;0;0o;;0;0;;;I"initialize;F;I"#Resolv::DNS::Requester::Sender;T;[o;;I"=::Resolv::DNS::Message msg, ::String data, ::Socket sock;T;I"untyped;To; ;0;0;	I" Resolv::DNS::Requester::TCP;T;
[ ;[ ;0;[ ;[ ;0;I"Resolv::DNS::Requester;To;;0;0;;;I"
close;F;I" Resolv::DNS::Requester::TCP;T;[o;;I" ;F;I"untyped;To;;0;0;;;I"recv_reply;F;I" Resolv::DNS::Requester::TCP;T;[o;;I"(::Array[::TCPSocket] readable_socks;T;I"[ ::String, ::String ];To;;0;0;;;I"sender;F;I" Resolv::DNS::Requester::TCP;T;[o;;I"O::Resolv::DNS::Message msg, ::String data, ?::String host, ?::Integer port;T;I"#Resolv::DNS::Requester::Sender;To;;0;0;;;I"initialize;F;I" Resolv::DNS::Requester::TCP;T;[o;;I"#::String host, ?::Integer port;T;I"untyped;To; ;0;0;	I"(Resolv::DNS::Requester::TCP::Sender;T;
[ ;[ ;0;[ ;[ ;0;I"#Resolv::DNS::Requester::Sender;To;;0;0;;;I"	data;F;I"(Resolv::DNS::Requester::TCP::Sender;T;[o;;I" ;F;I"String;To;;0;0;;;I"	send;F;I"(Resolv::DNS::Requester::TCP::Sender;T;[o;;I" ;F;I"	void;To; ;0;0;	I"+Resolv::DNS::Requester::UnconnectedUDP;T;
[ ;[ ;0;[ ;[ ;0;I"Resolv::DNS::Requester;To;;0;0;;;I"
close;F;I"+Resolv::DNS::Requester::UnconnectedUDP;T;[o;;I" ;F;I"	void;To;;0;0;;;I"lazy_initialize;F;I"+Resolv::DNS::Requester::UnconnectedUDP;T;[o;;I" ;F;I"	void;To;;0;0;;;I"recv_reply;F;I"+Resolv::DNS::Requester::UnconnectedUDP;T;[o;;I"(::Array[::UDPSocket] readable_socks;T;I"[ ::String, ::String ];To;;0;0;;;I"sender;F;I"+Resolv::DNS::Requester::UnconnectedUDP;T;[o;;I"O::Resolv::DNS::Message msg, ::String data, ?::String host, ?::Integer port;T;I"#Resolv::DNS::Requester::Sender;To;;0;0;;;I"initialize;F;I"+Resolv::DNS::Requester::UnconnectedUDP;T;[o;;I"-*[ ::String, ::Integer ] nameserver_port;T;I"untyped;To; ;0;0;	I"3Resolv::DNS::Requester::UnconnectedUDP::Sender;T;
[ ;[ ;0;[ ;[ ;0;I"#Resolv::DNS::Requester::Sender;To;;0;0;;;I"	data;F;I"3Resolv::DNS::Requester::UnconnectedUDP::Sender;T;[o;;I" ;F;I"String;To;;0;0;;;I"	send;F;I"3Resolv::DNS::Requester::UnconnectedUDP::Sender;T;[o;;I" ;F;I"	void;To;;0;0;;;I"initialize;F;I"3Resolv::DNS::Requester::UnconnectedUDP::Sender;T;[o;;I"_::Resolv::DNS::Message msg, ::String data, ::UDPSocket sock, ::String host, ::Integer port;T;I"untyped;To; ;I"%A DNS resource abstract class.

;T;0;	I"Resolv::DNS::Resource;T;
[ ;[ ;0;[ ;[ ;0;I"Resolv::DNS::Query;To;;0;0;;;I"decode_rdata;F;I"Resolv::DNS::Resource;T;[o;;I"/::Resolv::DNS::Message::MessageDecoder msg;T;I"instance;To;;0;0;;;I"get_class;F;I"Resolv::DNS::Resource;T;[o;;I"0::Integer type_value, ::Integer class_value;T;I"	self;To;;0;0;;;I"	eql?;F;I"Resolv::DNS::Resource;T;[o;;I""::Resolv::DNS::Resource other;T;I"	bool;To;;0;0;;;I"encode_rdata;F;I"Resolv::DNS::Resource;T;[o;;I"/::Resolv::DNS::Message::MessageEncoder msg;T;I"	void;To;;0;0;;;I"	hash;F;I"Resolv::DNS::Resource;T;[o;;I" ;F;I"Integer;To;;I"0Remaining Time To Live for this Resource.

;T;0;;;I"ttl;F;I"Resolv::DNS::Resource;T;[o;;I" ;F;I"Integer;To; ;I"&A Query type requesting any RR.

;T;0;	I"Resolv::DNS::Resource::ANY;T;
[ ;[ ;0;[ ;[ ;0;I"Resolv::DNS::Query;To; ;I"'The canonical name for an alias.

;T;0;	I"!Resolv::DNS::Resource::CNAME;T;
[ ;[ ;0;[ ;[ ;0;I"&Resolv::DNS::Resource::DomainName;To; ;I"+Domain Name resource abstract class.

;T;0;	I"&Resolv::DNS::Resource::DomainName;T;
[ ;[ ;0;[ ;[ ;0;I"Resolv::DNS::Resource;To;;0;0;;;I"decode_rdata;F;I"&Resolv::DNS::Resource::DomainName;T;[o;;I"/::Resolv::DNS::Message::MessageDecoder msg;T;I"instance;To;;0;0;;;I"encode_rdata;F;I"&Resolv::DNS::Resource::DomainName;T;[o;;I"/::Resolv::DNS::Message::MessageEncoder msg;T;I"	void;To;;I"#The name of this DomainName.

;T;0;;;I"	name;F;I"&Resolv::DNS::Resource::DomainName;T;[o;;I" ;F;I"String;To;;I",Creates a new DomainName from `name`.

;T;0;;;I"initialize;F;I"&Resolv::DNS::Resource::DomainName;T;[o;;I"::String name;T;I"untyped;To; ;I")A generic resource abstract class.

;T;0;	I"#Resolv::DNS::Resource::Generic;T;
[ ;[ ;0;[ ;[ ;0;I"Resolv::DNS::Resource;To;;0;0;;;I"create;F;I"#Resolv::DNS::Resource::Generic;T;[o;;I"0::Integer type_value, ::Integer class_value;T;I"instance;To;;0;0;;;I"decode_rdata;F;I"#Resolv::DNS::Resource::Generic;T;[o;;I"/::Resolv::DNS::Message::MessageDecoder msg;T;I"instance;To;;I"&Data for this generic resource.

;T;0;;;I"	data;F;I"#Resolv::DNS::Resource::Generic;T;[o;;I" ;F;I"String;To;;0;0;;;I"encode_rdata;F;I"#Resolv::DNS::Resource::Generic;T;[o;;I"/::Resolv::DNS::Message::MessageEncoder msg;T;I"	void;To;;I"&Creates a new generic resource.

;T;0;;;I"initialize;F;I"#Resolv::DNS::Resource::Generic;T;[o;;I"::String data;T;I"untyped;To; ;I"!Host Information resource.

;T;0;	I"!Resolv::DNS::Resource::HINFO;T;
[ ;[ ;0;[ ;[ ;0;I"Resolv::DNS::Resource;To;;0;0;;;I"decode_rdata;F;I"!Resolv::DNS::Resource::HINFO;T;[o;;I"/::Resolv::DNS::Message::MessageDecoder msg;T;I"instance;To;;I"*CPU architecture for this resource.

;T;0;;;I"cpu;F;I"!Resolv::DNS::Resource::HINFO;T;[o;;I" ;F;I"String;To;;0;0;;;I"encode_rdata;F;I"!Resolv::DNS::Resource::HINFO;T;[o;;I"/::Resolv::DNS::Message::MessageEncoder msg;T;I"	void;To;;I"*Operating system for this resource.

;T;0;;;I"os;F;I"!Resolv::DNS::Resource::HINFO;T;[o;;I" ;F;I"String;To;;I"1Creates a new HINFO running `os` on `cpu`.

;T;0;;;I"initialize;F;I"!Resolv::DNS::Resource::HINFO;T;[o;;I"::String cpu, ::String os;T;I"untyped;To;;I"5module IN contains ARPA Internet specific RRs.

;T;0;	I"Resolv::DNS::Resource::IN;T;
[ ;[ ;0;[ ;[ o; ;I"IPv4 Address resource

;T;0;	I"!Resolv::DNS::Resource::IN::A;T;
[ ;[ ;0;[ ;[ ;0;I"Resolv::DNS::Resource;To;;0;0;;;I"decode_rdata;F;I"!Resolv::DNS::Resource::IN::A;T;[o;;I"/::Resolv::DNS::Message::MessageDecoder msg;T;I"instance;To;;I"+The Resolv::IPv4 address for this A.

;T;0;;;I"address;F;I"!Resolv::DNS::Resource::IN::A;T;[o;;I" ;F;I"Resolv::IPv4;To;;0;0;;;I"encode_rdata;F;I"!Resolv::DNS::Resource::IN::A;T;[o;;I"/::Resolv::DNS::Message::MessageEncoder msg;T;I"	void;To;;I"%Creates a new A for `address`.

;T;0;;;I"initialize;F;I"!Resolv::DNS::Resource::IN::A;T;[o;;I"&::String | ::Resolv::IPv4 address;T;I"untyped;To; ;I"An IPv6 address record.

;T;0;	I"$Resolv::DNS::Resource::IN::AAAA;T;
[ ;[ ;0;[ ;[ ;0;I"Resolv::DNS::Resource;To;;0;0;;;I"decode_rdata;F;I"$Resolv::DNS::Resource::IN::AAAA;T;[o;;I"/::Resolv::DNS::Message::MessageDecoder msg;T;I"instance;To;;I".The Resolv::IPv6 address for this AAAA.

;T;0;;;I"address;F;I"$Resolv::DNS::Resource::IN::AAAA;T;[o;;I" ;F;I"Resolv::IPv6;To;;0;0;;;I"encode_rdata;F;I"$Resolv::DNS::Resource::IN::AAAA;T;[o;;I"/::Resolv::DNS::Message::MessageEncoder msg;T;I"	void;To;;I"(Creates a new AAAA for `address`.

;T;0;;;I"initialize;F;I"$Resolv::DNS::Resource::IN::AAAA;T;[o;;I"&::String | ::Resolv::IPv6 address;T;I"untyped;To; ;0;0;	I"#Resolv::DNS::Resource::IN::ANY;T;
[ ;[ ;0;[ ;[ ;0;I"Resolv::DNS::Resource::ANY;To; ;0;0;	I"%Resolv::DNS::Resource::IN::CNAME;T;
[ ;[ ;0;[ ;[ ;0;I"!Resolv::DNS::Resource::CNAME;To; ;0;0;	I"%Resolv::DNS::Resource::IN::HINFO;T;
[ ;[ ;0;[ ;[ ;0;I"!Resolv::DNS::Resource::HINFO;To; ;0;0;	I"#Resolv::DNS::Resource::IN::LOC;T;
[ ;[ ;0;[ ;[ ;0;I"Resolv::DNS::Resource::LOC;To; ;0;0;	I"%Resolv::DNS::Resource::IN::MINFO;T;
[ ;[ ;0;[ ;[ ;0;I"!Resolv::DNS::Resource::MINFO;To; ;0;0;	I""Resolv::DNS::Resource::IN::MX;T;
[ ;[ ;0;[ ;[ ;0;I"Resolv::DNS::Resource::MX;To; ;0;0;	I""Resolv::DNS::Resource::IN::NS;T;
[ ;[ ;0;[ ;[ ;0;I"Resolv::DNS::Resource::NS;To; ;0;0;	I"#Resolv::DNS::Resource::IN::PTR;T;
[ ;[ ;0;[ ;[ ;0;I"Resolv::DNS::Resource::PTR;To; ;0;0;	I"#Resolv::DNS::Resource::IN::SOA;T;
[ ;[ ;0;[ ;[ ;0;I"Resolv::DNS::Resource::SOA;To; ;I"|SRV resource record defined in RFC 2782

These records identify the hostname and port that a service is available at.

;T;0;	I"#Resolv::DNS::Resource::IN::SRV;T;
[ ;[ ;0;[ ;[ ;0;I"Resolv::DNS::Resource;To;;0;0;;;I"decode_rdata;F;I"#Resolv::DNS::Resource::IN::SRV;T;[o;;I"/::Resolv::DNS::Message::MessageDecoder msg;T;I"instance;To;;0;0;;;I"encode_rdata;F;I"#Resolv::DNS::Resource::IN::SRV;T;[o;;I"/::Resolv::DNS::Message::MessageEncoder msg;T;I"	void;To;;I"KThe port on this target host of this service.

The range is 0-65535.

;T;0;;;I"	port;F;I"#Resolv::DNS::Resource::IN::SRV;T;[o;;I" ;F;I"Integer;To;;I";The priority of this target host.

A client MUST attempt to contact the target host with the lowest-numbered
priority it can reach; target hosts with the same priority SHOULD be tried in
an order defined by the weight field. The range is 0-65535.  Note that it is
not widely implemented and should be set to zero.

;T;0;;;I"priority;F;I"#Resolv::DNS::Resource::IN::SRV;T;[o;;I" ;F;I"Integer;To;;I"}The domain name of the target host.

A target of "." means that the service is decidedly not available at this
domain.

;T;0;;;I"target;F;I"#Resolv::DNS::Resource::IN::SRV;T;[o;;I" ;F;I"String;To;;I"¾A server selection mechanism.

The weight field specifies a relative weight for entries with the same
priority. Larger weights SHOULD be given a proportionately higher probability
of being selected. The range of this number is 0-65535.  Domain administrators
SHOULD use Weight 0 when there isn't any server selection to do, to make the
RR easier to read for humans (less noisy). Note that it is not widely
implemented and should be set to zero.

;T;0;;;I"weight;F;I"#Resolv::DNS::Resource::IN::SRV;T;[o;;I" ;F;I"Integer;To;;I"›Create a SRV resource record.

See the documentation for #priority, #weight, #port and #target for
`priority`, `weight`, +port and `target` respectively.

;T;0;;;I"initialize;F;I"#Resolv::DNS::Resource::IN::SRV;T;[o;;I"J::Integer priority, ::Integer weight, ::Integer port, ::String target;T;I"untyped;To; ;0;0;	I"#Resolv::DNS::Resource::IN::TXT;T;
[ ;[ ;0;[ ;[ ;0;I"Resolv::DNS::Resource::TXT;To; ;I"#Well Known Service resource.

;T;0;	I"#Resolv::DNS::Resource::IN::WKS;T;
[ ;[ ;0;[ ;[ ;0;I"Resolv::DNS::Resource;To;;0;0;;;I"decode_rdata;F;I"#Resolv::DNS::Resource::IN::WKS;T;[o;;I"/::Resolv::DNS::Message::MessageDecoder msg;T;I"instance;To;;I"&The host these services run on.

;T;0;;;I"address;F;I"#Resolv::DNS::Resource::IN::WKS;T;[o;;I" ;F;I"Resolv::IPv4;To;;I"÷A bit map of enabled services on this host.

If protocol is 6 (TCP) then the 26th bit corresponds to the SMTP service (port
25).  If this bit is set, then an SMTP server should be listening on TCP port
25; if zero, SMTP service is not supported.

;T;0;;;I"bitmap;F;I"#Resolv::DNS::Resource::IN::WKS;T;[o;;I" ;F;I"Integer;To;;0;0;;;I"encode_rdata;F;I"#Resolv::DNS::Resource::IN::WKS;T;[o;;I"/::Resolv::DNS::Message::MessageEncoder msg;T;I"	void;To;;I"-IP protocol number for these services.

;T;0;;;I"protocol;F;I"#Resolv::DNS::Resource::IN::WKS;T;[o;;I" ;F;I"Integer;To;;I" ;T;0;;;I"initialize;F;I"#Resolv::DNS::Resource::IN::WKS;T;[o;;I"L::String | ::Resolv::IPv4 address, ::Integer protocol, ::Integer bitmap;T;I"untyped;To; ;I"Location resource

;T;0;	I"Resolv::DNS::Resource::LOC;T;
[ ;[ ;0;[ ;[ ;0;I"Resolv::DNS::Resource;To;;0;0;;;I"decode_rdata;F;I"Resolv::DNS::Resource::LOC;T;[o;;I"/::Resolv::DNS::Message::MessageDecoder msg;T;I"instance;To;;I"The altitude of the LOC above a reference sphere whose surface sits 100km
below the WGS84 spheroid in centimeters as an unsigned 32bit integer

;T;0;;;I"altitude;F;I"Resolv::DNS::Resource::LOC;T;[o;;I" ;F;I"Integer;To;;0;0;;;I"encode_rdata;F;I"Resolv::DNS::Resource::LOC;T;[o;;I"/::Resolv::DNS::Message::MessageEncoder msg;T;I"	void;To;;I"•The horizontal precision using ssize type values in meters using scientific
notation as 2 integers of XeY for precision use value/2 e.g. 2m = +/-1m

;T;0;;;I"hprecision;F;I"Resolv::DNS::Resource::LOC;T;[o;;I" ;F;I"Integer;To;;I"xThe latitude for this LOC where 2**31 is the equator in thousandths of an arc
second as an unsigned 32bit integer

;T;0;;;I"latitude;F;I"Resolv::DNS::Resource::LOC;T;[o;;I" ;F;I"Integer;To;;I"{The longitude for this LOC where 2**31 is the prime meridian in thousandths of
an arc second as an unsigned 32bit integer

;T;0;;;I"longitude;F;I"Resolv::DNS::Resource::LOC;T;[o;;I" ;F;I"Integer;To;;I"^The spherical size of this LOC in meters using scientific notation as 2
integers of XeY

;T;0;;;I"
ssize;F;I"Resolv::DNS::Resource::LOC;T;[o;;I" ;F;I"Integer;To;;I"NReturns the version value for this LOC record which should always be 00

;T;0;;;I"version;F;I"Resolv::DNS::Resource::LOC;T;[o;;I" ;F;I"Integer;To;;I"“The vertical precision using ssize type values in meters using scientific
notation as 2 integers of XeY for precision use value/2 e.g. 2m = +/-1m

;T;0;;;I"vprecision;F;I"Resolv::DNS::Resource::LOC;T;[o;;I" ;F;I"Integer;To;;I" ;T;0;;;I"initialize;F;I"Resolv::DNS::Resource::LOC;T;[o;;I"‹::Integer version, ::Integer ssize, ::Integer hprecision, ::Integer vprecision, ::Integer latitude, ::Integer longitude, ::Integer altitude;T;I"untyped;To; ;I"+Mailing list or mailbox information.

;T;0;	I"!Resolv::DNS::Resource::MINFO;T;
[ ;[ ;0;[ ;[ ;0;I"Resolv::DNS::Resource;To;;0;0;;;I"decode_rdata;F;I"!Resolv::DNS::Resource::MINFO;T;[o;;I"/::Resolv::DNS::Message::MessageDecoder msg;T;I"instance;To;;I"MMailbox to use for error messages related to the mail list or mailbox.

;T;0;;;I"emailbx;F;I"!Resolv::DNS::Resource::MINFO;T;[o;;I" ;F;I"String;To;;0;0;;;I"encode_rdata;F;I"!Resolv::DNS::Resource::MINFO;T;[o;;I"/::Resolv::DNS::Message::MessageEncoder msg;T;I"	void;To;;I"=Domain name responsible for this mail list or mailbox.

;T;0;;;I"rmailbx;F;I"!Resolv::DNS::Resource::MINFO;T;[o;;I" ;F;I"String;To;;I" ;T;0;;;I"initialize;F;I"!Resolv::DNS::Resource::MINFO;T;[o;;I"'::String rmailbx, ::String emailbx;T;I"untyped;To; ;I"Mail Exchanger resource.

;T;0;	I"Resolv::DNS::Resource::MX;T;
[ ;[ ;0;[ ;[ ;0;I"Resolv::DNS::Resource;To;;0;0;;;I"decode_rdata;F;I"Resolv::DNS::Resource::MX;T;[o;;I"/::Resolv::DNS::Message::MessageDecoder msg;T;I"instance;To;;0;0;;;I"encode_rdata;F;I"Resolv::DNS::Resource::MX;T;[o;;I"/::Resolv::DNS::Message::MessageEncoder msg;T;I"	void;To;;I"The host of this MX.

;T;0;;;I"exchange;F;I"Resolv::DNS::Resource::MX;T;[o;;I" ;F;I"String;To;;I""The preference for this MX.

;T;0;;;I"preference;F;I"Resolv::DNS::Resource::MX;T;[o;;I" ;F;I"Integer;To;;I"OCreates a new MX record with `preference`, accepting mail at `exchange`.

;T;0;;;I"initialize;F;I"Resolv::DNS::Resource::MX;T;[o;;I",::Integer preference, ::String exchange;T;I"untyped;To; ;I"$An authoritative name server.

;T;0;	I"Resolv::DNS::Resource::NS;T;
[ ;[ ;0;[ ;[ ;0;I"&Resolv::DNS::Resource::DomainName;To; ;I"%A Pointer to another DNS name.

;T;0;	I"Resolv::DNS::Resource::PTR;T;
[ ;[ ;0;[ ;[ ;0;I"&Resolv::DNS::Resource::DomainName;To; ;I"#Start Of Authority resource.

;T;0;	I"Resolv::DNS::Resource::SOA;T;
[ ;[ ;0;[ ;[ ;0;I"Resolv::DNS::Resource;To;;0;0;;;I"decode_rdata;F;I"Resolv::DNS::Resource::SOA;T;[o;;I"/::Resolv::DNS::Message::MessageDecoder msg;T;I"instance;To;;0;0;;;I"encode_rdata;F;I"Resolv::DNS::Resource::SOA;T;[o;;I"/::Resolv::DNS::Message::MessageEncoder msg;T;I"	void;To;;I"vTime in seconds that a secondary name server is to use the data before
refreshing from the primary name server.

;T;0;;;I"expire;F;I"Resolv::DNS::Resource::SOA;T;[o;;I" ;F;I"Integer;To;;I"FThe minimum number of seconds to be used for TTL values in RRs.

;T;0;;;I"minimum;F;I"Resolv::DNS::Resource::SOA;T;[o;;I" ;F;I"Integer;To;;I"IName of the host where the master zone file for this zone resides.

;T;0;;;I"
mname;F;I"Resolv::DNS::Resource::SOA;T;[o;;I" ;F;I"String;To;;I"kHow often, in seconds, a secondary name server is to check for updates from
the primary name server.

;T;0;;;I"refresh;F;I"Resolv::DNS::Resource::SOA;T;[o;;I" ;F;I"Integer;To;;I"iHow often, in seconds, a secondary name server is to retry after a failure to
check for a refresh.

;T;0;;;I"
retry;F;I"Resolv::DNS::Resource::SOA;T;[o;;I" ;F;I"Integer;To;;I"3The person responsible for this domain name.

;T;0;;;I"
rname;F;I"Resolv::DNS::Resource::SOA;T;[o;;I" ;F;I"String;To;;I"+The version number of the zone file.

;T;0;;;I"serial;F;I"Resolv::DNS::Resource::SOA;T;[o;;I" ;F;I"Integer;To;;I"^Creates a new SOA record.  See the attr documentation for the details of each
argument.

;T;0;;;I"initialize;F;I"Resolv::DNS::Resource::SOA;T;[o;;I"::String mname, ::String rname, ::Integer serial, ::Integer refresh, ::Integer retry_, ::Integer expire, ::Integer minimum;T;I"untyped;To; ;I""Unstructured text resource.

;T;0;	I"Resolv::DNS::Resource::TXT;T;
[ ;[ ;0;[ ;[ ;0;I"Resolv::DNS::Resource;To;;0;0;;;I"decode_rdata;F;I"Resolv::DNS::Resource::TXT;T;[o;;I"/::Resolv::DNS::Message::MessageDecoder msg;T;I"instance;To;;I"6Returns the concatenated string from `strings`.

;T;0;;;I"	data;F;I"Resolv::DNS::Resource::TXT;T;[o;;I" ;F;I"String;To;;0;0;;;I"encode_rdata;F;I"Resolv::DNS::Resource::TXT;T;[o;;I"/::Resolv::DNS::Message::MessageEncoder msg;T;I"	void;To;;I"7Returns an Array of Strings for this TXT record.

;T;0;;;I"strings;F;I"Resolv::DNS::Resource::TXT;T;[o;;I" ;F;I"Array[::String];To;;I" ;T;0;;;I"initialize;F;I"Resolv::DNS::Resource::TXT;T;[o;;I"2::String first_string, *::String rest_strings;T;I"untyped;To; ;I"LResolv::Hosts is a hostname resolver that uses the system hosts file.

;T;0;	I"Resolv::Hosts;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"OIterates over all IP addresses for `name` retrieved from the hosts file.

;T;0;;;I"each_address;F;I"Resolv::Hosts;T;[o;;I"::String name;T;I"	void;To;;I"OIterates over all hostnames for `address` retrieved from the hosts file.

;T;0;;;I"each_name;F;I"Resolv::Hosts;T;[o;;I"::String address;T;I"	void;To;;I"9Gets the IP address of `name` from the hosts file.

;T;0;;;I"getaddress;F;I"Resolv::Hosts;T;[o;;I"::String name;T;I"String;To;;I"<Gets all IP addresses for `name` from the hosts file.

;T;0;;;I"getaddresses;F;I"Resolv::Hosts;T;[o;;I"::String name;T;I"Array[::String];To;;I":Gets the hostname of `address` from the hosts file.

;T;0;;;I"getname;F;I"Resolv::Hosts;T;[o;;I"::String address;T;I"String;To;;I"<Gets all hostnames for `address` from the hosts file.

;T;0;;;I"getnames;F;I"Resolv::Hosts;T;[o;;I"::String address;T;I"Array[::String];To;;0;0;;;I"lazy_initialize;F;I"Resolv::Hosts;T;[o;;I" ;F;I"	void;To;;I"ICreates a new Resolv::Hosts, using `filename` for its data source.

;T;0;;;I"initialize;F;I"Resolv::Hosts;T;[o;;I"?::String filename;T;I"untyped;To; ;I""A Resolv::DNS IPv4 address.

;T;0;	I"Resolv::IPv4;T;
[ ;[ ;0;[ ;[ ;0;0o;;I" ;T;0;;;I"create;F;I"Resolv::IPv4;T;[o;;I"::String | instance arg;T;I"instance;To;;0;0;;;I"==;F;I"Resolv::IPv4;T;[o;;I"instance other;T;I"	bool;To;;I"(The raw IPv4 address as a String.

;T;0;;;I"address;F;I"Resolv::IPv4;T;[o;;I" ;F;I"String;To;;0;0;;;I"	eql?;F;I"Resolv::IPv4;T;[o;;I"instance other;T;I"	bool;To;;0;0;;;I"	hash;F;I"Resolv::IPv4;T;[o;;I" ;F;I"Integer;To;;0;0;;;I"inspect;F;I"Resolv::IPv4;T;[o;;I" ;F;I"String;To;;I"8Turns this IPv4 address into a Resolv::DNS::Name.

;T;0;;;I"to_name;F;I"Resolv::IPv4;T;[o;;I" ;F;I"Resolv::DNS::Name;To;;0;0;;;I"	to_s;F;I"Resolv::IPv4;T;[o;;I" ;F;I"String;To;;0;0;;;I"initialize;F;I"Resolv::IPv4;T;[o;;I"::String address;T;I"untyped;To; ;I""A Resolv::DNS IPv6 address.

;T;0;	I"Resolv::IPv6;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"ŒCreates a new IPv6 address from `arg` which may be:

IPv6
:   returns `arg`.
String
:   `arg` must match one of the IPv6::Regex* constants

;T;0;;;I"create;F;I"Resolv::IPv6;T;[o;;I"::String | instance arg;T;I"instance;To;;0;0;;;I"==;F;I"Resolv::IPv6;T;[o;;I"instance other;T;I"	bool;To;;I"(The raw IPv6 address as a String.

;T;0;;;I"address;F;I"Resolv::IPv6;T;[o;;I" ;F;I"String;To;;0;0;;;I"	eql?;F;I"Resolv::IPv6;T;[o;;I"instance other;T;I"	bool;To;;0;0;;;I"	hash;F;I"Resolv::IPv6;T;[o;;I" ;F;I"Integer;To;;0;0;;;I"inspect;F;I"Resolv::IPv6;T;[o;;I" ;F;I"String;To;;I"8Turns this IPv6 address into a Resolv::DNS::Name.

;T;0;;;I"to_name;F;I"Resolv::IPv6;T;[o;;I" ;F;I"Resolv::DNS::Name;To;;0;0;;;I"	to_s;F;I"Resolv::IPv6;T;[o;;I" ;F;I"String;To;;0;0;;;I"initialize;F;I"Resolv::IPv6;T;[o;;I"untyped address;T;I"untyped;To;;0;0;	I"Resolv::LOC;T;
[ ;[ ;0;[ ;[ o; ;I"A Resolv::LOC::Alt

;T;0;	I"Resolv::LOC::Alt;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"‡Creates a new LOC::Alt from `arg` which may be:

LOC::Alt
:   returns `arg`.
String
:   `arg` must match the LOC::Alt::Regex constant

;T;0;;;I"create;F;I"Resolv::LOC::Alt;T;[o;;I"&::Resolv::LOC::Alt | ::String arg;T;I"instance;To;;0;0;;;I"	eql?;F;I"Resolv::LOC::Alt;T;[o;;I"::Resolv::LOC::Alt other;T;I"	bool;To;;I"The raw altitude

;T;0;;;I"altitude;F;I"Resolv::LOC::Alt;T;[o;;I" ;F;I"Integer;To;;0;0;;;I"	hash;F;I"Resolv::LOC::Alt;T;[o;;I" ;F;I"Integer;To;;0;0;;;I"inspect;F;I"Resolv::LOC::Alt;T;[o;;I" ;F;I"String;To;;0;0;;;I"	to_s;F;I"Resolv::LOC::Alt;T;[o;;I" ;F;I"String;To;;I" ;T;0;;;I"initialize;F;I"Resolv::LOC::Alt;T;[o;;I"::Integer altitude;T;I"untyped;To; ;I"A Resolv::LOC::Coord

;T;0;	I"Resolv::LOC::Coord;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"Creates a new LOC::Coord from `arg` which may be:

LOC::Coord
:   returns `arg`.
String
:   `arg` must match the LOC::Coord::Regex constant

;T;0;;;I"create;F;I"Resolv::LOC::Coord;T;[o;;I"(::Resolv::LOC::Coord | ::String arg;T;I"instance;To;;0;0;;;I"	eql?;F;I"Resolv::LOC::Coord;T;[o;;I"::Resolv::LOC::Coord other;T;I"	bool;To;;I"The raw coordinates

;T;0;;;I"coordinates;F;I"Resolv::LOC::Coord;T;[o;;I" ;F;I"String;To;;0;0;;;I"	hash;F;I"Resolv::LOC::Coord;T;[o;;I" ;F;I"Integer;To;;0;0;;;I"inspect;F;I"Resolv::LOC::Coord;T;[o;;I" ;F;I"String;To;;I":The orientation of the hemisphere as 'lat' or 'lon'

;T;0;;;I"orientation;F;I"Resolv::LOC::Coord;T;[o;;I" ;F;I"$Resolv::LOC::Coord::orientation;To;;0;0;;;I"	to_s;F;I"Resolv::LOC::Coord;T;[o;;I" ;F;I"String;To;;I" ;T;0;;;I"initialize;F;I"Resolv::LOC::Coord;T;[o;;I"H::String coordinates, ::Resolv::LOC::Coord::orientation orientation;T;I"untyped;To; ;I"A Resolv::LOC::Size

;T;0;	I"Resolv::LOC::Size;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"ŠCreates a new LOC::Size from `arg` which may be:

LOC::Size
:   returns `arg`.
String
:   `arg` must match the LOC::Size::Regex constant

;T;0;;;I"create;F;I"Resolv::LOC::Size;T;[o;;I"'::Resolv::LOC::Size | ::String arg;T;I"instance;To;;0;0;;;I"	eql?;F;I"Resolv::LOC::Size;T;[o;;I"::Resolv::LOC::Size other;T;I"	bool;To;;0;0;;;I"	hash;F;I"Resolv::LOC::Size;T;[o;;I" ;F;I"Integer;To;;0;0;;;I"inspect;F;I"Resolv::LOC::Size;T;[o;;I" ;F;I"String;To;;I"The raw size

;T;0;;;I"scalar;F;I"Resolv::LOC::Size;T;[o;;I" ;F;I"String;To;;0;0;;;I"	to_s;F;I"Resolv::LOC::Size;T;[o;;I" ;F;I"String;To;;I" ;T;0;;;I"initialize;F;I"Resolv::LOC::Size;T;[o;;I"::String scalar;T;I"untyped;To; ;I"ÝResolv::MDNS is a one-shot Multicast DNS (mDNS) resolver.  It blindly makes
queries to the mDNS addresses without understanding anything about multicast
ports.

Information taken form the following places:

*   RFC 6762

;T;0;	I"Resolv::MDNS;T;
[ ;[ ;0;[ ;[ ;0;I"Resolv::DNS;To;;I"Iterates over all IP addresses for `name` retrieved from the mDNS resolver,
provided name ends with "local".  If the name does not end in "local" no
records will be returned.

`name` can be a Resolv::DNS::Name or a String.  Retrieved addresses will be a
Resolv::IPv4 or Resolv::IPv6

;T;0;;;I"each_address;F;I"Resolv::MDNS;T;[o;;I"!::Resolv::DNS::dns_name name;T;I"Resolv::DNS::ip_address;To;;0;0;;;I"make_udp_requester;F;I"Resolv::MDNS;T;[o;;I" ;F;I"TResolv::DNS::Requester::ConnectedUDP | ::Resolv::DNS::Requester::UnconnectedUDP;To;;I"ËCreates a new one-shot Multicast DNS (mDNS) resolver.

`config_info` can be:

nil
:   Uses the default mDNS addresses

Hash
:   Must contain :nameserver or :nameserver_port like Resolv::DNS#initialize.

;T;0;;;I"initialize;F;I"Resolv::MDNS;T;[o;;I"6?::String | ::Hash[::Symbol, untyped] config_info;T;I"untyped;To; ;I"8Indicates a failure to resolve a name or address.

;T;0;	I"Resolv::ResolvError;T;
[ ;[ ;0;[ ;[ ;0;I"StandardError;To; ;I"7Indicates a timeout resolving a name or address.

;T;0;	I"Resolv::ResolvTimeout;T;
[ ;[ ;0;[ ;[ ;0;I"Timeout::Error;To; ;I"}BasicSpecification is an abstract class which implements some common code used
by both Specification and StubSpecification.

;T;0;	I"Gem::BasicSpecification;T;
[ ;[ ;0;[ ;[ ;0;0o; ;I"LGem::ConfigFile RubyGems options and gem command options from gemrc.

gemrc is a YAML file that uses strings to match gem command arguments and
symbols to match RubyGems options.

Gem command arguments use a String key that matches the command name and allow
you to specify default arguments:

    install: --no-rdoc --no-ri
    update: --no-rdoc --no-ri

You can use `gem:` to set default arguments for all commands.

RubyGems options use symbol keys.  Valid options are:

`:backtrace`
:   See #backtrace
`:sources`
:   Sets Gem::sources
`:verbose`
:   See #verbose
`:concurrent_downloads`
:   See #concurrent_downloads


gemrc files may exist in various locations and are read and merged in the
following order:

*   system wide (/etc/gemrc)
*   per user (~/.gemrc)
*   per environment (gemrc files listed in the GEMRC environment variable)

;T;0;	I"Gem::ConfigFile;T;
[ ;[ ;0;[ ;[ ;0;0o; ;I"QInstalls a gem along with all its dependencies from local and remote gems.

;T;0;	I"Gem::DependencyInstaller;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"øRubyGems is the Ruby standard for publishing and managing third party
libraries.

For user documentation, see:

*   `gem help` and `gem help [command]`
*   [RubyGems User Guide](https://guides.rubygems.org/)
*   [Frequently Asked Questions](https://guides.rubygems.org/faqs)


For gem developer documentation see:

*   [Creating Gems](https://guides.rubygems.org/make-your-own-gem)
*   Gem::Specification
*   Gem::Version for version dependency notes


Further RubyGems documentation can be found at:

*   [RubyGems Guides](https://guides.rubygems.org)
*   [RubyGems API](https://www.rubydoc.info/github/rubygems/rubygems) (also
    available from `gem server`)


## RubyGems Plugins

RubyGems will load plugins in the latest version of each installed gem or
$LOAD_PATH.  Plugins must be named 'rubygems_plugin' (.rb, .so, etc) and
placed at the root of your gem's #require_path.  Plugins are installed at a
special location and loaded on boot.

For an example plugin, see the [Graph gem](https://github.com/seattlerb/graph)
which adds a `gem graph` command.

## RubyGems Defaults, Packaging

RubyGems defaults are stored in lib/rubygems/defaults.rb.  If you're packaging
RubyGems or implementing Ruby you can change RubyGems' defaults.

For RubyGems packagers, provide lib/rubygems/defaults/operating_system.rb and
override any defaults from lib/rubygems/defaults.rb.

For Ruby implementers, provide lib/rubygems/defaults/#{RUBY_ENGINE}.rb and
override any defaults from lib/rubygems/defaults.rb.

If you need RubyGems to perform extra work on install or uninstall, your
defaults override file can set pre/post install and uninstall hooks. See
Gem::pre_install, Gem::pre_uninstall, Gem::post_install, Gem::post_uninstall.

## Bugs

You can submit bugs to the [RubyGems bug
tracker](https://github.com/rubygems/rubygems/issues) on GitHub

## Credits

RubyGems is currently maintained by Eric Hodel.

RubyGems was originally developed at RubyConf 2003 by:

*   Rich Kilmer  -- rich(at)infoether.com
*   Chad Fowler  -- chad(at)chadfowler.com
*   David Black  -- dblack(at)wobblini.net
*   Paul Brannan -- paul(at)atdesk.com
*   Jim Weirich   -- jim(at)weirichhouse.org


Contributors:

*   Gavin Sinclair     -- gsinclair(at)soyabean.com.au
*   George Marrows     -- george.marrows(at)ntlworld.com
*   Dick Davies        -- rasputnik(at)hellooperator.net
*   Mauricio Fernandez -- batsman.geo(at)yahoo.com
*   Simon Strandgaard  -- neoneye(at)adslhome.dk
*   Dave Glasser       -- glasser(at)mit.edu
*   Paul Duncan        -- pabs(at)pablotron.org
*   Ville Aine         -- vaine(at)cs.helsinki.fi
*   Eric Hodel         -- drbrain(at)segment7.net
*   Daniel Berger      -- djberg96(at)gmail.com
*   Phil Hagelberg     -- technomancy(at)gmail.com
*   Ryan Davis         -- ryand-ruby(at)zenspider.com
*   Evan Phoenix       -- evan(at)fallingsnow.net
*   Steve Klabnik      -- steve(at)steveklabnik.com


(If your name is missing, PLEASE let us know!)

## License

See [LICENSE.txt](rdoc-ref:lib/rubygems/LICENSE.txt) for permissions.

Thanks!

-The RubyGems Team

;T;0;	I"Gem;T;
[ ;[ ;0;[ ;[ o;;0;0;	I"Gem;T;
[ ;[ ;0;[ ;[ o;;I"øRubyGems is the Ruby standard for publishing and managing third party
libraries.

For user documentation, see:

*   `gem help` and `gem help [command]`
*   [RubyGems User Guide](https://guides.rubygems.org/)
*   [Frequently Asked Questions](https://guides.rubygems.org/faqs)


For gem developer documentation see:

*   [Creating Gems](https://guides.rubygems.org/make-your-own-gem)
*   Gem::Specification
*   Gem::Version for version dependency notes


Further RubyGems documentation can be found at:

*   [RubyGems Guides](https://guides.rubygems.org)
*   [RubyGems API](https://www.rubydoc.info/github/rubygems/rubygems) (also
    available from `gem server`)


## RubyGems Plugins

RubyGems will load plugins in the latest version of each installed gem or
$LOAD_PATH.  Plugins must be named 'rubygems_plugin' (.rb, .so, etc) and
placed at the root of your gem's #require_path.  Plugins are installed at a
special location and loaded on boot.

For an example plugin, see the [Graph gem](https://github.com/seattlerb/graph)
which adds a `gem graph` command.

## RubyGems Defaults, Packaging

RubyGems defaults are stored in lib/rubygems/defaults.rb.  If you're packaging
RubyGems or implementing Ruby you can change RubyGems' defaults.

For RubyGems packagers, provide lib/rubygems/defaults/operating_system.rb and
override any defaults from lib/rubygems/defaults.rb.

For Ruby implementers, provide lib/rubygems/defaults/#{RUBY_ENGINE}.rb and
override any defaults from lib/rubygems/defaults.rb.

If you need RubyGems to perform extra work on install or uninstall, your
defaults override file can set pre/post install and uninstall hooks. See
Gem::pre_install, Gem::pre_uninstall, Gem::post_install, Gem::post_uninstall.

## Bugs

You can submit bugs to the [RubyGems bug
tracker](https://github.com/rubygems/rubygems/issues) on GitHub

## Credits

RubyGems is currently maintained by Eric Hodel.

RubyGems was originally developed at RubyConf 2003 by:

*   Rich Kilmer  -- rich(at)infoether.com
*   Chad Fowler  -- chad(at)chadfowler.com
*   David Black  -- dblack(at)wobblini.net
*   Paul Brannan -- paul(at)atdesk.com
*   Jim Weirich   -- jim(at)weirichhouse.org


Contributors:

*   Gavin Sinclair     -- gsinclair(at)soyabean.com.au
*   George Marrows     -- george.marrows(at)ntlworld.com
*   Dick Davies        -- rasputnik(at)hellooperator.net
*   Mauricio Fernandez -- batsman.geo(at)yahoo.com
*   Simon Strandgaard  -- neoneye(at)adslhome.dk
*   Dave Glasser       -- glasser(at)mit.edu
*   Paul Duncan        -- pabs(at)pablotron.org
*   Ville Aine         -- vaine(at)cs.helsinki.fi
*   Eric Hodel         -- drbrain(at)segment7.net
*   Daniel Berger      -- djberg96(at)gmail.com
*   Phil Hagelberg     -- technomancy(at)gmail.com
*   Ryan Davis         -- ryand-ruby(at)zenspider.com
*   Evan Phoenix       -- evan(at)fallingsnow.net
*   Steve Klabnik      -- steve(at)steveklabnik.com


(If your name is missing, PLEASE let us know!)

## License

See [LICENSE.txt](rdoc-ref:lib/rubygems/LICENSE.txt) for permissions.

Thanks!

-The RubyGems Team

;T;0;	I"Gem;T;
[ ;[ ;0;[ ;[ o;;I"‡The number of paths in the `$LOAD_PATH` from activated gems. Used to
prioritize `-I` and `[ENV]('RUBYLIB`)` entries during `require`.

;T;0;;;I"activated_gem_paths;F;I"Gem;T;[o;;I" ;F;I"Integer;To;;I"AAdd a list of paths to the $LOAD_PATH at the proper place.

;T;0;;;I"add_to_load_path;F;I"Gem;T;[o;;I"*::String paths;T;I"Array[::String];To;;I"éFind the full path to the executable for gem `name`.  If the `exec_name` is
not given, an exception will be raised, otherwise the specified executable's
path is returned.  `requirements` allows you to specify specific gem versions.

;T;0;;;I"bin_path;F;I"Gem;T;[o;;I"Q::String name, ::String exec_name, ?::Array[::Gem::Requirement] requirements;T;I"String;To;;I"9The mode needed to read a file as straight binary.

;T;0;;;I"binary_mode;F;I"Gem;T;[o;;I" ;F;I"String;To;;I":The path where gem executables are to be installed.

;T;0;;;I"bindir;F;I"Gem;T;[o;;I"?::String install_dir;T;I"String;To;;I"CThe path to standard location of the user's cache directory.

;T;0;;;I"cache_home;F;I"Gem;T;[o;;I" ;F;I"String;To;;I":Clear default gem related variables. It is for test

;T;0;;;I"clear_default_specs;F;I"Gem;T;[o;;I" ;F;I"	void;To;;I"¿Reset the `dir` and `path` values.  The next time `dir` or `path` is
requested, the values will be calculated from scratch.  This is mainly used by
the unit tests to provide test isolation.

;T;0;;;I"clear_paths;F;I"Gem;T;[o;;I" ;F;I"	void;To;;I"?The path to standard location of the user's .gemrc file.

;T;0;;;I"config_file;F;I"Gem;T;[o;;I" ;F;I"String;To;;I"KThe path to standard location of the user's configuration directory.

;T;0;;;I"config_home;F;I"Gem;T;[o;;I" ;F;I"String;To;;I"2The standard configuration object for gems.

;T;0;;;I"configuration;F;I"Gem;T;[o;;I" ;F;I"Gem::ConfigFile;To;;I"zUse the given configuration object (which implements the ConfigFile protocol)
as the standard configuration object.

;T;0;;;I"configuration=;F;I"Gem;T;[o;;I"::Gem::ConfigFile config;T;I"Gem::ConfigFile;To;;I"BThe path to standard location of the user's data directory.

;T;0;;;I"data_home;F;I"Gem;T;[o;;I" ;F;I"String;To;;I"wThe path to the data directory specified by the gem name.  If the package is
not available as a gem, return nil.

;T;0;;;I"datadir;F;I"Gem;T;[o;;I"::String gem_name;T;I"String?;To;;I")The default directory for binaries

;T;0;;;I"default_bindir;F;I"Gem;T;[o;;I" ;F;I"String;To;;I"1The default signing certificate chain path

;T;0;;;I"default_cert_path;F;I"Gem;T;[o;;I" ;F;I"String;To;;I"gDefault home directory path to be used if an alternate value is not specified
in the environment

;T;0;;;I"default_dir;F;I"Gem;T;[o;;I" ;F;I"String;To;;I"PDeduce Ruby's --program-prefix and --program-suffix from its install name

;T;0;;;I"default_exec_format;F;I"Gem;T;[o;;I" ;F;I"String;To;;I"âReturns binary extensions dir for specified RubyGems base dir or nil if such
directory cannot be determined.

By default, the binary extensions are located side by side with their Ruby
counterparts, therefore nil is returned

;T;0;;;I"default_ext_dir_for;F;I"Gem;T;[o;;I"::String base_dir;T;I"String?;To;;I"#The default signing key path

;T;0;;;I"default_key_path;F;I"Gem;T;[o;;I" ;F;I"String;To;;I"Default gem load path

;T;0;;;I"default_path;F;I"Gem;T;[o;;I" ;F;I"Array[::String];To;;I"BPaths where RubyGems' .rb files and bin files are installed

;T;0;;;I"default_rubygems_dirs;F;I"Gem;T;[o;;I" ;F;I"Array[::String]?;To;;I">An Array of the default sources that come with RubyGems

;T;0;;;I"default_sources;F;I"Gem;T;[o;;I" ;F;I"Array[::String];To;;I"gDefault spec directory path to be used if an alternate value is not specified
in the environment

;T;0;;;I"default_spec_cache_dir;F;I"Gem;T;[o;;I" ;F;I"String;To;;I"3Path to specification files of default gems.

;T;0;;;I"default_specifications_dir;F;I"Gem;T;[o;;I" ;F;I"String;To;;I"&A Zlib::Deflate.deflate wrapper

;T;0;;;I"deflate;F;I"Gem;T;[o;;I"::String data;T;I"String;To;;I"/The path where gems are to be installed.

;T;0;;;I"dir;F;I"Gem;T;[o;;I" ;F;I"String;To;;I"ÃRubyGems distributors (like operating system package managers) can disable
RubyGems update by setting this to error message printed to end-users on gem
update --system instead of actual update.

;T;0;;;I""disable_system_update_message;F;I"Gem;T;[o;;I" ;F;I"String?;To;;I"ÃRubyGems distributors (like operating system package managers) can disable
RubyGems update by setting this to error message printed to end-users on gem
update --system instead of actual update.

;T;0;;;I"#disable_system_update_message=;F;I"Gem;T;[o;;I"::String?;T;I"String?;To;;I"£Adds a post-installs hook that will be passed a Gem::DependencyInstaller and a
list of installed specifications when Gem::DependencyInstaller#install is
complete

;T;0;;;I"done_installing;F;I"Gem;T;[o;;I" ;F;I"Array[::Proc];To;;I"XThe list of hooks to be run after Gem::DependencyInstaller installs a set of
gems

;T;0;;;I"done_installing_hooks;F;I"Gem;T;[o;;I" ;F;I"Array[::Proc?];To;;I"?Quietly ensure the Gem directory `dir` contains all the proper subdirectories
for handling default gems.  If we can't create a directory due to a permission
problem, then we will silently continue.

If `mode` is given, missing directories are created with this mode.

World-writable directories will never be created.

;T;0;;;I"&ensure_default_gem_subdirectories;F;I"Gem;T;[o;;I".?::String dir, ?::Integer | ::String mode;T;I"Array[::String];To;;I"%Quietly ensure the Gem directory `dir` contains all the proper subdirectories.
 If we can't create a directory due to a permission problem, then we will
silently continue.

If `mode` is given, missing directories are created with this mode.

World-writable directories will never be created.

;T;0;;;I"ensure_gem_subdirectories;F;I"Gem;T;[o;;I".?::String dir, ?::Integer | ::String mode;T;I"Array[::String];To;;I" ;T;0;;;I"env_requirement;F;I"Gem;T;[o;;I"::String gem_name;T;I"Gem::Requirement;To;;I"#Finds the user's config file

;T;0;;;I"find_config_file;F;I"Gem;T;[o;;I" ;F;I"String;To;;I"«Returns a list of paths matching `glob` that can be used by a gem to pick up
features from other gems.  For example:

    Gem.find_files('rdoc/discover').each do |path| load path end

if `check_load_path` is true (the default), then find_files also searches
$LOAD_PATH for files as well as gems.

Note that find_files will return all files even if they are from different
versions of the same gem.  See also find_latest_files

;T;0;;;I"find_files;F;I"Gem;T;[o;;I".::String glob, ?::boolish check_load_path;T;I"Array[::String];To;;I"«Returns a list of paths matching `glob` from the latest gems that can be used
by a gem to pick up features from other gems.  For example:

    Gem.find_latest_files('rdoc/discover').each do |path| load path end

if `check_load_path` is true (the default), then find_latest_files also
searches $LOAD_PATH for files as well as gems.

Unlike find_files, find_latest_files will return only files from the latest
version of a gem.

;T;0;;;I"find_latest_files;F;I"Gem;T;[o;;I".::String glob, ?::boolish check_load_path;T;I"Array[::String];To;;I";Find a Gem::Specification of default gem from `path`

;T;0;;;I"!find_unresolved_default_spec;F;I"Gem;T;[o;;I"::String path;T;I"Gem::Specification?;To;;I" ;T;0;;;I"finish_resolve;F;I"Gem;T;[o;;I"#?::Gem::RequestSet request_set;T;I"	void;To;;I"}GemDependencyAPI object, which is set when .use_gemdeps is called. This
contains all the information from the Gemfile.

;T;0;;;I"gemdeps;F;I"Gem;T;[o;;I" ;F;I"'Gem::RequestSet::GemDependencyAPI?;To;;I"RGet the default RubyGems API host. This is normally `https://rubygems.org`.

;T;0;;;I"	host;F;I"Gem;T;[o;;I" ;F;I"String;To;;I")Set the default RubyGems API host.

;T;0;;;I"
host=;F;I"Gem;T;[o;;I"::String host;T;I"String;To;;I"ßTop level install helper method. Allows you to install gems interactively:

    % irb
    >> Gem.install "minitest"
    Fetching: minitest-5.14.0.gem (100%)
    => [#<Gem::Specification:0x1013b4528 @name="minitest", ...>]

;T;0;;;I"install;F;I"Gem;T;[o;;I"]::String name, ?::Gem::Requirement version, *::Gem::DependencyInstaller::options options;T;I" Array[::Gem::Specification];To;;I"Is this a java platform?

;T;0;;;I"java_platform?;F;I"Gem;T;[o;;I" ;F;I"	bool;To;;I"6Returns the latest release version of RubyGems.

;T;0;;;I"latest_rubygems_version;F;I"Gem;T;[o;;I" ;F;I"Gem::Version;To;;I"KReturns the latest release-version specification for the gem `name`.

;T;0;;;I"latest_spec_for;F;I"Gem;T;[o;;I"::String name;T;I"Gem::Specification?;To;;I"FReturns the version of the latest release-version of gem `name`

;T;0;;;I"latest_version_for;F;I"Gem;T;[o;;I"::String name;T;I"Gem::Version?;To;;I"CFind all 'rubygems_plugin' files in $LOAD_PATH and load them

;T;0;;;I"load_env_plugins;F;I"Gem;T;[o;;I" ;F;I"Array[::String];To;;I"‹The index to insert activated gem paths into the $LOAD_PATH. The activated
gem's paths are inserted before site lib directory by default.

;T;0;;;I"load_path_insert_index;F;I"Gem;T;[o;;I" ;F;I"Integer;To;;I"HFind rubygems plugin files in the standard location and load them

;T;0;;;I"load_plugins;F;I"Gem;T;[o;;I" ;F;I"Array[::String];To;;I"#Loads YAML, preferring Psych

;T;0;;;I"load_yaml;F;I"Gem;T;[o;;I" ;F;I"
bool?;To;;I"6Hash of loaded Gem::Specification keyed by name

;T;0;;;I"loaded_specs;F;I"Gem;T;[o;;I" ;F;I".Hash[::String, ::Gem::BasicSpecification];To;;I"yThe file name and line number of the caller of the caller of this method.

`depth` is how many layers up the call stack it should go.

e.g.,

def a; Gem.location_of_caller; end a #=> ["x.rb", 2]  # (it'll vary depending
on file name and line number)

def b; c; end def c; Gem.location_of_caller(2); end b #=> ["x.rb", 6]  #
(it'll vary depending on file name and line number)

;T;0;;;I"location_of_caller;F;I"Gem;T;[o;;I"?::Integer depth;T;I"[ ::String, ::Integer ];To;;I"7The version of the Marshal format for your Ruby.

;T;0;;;I"marshal_version;F;I"Gem;T;[o;;I" ;F;I"String;To;;I" ;T;0;;;I"
needs;F;I"Gem;T;[o;;I" ;F;I"	void;To;;I"kDefault options for gem commands for Ruby packagers.

The options here should be structured as an array of string "gem" command
names as keys and a string of the default options as values.

Example:

def self.operating_system_defaults
    {
        'install' => '--no-rdoc --no-ri --env-shebang',
        'update' => '--no-rdoc --no-ri --env-shebang'
    }

end

;T;0;;;I"operating_system_defaults;F;I"Gem;T;[o;;I" ;F;I"Hash[::String, ::String];To;;I" ;T;0;;;I"	path;F;I"Gem;T;[o;;I" ;F;I"Array[::String];To;;I"QHow String Gem paths should be split.  Overridable for esoteric platforms.

;T;0;;;I"path_separator;F;I"Gem;T;[o;;I" ;F;I"String;To;;I"JRetrieve the PathSupport object that RubyGems uses to lookup files.

;T;0;;;I"
paths;F;I"Gem;T;[o;;I" ;F;I"Gem::PathSupport;To;;I"ÿInitialize the filesystem paths to use from `env`. `env` is a hash-like object
(typically ENV) that is queried for 'GEM_HOME', 'GEM_PATH', and
'GEM_SPEC_CACHE' Keys for the `env` hash should be Strings, and values of the
hash should be Strings or `nil`.

;T;0;;;I"paths=;F;I"Gem;T;[o;;I".::Gem::_HashLike[::String, ::String?] env;T;I"Array[::String];To;;I"fDefault options for gem commands for Ruby implementers.

The options here should be structured as an array of string "gem" command
names as keys and a string of the default options as values.

Example:

def self.platform_defaults
    {
        'install' => '--no-rdoc --no-ri --env-shebang',
        'update' => '--no-rdoc --no-ri --env-shebang'
    }

end

;T;0;;;I"platform_defaults;F;I"Gem;T;[o;;I" ;F;I"Hash[::String, ::String];To;;I"1Array of platforms this RubyGems supports.

;T;0;;;I"platforms;F;I"Gem;T;[o;;I" ;F;I"&Array[::String | ::Gem::Platform];To;;I"MSet array of platforms this RubyGems supports (primarily for testing).

;T;0;;;I"platforms=;F;I"Gem;T;[o;;I"2::Array[::String | ::Gem::Platform] platforms;T;I"&Array[::String | ::Gem::Platform];To;;I"5Glob pattern for require-able plugin suffixes.

;T;0;;;I"plugin_suffix_pattern;F;I"Gem;T;[o;;I" ;F;I"String;To;;I"/Regexp for require-able plugin suffixes.

;T;0;;;I"plugin_suffix_regexp;F;I"Gem;T;[o;;I" ;F;I"Regexp;To;;I":The path were rubygems plugins are to be installed.

;T;0;;;I"plugindir;F;I"Gem;T;[o;;I"?::String install_dir;T;I"String;To;;I"]Adds a post-build hook that will be passed an Gem::Installer instance when
Gem::Installer#install is called.  The hook is called after the gem has been
extracted and extensions have been built but before the executables or gemspec
has been written.  If the hook returns `false` then the gem's files will be
removed and the install will be aborted.

;T;0;;;I"post_build;F;I"Gem;T;[o;;I" ;F;I"Array[::Proc];To;;I"dThe list of hooks to be run after Gem::Installer#install extracts files and
builds extensions

;T;0;;;I"post_build_hooks;F;I"Gem;T;[o;;I" ;F;I"Array[::Proc];To;;I"tAdds a post-install hook that will be passed an Gem::Installer instance when
Gem::Installer#install is called

;T;0;;;I"post_install;F;I"Gem;T;[o;;I" ;F;I"Array[::Proc];To;;I"VThe list of hooks to be run after Gem::Installer#install completes
installation

;T;0;;;I"post_install_hooks;F;I"Gem;T;[o;;I" ;F;I"Array[::Proc];To;;I"KAdds a hook that will get run after Gem::Specification.reset is run.

;T;0;;;I"post_reset;F;I"Gem;T;[o;;I" ;F;I"Array[::Proc];To;;I"IThe list of hooks to be run after Gem::Specification.reset is run.

;T;0;;;I"post_reset_hooks;F;I"Gem;T;[o;;I" ;F;I"Array[::Proc?];To;;I"˜Adds a post-uninstall hook that will be passed a Gem::Uninstaller instance and
the spec that was uninstalled when Gem::Uninstaller#uninstall is called

;T;0;;;I"post_uninstall;F;I"Gem;T;[o;;I" ;F;I"Array[::Proc];To;;I"ZThe list of hooks to be run after Gem::Uninstaller#uninstall completes
installation

;T;0;;;I"post_uninstall_hooks;F;I"Gem;T;[o;;I" ;F;I"Array[::Proc?];To;;I"®Adds a pre-install hook that will be passed an Gem::Installer instance when
Gem::Installer#install is called.  If the hook returns `false` then the
install will be aborted.

;T;0;;;I"pre_install;F;I"Gem;T;[o;;I" ;F;I"Array[::Proc];To;;I"NThe list of hooks to be run before Gem::Installer#install does any work

;T;0;;;I"pre_install_hooks;F;I"Gem;T;[o;;I" ;F;I"Array[::Proc?];To;;I"LAdds a hook that will get run before Gem::Specification.reset is run.

;T;0;;;I"pre_reset;F;I"Gem;T;[o;;I" ;F;I"Array[::Proc];To;;I"JThe list of hooks to be run before Gem::Specification.reset is run.

;T;0;;;I"pre_reset_hooks;F;I"Gem;T;[o;;I" ;F;I"Array[::Proc?];To;;I"œAdds a pre-uninstall hook that will be passed an Gem::Uninstaller instance and
the spec that will be uninstalled when Gem::Uninstaller#uninstall is called

;T;0;;;I"pre_uninstall;F;I"Gem;T;[o;;I" ;F;I"Array[::Proc];To;;I"RThe list of hooks to be run before Gem::Uninstaller#uninstall does any work

;T;0;;;I"pre_uninstall_hooks;F;I"Gem;T;[o;;I" ;F;I"Array[::Proc?];To;;I"±The directory prefix this RubyGems was installed at. If your prefix is in a
standard location (ie, rubygems is installed where you'd expect it to be),
then prefix returns nil.

;T;0;;;I"prefix;F;I"Gem;T;[o;;I" ;F;I"String?;To;;I":Safely read a file in binary mode on all platforms.

;T;0;;;I"read_binary;F;I"Gem;T;[o;;I"::String path;T;I"String;To;;I"(Refresh available gems from disk.

;T;0;;;I"refresh;F;I"Gem;T;[o;;I" ;F;I"Array[::Proc];To;;I"¢Register a Gem::Specification for default gem.

Two formats for the specification are supported:

*   MRI 2.0 style, where spec.files contains unprefixed require names. The
    spec's filenames will be registered as-is.
*   New style, where spec.files contains files prefixed with paths from
    spec.require_paths. The prefixes are stripped before registering the
    spec's filenames. Unprefixed files are omitted.

;T;0;;;I"register_default_spec;F;I"Gem;T;[o;;I"::Gem::Specification spec;T;I"Array[::String];To;;I"0The path to the running Ruby interpreter.

;T;0;;;I"	ruby;F;I"Gem;T;[o;;I" ;F;I"String;To;;I"HReturns a String containing the API compatibility version of Ruby

;T;0;;;I"ruby_api_version;F;I"Gem;T;[o;;I" ;F;I"String;To;;I" ;T;0;;;I"ruby_engine;F;I"Gem;T;[o;;I" ;F;I"String;To;;I"5A Gem::Version for the currently running Ruby.

;T;0;;;I"ruby_version;F;I"Gem;T;[o;;I" ;F;I"Gem::Version;To;;I"8A Gem::Version for the currently running RubyGems

;T;0;;;I"rubygems_version;F;I"Gem;T;[o;;I" ;F;I"Gem::Version;To;;I"ŠReturns the value of Gem.source_date_epoch_string, as a Time object.

This is used throughout RubyGems for enabling reproducible builds.

;T;0;;;I"source_date_epoch;F;I"Gem;T;[o;;I" ;F;I"	Time;To;;I"ËIf the SOURCE_DATE_EPOCH environment variable is set, returns it's value.
Otherwise, returns the time that `Gem.source_date_epoch_string` was first
called in the same format as SOURCE_DATE_EPOCH.

NOTE(@duckinator): The implementation is a tad weird because we want to:
    1. Make builds reproducible by default, by having this function always
       return the same result during a given run.
    2. Allow changing ENV['SOURCE_DATE_EPOCH'] at runtime, since multiple
       tests that set this variable will be run in a single process.

If you simplify this function and a lot of tests fail, that is likely due to
#2 above.

Details on SOURCE_DATE_EPOCH:
https://reproducible-builds.org/specs/source-date-epoch/

;T;0;;;I"source_date_epoch_string;F;I"Gem;T;[o;;I" ;F;I"String;To;;I"pReturns an Array of sources to fetch remote gems from. Uses default_sources if
the sources list is empty.

;T;0;;;I"sources;F;I"Gem;T;[o;;I" ;F;I"Gem::SourceList;To;;I"èNeed to be able to set the sources without calling Gem.sources.replace since
that would cause an infinite loop.

DOC: This comment is not documentation about the method itself, it's more of a
code comment about the implementation.

;T;0;;;I"sources=;F;I"Gem;T;[o;;I"#::Gem::SourceList? new_sources;T;I"Gem::SourceList?;To;;I" ;T;0;;;I"spec_cache_dir;F;I"Gem;T;[o;;I" ;F;I"String;To;;I"3Glob pattern for require-able path suffixes.

;T;0;;;I"suffix_pattern;F;I"Gem;T;[o;;I" ;F;I"String;To;;I"-Regexp for require-able path suffixes.

;T;0;;;I"suffix_regexp;F;I"Gem;T;[o;;I" ;F;I"Regexp;To;;I"'Suffixes for require-able paths.

;T;0;;;I"suffixes;F;I"Gem;T;[o;;I" ;F;I"Array[::String];To;;I"[Prints the amount of time the supplied block takes to run using the debug UI
output.

;T;0;;;I"	time;F;I"Gem;T;[o;;I"7::String msg, ?::Integer width, ?::boolish display;T;I"T;Fo;;I"´Try to activate a gem containing `path`. Returns true if activation succeeded
or wasn't needed because it was already activated. Returns false if it can't
find the path in a gem.

;T;0;;;I"try_activate;F;I"Gem;T;[o;;I"::String path;T;I"	bool;To;;I"FLazily loads DefaultUserInteraction and returns the default UI.

;T;0;;;I"ui;F;I"Gem;T;[o;;I" ;F;I"Gem::StreamUI;To;;I")Looks for a gem dependency file at `path` and activates the gems in the file
if found.  If the file is not found an ArgumentError is raised.

If `path` is not given the RUBYGEMS_GEMDEPS environment variable is used, but
if no file is found no exception is raised.

If '-' is given for `path` RubyGems searches up from the current working
directory for gem dependency files (gem.deps.rb, Gemfile, Isolate) and
activates the gems in the first one found.

You can run this automatically when rubygems starts.  To enable, set the
`RUBYGEMS_GEMDEPS` environment variable to either the path of your gem
dependencies file or "-" to auto-discover in parent directories.

NOTE: Enabling automatic discovery on multiuser systems can lead to execution
of arbitrary code when used from directories outside your control.

;T;0;;;I"use_gemdeps;F;I"Gem;T;[o;;I"?::String path;T;I"	void;To;;I"~Use the `home` and `paths` values for Gem.dir and Gem.path.  Used mainly by
the unit tests to provide environment isolation.

;T;0;;;I"use_paths;F;I"Gem;T;[o;;I"#::String home, *::String paths;T;I"Hash[::String, ::String];To;;I"1Path for gems in the user's home directory

;T;0;;;I"user_dir;F;I"Gem;T;[o;;I" ;F;I"String;To;;I"'The home directory for the user.

;T;0;;;I"user_home;F;I"Gem;T;[o;;I" ;F;I"String;To;;I""Is this a windows platform?

;T;0;;;I"win_platform?;F;I"Gem;T;[o;;I" ;F;I"	bool;To;;I";Safely write a file in binary mode on all platforms.

;T;0;;;I"write_binary;F;I"Gem;T;[o;;I"!::String path, ::String data;T;I"Integer;To;;0;0;	I"Gem;T;
[ ;[ ;0;[ ;[ o; ;I"ÖRaised when RubyGems is unable to load or activate a gem.  Contains the name
and version requirements of the gem that either conflicts with already
activated gems or that RubyGems is otherwise unable to activate.

;T;0;	I"Gem::LoadError;T;
[ ;[ ;0;[ ;[ ;0;I"LoadError;To; ;I"ÒRaised when trying to activate a gem, and that gem does not exist on the
system.  Instead of rescuing from this class, make sure to rescue from the
superclass Gem::LoadError to catch all types of load errors.

;T;0;	I"Gem::MissingSpecError;T;
[ ;[ ;0;[ ;[ ;0;0o; ;I"€The installer installs the files contained in the .gem into the Gem.home.

Gem::Installer does the work of putting files in all the right places on the
filesystem including unpacking the gem into its gem dir, installing the
gemspec in the specifications dir, storing the cached gem in the cache dir,
and installing either wrappers or symlinks for executables.

The installer invokes pre and post install hooks.  Hooks can be added either
through a rubygems_plugin.rb file in an installed gem or via a
rubygems/defaults/#{RUBY_ENGINE}.rb or rubygems/defaults/operating_system.rb
file.  See Gem.pre_install and Gem.post_install for details.

;T;0;	I"Gem::Installer;T;
[ ;[ ;0;[ ;[ ;0;0o; ;I"kGem::PathSupport facilitates the GEM_HOME and GEM_PATH environment settings to
the rest of RubyGems.

;T;0;	I"Gem::PathSupport;T;
[ ;[ ;0;[ ;[ ;0;0o; ;I"}Available list of platforms for targeting Gem installations.

See `gem help platform` for information on platform matching.

;T;0;	I"Gem::Platform;T;
[ ;[ ;0;[ ;[ ;0;0o; ;I"VA RequestSet groups a request to activate a set of dependencies.

    nokogiri = Gem::Dependency.new 'nokogiri', '~> 1.6'
    pg = Gem::Dependency.new 'pg', '~> 0.14'

    set = Gem::RequestSet.new nokogiri, pg

    requests = set.resolve

    p requests.map { |r| r.full_name }
    #=> ["nokogiri-1.6.0", "mini_portile-0.5.1", "pg-0.17.0"]

;T;0;	I"Gem::RequestSet;T;
[ ;[ ;0;[ ;[ ;0;0o; ;I"A semi-compatible DSL for the Bundler Gemfile and Isolate gem dependencies
files.

To work with both the Bundler Gemfile and Isolate formats this implementation
takes some liberties to allow compatibility with each, most notably in
#source.

A basic gem dependencies file will look like the following:

    source 'https://rubygems.org'

    gem 'rails', '3.2.14a
    gem 'devise', '~> 2.1', '>= 2.1.3'
    gem 'cancan'
    gem 'airbrake'
    gem 'pg'

RubyGems recommends saving this as gem.deps.rb over Gemfile or Isolate.

To install the gems in this Gemfile use `gem install -g` to install it and
create a lockfile.  The lockfile will ensure that when you make changes to
your gem dependencies file a minimum amount of change is made to the
dependencies of your gems.

RubyGems can activate all the gems in your dependencies file at startup using
the RUBYGEMS_GEMDEPS environment variable or through Gem.use_gemdeps. See
Gem.use_gemdeps for details and warnings.

See `gem help install` and `gem help gem_dependencies` for further details.

;T;0;	I"&Gem::RequestSet::GemDependencyAPI;T;
[ ;[ ;0;[ ;[ ;0;0o; ;I"ìA Requirement is a set of one or more version restrictions. It supports a few
(`=, !=, >, <, >=, <=, ~>`) different restriction operators.

See Gem::Version for a description on how versions and requirements work
together in RubyGems.

;T;0;	I"Gem::Requirement;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"ÊFactory method to create a Gem::Requirement object.  Input may be a Version, a
String, or nil.  Intended to simplify client code.

If the input is "weird", the default version requirement is returned.

;T;0;;;I"create;F;I"Gem::Requirement;T;[o;;I"A*::String | ::Gem::Version | ::Gem::Requirement | nil inputs;T;I"instance;To;;I" ;T;0;;;I"default;F;I"Gem::Requirement;T;[o;;I" ;F;I"instance;To;;I" ;T;0;;;I"default_prerelease;F;I"Gem::Requirement;T;[o;;I" ;F;I"instance;To;;I"µParse `obj`, returning an `[op, version]` pair. `obj` can be a String or a
Gem::Version.

If `obj` is a String, it can be either a full requirement specification, like
`">= 1.2"`, or a simple version number, like `"1.2"`.

    parse("> 1.0")                 # => [">", Gem::Version.new("1.0")]
    parse("1.0")                   # => ["=", Gem::Version.new("1.0")]
    parse(Gem::Version.new("1.0")) # => ["=,  Gem::Version.new("1.0")]

;T;0;;;I"
parse;F;I"Gem::Requirement;T;[o;;I""::String | ::Gem::Version obj;T;I"5[ ::Gem::Requirement::operator, ::Gem::Version ];To;;I"ÕConstructs a requirement from `requirements`. Requirements can be Strings,
Gem::Versions, or Arrays of those. `nil` and duplicate requirements are
ignored. An empty set of `requirements` is the same as `">= 0"`.

;T;0;;;I"initialize;F;I"Gem::Requirement;T;[o;;I",*::String | ::Gem::Version requirements;T;I"	void;To;;I"AConcatenates the `new` requirements onto this requirement.

;T;0;;;I"concat;F;I"Gem::Requirement;T;[o;;I"+::Array[::String | ::Gem::Version] new;T;I"	void;To;;I";true if the requirement is for only an exact version

;T;0;;;I"exact?;F;I"Gem::Requirement;T;[o;;I" ;F;I"	bool;To;;I",true if this gem has no requirements.

;T;0;;;I"
none?;F;I"Gem::Requirement;T;[o;;I" ;F;I"	bool;To;;I"XA requirement is a prerelease if any of the versions inside of it are
prereleases

;T;0;;;I"prerelease?;F;I"Gem::Requirement;T;[o;;I" ;F;I"	bool;To;;I"4True if `version` satisfies this Requirement.

;T;0;;;I"satisfied_by?;F;I"Gem::Requirement;T;[o;;I"::Gem::Version version;T;I"	bool;To;;I"HTrue if the requirement will not always match the latest version.

;T;0;;;I"specific?;F;I"Gem::Requirement;T;[o;;I" ;F;I"	bool;To; ;I"3Raised when a bad requirement is encountered

;T;0;	I"*Gem::Requirement::BadRequirementError;T;
[ ;[ ;0;[ ;[ ;0;I"ArgumentError;To; ;I"hThe SourceList represents the sources rubygems has been configured to use. A
source may be created from an array of sources:

    Gem::SourceList.from %w[https://rubygems.example https://internal.example]

Or by adding them:

    sources = Gem::SourceList.new
    sources << 'https://rubygems.example'

The most common way to get a SourceList is Gem.sources.

;T;0;	I"Gem::SourceList;T;
[ ;[ ;0;[ ;[ ;0;0o; ;I"5The Specification class contains the information for a gem.  Typically defined
in a .gemspec file or a Rakefile, and looks like this:

    Gem::Specification.new do |s|
      s.name        = 'example'
      s.version     = '0.1.0'
      s.licenses    = ['MIT']
      s.summary     = "This is an example!"
      s.description = "Much longer explanation of the example!"
      s.authors     = ["Ruby Coder"]
      s.email       = 'rubycoder@example.com'
      s.files       = ["lib/example.rb"]
      s.homepage    = 'https://rubygems.org/gems/example'
      s.metadata    = { "source_code_uri" => "https://github.com/example/example" }
    end

Starting in RubyGems 2.0, a Specification can hold arbitrary metadata.  See
#metadata for restrictions on the format and size of metadata items you may
add to a specification.

;T;0;	I"Gem::Specification;T;
[ ;[ ;0;[ ;[ ;0;I"Gem::BasicSpecification;To; ;I"EGem::StreamUI implements a simple stream based user interface.

;T;0;	I"Gem::StreamUI;T;
[ ;[ ;0;[ ;[ ;0;0o; ;I".An Uninstaller.

The uninstaller fires pre and post uninstall hooks.  Hooks can be added either
through a rubygems_plugin.rb file in an installed gem or via a
rubygems/defaults/#{RUBY_ENGINE}.rb or rubygems/defaults/operating_system.rb
file.  See Gem.pre_uninstall and Gem.post_uninstall for details.

;T;0;	I"Gem::Uninstaller;T;
[ ;[ ;0;[ ;[ ;0;0o; ;I"uThe Version class processes string versions into comparable values. A version
string should normally be a series of numbers separated by periods. Each part
(digits separated by periods) is considered its own number, and these are used
for sorting. So for instance, 3.10 sorts higher than 3.2 because ten is
greater than two.

If any part contains letters (currently only a-z are supported) then that
version is considered prerelease. Versions with a prerelease part in the Nth
part sort less than versions with N-1 parts. Prerelease parts are sorted
alphabetically using the normal Ruby string sorting rules. If a prerelease
part contains both letters and numbers, it will be broken into multiple parts
to provide expected sort behavior (1.0.a10 becomes 1.0.a.10, and is greater
than 1.0.a9).

Prereleases sort between real releases (newest to oldest):

1.  1.0
2.  1.0.b1
3.  1.0.a.2
4.  0.9


If you want to specify a version restriction that includes both prereleases
and regular releases of the 1.x series this is the best way:

    s.add_dependency 'example', '>= 1.0.0.a', '< 2.0.0'

## How Software Changes

Users expect to be able to specify a version constraint that gives them some
reasonable expectation that new versions of a library will work with their
software if the version constraint is true, and not work with their software
if the version constraint is false.  In other words, the perfect system will
accept all compatible versions of the library and reject all incompatible
versions.

Libraries change in 3 ways (well, more than 3, but stay focused here!).

1.  The change may be an implementation detail only and have no effect on the
    client software.
2.  The change may add new features, but do so in a way that client software
    written to an earlier version is still compatible.
3.  The change may change the public interface of the library in such a way
    that old software is no longer compatible.


Some examples are appropriate at this point.  Suppose I have a Stack class
that supports a `push` and a `pop` method.

### Examples of Category 1 changes:

*   Switch from an array based implementation to a linked-list based
    implementation.
*   Provide an automatic (and transparent) backing store for large stacks.


### Examples of Category 2 changes might be:

*   Add a `depth` method to return the current depth of the stack.
*   Add a `top` method that returns the current top of stack (without changing
    the stack).
*   Change `push` so that it returns the item pushed (previously it had no
    usable return value).


### Examples of Category 3 changes might be:

*   Changes `pop` so that it no longer returns a value (you must use `top` to
    get the top of the stack).
*   Rename the methods to `push_item` and `pop_item`.


## RubyGems Rational Versioning

*   Versions shall be represented by three non-negative integers, separated by
    periods (e.g. 3.1.4).  The first integers is the "major" version number,
    the second integer is the "minor" version number, and the third integer is
    the "build" number.

*   A category 1 change (implementation detail) will increment the build
    number.

*   A category 2 change (backwards compatible) will increment the minor
    version number and reset the build number.

*   A category 3 change (incompatible) will increment the major build number
    and reset the minor and build numbers.

*   Any "public" release of a gem should have a different version.  Normally
    that means incrementing the build number.  This means a developer can
    generate builds all day long, but as soon as they make a public release,
    the version must be updated.


### Examples

Let's work through a project lifecycle using our Stack example from above.

Version 0.0.1
:   The initial Stack class is release.
Version 0.0.2
:   Switched to a linked=list implementation because it is cooler.
Version 0.1.0
:   Added a `depth` method.
Version 1.0.0
:   Added `top` and made `pop` return nil (`pop` used to return the  old top
    item).
Version 1.1.0
:   `push` now returns the value pushed (it used it return nil).
Version 1.1.1
:   Fixed a bug in the linked list implementation.
Version 1.1.2
:   Fixed a bug introduced in the last fix.


Client A needs a stack with basic push/pop capability.  They write to the
original interface (no `top`), so their version constraint looks like:

    gem 'stack', '>= 0.0'

Essentially, any version is OK with Client A.  An incompatible change to the
library will cause them grief, but they are willing to take the chance (we
call Client A optimistic).

Client B is just like Client A except for two things: (1) They use the `depth`
method and (2) they are worried about future incompatibilities, so they write
their version constraint like this:

    gem 'stack', '~> 0.1'

The `depth` method was introduced in version 0.1.0, so that version or
anything later is fine, as long as the version stays below version 1.0 where
incompatibilities are introduced.  We call Client B pessimistic because they
are worried about incompatible future changes (it is OK to be pessimistic!).

## Preventing Version Catastrophe:

From: http://blog.zenspider.com/2008/10/rubygems-howto-preventing-cata.html

Let's say you're depending on the fnord gem version 2.y.z. If you specify your
dependency as ">= 2.0.0" then, you're good, right? What happens if fnord 3.0
comes out and it isn't backwards compatible with 2.y.z? Your stuff will break
as a result of using ">=". The better route is to specify your dependency with
an "approximate" version specifier ("~>"). They're a tad confusing, so here is
how the dependency specifiers work:

    Specification From  ... To (exclusive)
    ">= 3.0"      3.0   ... &infin;
    "~> 3.0"      3.0   ... 4.0
    "~> 3.0.0"    3.0.0 ... 3.1
    "~> 3.5"      3.5   ... 4.0
    "~> 3.5.0"    3.5.0 ... 3.6
    "~> 3"        3.0   ... 4.0

For the last example, single-digit versions are automatically extended with a
zero to give a sensible result.

;T;0;	I"Gem::Version;T;
[ ;[I"Comparable;T;0;[ ;[ ;0;0o;;I"CTrue if the `version` string matches RubyGems' requirements.

;T;0;;;I"correct?;F;I"Gem::Version;T;[o;;I"::_ToS version;T;I"	bool;To;;I"Factory method to create a Version object. Input may be a Version or a String.
Intended to simplify client code.

    ver1 = Version.create('1.3.17')   # -> (Version object)
    ver2 = Version.create(ver1)       # -> (ver1)
    ver3 = Version.create(nil)        # -> nil

;T;0;;;I"create;F;I"Gem::Version;T;[o;;I""::_ToS | ::Gem::Version input;T;I"instance;To;;I"nil input;T;I"nil;To;;I"}Constructs a Version from the `version` string.  A version string is a series
of digits or ASCII letters separated by dots.

;T;0;;;I"initialize;F;I"Gem::Version;T;[o;;I"::_ToS version;T;I"	void;To;;I"ãCompares this version with `other` returning -1, 0, or 1 if the other version
is larger, the same, or smaller than this one. Attempts to compare to
something that's not a `Gem::Version` or a valid version String return `nil`.

;T;0;;;I"<=>;F;I"Gem::Version;T;[o;;I"untyped other;T;I"Integer?;To;;I";A recommended version for use with a ~> Requirement.

;T;0;;;I"approximate_recommendation;F;I"Gem::Version;T;[o;;I" ;F;I"String;To;;I"­Return a new version object where the next to the last revision number is one
greater (e.g., 5.3.1 => 5.4).

Pre-release (alpha) parts, e.g, 5.3.1.b.2 => 5.4, are ignored.

;T;0;;;I"	bump;F;I"Gem::Version;T;[o;;I" ;F;I"instance;To;;I" ;T;0;;;I"canonical_segments;F;I"Gem::Version;T;[o;;I" ;F;I" Array[::Integer | ::String];To;;I"‚A Version is only eql? to another version if it's specified to the same
precision. Version "1.0" is not the same as version "1".

;T;0;;;I"	eql?;F;I"Gem::Version;T;[o;;I"untyped other;T;I"	bool;To;;I"„Dump only the raw version string, not the complete object. It's a string for
backwards (RubyGems 1.3.5 and earlier) compatibility.

;T;0;;;I"marshal_dump;F;I"Gem::Version;T;[o;;I" ;F;I"Array[::String];To;;I"jLoad custom marshal format. It's a string for backwards (RubyGems 1.3.5 and
earlier) compatibility.

;T;0;;;I"marshal_load;F;I"Gem::Version;T;[o;;I"::Array[::String] array;T;I"	void;To;;I"DA version is considered a prerelease if it contains a letter.

;T;0;;;I"prerelease?;F;I"Gem::Version;T;[o;;I" ;F;I"	bool;To;;I"gThe release for this version (e.g. 1.2.0.a -> 1.2.0). Non-prerelease versions
return themselves.

;T;0;;;I"release;F;I"Gem::Version;T;[o;;I" ;F;I"instance;To;;I"/A string representation of this Version.

;T;0;;;I"version;F;I"Gem::Version;T;[o;;I" ;F;I"String;To;;I"
## Secure random number generator interface.

This library is an interface to secure random number generators which are
suitable for generating session keys in HTTP cookies, etc.

You can use this library in your application by requiring it:

    require 'securerandom'

It supports the following secure random number generators:

*   openssl
*   /dev/urandom
*   Win32


SecureRandom is extended by the Random::Formatter module which defines the
following methods:

*   alphanumeric
*   base64
*   choose
*   gen_random
*   hex
*   rand
*   random_bytes
*   random_number
*   urlsafe_base64
*   uuid


These methods are usable as class methods of SecureRandom such as
`SecureRandom.hex`.

If a secure random number generator is not available, `NotImplementedError` is
raised.

;T;0;	I"SecureRandom;T;
[ ;[ ;0;[ ;[ o;;0;0;;;I"alphanumeric;F;I"SecureRandom;T;[o;;I"?::Integer?;T;I"String;To;;0;0;;;I"base64;F;I"SecureRandom;T;[o;;I"?::Integer?;T;I"String;To;;0;0;;;I"hex;F;I"SecureRandom;T;[o;;I"?::Integer?;T;I"String;To;;0;0;;;I"random_bytes;F;I"SecureRandom;T;[o;;I"?::Integer?;T;I"String;To;;0;0;;;I"random_number;F;I"SecureRandom;T;[o;;I" ;F;I"
Float;To;;I"::Integer;T;I"Integer;To;;I"::Numeric;T;I"Numeric;To;;0;0;;;I"urlsafe_base64;F;I"SecureRandom;T;[o;;I"?::Integer?, ?bool?;T;I"String;To;;0;0;;;I"	uuid;F;I"SecureRandom;T;[o;;I" ;F;I"String;To;;I"e## Manipulates strings like the UNIX Bourne shell

This module manipulates strings according to the word parsing rules of the
UNIX Bourne shell.

The shellwords() function was originally a port of shellwords.pl, but modified
to conform to the Shell & Utilities volume of the IEEE Std 1003.1-2008, 2016
Edition [1].

### Usage

You can use Shellwords to parse a string into a Bourne shell friendly Array.

    require 'shellwords'

    argv = Shellwords.split('three blind "mice"')
    argv #=> ["three", "blind", "mice"]

Once you've required Shellwords, you can use the #split alias
String#shellsplit.

    argv = "see how they run".shellsplit
    argv #=> ["see", "how", "they", "run"]

They treat quotes as special characters, so an unmatched quote will cause an
ArgumentError.

    argv = "they all ran after the farmer's wife".shellsplit
         #=> ArgumentError: Unmatched quote: ...

Shellwords also provides methods that do the opposite. Shellwords.escape, or
its alias, String#shellescape, escapes shell metacharacters in a string for
use in a command line.

    filename = "special's.txt"

    system("cat -- #{filename.shellescape}")
    # runs "cat -- special\\'s.txt"

Note the '--'.  Without it, cat(1) will treat the following argument as a
command line option if it starts with '-'.  It is guaranteed that
Shellwords.escape converts a string to a form that a Bourne shell will parse
back to the original string, but it is the programmer's responsibility to make
sure that passing an arbitrary argument to a command does no harm.

Shellwords also comes with a core extension for Array, Array#shelljoin.

    dir = "Funny GIFs"
    argv = %W[ls -lta -- #{dir}]
    system(argv.shelljoin + " | less")
    # runs "ls -lta -- Funny\\ GIFs | less"

You can use this method to build a complete command line out of an array of
arguments.

### Authors
*   Wakou Aoyama
*   Akinori MUSHA <knu@iDaemons.org>


### Contact
*   Akinori MUSHA <knu@iDaemons.org> (current maintainer)


### Resources

1: [IEEE Std 1003.1-2008, 2016 Edition, the Shell & Utilities
volume](http://pubs.opengroup.org/onlinepubs/9699919799/utilities/contents.htm
l)

;T;0;	I"Shellwords;T;
[ ;[ ;0;[ ;[ o;;I"HEscapes a string so that it can be safely used in a Bourne shell command line.
 `str` can be a non-string object that responds to `to_s`.

Note that a resulted string should be used unquoted and is not intended for
use in double quotes nor in single quotes.

    argv = Shellwords.escape("It's better to give than to receive")
    argv #=> "It\\'s\\ better\\ to\\ give\\ than\\ to\\ receive"

String#shellescape is a shorthand for this function.

    argv = "It's better to give than to receive".shellescape
    argv #=> "It\\'s\\ better\\ to\\ give\\ than\\ to\\ receive"

    # Search files in lib for method definitions
    pattern = "^[ \t]*def "
    open("| grep -Ern -e #{pattern.shellescape} lib") { |grep|
      grep.each_line { |line|
        file, lineno, matched_line = line.split(':', 3)
        # ...
      }
    }

It is the caller's responsibility to encode the string in the right encoding
for the shell environment where this string is used.

Multibyte characters are treated as multibyte characters, not as bytes.

Returns an empty quoted String if `str` has a length of zero.

;T;0;;;I"shellescape;F;I"Shellwords;T;[o;;I"::String str;T;I"String;To;;I"šBuilds a command line string from an argument list, `array`.

All elements are joined into a single string with fields separated by a space,
where each element is escaped for the Bourne shell and stringified using
`to_s`.

    ary = ["There's", "a", "time", "and", "place", "for", "everything"]
    argv = Shellwords.join(ary)
    argv #=> "There\\'s a time and place for everything"

Array#shelljoin is a shortcut for this function.

    ary = ["Don't", "rock", "the", "boat"]
    argv = ary.shelljoin
    argv #=> "Don\\'t rock the boat"

You can also mix non-string objects in the elements as allowed in Array#join.

    output = `#{['ps', '-p', $$].shelljoin}`

;T;0;;;I"shelljoin;F;I"Shellwords;T;[o;;I"::Array[::String] array;T;I"String;To;;I"ESplits a string into an array of tokens in the same way the UNIX Bourne shell
does.

    argv = Shellwords.split('here are "two words"')
    argv #=> ["here", "are", "two words"]

Note, however, that this is not a command line parser.  Shell metacharacters
except for the single and double quotes and backslash are not treated as such.

    argv = Shellwords.split('ruby my_prog.rb | less')
    argv #=> ["ruby", "my_prog.rb", "|", "less"]

String#shellsplit is a shortcut for this function.

    argv = 'here are "two words"'.shellsplit
    argv #=> ["here", "are", "two words"]

;T;0;;;I"shellsplit;F;I"Shellwords;T;[o;;I"::String line;T;I"Array[::String];To;;I"FThe Singleton module implements the Singleton pattern.

## Usage

To use Singleton, include the module in your class.

    class Klass
       include Singleton
       # ...
    end

This ensures that only one instance of Klass can be created.

    a,b = Klass.instance, Klass.instance

    a == b
    # => true

    Klass.new
    # => NoMethodError - new is private ...

The instance is created at upon the first call of Klass.instance().

    class OtherKlass
      include Singleton
      # ...
    end

    ObjectSpace.each_object(OtherKlass){}
    # => 0

    OtherKlass.instance
    ObjectSpace.each_object(OtherKlass){}
    # => 1

This behavior is preserved under inheritance and cloning.

## Implementation

This above is achieved by:

*   Making Klass.new and Klass.allocate private.

*   Overriding Klass.inherited(sub_klass) and Klass.clone() to ensure that the
    Singleton properties are kept when inherited and cloned.

*   Providing the Klass.instance() method that returns the same object each
    time it is called.

*   Overriding Klass._load(str) to call Klass.instance().

*   Overriding Klass#clone and Klass#dup to raise TypeErrors to prevent
    cloning or duping.


## Singleton and Marshal

By default Singleton's #_dump(depth) returns the empty string. Marshalling by
default will strip state information, e.g. instance variables from the
instance. Classes using Singleton can provide custom _load(str) and
_dump(depth) methods to retain some of the previous state of the instance.

    require 'singleton'

    class Example
      include Singleton
      attr_accessor :keep, :strip
      def _dump(depth)
        # this strips the @strip information from the instance
        Marshal.dump(@keep, depth)
      end

      def self._load(str)
        instance.keep = Marshal.load(str)
        instance
      end
    end

    a = Example.instance
    a.keep = "keep this"
    a.strip = "get rid of this"

    stored_state = Marshal.dump(a)

    a.keep = nil
    a.strip = nil
    b = Marshal.load(stored_state)
    p a == b  #  => true
    p a.keep  #  => "keep this"
    p a.strip #  => nil

;T;0;	I"Singleton;T;
[ ;[ ;0;[ ;[ o;;0;0;;;I"__init__;F;I"Singleton;T;[o;;I"::Class klass;T;I"
Class;To;;I"&Returns the singleton instance.

;T;0;;;I"instance;F;I"Singleton;T;[o;;I" ;F;I"instance;To;;I"<By default, do not retain any state when marshalling.

;T;0;;;I"
_dump;F;I"Singleton;T;[o;;I"?::Integer depth;T;I"String;To;;I"-Raises a TypeError to prevent cloning.

;T;0;;;I"
clone;F;I"Singleton;T;[o;;I" ;F;I"bot;To;;I",Raises a TypeError to prevent duping.

;T;0;;;I"dup;F;I"Singleton;T;[o;;I" ;F;I"bot;To;;0;0;	I"%Singleton::SingletonClassMethods;T;
[ ;[ ;0;[ ;[ o; ;0;0;	I"Addrinfo;T;
[ ;[ ;0;[ ;[ ;0;0o;;I" iterates over the list of Addrinfo objects obtained by Addrinfo.getaddrinfo.

    Addrinfo.foreach(nil, 80) {|x| p x }
    #=> #<Addrinfo: 127.0.0.1:80 TCP (:80)>
    #   #<Addrinfo: 127.0.0.1:80 UDP (:80)>
    #   #<Addrinfo: [::1]:80 TCP (:80)>
    #   #<Addrinfo: [::1]:80 UDP (:80)>

;T;0;;;I"foreach;F;I"Addrinfo;T;[o;;I"Ÿ::String? nodename, ::String | ::Integer service, ?::Integer? family, ?::Symbol socktype, ?::Symbol | ::Integer protocol, ?::Integer flags, ?timeout: ::Numeric;T;I"	void;To;;I"Ÿ::String? nodename, ::String | ::Integer service, ?::Integer? family, ?::Symbol socktype, ?::Symbol | ::Integer protocol, ?::Integer flags, ?timeout: ::Numeric;T;I"Enumerable[::Addrinfo];To;;I"(returns a list of addrinfo objects as an array.

This method converts nodename (hostname) and service (port) to addrinfo. Since
the conversion is not unique, the result is a list of addrinfo objects.

nodename or service can be nil if no conversion intended.

family, socktype and protocol are hint for preferred protocol. If the result
will be used for a socket with SOCK_STREAM, SOCK_STREAM should be specified as
socktype. If so, Addrinfo.getaddrinfo returns addrinfo list appropriate for
SOCK_STREAM. If they are omitted or nil is given, the result is not
restricted.

Similarly, PF_INET6 as family restricts for IPv6.

flags should be bitwise OR of Socket::AI_??? constants such as follows. Note
that the exact list of the constants depends on OS.

    AI_PASSIVE      Get address to use with bind()
    AI_CANONNAME    Fill in the canonical name
    AI_NUMERICHOST  Prevent host name resolution
    AI_NUMERICSERV  Prevent service name resolution
    AI_V4MAPPED     Accept IPv4-mapped IPv6 addresses
    AI_ALL          Allow all addresses
    AI_ADDRCONFIG   Accept only if any address is assigned

Note that socktype should be specified whenever application knows the usage of
the address. Some platform causes an error when socktype is omitted and
servname is specified as an integer because some port numbers, 512 for
example, are ambiguous without socktype.

    Addrinfo.getaddrinfo("www.kame.net", 80, nil, :STREAM)
    #=> [#<Addrinfo: 203.178.141.194:80 TCP (www.kame.net)>,
    #    #<Addrinfo: [2001:200:dff:fff1:216:3eff:feb1:44d7]:80 TCP (www.kame.net)>]

;T;0;;;I"getaddrinfo;F;I"Addrinfo;T;[o;;I"h::String nodename, ?::String | ::Integer service, ?::Symbol? family, ?::Symbol | ::Integer protocol;T;I"Array[::Addrinfo];To;;I"Þreturns an addrinfo object for IP address.

The port, socktype, protocol of the result is filled by zero. So, it is not
appropriate to create a socket.

    Addrinfo.ip("localhost") #=> #<Addrinfo: 127.0.0.1 (localhost)>

;T;0;;;I"ip;F;I"Addrinfo;T;[o;;I"::String host;T;I"Addrinfo;To;;I"‡returns an addrinfo object for TCP address.

    Addrinfo.tcp("localhost", "smtp") #=> #<Addrinfo: 127.0.0.1:25 TCP (localhost:smtp)>

;T;0;;;I"tcp;F;I"Addrinfo;T;[o;;I"0::String host, ::String | ::Integer service;T;I"Addrinfo;To;;I"returns an addrinfo object for UDP address.

    Addrinfo.udp("localhost", "daytime") #=> #<Addrinfo: 127.0.0.1:13 UDP (localhost:daytime)>

;T;0;;;I"udp;F;I"Addrinfo;T;[o;;I"0::String host, ::String | ::Integer service;T;I"Addrinfo;To;;I"returns an addrinfo object for UNIX socket address.

*socktype* specifies the socket type. If it is omitted, :STREAM is used.

    Addrinfo.unix("/tmp/sock")         #=> #<Addrinfo: /tmp/sock SOCK_STREAM>
    Addrinfo.unix("/tmp/sock", :DGRAM) #=> #<Addrinfo: /tmp/sock SOCK_DGRAM>

;T;0;;;I"	unix;F;I"Addrinfo;T;[o;;I"&::String path, ?::Symbol socktype;T;I"Addrinfo;To;;I"wreturns the address family as an integer.

    Addrinfo.tcp("localhost", 80).afamily == Socket::AF_INET #=> true

;T;0;;;I"afamily;F;I"Addrinfo;T;[o;;I" ;F;I"Integer;To;;I"'creates a socket bound to self.

If a block is given, it is called with the socket and the value of the block
is returned. The socket is returned otherwise.

    Addrinfo.udp("0.0.0.0", 9981).bind {|s|
      s.local_address.connect {|s| s.send "hello", 0 }
      p s.recv(10) #=> "hello"
    }

;T;0;;;I"	bind;F;I"Addrinfo;T;[o;;I" ;F;I"Socket;To;;I" ;F;I"	void;To;;I"™returns the canonical name as a string.

nil is returned if no canonical name.

The canonical name is set by Addrinfo.getaddrinfo when AI_CANONNAME is
specified.

    list = Addrinfo.getaddrinfo("www.ruby-lang.org", 80, :INET, :STREAM, nil, Socket::AI_CANONNAME)
    p list[0] #=> #<Addrinfo: 221.186.184.68:80 TCP carbon.ruby-lang.org (www.ruby-lang.org)>
    p list[0].canonname #=> "carbon.ruby-lang.org"

;T;0;;;I"canonname;F;I"Addrinfo;T;[o;;I" ;F;I"String;To;;I"Õcreates a socket connected to the address of self.

The optional argument *opts* is options represented by a hash. *opts* may have
following options:

:timeout
:   specify the timeout in seconds.


If a block is given, it is called with the socket and the value of the block
is returned. The socket is returned otherwise.

    Addrinfo.tcp("www.ruby-lang.org", 80).connect {|s|
      s.print "GET / HTTP/1.0\r\nHost: www.ruby-lang.org\r\n\r\n"
      puts s.read
    }

;T;0;;;I"connect;F;I"Addrinfo;T;[o;;I"?timeout: ::Numeric;T;I"	void;To;;I"?timeout: ::Numeric;T;I"Socket;To;;I"Ûcreates a socket connected to the address of self.

If one or more arguments given as *local_addr_args*, it is used as the local
address of the socket. *local_addr_args* is given for family_addrinfo to
obtain actual address.

If *local_addr_args* is not given, the local address of the socket is not
bound.

The optional last argument *opts* is options represented by a hash. *opts* may
have following options:

:timeout
:   specify the timeout in seconds.


If a block is given, it is called with the socket and the value of the block
is returned. The socket is returned otherwise.

    Addrinfo.tcp("www.ruby-lang.org", 80).connect_from("0.0.0.0", 4649) {|s|
      s.print "GET / HTTP/1.0\r\nHost: www.ruby-lang.org\r\n\r\n"
      puts s.read
    }

    # Addrinfo object can be taken for the argument.
    Addrinfo.tcp("www.ruby-lang.org", 80).connect_from(Addrinfo.tcp("0.0.0.0", 4649)) {|s|
      s.print "GET / HTTP/1.0\r\nHost: www.ruby-lang.org\r\n\r\n"
      puts s.read
    }

;T;0;;;I"connect_from;F;I"Addrinfo;T;[	o;;I"7::String host, ::Integer port, ?timeout: ::Numeric;T;I"	void;To;;I"7::String host, ::Integer port, ?timeout: ::Numeric;T;I"Socket;To;;I"-::Addrinfo sockaddr, ?timeout: ::Numeric;T;I"	void;To;;I"-::Addrinfo sockaddr, ?timeout: ::Numeric;T;I"Socket;To;;I"ÿcreates a socket connected to *remote_addr_args* and bound to self.

The optional last argument *opts* is options represented by a hash. *opts* may
have following options:

:timeout
:   specify the timeout in seconds.


If a block is given, it is called with the socket and the value of the block
is returned. The socket is returned otherwise.

    Addrinfo.tcp("0.0.0.0", 4649).connect_to("www.ruby-lang.org", 80) {|s|
      s.print "GET / HTTP/1.0\r\nHost: www.ruby-lang.org\r\n\r\n"
      puts s.read
    }

;T;0;;;I"connect_to;F;I"Addrinfo;T;[	o;;I"7::String host, ::Integer port, ?timeout: ::Numeric;T;I"	void;To;;I"7::String host, ::Integer port, ?timeout: ::Numeric;T;I"Socket;To;;I"-::Addrinfo sockaddr, ?timeout: ::Numeric;T;I"	void;To;;I"-::Addrinfo sockaddr, ?timeout: ::Numeric;T;I"Socket;To;;I"[creates an Addrinfo object from the arguments.

The arguments are interpreted as similar to self.

    Addrinfo.tcp("0.0.0.0", 4649).family_addrinfo("www.ruby-lang.org", 80)
    #=> #<Addrinfo: 221.186.184.68:80 TCP (www.ruby-lang.org:80)>

    Addrinfo.unix("/tmp/sock").family_addrinfo("/tmp/sock2")
    #=> #<Addrinfo: /tmp/sock2 SOCK_STREAM>

;T;0;;;I"family_addrinfo;F;I"Addrinfo;T;[o;;I""::String host, ::Integer port;T;I"Addrinfo;To;;I"::String path;T;I"Addrinfo;To;;I"]returns nodename and service as a pair of strings. This converts struct
sockaddr in addrinfo to textual representation.

flags should be bitwise OR of Socket::NI_??? constants.

    Addrinfo.tcp("127.0.0.1", 80).getnameinfo #=> ["localhost", "www"]

    Addrinfo.tcp("127.0.0.1", 80).getnameinfo(Socket::NI_NUMERICSERV)
    #=> ["localhost", "80"]

;T;0;;;I"getnameinfo;F;I"Addrinfo;T;[o;;I"?::Integer flags;T;I"[ ::String, ::Integer ];To;;I"íreturns a string which shows addrinfo in human-readable form.

    Addrinfo.tcp("localhost", 80).inspect #=> "#<Addrinfo: 127.0.0.1:80 TCP (localhost)>"
    Addrinfo.unix("/tmp/sock").inspect    #=> "#<Addrinfo: /tmp/sock SOCK_STREAM>"

;T;0;;;I"inspect;F;I"Addrinfo;T;[o;;I" ;F;I"String;To;;I"+returns a string which shows the sockaddr in *addrinfo* with human-readable
form.

    Addrinfo.tcp("localhost", 80).inspect_sockaddr     #=> "127.0.0.1:80"
    Addrinfo.tcp("ip6-localhost", 80).inspect_sockaddr #=> "[::1]:80"
    Addrinfo.unix("/tmp/sock").inspect_sockaddr        #=> "/tmp/sock"

;T;0;;;I"inspect_sockaddr;F;I"Addrinfo;T;[o;;I" ;F;I"String;To;;I"ãreturns true if addrinfo is internet (IPv4/IPv6) address. returns false
otherwise.

    Addrinfo.tcp("127.0.0.1", 80).ip? #=> true
    Addrinfo.tcp("::1", 80).ip?       #=> true
    Addrinfo.unix("/tmp/sock").ip?    #=> false

;T;0;;;I"ip?;F;I"Addrinfo;T;[o;;I" ;F;I"	bool;To;;I" Returns the IP address as a string.

    Addrinfo.tcp("127.0.0.1", 80).ip_address    #=> "127.0.0.1"
    Addrinfo.tcp("::1", 80).ip_address          #=> "::1"

;T;0;;;I"ip_address;F;I"Addrinfo;T;[o;;I" ;F;I"String;To;;I"‘Returns the port number as an integer.

    Addrinfo.tcp("127.0.0.1", 80).ip_port    #=> 80
    Addrinfo.tcp("::1", 80).ip_port          #=> 80

;T;0;;;I"ip_port;F;I"Addrinfo;T;[o;;I" ;F;I"Integer;To;;I"ÁReturns the IP address and port number as 2-element array.

    Addrinfo.tcp("127.0.0.1", 80).ip_unpack    #=> ["127.0.0.1", 80]
    Addrinfo.tcp("::1", 80).ip_unpack          #=> ["::1", 80]

;T;0;;;I"ip_unpack;F;I"Addrinfo;T;[o;;I" ;F;I"[ ::String, ::Integer ];To;;I"Úreturns true if addrinfo is IPv4 address. returns false otherwise.

    Addrinfo.tcp("127.0.0.1", 80).ipv4? #=> true
    Addrinfo.tcp("::1", 80).ipv4?       #=> false
    Addrinfo.unix("/tmp/sock").ipv4?    #=> false

;T;0;;;I"
ipv4?;F;I"Addrinfo;T;[o;;I" ;F;I"	bool;To;;I"XReturns true for IPv4 loopback address (127.0.0.0/8). It returns false
otherwise.

;T;0;;;I"ipv4_loopback?;F;I"Addrinfo;T;[o;;I" ;F;I"	bool;To;;I"YReturns true for IPv4 multicast address (224.0.0.0/4). It returns false
otherwise.

;T;0;;;I"ipv4_multicast?;F;I"Addrinfo;T;[o;;I" ;F;I"	bool;To;;I"uReturns true for IPv4 private address (10.0.0.0/8, 172.16.0.0/12,
192.168.0.0/16). It returns false otherwise.

;T;0;;;I"ipv4_private?;F;I"Addrinfo;T;[o;;I" ;F;I"	bool;To;;I"Úreturns true if addrinfo is IPv6 address. returns false otherwise.

    Addrinfo.tcp("127.0.0.1", 80).ipv6? #=> false
    Addrinfo.tcp("::1", 80).ipv6?       #=> true
    Addrinfo.unix("/tmp/sock").ipv6?    #=> false

;T;0;;;I"
ipv6?;F;I"Addrinfo;T;[o;;I" ;F;I"	bool;To;;I"XReturns true for IPv6 link local address (ff80::/10). It returns false
otherwise.

;T;0;;;I"ipv6_linklocal?;F;I"Addrinfo;T;[o;;I" ;F;I"	bool;To;;I"PReturns true for IPv6 loopback address (::1). It returns false otherwise.

;T;0;;;I"ipv6_loopback?;F;I"Addrinfo;T;[o;;I" ;F;I"	bool;To;;I"XReturns true for IPv6 multicast global scope address. It returns false
otherwise.

;T;0;;;I"ipv6_mc_global?;F;I"Addrinfo;T;[o;;I" ;F;I"	bool;To;;I"\Returns true for IPv6 multicast link-local scope address. It returns false
otherwise.

;T;0;;;I"ipv6_mc_linklocal?;F;I"Addrinfo;T;[o;;I" ;F;I"	bool;To;;I"\Returns true for IPv6 multicast node-local scope address. It returns false
otherwise.

;T;0;;;I"ipv6_mc_nodelocal?;F;I"Addrinfo;T;[o;;I" ;F;I"	bool;To;;I"dReturns true for IPv6 multicast organization-local scope address. It returns
false otherwise.

;T;0;;;I"ipv6_mc_orglocal?;F;I"Addrinfo;T;[o;;I" ;F;I"	bool;To;;I"\Returns true for IPv6 multicast site-local scope address. It returns false
otherwise.

;T;0;;;I"ipv6_mc_sitelocal?;F;I"Addrinfo;T;[o;;I" ;F;I"	bool;To;;I"VReturns true for IPv6 multicast address (ff00::/8). It returns false
otherwise.

;T;0;;;I"ipv6_multicast?;F;I"Addrinfo;T;[o;;I" ;F;I"	bool;To;;I"XReturns true for IPv6 site local address (ffc0::/10). It returns false
otherwise.

;T;0;;;I"ipv6_sitelocal?;F;I"Addrinfo;T;[o;;I" ;F;I"	bool;To;;I"ÇReturns IPv4 address of IPv4 mapped/compatible IPv6 address. It returns nil if
`self` is not IPv4 mapped/compatible IPv6 address.

    Addrinfo.ip("::192.0.2.3").ipv6_to_ipv4      #=> #<Addrinfo: 192.0.2.3>
    Addrinfo.ip("::ffff:192.0.2.3").ipv6_to_ipv4 #=> #<Addrinfo: 192.0.2.3>
    Addrinfo.ip("::1").ipv6_to_ipv4              #=> nil
    Addrinfo.ip("192.0.2.3").ipv6_to_ipv4        #=> nil
    Addrinfo.unix("/tmp/sock").ipv6_to_ipv4      #=> nil

;T;0;;;I"ipv6_to_ipv4;F;I"Addrinfo;T;[o;;I" ;F;I"Addrinfo?;To;;I"bReturns true for IPv6 unique local address (fc00::/7, RFC4193). It returns
false otherwise.

;T;0;;;I"ipv6_unique_local?;F;I"Addrinfo;T;[o;;I" ;F;I"	bool;To;;I"RReturns true for IPv6 unspecified address (::). It returns false otherwise.

;T;0;;;I"ipv6_unspecified?;F;I"Addrinfo;T;[o;;I" ;F;I"	bool;To;;I"YReturns true for IPv4-compatible IPv6 address (::/80). It returns false
otherwise.

;T;0;;;I"ipv6_v4compat?;F;I"Addrinfo;T;[o;;I" ;F;I"	bool;To;;I"]Returns true for IPv4-mapped IPv6 address (::ffff:0:0/80). It returns false
otherwise.

;T;0;;;I"ipv6_v4mapped?;F;I"Addrinfo;T;[o;;I" ;F;I"	bool;To;;I"0creates a listening socket bound to self.

;T;0;;;I"listen;F;I"Addrinfo;T;[o;;I"::Integer backlog;T;I"	void;To;;0;0;;;I"marshal_dump;F;I"Addrinfo;T;[o;;I" ;F;I"String;To;;0;0;;;I"marshal_load;F;I"Addrinfo;T;[o;;I"::String;T;I"instance;To;;I"xreturns the protocol family as an integer.

    Addrinfo.tcp("localhost", 80).pfamily == Socket::PF_INET #=> true

;T;0;;;I"pfamily;F;I"Addrinfo;T;[o;;I" ;F;I"Integer;To;;I"yreturns the socket type as an integer.

    Addrinfo.tcp("localhost", 80).protocol == Socket::IPPROTO_TCP #=> true

;T;0;;;I"protocol;F;I"Addrinfo;T;[o;;I" ;F;I"Integer;To;;I"yreturns the socket type as an integer.

    Addrinfo.tcp("localhost", 80).socktype == Socket::SOCK_STREAM #=> true

;T;0;;;I"socktype;F;I"Addrinfo;T;[o;;I" ;F;I"Integer;To;;I"µreturns the socket address as packed struct sockaddr string.

    Addrinfo.tcp("localhost", 80).to_sockaddr
    #=> "\x02\x00\x00P\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00"

;T;0;;;I"	to_s;F;I"Addrinfo;T;[o;;I" ;F;I"String;To;;I"µreturns the socket address as packed struct sockaddr string.

    Addrinfo.tcp("localhost", 80).to_sockaddr
    #=> "\x02\x00\x00P\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00"

;T;0;;;I"to_sockaddr;F;I"Addrinfo;T;[o;;I" ;F;I"String;To;;I"Úreturns true if addrinfo is UNIX address. returns false otherwise.

    Addrinfo.tcp("127.0.0.1", 80).unix? #=> false
    Addrinfo.tcp("::1", 80).unix?       #=> false
    Addrinfo.unix("/tmp/sock").unix?    #=> true

;T;0;;;I"
unix?;F;I"Addrinfo;T;[o;;I" ;F;I"	bool;To;;I"kReturns the socket path as a string.

    Addrinfo.unix("/tmp/sock").unix_path       #=> "/tmp/sock"

;T;0;;;I"unix_path;F;I"Addrinfo;T;[o;;I" ;F;I"String;To;;I"returns a new instance of Addrinfo. The instance contains sockaddr, family,
socktype, protocol. sockaddr means struct sockaddr which can be used for
connect(2), etc. family, socktype and protocol are integers which is used for
arguments of socket(2).

sockaddr is specified as an array or a string. The array should be compatible
to the value of IPSocket#addr or UNIXSocket#addr. The string should be struct
sockaddr as generated by Socket.sockaddr_in or Socket.unpack_sockaddr_un.

sockaddr examples:

    "AF_INET", 46102, "localhost.localdomain", "127.0.0.1"
:

    "AF_INET6", 42304, "ip6-localhost", "::1"
:

    "AF_UNIX", "/tmp/sock"
:
*   Socket.sockaddr_in("smtp", "2001:DB8::1")
*   Socket.sockaddr_in(80, "172.18.22.42")
*   Socket.sockaddr_in(80, "www.ruby-lang.org")
*   Socket.sockaddr_un("/tmp/sock")


In an AF_INET/AF_INET6 sockaddr array, the 4th element, numeric IP address, is
used to construct socket address in the Addrinfo instance. If the 3rd element,
textual host name, is non-nil, it is also recorded but used only for
Addrinfo#inspect.

family is specified as an integer to specify the protocol family such as
Socket::PF_INET. It can be a symbol or a string which is the constant name
with or without PF_ prefix such as :INET, :INET6, :UNIX, "PF_INET", etc. If
omitted, PF_UNSPEC is assumed.

socktype is specified as an integer to specify the socket type such as
Socket::SOCK_STREAM. It can be a symbol or a string which is the constant name
with or without SOCK_ prefix such as :STREAM, :DGRAM, :RAW, "SOCK_STREAM",
etc. If omitted, 0 is assumed.

protocol is specified as an integer to specify the protocol such as
Socket::IPPROTO_TCP. It must be an integer, unlike family and socktype. If
omitted, 0 is assumed. Note that 0 is reasonable value for most protocols,
except raw socket.

;T;0;;;I"initialize;F;I"Addrinfo;T;[o;;I"a::String sockaddr, ?::Symbol family, ?(::Symbol | ::Integer)? socktype, ?::Integer? protocol;T;I"untyped;To; ;I"ABasicSocket is the super class for all the Socket classes.

;T;0;	I"BasicSocket;T;
[ ;[ ;0;[ ;[ ;0;I"IO;To;;I"dGets the global do_not_reverse_lookup flag.

    BasicSocket.do_not_reverse_lookup  #=> false

;T;0;;;I"do_not_reverse_lookup;F;I"BasicSocket;T;[o;;I" ;F;I"	bool;To;;I"£Sets the global do_not_reverse_lookup flag.

The flag is used for initial value of do_not_reverse_lookup for each socket.

    s1 = TCPSocket.new("localhost", 80)
    p s1.do_not_reverse_lookup                 #=> true
    BasicSocket.do_not_reverse_lookup = false
    s2 = TCPSocket.new("localhost", 80)
    p s2.do_not_reverse_lookup                 #=> false
    p s1.do_not_reverse_lookup                 #=> true

;T;0;;;I"do_not_reverse_lookup=;F;I"BasicSocket;T;[o;;I"::boolish;T;I"	void;To;;I"ÍReturns a socket object which contains the file descriptor, *fd*.

    # If invoked by inetd, STDIN/STDOUT/STDERR is a socket.
    STDIN_SOCK = Socket.for_fd(STDIN.fileno)
    p STDIN_SOCK.remote_address

;T;0;;;I"for_fd;F;I"BasicSocket;T;[o;;I"::Integer fileno;T;I"BasicSocket;To;;I"Disallows further read using shutdown system call.

    s1, s2 = UNIXSocket.pair
    s1.close_read
    s2.puts #=> Broken pipe (Errno::EPIPE)

;T;0;;;I"close_read;F;I"BasicSocket;T;[o;;I" ;F;I"	void;To;;I"îDisallows further write using shutdown system call.

    UNIXSocket.pair {|s1, s2|
      s1.print "ping"
      s1.close_write
      p s2.read        #=> "ping"
      s2.print "pong"
      s2.close
      p s1.read        #=> "pong"
    }

;T;0;;;I"close_write;F;I"BasicSocket;T;[o;;I" ;F;I"	void;To;;I"Returns an address of the socket suitable for connect in the local machine.

This method returns *self*.local_address, except following condition.

*   IPv4 unspecified address (0.0.0.0) is replaced by IPv4 loopback address
    (127.0.0.1).
*   IPv6 unspecified address (::) is replaced by IPv6 loopback address (::1).


If the local address is not suitable for connect, SocketError is raised. IPv4
and IPv6 address which port is 0 is not suitable for connect. Unix domain
socket which has no path is not suitable for connect.

    Addrinfo.tcp("0.0.0.0", 0).listen {|serv|
      p serv.connect_address #=> #<Addrinfo: 127.0.0.1:53660 TCP>
      serv.connect_address.connect {|c|
        s, _ = serv.accept
        p [c, s] #=> [#<Socket:fd 4>, #<Socket:fd 6>]
      }
    }

;T;0;;;I"connect_address;F;I"BasicSocket;T;[o;;I" ;F;I"Addrinfo;To;;I"€Gets the do_not_reverse_lookup flag of *basicsocket*.

    require 'socket'

    BasicSocket.do_not_reverse_lookup = false
    TCPSocket.open("www.ruby-lang.org", 80) {|sock|
      p sock.do_not_reverse_lookup      #=> false
    }
    BasicSocket.do_not_reverse_lookup = true
    TCPSocket.open("www.ruby-lang.org", 80) {|sock|
      p sock.do_not_reverse_lookup      #=> true
    }

;T;0;;;I"do_not_reverse_lookup;F;I"BasicSocket;T;[o;;I" ;F;I"	bool;To;;I"•Sets the do_not_reverse_lookup flag of *basicsocket*.

    TCPSocket.open("www.ruby-lang.org", 80) {|sock|
      p sock.do_not_reverse_lookup       #=> true
      p sock.peeraddr                    #=> ["AF_INET", 80, "221.186.184.68", "221.186.184.68"]
      sock.do_not_reverse_lookup = false
      p sock.peeraddr                    #=> ["AF_INET", 80, "carbon.ruby-lang.org", "54.163.249.195"]
    }

;T;0;;;I"do_not_reverse_lookup=;F;I"BasicSocket;T;[o;;I"::boolish;T;I"	void;To;;I"¨Returns the user and group on the peer of the UNIX socket. The result is a two
element array which contains the effective uid and the effective gid.

    Socket.unix_server_loop("/tmp/sock") {|s|
      begin
        euid, egid = s.getpeereid

        # Check the connected client is myself or not.
        next if euid != Process.uid

        # do something about my resource.

      ensure
        s.close
      end
    }

;T;0;;;I"getpeereid;F;I"BasicSocket;T;[o;;I" ;F;I"[ ::Integer, ::Integer ];To;;I"iReturns the remote address of the socket as a sockaddr string.

    TCPServer.open("127.0.0.1", 1440) {|serv|
      c = TCPSocket.new("127.0.0.1", 1440)
      s = serv.accept
      p s.getpeername #=> "\x02\x00\x82u\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00"
    }

If Addrinfo object is preferred over the binary string, use
BasicSocket#remote_address.

;T;0;;;I"getpeername;F;I"BasicSocket;T;[o;;I" ;F;I"String;To;;I"*Returns the local address of the socket as a sockaddr string.

    TCPServer.open("127.0.0.1", 15120) {|serv|
      p serv.getsockname #=> "\x02\x00;\x10\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00"
    }

If Addrinfo object is preferred over the binary string, use
BasicSocket#local_address.

;T;0;;;I"getsockname;F;I"BasicSocket;T;[o;;I" ;F;I"String;To;;I"ºGets a socket option. These are protocol and system specific, see your local
system documentation for details. The option is returned as a Socket::Option
object.

### Parameters
*   `level` is an integer, usually one of the SOL_ constants such as
    Socket::SOL_SOCKET, or a protocol level. A string or symbol of the name,
    possibly without prefix, is also accepted.
*   `optname` is an integer, usually one of the SO_ constants, such as
    Socket::SO_REUSEADDR. A string or symbol of the name, possibly without
    prefix, is also accepted.


### Examples

Some socket options are integers with boolean values, in this case #getsockopt
could be called like this:

    reuseaddr = sock.getsockopt(:SOCKET, :REUSEADDR).bool

    optval = sock.getsockopt(Socket::SOL_SOCKET,Socket::SO_REUSEADDR)
    optval = optval.unpack "i"
    reuseaddr = optval[0] == 0 ? false : true

Some socket options are integers with numeric values, in this case #getsockopt
could be called like this:

    ipttl = sock.getsockopt(:IP, :TTL).int

    optval = sock.getsockopt(Socket::IPPROTO_IP, Socket::IP_TTL)
    ipttl = optval.unpack1("i")

Option values may be structs. Decoding them can be complex as it involves
examining your system headers to determine the correct definition. An example
is a +struct linger+, which may be defined in your system headers as:
    struct linger {
      int l_onoff;
      int l_linger;
    };

In this case #getsockopt could be called like this:

    # Socket::Option knows linger structure.
    onoff, linger = sock.getsockopt(:SOCKET, :LINGER).linger

    optval =  sock.getsockopt(Socket::SOL_SOCKET, Socket::SO_LINGER)
    onoff, linger = optval.unpack "ii"
    onoff = onoff == 0 ? false : true

;T;0;;;I"getsockopt;F;I"BasicSocket;T;[o;;I"/::Symbol | ::Integer, ::Symbol | ::Integer;T;I"#Integer | ::boolish | ::String;To;;I"aReturns an Addrinfo object for local address obtained by getsockname.

Note that addrinfo.protocol is filled by 0.

    TCPSocket.open("www.ruby-lang.org", 80) {|s|
      p s.local_address #=> #<Addrinfo: 192.168.0.129:36873 TCP>
    }

    TCPServer.open("127.0.0.1", 1512) {|serv|
      p serv.local_address #=> #<Addrinfo: 127.0.0.1:1512 TCP>
    }

;T;0;;;I"local_address;F;I"BasicSocket;T;[o;;I" ;F;I"Addrinfo;To;;I"þReceives a message.

*maxlen* is the maximum number of bytes to receive.

*flags* should be a bitwise OR of Socket::MSG_* constants.

*outbuf* will contain only the received data after the method call even if it
is not empty at the beginning.

    UNIXSocket.pair {|s1, s2|
      s1.puts "Hello World"
      p s2.recv(4)                     #=> "Hell"
      p s2.recv(4, Socket::MSG_PEEK)   #=> "o Wo"
      p s2.recv(4)                     #=> "o Wo"
      p s2.recv(10)                    #=> "rld\n"
    }

;T;0;;;I"	recv;F;I"BasicSocket;T;[o;;I"9::Integer maxlen, ?::Integer flags, ?::String outbuf;T;I"String;To;;I"'::Integer maxlen, ?::String outbuf;T;I"String;To;;I"ìReceives up to *maxlen* bytes from `socket` using recvfrom(2) after O_NONBLOCK
is set for the underlying file descriptor. *flags* is zero or more of the
`MSG_` options. The result, *mesg*, is the data received.

When recvfrom(2) returns 0, Socket#recv_nonblock returns an empty string as
data. The meaning depends on the socket: EOF on TCP, empty packet on UDP, etc.

### Parameters
*   `maxlen` - the number of bytes to receive from the socket
*   `flags` - zero or more of the `MSG_` options
*   `buf` - destination String buffer
*   `options` - keyword hash, supporting `exception: false`


### Example
    serv = TCPServer.new("127.0.0.1", 0)
    af, port, host, addr = serv.addr
    c = TCPSocket.new(addr, port)
    s = serv.accept
    c.send "aaa", 0
    begin # emulate blocking recv.
      p s.recv_nonblock(10) #=> "aaa"
    rescue IO::WaitReadable
      IO.select([s])
      retry
    end

Refer to Socket#recvfrom for the exceptions that may be thrown if the call to
*recv_nonblock* fails.

BasicSocket#recv_nonblock may raise any error corresponding to recvfrom(2)
failure, including Errno::EWOULDBLOCK.

If the exception is Errno::EWOULDBLOCK or Errno::EAGAIN, it is extended by
IO::WaitReadable. So IO::WaitReadable can be used to rescue the exceptions for
retrying recv_nonblock.

By specifying a keyword argument *exception* to `false`, you can indicate that
recv_nonblock should not raise an IO::WaitReadable exception, but return the
symbol `:wait_readable` instead.

### See
*   Socket#recvfrom

;T;0;;;I"recv_nonblock;F;I"BasicSocket;T;[o;;I"M::Integer maxlen, ?::Integer flags, ?::String buf, ?exception: ::boolish;T;I"String | :wait_readable;To;;I"crecvmsg receives a message using recvmsg(2) system call in blocking manner.

*maxmesglen* is the maximum length of mesg to receive.

*flags* is bitwise OR of MSG_* constants such as Socket::MSG_PEEK.

*maxcontrollen* is the maximum length of controls (ancillary data) to receive.

*opts* is option hash. Currently :scm_rights=>bool is the only option.

:scm_rights option specifies that application expects SCM_RIGHTS control
message. If the value is nil or false, application don't expects SCM_RIGHTS
control message. In this case, recvmsg closes the passed file descriptors
immediately. This is the default behavior.

If :scm_rights value is neither nil nor false, application expects SCM_RIGHTS
control message. In this case, recvmsg creates IO objects for each file
descriptors for Socket::AncillaryData#unix_rights method.

The return value is 4-elements array.

*mesg* is a string of the received message.

*sender_addrinfo* is a sender socket address for connection-less socket. It is
an Addrinfo object. For connection-oriented socket such as TCP,
sender_addrinfo is platform dependent.

*rflags* is a flags on the received message which is bitwise OR of MSG_*
constants such as Socket::MSG_TRUNC. It will be nil if the system uses 4.3BSD
style old recvmsg system call.

*controls* is ancillary data which is an array of Socket::AncillaryData
objects such as:

    #<Socket::AncillaryData: AF_UNIX SOCKET RIGHTS 7>

*maxmesglen* and *maxcontrollen* can be nil. In that case, the buffer will be
grown until the message is not truncated. Internally, MSG_PEEK is used. Buffer
full and MSG_CTRUNC are checked for truncation.

recvmsg can be used to implement recv_io as follows:

    mesg, sender_sockaddr, rflags, *controls = sock.recvmsg(:scm_rights=>true)
    controls.each {|ancdata|
      if ancdata.cmsg_is?(:SOCKET, :RIGHTS)
        return ancdata.unix_rights[0]
      end
    }

;T;0;;;I"recvmsg;F;I"BasicSocket;T;[o;;I"O?::Integer dlen, ?::Integer flags, ?::Integer clen, ?scm_rights: ::boolish;T;I"K[ ::String, ::Addrinfo, ::Integer?, ::Array[::Socket::AncillaryData] ];To;;I"’recvmsg receives a message using recvmsg(2) system call in non-blocking
manner.

It is similar to BasicSocket#recvmsg but non-blocking flag is set before the
system call and it doesn't retry the system call.

By specifying a keyword argument *exception* to `false`, you can indicate that
recvmsg_nonblock should not raise an IO::WaitReadable exception, but return
the symbol `:wait_readable` instead.

;T;0;;;I"recvmsg_nonblock;F;I"BasicSocket;T;[o;;I"f?::Integer dlen, ?::Integer flags, ?::Integer clen, ?exception: ::boolish, ?scm_rights: ::boolish;T;I"\[ ::String, ::Addrinfo, ::Integer?, ::Array[::Socket::AncillaryData] ] | :wait_readable;To;;I"¡Returns an Addrinfo object for remote address obtained by getpeername.

Note that addrinfo.protocol is filled by 0.

    TCPSocket.open("www.ruby-lang.org", 80) {|s|
      p s.remote_address #=> #<Addrinfo: 221.186.184.68:80 TCP>
    }

    TCPServer.open("127.0.0.1", 1728) {|serv|
      c = TCPSocket.new("127.0.0.1", 1728)
      s = serv.accept
      p s.remote_address #=> #<Addrinfo: 127.0.0.1:36504 TCP>
    }

;T;0;;;I"remote_address;F;I"BasicSocket;T;[o;;I" ;F;I"Addrinfo;To;;I"$send *mesg* via *basicsocket*.

*mesg* should be a string.

*flags* should be a bitwise OR of Socket::MSG_* constants.

*dest_sockaddr* should be a packed sockaddr string or an addrinfo.

    TCPSocket.open("localhost", 80) {|s|
      s.send "GET / HTTP/1.0\r\n\r\n", 0
      p s.read
    }

;T;0;;;I"	send;F;I"BasicSocket;T;[o;;I"I::String msg, ?::Integer flags, ?::Addrinfo | ::String dest_sockaddr;T;I"	void;To;;I"³sendmsg sends a message using sendmsg(2) system call in blocking manner.

*mesg* is a string to send.

*flags* is bitwise OR of MSG_* constants such as Socket::MSG_OOB.

*dest_sockaddr* is a destination socket address for connection-less socket. It
should be a sockaddr such as a result of Socket.sockaddr_in. An Addrinfo
object can be used too.

*controls* is a list of ancillary data. The element of *controls* should be
Socket::AncillaryData or 3-elements array. The 3-element array should contains
cmsg_level, cmsg_type and data.

The return value, *numbytes_sent* is an integer which is the number of bytes
sent.

sendmsg can be used to implement send_io as follows:

    # use Socket::AncillaryData.
    ancdata = Socket::AncillaryData.int(:UNIX, :SOCKET, :RIGHTS, io.fileno)
    sock.sendmsg("a", 0, nil, ancdata)

    # use 3-element array.
    ancdata = [:SOCKET, :RIGHTS, [io.fileno].pack("i!")]
    sock.sendmsg("\0", 0, nil, ancdata)

;T;0;;;I"sendmsg;F;I"BasicSocket;T;[o;;I"m::String mesg, ?::Integer flags, ?::Addrinfo | ::String dest_sockaddr, *::Socket::AncillaryData controls;T;I"Integer;To;;I"œsendmsg_nonblock sends a message using sendmsg(2) system call in non-blocking
manner.

It is similar to BasicSocket#sendmsg but the non-blocking flag is set before
the system call and it doesn't retry the system call.

By specifying a keyword argument *exception* to `false`, you can indicate that
sendmsg_nonblock should not raise an IO::WaitWritable exception, but return
the symbol `:wait_writable` instead.

;T;0;;;I"sendmsg_nonblock;F;I"BasicSocket;T;[o;;I"::String mesg, ?::Integer flags, ?::Addrinfo | ::String dest_sockaddr, *::Socket::AncillaryData controls, ?exception: ::boolish;T;I"Integer | :wait_writable;To;;I"«Sets a socket option. These are protocol and system specific, see your local
system documentation for details.

### Parameters
*   `level` is an integer, usually one of the SOL_ constants such as
    Socket::SOL_SOCKET, or a protocol level. A string or symbol of the name,
    possibly without prefix, is also accepted.
*   `optname` is an integer, usually one of the SO_ constants, such as
    Socket::SO_REUSEADDR. A string or symbol of the name, possibly without
    prefix, is also accepted.
*   `optval` is the value of the option, it is passed to the underlying
    setsockopt() as a pointer to a certain number of bytes. How this is done
    depends on the type:
    *   Integer: value is assigned to an int, and a pointer to the int is
        passed, with length of sizeof(int).
    *   true or false: 1 or 0 (respectively) is assigned to an int, and the
        int is passed as for an Integer. Note that `false` must be passed, not
        `nil`.
    *   String: the string's data and length is passed to the socket.

*   `socketoption` is an instance of Socket::Option


### Examples

Some socket options are integers with boolean values, in this case #setsockopt
could be called like this:
    sock.setsockopt(:SOCKET, :REUSEADDR, true)
    sock.setsockopt(Socket::SOL_SOCKET,Socket::SO_REUSEADDR, true)
    sock.setsockopt(Socket::Option.bool(:INET, :SOCKET, :REUSEADDR, true))

Some socket options are integers with numeric values, in this case #setsockopt
could be called like this:
    sock.setsockopt(:IP, :TTL, 255)
    sock.setsockopt(Socket::IPPROTO_IP, Socket::IP_TTL, 255)
    sock.setsockopt(Socket::Option.int(:INET, :IP, :TTL, 255))

Option values may be structs. Passing them can be complex as it involves
examining your system headers to determine the correct definition. An example
is an `ip_mreq`, which may be defined in your system headers as:
    struct ip_mreq {
      struct  in_addr imr_multiaddr;
      struct  in_addr imr_interface;
    };

In this case #setsockopt could be called like this:
    optval = IPAddr.new("224.0.0.251").hton +
             IPAddr.new(Socket::INADDR_ANY, Socket::AF_INET).hton
    sock.setsockopt(Socket::IPPROTO_IP, Socket::IP_ADD_MEMBERSHIP, optval)

;T;0;;;I"setsockopt;F;I"BasicSocket;T;[o;;I"<*::Symbol | ::Integer, ::boolish | ::Integer | ::String;T;I"	void;To;;I"Calls shutdown(2) system call.

s.shutdown(Socket::SHUT_RD) disallows further read.

s.shutdown(Socket::SHUT_WR) disallows further write.

s.shutdown(Socket::SHUT_RDWR) disallows further read and write.

*how* can be symbol or string:
*   :RD, :SHUT_RD, "RD" and "SHUT_RD" are accepted as Socket::SHUT_RD.
*   :WR, :SHUT_WR, "WR" and "SHUT_WR" are accepted as Socket::SHUT_WR.
*   :RDWR, :SHUT_RDWR, "RDWR" and "SHUT_RDWR" are accepted as
    Socket::SHUT_RDWR.

    UNIXSocket.pair {|s1, s2|
        s1.puts "ping"
        s1.shutdown(:WR)
        p s2.read          #=> "ping\n"
        s2.puts "pong"
        s2.close
        p s1.read          #=> "pong\n"

    }

;T;0;;;I"shutdown;F;I"BasicSocket;T;[o;;I"*::Symbol | ::String | ::Integer flags;T;I"	void;To;;0;0;;;I"__recv_nonblock;F;I"BasicSocket;T;[o;;I"'untyped, untyped, untyped, untyped;T;I"untyped;To;;0;0;;;I"__recvmsg;F;I"BasicSocket;T;[o;;I"'untyped, untyped, untyped, untyped;T;I"untyped;To;;0;0;;;I"__recvmsg_nonblock;F;I"BasicSocket;T;[o;;I"0untyped, untyped, untyped, untyped, untyped;T;I"untyped;To;;0;0;;;I"__sendmsg;F;I"BasicSocket;T;[o;;I"'untyped, untyped, untyped, untyped;T;I"untyped;To;;0;0;;;I"__sendmsg_nonblock;F;I"BasicSocket;T;[o;;I"0untyped, untyped, untyped, untyped, untyped;T;I"untyped;To; ;I">IPSocket is the super class of TCPSocket and UDPSocket.

;T;0;	I"IPSocket;T;
[ ;[ ;0;[ ;[ ;0;I"BasicSocket;To;;I"¦Lookups the IP address of *host*.

    require 'socket'

    IPSocket.getaddress("localhost")     #=> "127.0.0.1"
    IPSocket.getaddress("ip6-localhost") #=> "::1"

;T;0;;;I"getaddress;F;I"IPSocket;T;[o;;I"::String host;T;I"String;To;;I"HReturns the local address as an array which contains address_family, port,
hostname and numeric_address.

If `reverse_lookup` is `true` or `:hostname`, hostname is obtained from
numeric_address using reverse lookup. Or if it is `false`, or `:numeric`,
hostname is the same as numeric_address. Or if it is `nil` or omitted, obeys
to `ipsocket.do_not_reverse_lookup`. See `Socket.getaddrinfo` also.

    TCPSocket.open("www.ruby-lang.org", 80) {|sock|
      p sock.addr #=> ["AF_INET", 49429, "hal", "192.168.0.128"]
      p sock.addr(true)  #=> ["AF_INET", 49429, "hal", "192.168.0.128"]
      p sock.addr(false) #=> ["AF_INET", 49429, "192.168.0.128", "192.168.0.128"]
      p sock.addr(:hostname)  #=> ["AF_INET", 49429, "hal", "192.168.0.128"]
      p sock.addr(:numeric)   #=> ["AF_INET", 49429, "192.168.0.128", "192.168.0.128"]
    }

;T;0;;;I"	addr;F;I"IPSocket;T;[o;;I"5?::boolish | :hostname | :numeric reverse_lookup;T;I"0[ ::String, ::Integer, ::String, ::String ];To;;I"7Return a string describing this IPSocket object.

;T;0;;;I"inspect;F;I"IPSocket;T;[o;;I" ;F;I"String;To;;I"ÆReturns the remote address as an array which contains address_family, port,
hostname and numeric_address. It is defined for connection oriented socket
such as TCPSocket.

If `reverse_lookup` is `true` or `:hostname`, hostname is obtained from
numeric_address using reverse lookup. Or if it is `false`, or `:numeric`,
hostname is the same as numeric_address. Or if it is `nil` or omitted, obeys
to `ipsocket.do_not_reverse_lookup`. See `Socket.getaddrinfo` also.

    TCPSocket.open("www.ruby-lang.org", 80) {|sock|
      p sock.peeraddr #=> ["AF_INET", 80, "carbon.ruby-lang.org", "221.186.184.68"]
      p sock.peeraddr(true)  #=> ["AF_INET", 80, "carbon.ruby-lang.org", "221.186.184.68"]
      p sock.peeraddr(false) #=> ["AF_INET", 80, "221.186.184.68", "221.186.184.68"]
      p sock.peeraddr(:hostname) #=> ["AF_INET", 80, "carbon.ruby-lang.org", "221.186.184.68"]
      p sock.peeraddr(:numeric)  #=> ["AF_INET", 80, "221.186.184.68", "221.186.184.68"]
    }

;T;0;;;I"peeraddr;F;I"IPSocket;T;[o;;I"5?::boolish | :hostname | :numeric reverse_lookup;T;I"0[ ::String, ::Integer, ::String, ::String ];To;;I"ÍReceives a message and return the message as a string and an address which the
message come from.

*maxlen* is the maximum number of bytes to receive.

*flags* should be a bitwise OR of Socket::MSG_* constants.

ipaddr is the same as IPSocket#{peeraddr,addr}.

    u1 = UDPSocket.new
    u1.bind("127.0.0.1", 4913)
    u2 = UDPSocket.new
    u2.send "uuuu", 0, "127.0.0.1", 4913
    p u1.recvfrom(10) #=> ["uuuu", ["AF_INET", 33230, "localhost", "127.0.0.1"]]

;T;0;;;I"recvfrom;F;I"IPSocket;T;[o;;I"'::Integer maxlen, ?::Integer flags;T;I">[ ::String, [ ::String, ::Integer, ::String, ::String ] ];To; ;I"ïClass `Socket` provides access to the underlying operating system socket
implementations.  It can be used to provide more operating system specific
functionality than the protocol-specific socket classes.

The constants defined under Socket::Constants are also defined under Socket.
For example, Socket::AF_INET is usable as well as Socket::Constants::AF_INET.
See Socket::Constants for the list of constants.

### What's a socket?

Sockets are endpoints of a bidirectional communication channel. Sockets can
communicate within a process, between processes on the same machine or between
different machines.  There are many types of socket: TCPSocket, UDPSocket or
UNIXSocket for example.

Sockets have their own vocabulary:

**domain:** The family of protocols:
*   Socket::PF_INET
*   Socket::PF_INET6
*   Socket::PF_UNIX
*   etc.


**type:** The type of communications between the two endpoints, typically
*   Socket::SOCK_STREAM
*   Socket::SOCK_DGRAM.


**protocol:** Typically *zero*. This may be used to identify a variant of a
protocol.

**hostname:** The identifier of a network interface:
*   a string (hostname, IPv4 or IPv6 address or `broadcast` which specifies a
    broadcast address)
*   a zero-length string which specifies INADDR_ANY
*   an integer (interpreted as binary address in host byte order).


### Quick start

Many of the classes, such as TCPSocket, UDPSocket or UNIXSocket, ease the use
of sockets comparatively to the equivalent C programming interface.

Let's create an internet socket using the IPv4 protocol in a C-like manner:

    require 'socket'

    s = Socket.new Socket::AF_INET, Socket::SOCK_STREAM
    s.connect Socket.pack_sockaddr_in(80, 'example.com')

You could also use the TCPSocket class:

    s = TCPSocket.new 'example.com', 80

A simple server might look like this:

    require 'socket'

    server = TCPServer.new 2000 # Server bound to port 2000

    loop do
      client = server.accept    # Wait for a client to connect
      client.puts "Hello !"
      client.puts "Time is #{Time.now}"
      client.close
    end

A simple client may look like this:

    require 'socket'

    s = TCPSocket.new 'localhost', 2000

    while line = s.gets # Read lines from socket
      puts line         # and print them
    end

    s.close             # close socket when done

### Exception Handling

Ruby's Socket implementation raises exceptions based on the error generated by
the system dependent implementation.  This is why the methods are documented
in a way that isolate Unix-based system exceptions from Windows based
exceptions. If more information on a particular exception is needed, please
refer to the Unix manual pages or the Windows WinSock reference.

### Convenience methods

Although the general way to create socket is Socket.new, there are several
methods of socket creation for most cases.

TCP client socket
:   Socket.tcp, TCPSocket.open
TCP server socket
:   Socket.tcp_server_loop, TCPServer.open
UNIX client socket
:   Socket.unix, UNIXSocket.open
UNIX server socket
:   Socket.unix_server_loop, UNIXServer.open


### Documentation by

*   Zach Dennis
*   Sam Roberts
*   *Programming Ruby* from The Pragmatic Bookshelf.


Much material in this documentation is taken with permission from *Programming
Ruby* from The Pragmatic Bookshelf.

;T;0;	I"Socket;T;
[ ;[ ;0;[ ;[ ;0;I"BasicSocket;To;;I"–yield socket and client address for each a connection accepted via given
sockets.

The arguments are a list of sockets. The individual argument should be a
socket or an array of sockets.

This method yields the block sequentially. It means that the next connection
is not accepted until the block returns. So concurrent mechanism, thread for
example, should be used to service multiple clients at a time.

;T;0;;;I"accept_loop;F;I"Socket;T;[o;;I"*::_ToIO sockets;T;I"	void;To;;I"uObtains address information for *nodename*:*servname*.

Note that Addrinfo.getaddrinfo provides the same functionality in an object
oriented style.

*family* should be an address family such as: :INET, :INET6, etc.

*socktype* should be a socket type such as: :STREAM, :DGRAM, :RAW, etc.

*protocol* should be a protocol defined in the family, and defaults to 0 for
the family.

*flags* should be bitwise OR of Socket::AI_* constants.

    Socket.getaddrinfo("www.ruby-lang.org", "http", nil, :STREAM)
    #=> [["AF_INET", 80, "carbon.ruby-lang.org", "221.186.184.68", 2, 1, 6]] # PF_INET/SOCK_STREAM/IPPROTO_TCP

    Socket.getaddrinfo("localhost", nil)
    #=> [["AF_INET", 0, "localhost", "127.0.0.1", 2, 1, 6],  # PF_INET/SOCK_STREAM/IPPROTO_TCP
    #    ["AF_INET", 0, "localhost", "127.0.0.1", 2, 2, 17], # PF_INET/SOCK_DGRAM/IPPROTO_UDP
    #    ["AF_INET", 0, "localhost", "127.0.0.1", 2, 3, 0]]  # PF_INET/SOCK_RAW/IPPROTO_IP

*reverse_lookup* directs the form of the third element, and has to be one of
below.  If *reverse_lookup* is omitted, the default value is `nil`.

    +true+, +:hostname+:  hostname is obtained from numeric address using reverse lookup, which may take a time.
    +false+, +:numeric+:  hostname is the same as numeric address.
    +nil+:              obey to the current +do_not_reverse_lookup+ flag.

If Addrinfo object is preferred, use Addrinfo.getaddrinfo.

;T;0;;;I"getaddrinfo;F;I"Socket;T;[o;;I"º::String peer, ::String | ::Integer | nil protocol, ?::Integer | ::Symbol | nil family, ?::Integer | ::Symbol | nil socktype, ?::Integer | ::Symbol | nil protocol, ?::Integer | nil flags;T;I"Q[ ::String, ::Integer, ::String, ::String, ::Integer, ::Integer, ::Integer ];To;;I"fUse Addrinfo#getnameinfo instead. This method is deprecated for the following
reasons:

*   Uncommon address representation: 4/16-bytes binary string to represent
    IPv4/IPv6 address.
*   gethostbyaddr() may take a long time and it may block other threads. (GVL
    cannot be released since gethostbyname() is not thread safe.)
*   This method uses gethostbyname() function already removed from POSIX.


This method obtains the host information for *address*.

    p Socket.gethostbyaddr([221,186,184,68].pack("CCCC"))
    #=> ["carbon.ruby-lang.org", [], 2, "\xDD\xBA\xB8D"]

    p Socket.gethostbyaddr([127,0,0,1].pack("CCCC"))
    ["localhost", [], 2, "\x7F\x00\x00\x01"]
    p Socket.gethostbyaddr(([0]*15+[1]).pack("C"*16))
    #=> ["localhost", ["ip6-localhost", "ip6-loopback"], 10,
         "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01"]

;T;0;;;I"gethostbyaddr;F;I"Socket;T;[o;;I"::String ip;T;I"9[ ::String, ::Array[::String], ::Integer, ::String ];To;;I"»Use Addrinfo.getaddrinfo instead. This method is deprecated for the following
reasons:

*   The 3rd element of the result is the address family of the first address.
    The address families of the rest of the addresses are not returned.
*   Uncommon address representation: 4/16-bytes binary string to represent
    IPv4/IPv6 address.
*   gethostbyname() may take a long time and it may block other threads. (GVL
    cannot be released since gethostbyname() is not thread safe.)
*   This method uses gethostbyname() function already removed from POSIX.


This method obtains the host information for *hostname*.

    p Socket.gethostbyname("hal") #=> ["localhost", ["hal"], 2, "\x7F\x00\x00\x01"]

;T;0;;;I"gethostbyname;F;I"Socket;T;[o;;I"::String name;T;I"9[ ::String, ::Array[::String], ::Integer, ::String ];To;;I"àReturns the hostname.

    p Socket.gethostname #=> "hal"

Note that it is not guaranteed to be able to convert to IP address using
gethostbyname, getaddrinfo, etc. If you need local IP address, use
Socket.ip_address_list.

;T;0;;;I"gethostname;F;I"Socket;T;[o;;I" ;F;I"String;To;;I"Á	Returns an array of interface addresses. An element of the array is an
instance of Socket::Ifaddr.

This method can be used to find multicast-enabled interfaces:

    pp Socket.getifaddrs.reject {|ifaddr|
      !ifaddr.addr.ip? || (ifaddr.flags & Socket::IFF_MULTICAST == 0)
    }.map {|ifaddr| [ifaddr.name, ifaddr.ifindex, ifaddr.addr] }
    #=> [["eth0", 2, #<Addrinfo: 221.186.184.67>],
    #    ["eth0", 2, #<Addrinfo: fe80::216:3eff:fe95:88bb%eth0>]]

Example result on GNU/Linux:
    pp Socket.getifaddrs
    #=> [#<Socket::Ifaddr lo UP,LOOPBACK,RUNNING,0x10000 PACKET[protocol=0 lo hatype=772 HOST hwaddr=00:00:00:00:00:00]>,
    #    #<Socket::Ifaddr eth0 UP,BROADCAST,RUNNING,MULTICAST,0x10000 PACKET[protocol=0 eth0 hatype=1 HOST hwaddr=00:16:3e:95:88:bb] broadcast=PACKET[protocol=0 eth0 hatype=1 HOST hwaddr=ff:ff:ff:ff:ff:ff]>,
    #    #<Socket::Ifaddr sit0 NOARP PACKET[protocol=0 sit0 hatype=776 HOST hwaddr=00:00:00:00]>,
    #    #<Socket::Ifaddr lo UP,LOOPBACK,RUNNING,0x10000 127.0.0.1 netmask=255.0.0.0>,
    #    #<Socket::Ifaddr eth0 UP,BROADCAST,RUNNING,MULTICAST,0x10000 221.186.184.67 netmask=255.255.255.240 broadcast=221.186.184.79>,
    #    #<Socket::Ifaddr lo UP,LOOPBACK,RUNNING,0x10000 ::1 netmask=ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff>,
    #    #<Socket::Ifaddr eth0 UP,BROADCAST,RUNNING,MULTICAST,0x10000 fe80::216:3eff:fe95:88bb%eth0 netmask=ffff:ffff:ffff:ffff::>]

Example result on FreeBSD:
    pp Socket.getifaddrs
    #=> [#<Socket::Ifaddr usbus0 UP,0x10000 LINK[usbus0]>,
    #    #<Socket::Ifaddr re0 UP,BROADCAST,RUNNING,MULTICAST,0x800 LINK[re0 3a:d0:40:9a:fe:e8]>,
    #    #<Socket::Ifaddr re0 UP,BROADCAST,RUNNING,MULTICAST,0x800 10.250.10.18 netmask=255.255.255.? (7 bytes for 16 bytes sockaddr_in) broadcast=10.250.10.255>,
    #    #<Socket::Ifaddr re0 UP,BROADCAST,RUNNING,MULTICAST,0x800 fe80:2::38d0:40ff:fe9a:fee8 netmask=ffff:ffff:ffff:ffff::>,
    #    #<Socket::Ifaddr re0 UP,BROADCAST,RUNNING,MULTICAST,0x800 2001:2e8:408:10::12 netmask=UNSPEC>,
    #    #<Socket::Ifaddr plip0 POINTOPOINT,MULTICAST,0x800 LINK[plip0]>,
    #    #<Socket::Ifaddr lo0 UP,LOOPBACK,RUNNING,MULTICAST LINK[lo0]>,
    #    #<Socket::Ifaddr lo0 UP,LOOPBACK,RUNNING,MULTICAST ::1 netmask=ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff>,
    #    #<Socket::Ifaddr lo0 UP,LOOPBACK,RUNNING,MULTICAST fe80:4::1 netmask=ffff:ffff:ffff:ffff::>,
    #    #<Socket::Ifaddr lo0 UP,LOOPBACK,RUNNING,MULTICAST 127.0.0.1 netmask=255.?.?.? (5 bytes for 16 bytes sockaddr_in)>]

;T;0;;;I"getifaddrs;F;I"Socket;T;[o;;I" ;F;I"Array[::Socket::Ifaddr];To;;I"éObtains name information for *sockaddr*.

*sockaddr* should be one of follows.
*   packed sockaddr string such as Socket.sockaddr_in(80, "127.0.0.1")
*   3-elements array such as ["AF_INET", 80, "127.0.0.1"]
*   4-elements array such as ["AF_INET", 80, ignored, "127.0.0.1"]


*flags* should be bitwise OR of Socket::NI_* constants.

Note: The last form is compatible with IPSocket#addr and IPSocket#peeraddr.

    Socket.getnameinfo(Socket.sockaddr_in(80, "127.0.0.1"))       #=> ["localhost", "www"]
    Socket.getnameinfo(["AF_INET", 80, "127.0.0.1"])              #=> ["localhost", "www"]
    Socket.getnameinfo(["AF_INET", 80, "localhost", "127.0.0.1"]) #=> ["localhost", "www"]

If Addrinfo object is preferred, use Addrinfo#getnameinfo.

;T;0;;;I"getnameinfo;F;I"Socket;T;[o;;I"&[ ::String, ::Integer, ::String ];T;I"Array[::String];To;;I"0[ ::String, ::Integer, ::String, ::String ];T;I"Array[::String];To;;I"::String sockaddr;T;I"Array[::String];To;;I"÷Obtains the port number for *service_name*.

If *protocol_name* is not given, "tcp" is assumed.

    Socket.getservbyname("smtp")          #=> 25
    Socket.getservbyname("shell")         #=> 514
    Socket.getservbyname("syslog", "udp") #=> 514

;T;0;;;I"getservbyname;F;I"Socket;T;[o;;I"::String service_proto;T;I"Integer;To;;I"2::String service_proto, ::String layer4_proto;T;I"Integer;To;;I"ìObtains the port number for *port*.

If *protocol_name* is not given, "tcp" is assumed.

    Socket.getservbyport(80)         #=> "www"
    Socket.getservbyport(514, "tcp") #=> "shell"
    Socket.getservbyport(514, "udp") #=> "syslog"

;T;0;;;I"getservbyport;F;I"Socket;T;[o;;I"::Integer service_port;T;I"String;To;;I"2::Integer service_port, ::String layer4_proto;T;I"String;To;;I"ÝReturns local IP addresses as an array.

The array contains Addrinfo objects.

    pp Socket.ip_address_list
    #=> [#<Addrinfo: 127.0.0.1>,
         #<Addrinfo: 192.168.0.128>,
         #<Addrinfo: ::1>,
         ...]

;T;0;;;I"ip_address_list;F;I"Socket;T;[o;;I" ;F;I"Array[::Addrinfo];To;;I"KPacks *port* and *host* as an AF_INET/AF_INET6 sockaddr string.

    Socket.sockaddr_in(80, "127.0.0.1")
    #=> "\x02\x00\x00P\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00"

    Socket.sockaddr_in(80, "::1")
    #=> "\n\x00\x00P\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00"

;T;0;;;I"pack_sockaddr_in;F;I"Socket;T;[o;;I" ::Integer port, ::String ip;T;I"String;To;;I"zPacks *path* as an AF_UNIX sockaddr string.

    Socket.sockaddr_un("/tmp/sock") #=> "\x01\x00/tmp/sock\x00\x00..."

;T;0;;;I"pack_sockaddr_un;F;I"Socket;T;[o;;I"::String sockpath;T;I"String;To;;I"SCreates a pair of sockets connected each other.

*domain* should be a communications domain such as: :INET, :INET6, :UNIX, etc.

*socktype* should be a socket type such as: :STREAM, :DGRAM, :RAW, etc.

*protocol* should be a protocol defined in the domain, defaults to 0 for the
domain.

    s1, s2 = Socket.pair(:UNIX, :STREAM, 0)
    s1.send "a", 0
    s1.send "b", 0
    s1.close
    p s2.recv(10) #=> "ab"
    p s2.recv(10) #=> ""
    p s2.recv(10) #=> ""

    s1, s2 = Socket.pair(:UNIX, :DGRAM, 0)
    s1.send "a", 0
    s1.send "b", 0
    p s2.recv(10) #=> "a"
    p s2.recv(10) #=> "b"

;T;0;;;I"	pair;F;I"Socket;T;[o;;I"?::Symbol sockdomain, ::Symbol socktype, ::Integer protocol;T;I"[ instance, instance ];To;;I"KPacks *port* and *host* as an AF_INET/AF_INET6 sockaddr string.

    Socket.sockaddr_in(80, "127.0.0.1")
    #=> "\x02\x00\x00P\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00"

    Socket.sockaddr_in(80, "::1")
    #=> "\n\x00\x00P\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00"

;T;0;;;I"sockaddr_in;F;I"Socket;T;[o;;I" ::Integer port, ::String ip;T;I"String;To;;I"zPacks *path* as an AF_UNIX sockaddr string.

    Socket.sockaddr_un("/tmp/sock") #=> "\x01\x00/tmp/sock\x00\x00..."

;T;0;;;I"sockaddr_un;F;I"Socket;T;[o;;I"::String sockpath;T;I"String;To;;I"SCreates a pair of sockets connected each other.

*domain* should be a communications domain such as: :INET, :INET6, :UNIX, etc.

*socktype* should be a socket type such as: :STREAM, :DGRAM, :RAW, etc.

*protocol* should be a protocol defined in the domain, defaults to 0 for the
domain.

    s1, s2 = Socket.pair(:UNIX, :STREAM, 0)
    s1.send "a", 0
    s1.send "b", 0
    s1.close
    p s2.recv(10) #=> "ab"
    p s2.recv(10) #=> ""
    p s2.recv(10) #=> ""

    s1, s2 = Socket.pair(:UNIX, :DGRAM, 0)
    s1.send "a", 0
    s1.send "b", 0
    p s2.recv(10) #=> "a"
    p s2.recv(10) #=> "b"

;T;0;;;I"socketpair;F;I"Socket;T;[o;;I"?::Symbol sockdomain, ::Symbol socktype, ::Integer protocol;T;I"[ instance, instance ];To;;I"Écreates a new socket object connected to host:port using TCP/IP.

If local_host:local_port is given, the socket is bound to it.

The optional last argument *opts* is options represented by a hash. *opts* may
have following options:

:connect_timeout
:   specify the timeout in seconds.
:resolv_timeout
:   specify the name resolution timeout in seconds.


If a block is given, the block is called with the socket. The value of the
block is returned. The socket is closed when this method returns.

If no block is given, the socket is returned.

    Socket.tcp("www.ruby-lang.org", 80) {|sock|
      sock.print "GET / HTTP/1.0\r\nHost: www.ruby-lang.org\r\n\r\n"
      sock.close_write
      puts sock.read
    }

;T;0;;;I"tcp;F;I"Socket;T;[o;;I"ƒ::String host, ::Integer port, ?::String local_host, ?::Integer local_port, ?resolv_timeout: ::Numeric, ?connect_timeout: ::Numeric;T;I"instance;To;;I"ƒ::String host, ::Integer port, ?::String local_host, ?::Integer local_port, ?resolv_timeout: ::Numeric, ?connect_timeout: ::Numeric;T;I"	void;To;;I"[creates a TCP/IP server on *port* and calls the block for each connection
accepted. The block is called with a socket and a client_address as an
Addrinfo object.

If *host* is specified, it is used with *port* to determine the server
addresses.

The socket is **not** closed when the block returns. So application should
close it explicitly.

This method calls the block sequentially. It means that the next connection is
not accepted until the block returns. So concurrent mechanism, thread for
example, should be used to service multiple clients at a time.

Note that Addrinfo.getaddrinfo is used to determine the server socket
addresses. When Addrinfo.getaddrinfo returns two or more addresses, IPv4 and
IPv6 address for example, all of them are used. Socket.tcp_server_loop
succeeds if one socket can be used at least.

    # Sequential echo server.
    # It services only one client at a time.
    Socket.tcp_server_loop(16807) {|sock, client_addrinfo|
      begin
        IO.copy_stream(sock, sock)
      ensure
        sock.close
      end
    }

    # Threaded echo server
    # It services multiple clients at a time.
    # Note that it may accept connections too much.
    Socket.tcp_server_loop(16807) {|sock, client_addrinfo|
      Thread.new {
        begin
          IO.copy_stream(sock, sock)
        ensure
          sock.close
        end
      }
    }

;T;0;;;I"tcp_server_loop;F;I"Socket;T;[o;;I"#?::String host, ::Integer port;T;I"	void;To;;I"Ocreates TCP/IP server sockets for *host* and *port*. *host* is optional.

If no block given, it returns an array of listening sockets.

If a block is given, the block is called with the sockets. The value of the
block is returned. The socket is closed when this method returns.

If *port* is 0, actual port number is chosen dynamically. However all sockets
in the result has same port number.

    # tcp_server_sockets returns two sockets.
    sockets = Socket.tcp_server_sockets(1296)
    p sockets #=> [#<Socket:fd 3>, #<Socket:fd 4>]

    # The sockets contains IPv6 and IPv4 sockets.
    sockets.each {|s| p s.local_address }
    #=> #<Addrinfo: [::]:1296 TCP>
    #   #<Addrinfo: 0.0.0.0:1296 TCP>

    # IPv6 and IPv4 socket has same port number, 53114, even if it is chosen dynamically.
    sockets = Socket.tcp_server_sockets(0)
    sockets.each {|s| p s.local_address }
    #=> #<Addrinfo: [::]:53114 TCP>
    #   #<Addrinfo: 0.0.0.0:53114 TCP>

    # The block is called with the sockets.
    Socket.tcp_server_sockets(0) {|sockets|
      p sockets #=> [#<Socket:fd 3>, #<Socket:fd 4>]
    }

;T;0;;;I"tcp_server_sockets;F;I"Socket;T;[o;;I"#?::String host, ::Integer port;T;I"Array[::TCPServer];To;;I"#?::String host, ::Integer port;T;I"	void;To;;I"îcreates a UDP/IP server on *port* and calls the block for each message
arrived. The block is called with the message and its source information.

This method allocates sockets internally using *port*. If *host* is specified,
it is used conjunction with *port* to determine the server addresses.

The *msg* is a string.

The *msg_src* is a Socket::UDPSource object. It is used for reply.

    # UDP/IP echo server.
    Socket.udp_server_loop(9261) {|msg, msg_src|
      msg_src.reply msg
    }

;T;0;;;I"udp_server_loop;F;I"Socket;T;[o;;I"#?::String host, ::Integer port;T;I"	void;To;;I"­Run UDP/IP server loop on the given sockets.

The return value of Socket.udp_server_sockets is appropriate for the argument.

It calls the block for each message received.

;T;0;;;I"udp_server_loop_on;F;I"Socket;T;[o;;I"::UDPSocket sockets;T;I"	void;To;;I"Receive UDP/IP packets from the given *sockets*. For each packet received, the
block is called.

The block receives *msg* and *msg_src*. *msg* is a string which is the payload
of the received packet. *msg_src* is a Socket::UDPSource object which is used
for reply.

Socket.udp_server_loop can be implemented using this method as follows.

    udp_server_sockets(host, port) {|sockets|
      loop {
        readable, _, _ = IO.select(sockets)
        udp_server_recv(readable) {|msg, msg_src| ... }
      }
    }

;T;0;;;I"udp_server_recv;F;I"Socket;T;[o;;I"!::Array[::UDPSocket] sockets;T;I"	void;To;;I"*Creates UDP/IP sockets for a UDP server.

If no block given, it returns an array of sockets.

If a block is given, the block is called with the sockets. The value of the
block is returned. The sockets are closed when this method returns.

If *port* is zero, some port is chosen. But the chosen port is used for the
all sockets.

    # UDP/IP echo server
    Socket.udp_server_sockets(0) {|sockets|
      p sockets.first.local_address.ip_port     #=> 32963
      Socket.udp_server_loop_on(sockets) {|msg, msg_src|
        msg_src.reply msg
      }
    }

;T;0;;;I"udp_server_sockets;F;I"Socket;T;[o;;I"#?::String host, ::Integer port;T;I"	void;To;;I"°creates a new socket connected to path using UNIX socket socket.

If a block is given, the block is called with the socket. The value of the
block is returned. The socket is closed when this method returns.

If no block is given, the socket is returned.

    # talk to /tmp/sock socket.
    Socket.unix("/tmp/sock") {|sock|
      t = Thread.new { IO.copy_stream(sock, STDOUT) }
      IO.copy_stream(STDIN, sock)
      t.join
    }

;T;0;;;I"	unix;F;I"Socket;T;[o;;I"::String path;T;I"UNIXSocket;To;;I"::String path;T;I"	void;To;;I"bcreates a UNIX socket server on *path*. It calls the block for each socket
accepted.

If *host* is specified, it is used with *port* to determine the server ports.

The socket is **not** closed when the block returns. So application should
close it.

This method deletes the socket file pointed by *path* at first if the file is
a socket file and it is owned by the user of the application. This is safe
only if the directory of *path* is not changed by a malicious user. So don't
use /tmp/malicious-users-directory/socket. Note that /tmp/socket and
/tmp/your-private-directory/socket is safe assuming that /tmp has sticky bit.

    # Sequential echo server.
    # It services only one client at a time.
    Socket.unix_server_loop("/tmp/sock") {|sock, client_addrinfo|
      begin
        IO.copy_stream(sock, sock)
      ensure
        sock.close
      end
    }

;T;0;;;I"unix_server_loop;F;I"Socket;T;[o;;I"::String path;T;I"	void;To;;I"Ncreates a UNIX server socket on *path*

If no block given, it returns a listening socket.

If a block is given, it is called with the socket and the block value is
returned. When the block exits, the socket is closed and the socket file is
removed.

    socket = Socket.unix_server_socket("/tmp/s")
    p socket                  #=> #<Socket:fd 3>
    p socket.local_address    #=> #<Addrinfo: /tmp/s SOCK_STREAM>

    Socket.unix_server_socket("/tmp/sock") {|s|
      p s                     #=> #<Socket:fd 3>
      p s.local_address       #=> # #<Addrinfo: /tmp/sock SOCK_STREAM>
    }

;T;0;;;I"unix_server_socket;F;I"Socket;T;[o;;I"::String path;T;I"Socket;To;;I"::String path;T;I"	void;To;;I"9Unpacks *sockaddr* into port and ip_address.

*sockaddr* should be a string or an addrinfo for AF_INET/AF_INET6.

    sockaddr = Socket.sockaddr_in(80, "127.0.0.1")
    p sockaddr #=> "\x02\x00\x00P\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00"
    p Socket.unpack_sockaddr_in(sockaddr) #=> [80, "127.0.0.1"]

;T;0;;;I"unpack_sockaddr_in;F;I"Socket;T;[o;;I"#::String | ::Addrinfo sockaddr;T;I"[ ::Integer, ::String ];To;;I"ÄUnpacks *sockaddr* into path.

*sockaddr* should be a string or an addrinfo for AF_UNIX.

    sockaddr = Socket.sockaddr_un("/tmp/sock")
    p Socket.unpack_sockaddr_un(sockaddr) #=> "/tmp/sock"

;T;0;;;I"unpack_sockaddr_un;F;I"Socket;T;[o;;I"::String path;T;I"String;To;;I"Accepts a next connection. Returns a new Socket object and Addrinfo object.

    serv = Socket.new(:INET, :STREAM, 0)
    serv.listen(5)
    c = Socket.new(:INET, :STREAM, 0)
    c.connect(serv.connect_address)
    p serv.accept #=> [#<Socket:fd 6>, #<Addrinfo: 127.0.0.1:48555 TCP>]

;T;0;;;I"accept;F;I"Socket;T;[o;;I" ;F;I"[ ::Socket, ::Addrinfo ];To;;I"þAccepts an incoming connection using accept(2) after O_NONBLOCK is set for the
underlying file descriptor. It returns an array containing the accepted socket
for the incoming connection, *client_socket*, and an Addrinfo,
*client_addrinfo*.

### Example
    # In one script, start this first
    require 'socket'
    include Socket::Constants
    socket = Socket.new(AF_INET, SOCK_STREAM, 0)
    sockaddr = Socket.sockaddr_in(2200, 'localhost')
    socket.bind(sockaddr)
    socket.listen(5)
    begin # emulate blocking accept
      client_socket, client_addrinfo = socket.accept_nonblock
    rescue IO::WaitReadable, Errno::EINTR
      IO.select([socket])
      retry
    end
    puts "The client said, '#{client_socket.readline.chomp}'"
    client_socket.puts "Hello from script one!"
    socket.close

    # In another script, start this second
    require 'socket'
    include Socket::Constants
    socket = Socket.new(AF_INET, SOCK_STREAM, 0)
    sockaddr = Socket.sockaddr_in(2200, 'localhost')
    socket.connect(sockaddr)
    socket.puts "Hello from script 2."
    puts "The server said, '#{socket.readline.chomp}'"
    socket.close

Refer to Socket#accept for the exceptions that may be thrown if the call to
*accept_nonblock* fails.

Socket#accept_nonblock may raise any error corresponding to accept(2) failure,
including Errno::EWOULDBLOCK.

If the exception is Errno::EWOULDBLOCK, Errno::EAGAIN, Errno::ECONNABORTED or
Errno::EPROTO, it is extended by IO::WaitReadable. So IO::WaitReadable can be
used to rescue the exceptions for retrying accept_nonblock.

By specifying a keyword argument *exception* to `false`, you can indicate that
accept_nonblock should not raise an IO::WaitReadable exception, but return the
symbol `:wait_readable` instead.

### See
*   Socket#accept

;T;0;;;I"accept_nonblock;F;I"Socket;T;[o;;I"?exception: ::boolish;T;I".[ ::Socket, ::Addrinfo ] | :wait_readable;To;;I"Binds to the given local address.

### Parameter
*   `local_sockaddr` - the `struct` sockaddr contained in a string or an
    Addrinfo object


### Example
    require 'socket'

    # use Addrinfo
    socket = Socket.new(:INET, :STREAM, 0)
    socket.bind(Addrinfo.tcp("127.0.0.1", 2222))
    p socket.local_address #=> #<Addrinfo: 127.0.0.1:2222 TCP>

    # use struct sockaddr
    include Socket::Constants
    socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
    sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
    socket.bind( sockaddr )

### Unix-based Exceptions
On unix-based based systems the following system exceptions may be raised if
the call to *bind* fails:
*   Errno::EACCES - the specified *sockaddr* is protected and the current user
    does not have permission to bind to it
*   Errno::EADDRINUSE - the specified *sockaddr* is already in use
*   Errno::EADDRNOTAVAIL - the specified *sockaddr* is not available from the
    local machine
*   Errno::EAFNOSUPPORT - the specified *sockaddr* is not a valid address for
    the family of the calling `socket`
*   Errno::EBADF - the *sockaddr* specified is not a valid file descriptor
*   Errno::EFAULT - the *sockaddr* argument cannot be accessed
*   Errno::EINVAL - the `socket` is already bound to an address, and the
    protocol does not support binding to the new *sockaddr* or the `socket`
    has been shut down.
*   Errno::EINVAL - the address length is not a valid length for the address
    family
*   Errno::ENAMETOOLONG - the pathname resolved had a length which exceeded
    PATH_MAX
*   Errno::ENOBUFS - no buffer space is available
*   Errno::ENOSR - there were insufficient STREAMS resources available to
    complete the operation
*   Errno::ENOTSOCK - the `socket` does not refer to a socket
*   Errno::EOPNOTSUPP - the socket type of the `socket` does not support
    binding to an address


On unix-based based systems if the address family of the calling `socket` is
Socket::AF_UNIX the follow exceptions may be raised if the call to *bind*
fails:
*   Errno::EACCES - search permission is denied for a component of the prefix
    path or write access to the `socket` is denied
*   Errno::EDESTADDRREQ - the *sockaddr* argument is a null pointer
*   Errno::EISDIR - same as Errno::EDESTADDRREQ
*   Errno::EIO - an i/o error occurred
*   Errno::ELOOP - too many symbolic links were encountered in translating the
    pathname in *sockaddr*
*   Errno::ENAMETOOLLONG - a component of a pathname exceeded NAME_MAX
    characters, or an entire pathname exceeded PATH_MAX characters
*   Errno::ENOENT - a component of the pathname does not name an existing file
    or the pathname is an empty string
*   Errno::ENOTDIR - a component of the path prefix of the pathname in
    *sockaddr* is not a directory
*   Errno::EROFS - the name would reside on a read only filesystem


### Windows Exceptions
On Windows systems the following system exceptions may be raised if the call
to *bind* fails:
*   Errno::ENETDOWN-- the network is down
*   Errno::EACCES - the attempt to connect the datagram socket to the
    broadcast address failed
*   Errno::EADDRINUSE - the socket's local address is already in use
*   Errno::EADDRNOTAVAIL - the specified address is not a valid address for
    this computer
*   Errno::EFAULT - the socket's internal address or address length parameter
    is too small or is not a valid part of the user space addressed
*   Errno::EINVAL - the `socket` is already bound to an address
*   Errno::ENOBUFS - no buffer space is available
*   Errno::ENOTSOCK - the `socket` argument does not refer to a socket


### See
*   bind manual pages on unix-based systems
*   bind function in Microsoft's Winsock functions reference

;T;0;;;I"	bind;F;I"Socket;T;[o;;I")::String | ::Addrinfo local_sockaddr;T;I"	void;To;;I"BRequests a connection to be made on the given `remote_sockaddr`. Returns 0 if
successful, otherwise an exception is raised.

### Parameter
*   `remote_sockaddr` - the `struct` sockaddr contained in a string or
    Addrinfo object


### Example:
    # Pull down Google's web page
    require 'socket'
    include Socket::Constants
    socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
    sockaddr = Socket.pack_sockaddr_in( 80, 'www.google.com' )
    socket.connect( sockaddr )
    socket.write( "GET / HTTP/1.0\r\n\r\n" )
    results = socket.read

### Unix-based Exceptions
On unix-based systems the following system exceptions may be raised if the
call to *connect* fails:
*   Errno::EACCES - search permission is denied for a component of the prefix
    path or write access to the `socket` is denied
*   Errno::EADDRINUSE - the *sockaddr* is already in use
*   Errno::EADDRNOTAVAIL - the specified *sockaddr* is not available from the
    local machine
*   Errno::EAFNOSUPPORT - the specified *sockaddr* is not a valid address for
    the address family of the specified `socket`
*   Errno::EALREADY - a connection is already in progress for the specified
    socket
*   Errno::EBADF - the `socket` is not a valid file descriptor
*   Errno::ECONNREFUSED - the target *sockaddr* was not listening for
    connections refused the connection request
*   Errno::ECONNRESET - the remote host reset the connection request
*   Errno::EFAULT - the *sockaddr* cannot be accessed
*   Errno::EHOSTUNREACH - the destination host cannot be reached (probably
    because the host is down or a remote router cannot reach it)
*   Errno::EINPROGRESS - the O_NONBLOCK is set for the `socket` and the
    connection cannot be immediately established; the connection will be
    established asynchronously
*   Errno::EINTR - the attempt to establish the connection was interrupted by
    delivery of a signal that was caught; the connection will be established
    asynchronously
*   Errno::EISCONN - the specified `socket` is already connected
*   Errno::EINVAL - the address length used for the *sockaddr* is not a valid
    length for the address family or there is an invalid family in *sockaddr*
*   Errno::ENAMETOOLONG - the pathname resolved had a length which exceeded
    PATH_MAX
*   Errno::ENETDOWN - the local interface used to reach the destination is
    down
*   Errno::ENETUNREACH - no route to the network is present
*   Errno::ENOBUFS - no buffer space is available
*   Errno::ENOSR - there were insufficient STREAMS resources available to
    complete the operation
*   Errno::ENOTSOCK - the `socket` argument does not refer to a socket
*   Errno::EOPNOTSUPP - the calling `socket` is listening and cannot be
    connected
*   Errno::EPROTOTYPE - the *sockaddr* has a different type than the socket
    bound to the specified peer address
*   Errno::ETIMEDOUT - the attempt to connect timed out before a connection
    was made.


On unix-based systems if the address family of the calling `socket` is AF_UNIX
the follow exceptions may be raised if the call to *connect* fails:
*   Errno::EIO - an i/o error occurred while reading from or writing to the
    file system
*   Errno::ELOOP - too many symbolic links were encountered in translating the
    pathname in *sockaddr*
*   Errno::ENAMETOOLLONG - a component of a pathname exceeded NAME_MAX
    characters, or an entire pathname exceeded PATH_MAX characters
*   Errno::ENOENT - a component of the pathname does not name an existing file
    or the pathname is an empty string
*   Errno::ENOTDIR - a component of the path prefix of the pathname in
    *sockaddr* is not a directory


### Windows Exceptions
On Windows systems the following system exceptions may be raised if the call
to *connect* fails:
*   Errno::ENETDOWN - the network is down
*   Errno::EADDRINUSE - the socket's local address is already in use
*   Errno::EINTR - the socket was cancelled
*   Errno::EINPROGRESS - a blocking socket is in progress or the service
    provider is still processing a callback function. Or a nonblocking connect
    call is in progress on the `socket`.
*   Errno::EALREADY - see Errno::EINVAL
*   Errno::EADDRNOTAVAIL - the remote address is not a valid address, such as
    ADDR_ANY TODO check ADDRANY TO INADDR_ANY
*   Errno::EAFNOSUPPORT - addresses in the specified family cannot be used
    with with this `socket`
*   Errno::ECONNREFUSED - the target *sockaddr* was not listening for
    connections refused the connection request
*   Errno::EFAULT - the socket's internal address or address length parameter
    is too small or is not a valid part of the user space address
*   Errno::EINVAL - the `socket` is a listening socket
*   Errno::EISCONN - the `socket` is already connected
*   Errno::ENETUNREACH - the network cannot be reached from this host at this
    time
*   Errno::EHOSTUNREACH - no route to the network is present
*   Errno::ENOBUFS - no buffer space is available
*   Errno::ENOTSOCK - the `socket` argument does not refer to a socket
*   Errno::ETIMEDOUT - the attempt to connect timed out before a connection
    was made.
*   Errno::EWOULDBLOCK - the socket is marked as nonblocking and the
    connection cannot be completed immediately
*   Errno::EACCES - the attempt to connect the datagram socket to the
    broadcast address failed


### See
*   connect manual pages on unix-based systems
*   connect function in Microsoft's Winsock functions reference

;T;0;;;I"connect;F;I"Socket;T;[o;;I"*::String | ::Addrinfo remote_sockaddr;T;I"Integer;To;;I"¶Requests a connection to be made on the given `remote_sockaddr` after
O_NONBLOCK is set for the underlying file descriptor. Returns 0 if successful,
otherwise an exception is raised.

### Parameter
    # +remote_sockaddr+ - the +struct+ sockaddr contained in a string or Addrinfo object

### Example:
    # Pull down Google's web page
    require 'socket'
    include Socket::Constants
    socket = Socket.new(AF_INET, SOCK_STREAM, 0)
    sockaddr = Socket.sockaddr_in(80, 'www.google.com')
    begin # emulate blocking connect
      socket.connect_nonblock(sockaddr)
    rescue IO::WaitWritable
      IO.select(nil, [socket]) # wait 3-way handshake completion
      begin
        socket.connect_nonblock(sockaddr) # check connection failure
      rescue Errno::EISCONN
      end
    end
    socket.write("GET / HTTP/1.0\r\n\r\n")
    results = socket.read

Refer to Socket#connect for the exceptions that may be thrown if the call to
*connect_nonblock* fails.

Socket#connect_nonblock may raise any error corresponding to connect(2)
failure, including Errno::EINPROGRESS.

If the exception is Errno::EINPROGRESS, it is extended by IO::WaitWritable. So
IO::WaitWritable can be used to rescue the exceptions for retrying
connect_nonblock.

By specifying a keyword argument *exception* to `false`, you can indicate that
connect_nonblock should not raise an IO::WaitWritable exception, but return
the symbol `:wait_writable` instead.

### See
    # Socket#connect

;T;0;;;I"connect_nonblock;F;I"Socket;T;[o;;I"&untyped addr, ?exception: untyped;T;I"Integer | :wait_writable;To;;I"Henable the socket option IPV6_V6ONLY if IPV6_V6ONLY is available.

;T;0;;;I"ipv6only!;F;I"Socket;T;[o;;I" ;F;I"	void;To;;I"µListens for connections, using the specified `int` as the backlog. A call to
*listen* only applies if the `socket` is of type SOCK_STREAM or
SOCK_SEQPACKET.

### Parameter
*   `backlog` - the maximum length of the queue for pending connections.


### Example 1
    require 'socket'
    include Socket::Constants
    socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
    sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
    socket.bind( sockaddr )
    socket.listen( 5 )

### Example 2 (listening on an arbitrary port, unix-based systems only):
    require 'socket'
    include Socket::Constants
    socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
    socket.listen( 1 )

### Unix-based Exceptions
On unix based systems the above will work because a new `sockaddr` struct is
created on the address ADDR_ANY, for an arbitrary port number as handed off by
the kernel. It will not work on Windows, because Windows requires that the
`socket` is bound by calling *bind* before it can *listen*.

If the *backlog* amount exceeds the implementation-dependent maximum queue
length, the implementation's maximum queue length will be used.

On unix-based based systems the following system exceptions may be raised if
the call to *listen* fails:
*   Errno::EBADF - the *socket* argument is not a valid file descriptor
*   Errno::EDESTADDRREQ - the *socket* is not bound to a local address, and
    the protocol does not support listening on an unbound socket
*   Errno::EINVAL - the *socket* is already connected
*   Errno::ENOTSOCK - the *socket* argument does not refer to a socket
*   Errno::EOPNOTSUPP - the *socket* protocol does not support listen
*   Errno::EACCES - the calling process does not have appropriate privileges
*   Errno::EINVAL - the *socket* has been shut down
*   Errno::ENOBUFS - insufficient resources are available in the system to
    complete the call


### Windows Exceptions
On Windows systems the following system exceptions may be raised if the call
to *listen* fails:
*   Errno::ENETDOWN - the network is down
*   Errno::EADDRINUSE - the socket's local address is already in use. This
    usually occurs during the execution of *bind* but could be delayed if the
    call to *bind* was to a partially wildcard address (involving ADDR_ANY)
    and if a specific address needs to be committed at the time of the call to
    *listen*
*   Errno::EINPROGRESS - a Windows Sockets 1.1 call is in progress or the
    service provider is still processing a callback function
*   Errno::EINVAL - the `socket` has not been bound with a call to *bind*.
*   Errno::EISCONN - the `socket` is already connected
*   Errno::EMFILE - no more socket descriptors are available
*   Errno::ENOBUFS - no buffer space is available
*   Errno::ENOTSOC - `socket` is not a socket
*   Errno::EOPNOTSUPP - the referenced `socket` is not a type that supports
    the *listen* method


### See
*   listen manual pages on unix-based systems
*   listen function in Microsoft's Winsock functions reference

;T;0;;;I"listen;F;I"Socket;T;[o;;I"::Integer backlog_len;T;I"	void;To;;I"áReceives up to *maxlen* bytes from `socket`. *flags* is zero or more of the
`MSG_` options. The first element of the results, *mesg*, is the data
received. The second element, *sender_addrinfo*, contains protocol-specific
address information of the sender.

### Parameters
*   `maxlen` - the maximum number of bytes to receive from the socket
*   `flags` - zero or more of the `MSG_` options


### Example
    # In one file, start this first
    require 'socket'
    include Socket::Constants
    socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
    sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
    socket.bind( sockaddr )
    socket.listen( 5 )
    client, client_addrinfo = socket.accept
    data = client.recvfrom( 20 )[0].chomp
    puts "I only received 20 bytes '#{data}'"
    sleep 1
    socket.close

    # In another file, start this second
    require 'socket'
    include Socket::Constants
    socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
    sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
    socket.connect( sockaddr )
    socket.puts "Watch this get cut short!"
    socket.close

### Unix-based Exceptions
On unix-based based systems the following system exceptions may be raised if
the call to *recvfrom* fails:
*   Errno::EAGAIN - the `socket` file descriptor is marked as O_NONBLOCK and
    no data is waiting to be received; or MSG_OOB is set and no out-of-band
    data is available and either the `socket` file descriptor is marked as
    O_NONBLOCK or the `socket` does not support blocking to wait for
    out-of-band-data
*   Errno::EWOULDBLOCK - see Errno::EAGAIN
*   Errno::EBADF - the `socket` is not a valid file descriptor
*   Errno::ECONNRESET - a connection was forcibly closed by a peer
*   Errno::EFAULT - the socket's internal buffer, address or address length
    cannot be accessed or written
*   Errno::EINTR - a signal interrupted *recvfrom* before any data was
    available
*   Errno::EINVAL - the MSG_OOB flag is set and no out-of-band data is
    available
*   Errno::EIO - an i/o error occurred while reading from or writing to the
    filesystem
*   Errno::ENOBUFS - insufficient resources were available in the system to
    perform the operation
*   Errno::ENOMEM - insufficient memory was available to fulfill the request
*   Errno::ENOSR - there were insufficient STREAMS resources available to
    complete the operation
*   Errno::ENOTCONN - a receive is attempted on a connection-mode socket that
    is not connected
*   Errno::ENOTSOCK - the `socket` does not refer to a socket
*   Errno::EOPNOTSUPP - the specified flags are not supported for this socket
    type
*   Errno::ETIMEDOUT - the connection timed out during connection
    establishment or due to a transmission timeout on an active connection


### Windows Exceptions
On Windows systems the following system exceptions may be raised if the call
to *recvfrom* fails:
*   Errno::ENETDOWN - the network is down
*   Errno::EFAULT - the internal buffer and from parameters on `socket` are
    not part of the user address space, or the internal fromlen parameter is
    too small to accommodate the peer address
*   Errno::EINTR - the (blocking) call was cancelled by an internal call to
    the WinSock function WSACancelBlockingCall
*   Errno::EINPROGRESS - a blocking Windows Sockets 1.1 call is in progress or
    the service provider is still processing a callback function
*   Errno::EINVAL - `socket` has not been bound with a call to *bind*, or an
    unknown flag was specified, or MSG_OOB was specified for a socket with
    SO_OOBINLINE enabled, or (for byte stream-style sockets only) the internal
    len parameter on `socket` was zero or negative
*   Errno::EISCONN - `socket` is already connected. The call to *recvfrom* is
    not permitted with a connected socket on a socket that is connection
    oriented or connectionless.
*   Errno::ENETRESET - the connection has been broken due to the keep-alive
    activity detecting a failure while the operation was in progress.
*   Errno::EOPNOTSUPP - MSG_OOB was specified, but `socket` is not
    stream-style such as type SOCK_STREAM. OOB data is not supported in the
    communication domain associated with `socket`, or `socket` is
    unidirectional and supports only send operations
*   Errno::ESHUTDOWN - `socket` has been shutdown. It is not possible to call
    *recvfrom* on a socket after *shutdown* has been invoked.
*   Errno::EWOULDBLOCK - `socket` is marked as nonblocking and a  call to
    *recvfrom* would block.
*   Errno::EMSGSIZE - the message was too large to fit into the specified
    buffer and was truncated.
*   Errno::ETIMEDOUT - the connection has been dropped, because of a network
    failure or because the system on the other end went down without notice
*   Errno::ECONNRESET - the virtual circuit was reset by the remote side
    executing a hard or abortive close. The application should close the
    socket; it is no longer usable. On a UDP-datagram socket this error
    indicates a previous send operation resulted in an ICMP Port Unreachable
    message.

;T;0;;;I"recvfrom;F;I"Socket;T;[o;;I"'::Integer maxlen, ?::Integer flags;T;I"[ ::String, ::Addrinfo ];To;;I"‹Receives up to *maxlen* bytes from `socket` using recvfrom(2) after O_NONBLOCK
is set for the underlying file descriptor. *flags* is zero or more of the
`MSG_` options. The first element of the results, *mesg*, is the data
received. The second element, *sender_addrinfo*, contains protocol-specific
address information of the sender.

When recvfrom(2) returns 0, Socket#recvfrom_nonblock returns an empty string
as data. The meaning depends on the socket: EOF on TCP, empty packet on UDP,
etc.

### Parameters
*   `maxlen` - the maximum number of bytes to receive from the socket
*   `flags` - zero or more of the `MSG_` options
*   `outbuf` - destination String buffer
*   `opts` - keyword hash, supporting `exception: false`


### Example
    # In one file, start this first
    require 'socket'
    include Socket::Constants
    socket = Socket.new(AF_INET, SOCK_STREAM, 0)
    sockaddr = Socket.sockaddr_in(2200, 'localhost')
    socket.bind(sockaddr)
    socket.listen(5)
    client, client_addrinfo = socket.accept
    begin # emulate blocking recvfrom
      pair = client.recvfrom_nonblock(20)
    rescue IO::WaitReadable
      IO.select([client])
      retry
    end
    data = pair[0].chomp
    puts "I only received 20 bytes '#{data}'"
    sleep 1
    socket.close

    # In another file, start this second
    require 'socket'
    include Socket::Constants
    socket = Socket.new(AF_INET, SOCK_STREAM, 0)
    sockaddr = Socket.sockaddr_in(2200, 'localhost')
    socket.connect(sockaddr)
    socket.puts "Watch this get cut short!"
    socket.close

Refer to Socket#recvfrom for the exceptions that may be thrown if the call to
*recvfrom_nonblock* fails.

Socket#recvfrom_nonblock may raise any error corresponding to recvfrom(2)
failure, including Errno::EWOULDBLOCK.

If the exception is Errno::EWOULDBLOCK or Errno::EAGAIN, it is extended by
IO::WaitReadable. So IO::WaitReadable can be used to rescue the exceptions for
retrying recvfrom_nonblock.

By specifying a keyword argument *exception* to `false`, you can indicate that
recvfrom_nonblock should not raise an IO::WaitReadable exception, but return
the symbol `:wait_readable` instead.

### See
*   Socket#recvfrom

;T;0;;;I"recvfrom_nonblock;F;I"Socket;T;[o;;I"O::Integer maxlen, ?::Integer flags, ?untyped outbuf, ?exception: ::boolish;T;I".[ ::String, ::Addrinfo ] | :wait_readable;To;;I"pAccepts an incoming connection returning an array containing the (integer)
file descriptor for the incoming connection, *client_socket_fd*, and an
Addrinfo, *client_addrinfo*.

### Example
    # In one script, start this first
    require 'socket'
    include Socket::Constants
    socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
    sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
    socket.bind( sockaddr )
    socket.listen( 5 )
    client_fd, client_addrinfo = socket.sysaccept
    client_socket = Socket.for_fd( client_fd )
    puts "The client said, '#{client_socket.readline.chomp}'"
    client_socket.puts "Hello from script one!"
    socket.close

    # In another script, start this second
    require 'socket'
    include Socket::Constants
    socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
    sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
    socket.connect( sockaddr )
    socket.puts "Hello from script 2."
    puts "The server said, '#{socket.readline.chomp}'"
    socket.close

Refer to Socket#accept for the exceptions that may be thrown if the call to
*sysaccept* fails.

### See
*   Socket#accept

;T;0;;;I"sysaccept;F;I"Socket;T;[o;;I" ;F;I"[ ::Integer, ::Addrinfo ];To;;0;0;;;I"__accept_nonblock;F;I"Socket;T;[o;;I"untyped;T;I"untyped;To;;0;0;;;I"__connect_nonblock;F;I"Socket;T;[o;;I"untyped, untyped;T;I"untyped;To;;0;0;;;I"__recvfrom_nonblock;F;I"Socket;T;[o;;I"'untyped, untyped, untyped, untyped;T;I"untyped;To;;I"òCreates a new socket object.

*domain* should be a communications domain such as: :INET, :INET6, :UNIX, etc.

*socktype* should be a socket type such as: :STREAM, :DGRAM, :RAW, etc.

*protocol* is optional and should be a protocol defined in the domain. If
protocol is not given, 0 is used internally.

    Socket.new(:INET, :STREAM) # TCP socket
    Socket.new(:INET, :DGRAM)  # UDP socket
    Socket.new(:UNIX, :STREAM) # UNIX stream socket
    Socket.new(:UNIX, :DGRAM)  # UNIX datagram socket

;T;0;;;I"initialize;F;I"Socket;T;[o;;I"<::Symbol domain, ::Symbol socktype, ?::Integer protocol;T;I"untyped;To; ;I"CSocket::Ifaddr represents a result of getifaddrs() function.

;T;0;	I"Socket::Ifaddr;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"`Returns the address of *ifaddr*. nil is returned if address is not available
in *ifaddr*.

;T;0;;;I"	addr;F;I"Socket::Ifaddr;T;[o;;I" ;F;I"Addrinfo?;To;;I"jReturns the broadcast address of *ifaddr*. nil is returned if the flags
doesn't have IFF_BROADCAST.

;T;0;;;I"broadaddr;F;I"Socket::Ifaddr;T;[o;;I" ;F;I"Addrinfo?;To;;I"nReturns the destination address of *ifaddr*. nil is returned if the flags
doesn't have IFF_POINTOPOINT.

;T;0;;;I"dstaddr;F;I"Socket::Ifaddr;T;[o;;I" ;F;I"Addrinfo?;To;;I"%Returns the flags of *ifaddr*.

;T;0;;;I"
flags;F;I"Socket::Ifaddr;T;[o;;I" ;F;I"Integer;To;;I"/Returns the interface index of *ifaddr*.

;T;0;;;I"ifindex;F;I"Socket::Ifaddr;T;[o;;I" ;F;I"Integer;To;;I"5Returns a string to show contents of *ifaddr*.

;T;0;;;I"inspect;F;I"Socket::Ifaddr;T;[o;;I" ;F;I"String;To;;I".Returns the interface name of *ifaddr*.

;T;0;;;I"	name;F;I"Socket::Ifaddr;T;[o;;I" ;F;I"String;To;;I"hReturns the netmask address of *ifaddr*. nil is returned if netmask is not
available in *ifaddr*.

;T;0;;;I"netmask;F;I"Socket::Ifaddr;T;[o;;I" ;F;I"Addrinfo?;To; ;I"AUDP/IP address information used by Socket.udp_server_loop.

;T;0;	I"Socket::UDPSource;T;
[ ;[ ;0;[ ;[ ;0;0o;;0;0;;;I"inspect;F;I"Socket::UDPSource;T;[o;;I" ;F;I"String;To;;I"Local address

;T;0;;;I"local_address;F;I"Socket::UDPSource;T;[o;;I" ;F;I"Addrinfo;To;;I"Address of the source

;T;0;;;I"remote_address;F;I"Socket::UDPSource;T;[o;;I" ;F;I"Addrinfo;To;;I"+Sends the String `msg` to the source

;T;0;;;I"
reply;F;I"Socket::UDPSource;T;[o;;I"::String msg;T;I"	void;To;;I"`remote_address` is an Addrinfo object.

`local_address` is an Addrinfo object.

`reply_proc` is a Proc used to send reply back to the source.

;T;0;;;I"initialize;F;I"Socket::UDPSource;T;[o;;I"8::Addrinfo remote_address, ::Addrinfo local_address;T;I"	void;To; ;I"ËSocket::AncillaryData represents the ancillary data (control information) used
by sendmsg and recvmsg system call.  It contains socket #family, control
message (cmsg) #level, cmsg #type and cmsg #data.

;T;0;	I"Socket::AncillaryData;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"Creates a new Socket::AncillaryData object which contains a int as data.

The size and endian is dependent on the host.

    require 'socket'

    p Socket::AncillaryData.int(:UNIX, :SOCKET, :RIGHTS, STDERR.fileno)
    #=> #<Socket::AncillaryData: UNIX SOCKET RIGHTS 2>

;T;0;;;I"int;F;I"Socket::AncillaryData;T;[o;;I"+::Symbol, ::Symbol, ::Symbol, ::Symbol;T;I"instance;To;;I"‡Returns new ancillary data for IP_PKTINFO.

If spec_dst is not given, addr is used.

IP_PKTINFO is not standard.

Supported platform: GNU/Linux

    addr = Addrinfo.ip("127.0.0.1")
    ifindex = 0
    spec_dst = Addrinfo.ip("127.0.0.1")
    p Socket::AncillaryData.ip_pktinfo(addr, ifindex, spec_dst)
    #=> #<Socket::AncillaryData: INET IP PKTINFO 127.0.0.1 ifindex:0 spec_dst:127.0.0.1>

;T;0;;;I"ip_pktinfo;F;I"Socket::AncillaryData;T;[o;;I"=::Addrinfo addr, ::Integer ifindex, ?::Addrinfo spec_dst;T;I"instance;To;;I"þReturns new ancillary data for IPV6_PKTINFO.

IPV6_PKTINFO is defined by RFC 3542.

    addr = Addrinfo.ip("::1")
    ifindex = 0
    p Socket::AncillaryData.ipv6_pktinfo(addr, ifindex)
    #=> #<Socket::AncillaryData: INET6 IPV6 PKTINFO ::1 ifindex:0>

;T;0;;;I"ipv6_pktinfo;F;I"Socket::AncillaryData;T;[o;;I"'::Addrinfo addr, ::Integer ifindex;T;I"instance;To;;I"½Creates a new Socket::AncillaryData object which contains file descriptors as
data.

    p Socket::AncillaryData.unix_rights(STDERR)
    #=> #<Socket::AncillaryData: UNIX SOCKET RIGHTS 2>

;T;0;;;I"unix_rights;F;I"Socket::AncillaryData;T;[o;;I"::IO fd;T;I"instance;To;;I"_tests the level and type of *ancillarydata*.

    ancdata = Socket::AncillaryData.new(:INET6, :IPV6, :PKTINFO, "")
    ancdata.cmsg_is?(Socket::IPPROTO_IPV6, Socket::IPV6_PKTINFO) #=> true
    ancdata.cmsg_is?(:IPV6, :PKTINFO)       #=> true
    ancdata.cmsg_is?(:IP, :PKTINFO)         #=> false
    ancdata.cmsg_is?(:SOCKET, :RIGHTS)      #=> false

;T;0;;;I"cmsg_is?;F;I"Socket::AncillaryData;T;[o;;I".::Integer level, ::Integer ancillary_type;T;I"	bool;To;;I"wreturns the cmsg data as a string.

    p Socket::AncillaryData.new(:INET6, :IPV6, :PKTINFO, "").data
    #=> ""

;T;0;;;I"	data;F;I"Socket::AncillaryData;T;[o;;I" ;F;I"String;To;;I"returns the socket family as an integer.

    p Socket::AncillaryData.new(:INET6, :IPV6, :PKTINFO, "").family
    #=> 10

;T;0;;;I"family;F;I"Socket::AncillaryData;T;[o;;I" ;F;I"Integer;To;;I"Æreturns a string which shows ancillarydata in human-readable form.

    p Socket::AncillaryData.new(:INET6, :IPV6, :PKTINFO, "").inspect
    #=> "#<Socket::AncillaryData: INET6 IPV6 PKTINFO \"\">"

;T;0;;;I"inspect;F;I"Socket::AncillaryData;T;[o;;I" ;F;I"String;To;;I"ÈReturns the data in *ancillarydata* as an int.

The size and endian is dependent on the host.

    ancdata = Socket::AncillaryData.int(:UNIX, :SOCKET, :RIGHTS, STDERR.fileno)
    p ancdata.int #=> 2

;T;0;;;I"int;F;I"Socket::AncillaryData;T;[o;;I" ;F;I"Integer;To;;I"}Extracts addr, ifindex and spec_dst from IP_PKTINFO ancillary data.

IP_PKTINFO is not standard.

Supported platform: GNU/Linux

    addr = Addrinfo.ip("127.0.0.1")
    ifindex = 0
    spec_dest = Addrinfo.ip("127.0.0.1")
    ancdata = Socket::AncillaryData.ip_pktinfo(addr, ifindex, spec_dest)
    p ancdata.ip_pktinfo
    #=> [#<Addrinfo: 127.0.0.1>, 0, #<Addrinfo: 127.0.0.1>]

;T;0;;;I"ip_pktinfo;F;I"Socket::AncillaryData;T;[o;;I" ;F;I"*[ ::Addrinfo, ::Integer, ::Addrinfo ];To;;I"Extracts addr and ifindex from IPV6_PKTINFO ancillary data.

IPV6_PKTINFO is defined by RFC 3542.

    addr = Addrinfo.ip("::1")
    ifindex = 0
    ancdata = Socket::AncillaryData.ipv6_pktinfo(addr, ifindex)
    p ancdata.ipv6_pktinfo #=> [#<Addrinfo: ::1>, 0]

;T;0;;;I"ipv6_pktinfo;F;I"Socket::AncillaryData;T;[o;;I" ;F;I"[ ::Addrinfo, ::Integer ];To;;I"ûExtracts addr from IPV6_PKTINFO ancillary data.

IPV6_PKTINFO is defined by RFC 3542.

    addr = Addrinfo.ip("::1")
    ifindex = 0
    ancdata = Socket::AncillaryData.ipv6_pktinfo(addr, ifindex)
    p ancdata.ipv6_pktinfo_addr #=> #<Addrinfo: ::1>

;T;0;;;I"ipv6_pktinfo_addr;F;I"Socket::AncillaryData;T;[o;;I" ;F;I"Addrinfo;To;;I"òExtracts ifindex from IPV6_PKTINFO ancillary data.

IPV6_PKTINFO is defined by RFC 3542.

    addr = Addrinfo.ip("::1")
    ifindex = 0
    ancdata = Socket::AncillaryData.ipv6_pktinfo(addr, ifindex)
    p ancdata.ipv6_pktinfo_ifindex #=> 0

;T;0;;;I"ipv6_pktinfo_ifindex;F;I"Socket::AncillaryData;T;[o;;I" ;F;I"Integer;To;;I"{returns the cmsg level as an integer.

    p Socket::AncillaryData.new(:INET6, :IPV6, :PKTINFO, "").level
    #=> 41

;T;0;;;I"
level;F;I"Socket::AncillaryData;T;[o;;I" ;F;I"Integer;To;;I"returns the timestamp as a time object.

*ancillarydata* should be one of following type:
*   SOL_SOCKET/SCM_TIMESTAMP (microsecond) GNU/Linux, FreeBSD, NetBSD,
    OpenBSD, Solaris, MacOS X
*   SOL_SOCKET/SCM_TIMESTAMPNS (nanosecond) GNU/Linux
*   SOL_SOCKET/SCM_BINTIME (2**(-64) second) FreeBSD

    Addrinfo.udp("127.0.0.1", 0).bind {|s1|
        Addrinfo.udp("127.0.0.1", 0).bind {|s2|
          s1.setsockopt(:SOCKET, :TIMESTAMP, true)
          s2.send "a", 0, s1.local_address
          ctl = s1.recvmsg.last
          p ctl    #=> #<Socket::AncillaryData: INET SOCKET TIMESTAMP 2009-02-24 17:35:46.775581>
          t = ctl.timestamp
          p t      #=> 2009-02-24 17:35:46 +0900
          p t.usec #=> 775581
          p t.nsec #=> 775581000
        }

    }

;T;0;;;I"timestamp;F;I"Socket::AncillaryData;T;[o;;I" ;F;I"	Time;To;;I"xreturns the cmsg type as an integer.

    p Socket::AncillaryData.new(:INET6, :IPV6, :PKTINFO, "").type
    #=> 2

;T;0;;;I"	type;F;I"Socket::AncillaryData;T;[o;;I" ;F;I"Integer;To;;I"àreturns the array of IO objects for SCM_RIGHTS control message in UNIX domain
socket.

The class of the IO objects in the array is IO or Socket.

The array is attached to *ancillarydata* when it is instantiated. For example,
BasicSocket#recvmsg attach the array when receives a SCM_RIGHTS control
message and :scm_rights=>true option is given.

    # recvmsg needs :scm_rights=>true for unix_rights
    s1, s2 = UNIXSocket.pair
    p s1                                         #=> #<UNIXSocket:fd 3>
    s1.sendmsg "stdin and a socket", 0, nil, Socket::AncillaryData.unix_rights(STDIN, s1)
    _, _, _, ctl = s2.recvmsg(:scm_rights=>true)
    p ctl                                        #=> #<Socket::AncillaryData: UNIX SOCKET RIGHTS 6 7>
    p ctl.unix_rights                            #=> [#<IO:fd 6>, #<Socket:fd 7>]
    p File.identical?(STDIN, ctl.unix_rights[0]) #=> true
    p File.identical?(s1, ctl.unix_rights[1])    #=> true

    # If :scm_rights=>true is not given, unix_rights returns nil
    s1, s2 = UNIXSocket.pair
    s1.sendmsg "stdin and a socket", 0, nil, Socket::AncillaryData.unix_rights(STDIN, s1)
    _, _, _, ctl = s2.recvmsg
    p ctl #=> #<Socket::AncillaryData: UNIX SOCKET RIGHTS 6 7>
    p ctl.unix_rights #=> nil

;T;0;;;I"unix_rights;F;I"Socket::AncillaryData;T;[o;;I" ;F;I"Array[::IO]?;To;;I"#*family* should be an integer, a string or a symbol.
*   Socket::AF_INET, "AF_INET", "INET", :AF_INET, :INET
*   Socket::AF_UNIX, "AF_UNIX", "UNIX", :AF_UNIX, :UNIX
*   etc.


*cmsg_level* should be an integer, a string or a symbol.
*   Socket::SOL_SOCKET, "SOL_SOCKET", "SOCKET", :SOL_SOCKET and :SOCKET
*   Socket::IPPROTO_IP, "IP" and :IP
*   Socket::IPPROTO_IPV6, "IPV6" and :IPV6
*   Socket::IPPROTO_TCP, "TCP" and :TCP
*   etc.


*cmsg_type* should be an integer, a string or a symbol. If a string/symbol is
specified, it is interpreted depend on *cmsg_level*.
*   Socket::SCM_RIGHTS, "SCM_RIGHTS", "RIGHTS", :SCM_RIGHTS, :RIGHTS for
    SOL_SOCKET
*   Socket::IP_RECVTTL, "RECVTTL" and :RECVTTL for IPPROTO_IP
*   Socket::IPV6_PKTINFO, "PKTINFO" and :PKTINFO for IPPROTO_IPV6
*   etc.


*cmsg_data* should be a string.

    p Socket::AncillaryData.new(:INET, :TCP, :NODELAY, "")
    #=> #<Socket::AncillaryData: INET TCP NODELAY "">

    p Socket::AncillaryData.new(:INET6, :IPV6, :PKTINFO, "")
    #=> #<Socket::AncillaryData: INET6 IPV6 PKTINFO "">

;T;0;;;I"initialize;F;I"Socket::AncillaryData;T;[o;;I"‘::Symbol | ::String | ::Integer family, ::Symbol | ::String | ::Integer cmsg_level, ::Symbol | ::String | ::Integer cmsg_data, ::String cmsg_data;T;I"untyped;To; ;I"`TCPServer represents a TCP/IP server socket.

A simple TCP server may look like:

    require 'socket'

    server = TCPServer.new 2000 # Server bind to port 2000
    loop do
      client = server.accept    # Wait for a client to connect
      client.puts "Hello !"
      client.puts "Time is #{Time.now}"
      client.close
    end

A more usable server (serving multiple clients):

    require 'socket'

    server = TCPServer.new 2000
    loop do
      Thread.start(server.accept) do |client|
        client.puts "Hello !"
        client.puts "Time is #{Time.now}"
        client.close
      end
    end

;T;0;	I"TCPServer;T;
[ ;[ ;0;[ ;[ ;0;I"TCPSocket;To;;I"´Accepts an incoming connection. It returns a new TCPSocket object.

    TCPServer.open("127.0.0.1", 14641) {|serv|
      s = serv.accept
      s.puts Time.now
      s.close
    }

;T;0;;;I"accept;F;I"TCPServer;T;[o;;I" ;F;I"TCPSocket;To;;I"OAccepts an incoming connection using accept(2) after O_NONBLOCK is set for the
underlying file descriptor. It returns an accepted TCPSocket for the incoming
connection.

### Example
    require 'socket'
    serv = TCPServer.new(2202)
    begin # emulate blocking accept
      sock = serv.accept_nonblock
    rescue IO::WaitReadable, Errno::EINTR
      IO.select([serv])
      retry
    end
    # sock is an accepted socket.

Refer to Socket#accept for the exceptions that may be thrown if the call to
TCPServer#accept_nonblock fails.

TCPServer#accept_nonblock may raise any error corresponding to accept(2)
failure, including Errno::EWOULDBLOCK.

If the exception is Errno::EWOULDBLOCK, Errno::EAGAIN, Errno::ECONNABORTED,
Errno::EPROTO, it is extended by IO::WaitReadable. So IO::WaitReadable can be
used to rescue the exceptions for retrying accept_nonblock.

By specifying a keyword argument *exception* to `false`, you can indicate that
accept_nonblock should not raise an IO::WaitReadable exception, but return the
symbol `:wait_readable` instead.

### See
*   TCPServer#accept
*   Socket#accept

;T;0;;;I"accept_nonblock;F;I"TCPServer;T;[o;;I"?exception: ::boolish;T;I"TCPSocket | :wait_readable;To;;I"µListens for connections, using the specified `int` as the backlog. A call to
*listen* only applies if the `socket` is of type SOCK_STREAM or
SOCK_SEQPACKET.

### Parameter
*   `backlog` - the maximum length of the queue for pending connections.


### Example 1
    require 'socket'
    include Socket::Constants
    socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
    sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
    socket.bind( sockaddr )
    socket.listen( 5 )

### Example 2 (listening on an arbitrary port, unix-based systems only):
    require 'socket'
    include Socket::Constants
    socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
    socket.listen( 1 )

### Unix-based Exceptions
On unix based systems the above will work because a new `sockaddr` struct is
created on the address ADDR_ANY, for an arbitrary port number as handed off by
the kernel. It will not work on Windows, because Windows requires that the
`socket` is bound by calling *bind* before it can *listen*.

If the *backlog* amount exceeds the implementation-dependent maximum queue
length, the implementation's maximum queue length will be used.

On unix-based based systems the following system exceptions may be raised if
the call to *listen* fails:
*   Errno::EBADF - the *socket* argument is not a valid file descriptor
*   Errno::EDESTADDRREQ - the *socket* is not bound to a local address, and
    the protocol does not support listening on an unbound socket
*   Errno::EINVAL - the *socket* is already connected
*   Errno::ENOTSOCK - the *socket* argument does not refer to a socket
*   Errno::EOPNOTSUPP - the *socket* protocol does not support listen
*   Errno::EACCES - the calling process does not have appropriate privileges
*   Errno::EINVAL - the *socket* has been shut down
*   Errno::ENOBUFS - insufficient resources are available in the system to
    complete the call


### Windows Exceptions
On Windows systems the following system exceptions may be raised if the call
to *listen* fails:
*   Errno::ENETDOWN - the network is down
*   Errno::EADDRINUSE - the socket's local address is already in use. This
    usually occurs during the execution of *bind* but could be delayed if the
    call to *bind* was to a partially wildcard address (involving ADDR_ANY)
    and if a specific address needs to be committed at the time of the call to
    *listen*
*   Errno::EINPROGRESS - a Windows Sockets 1.1 call is in progress or the
    service provider is still processing a callback function
*   Errno::EINVAL - the `socket` has not been bound with a call to *bind*.
*   Errno::EISCONN - the `socket` is already connected
*   Errno::EMFILE - no more socket descriptors are available
*   Errno::ENOBUFS - no buffer space is available
*   Errno::ENOTSOC - `socket` is not a socket
*   Errno::EOPNOTSUPP - the referenced `socket` is not a type that supports
    the *listen* method


### See
*   listen manual pages on unix-based systems
*   listen function in Microsoft's Winsock functions reference

;T;0;;;I"listen;F;I"TCPServer;T;[o;;I"::Integer backlog;T;I"	void;To;;I"ÁReturns a file descriptor of a accepted connection.

    TCPServer.open("127.0.0.1", 28561) {|serv|
      fd = serv.sysaccept
      s = IO.for_fd(fd)
      s.puts Time.now
      s.close
    }

;T;0;;;I"sysaccept;F;I"TCPServer;T;[o;;I" ;F;I"Integer;To;;0;0;;;I"__accept_nonblock;F;I"TCPServer;T;[o;;I"untyped;T;I"untyped;To;;I"§Creates a new server socket bound to *port*.

If *hostname* is given, the socket is bound to it.

    serv = TCPServer.new("127.0.0.1", 28561)
    s = serv.accept
    s.puts Time.now
    s.close

Internally, TCPServer.new calls getaddrinfo() function to obtain addresses. If
getaddrinfo() returns multiple addresses, TCPServer.new tries to create a
server socket for each address and returns first one that is successful.

;T;0;;;I"initialize;F;I"TCPServer;T;[o;;I"#?::String host, ::Integer port;T;I"untyped;To; ;I""TCPSocket represents a TCP/IP client socket.

A simple client may look like:

    require 'socket'

    s = TCPSocket.new 'localhost', 2000

    while line = s.gets # Read lines from socket
      puts line         # and print them
    end

    s.close             # close socket when done

;T;0;	I"TCPSocket;T;
[ ;[ ;0;[ ;[ ;0;I"IPSocket;To;;I"XUse Addrinfo.getaddrinfo instead. This method is deprecated for the following
reasons:

*   The 3rd element of the result is the address family of the first address.
    The address families of the rest of the addresses are not returned.
*   gethostbyname() may take a long time and it may block other threads. (GVL
    cannot be released since gethostbyname() is not thread safe.)
*   This method uses gethostbyname() function already removed from POSIX.


This method lookups host information by *hostname*.

    TCPSocket.gethostbyname("localhost")
    #=> ["localhost", ["hal"], 2, "127.0.0.1"]

;T;0;;;I"gethostbyname;F;I"TCPSocket;T;[o;;I"::String host;T;I"9[ ::String, ::Array[::String], ::Integer, ::String ];To;;I" ;T;0;;;I"initialize;F;I"TCPSocket;T;[o;;I"]::String remote_host, ::Integer remote_port, ?::String local_host, ?::Integer local_port;T;I"untyped;To; ;I",UDPSocket represents a UDP/IP socket.

;T;0;	I"UDPSocket;T;
[ ;[ ;0;[ ;[ ;0;I"IPSocket;To;;I"æBinds *udpsocket* to *host*:*port*.

    u1 = UDPSocket.new
    u1.bind("127.0.0.1", 4913)
    u1.send "message-to-self", 0, "127.0.0.1", 4913
    p u1.recvfrom(10) #=> ["message-to", ["AF_INET", 4913, "localhost", "127.0.0.1"]]

;T;0;;;I"	bind;F;I"UDPSocket;T;[o;;I""::String host, ::Integer port;T;I"	void;To;;I"9Connects *udpsocket* to *host*:*port*.

This makes possible to send without destination address.

    u1 = UDPSocket.new
    u1.bind("127.0.0.1", 4913)
    u2 = UDPSocket.new
    u2.connect("127.0.0.1", 4913)
    u2.send "uuuu", 0
    p u1.recvfrom(10) #=> ["uuuu", ["AF_INET", 33230, "localhost", "127.0.0.1"]]

;T;0;;;I"connect;F;I"UDPSocket;T;[o;;I""::String host, ::Integer port;T;I"	void;To;;I"ÎReceives up to *maxlen* bytes from `udpsocket` using recvfrom(2) after
O_NONBLOCK is set for the underlying file descriptor. *flags* is zero or more
of the `MSG_` options. The first element of the results, *mesg*, is the data
received. The second element, *sender_inet_addr*, is an array to represent the
sender address.

When recvfrom(2) returns 0, Socket#recvfrom_nonblock returns an empty string
as data. It means an empty packet.

### Parameters
*   `maxlen` - the number of bytes to receive from the socket
*   `flags` - zero or more of the `MSG_` options
*   `outbuf` - destination String buffer
*   `options` - keyword hash, supporting `exception: false`


### Example
    require 'socket'
    s1 = UDPSocket.new
    s1.bind("127.0.0.1", 0)
    s2 = UDPSocket.new
    s2.bind("127.0.0.1", 0)
    s2.connect(*s1.addr.values_at(3,1))
    s1.connect(*s2.addr.values_at(3,1))
    s1.send "aaa", 0
    begin # emulate blocking recvfrom
      p s2.recvfrom_nonblock(10)  #=> ["aaa", ["AF_INET", 33302, "localhost.localdomain", "127.0.0.1"]]
    rescue IO::WaitReadable
      IO.select([s2])
      retry
    end

Refer to Socket#recvfrom for the exceptions that may be thrown if the call to
*recvfrom_nonblock* fails.

UDPSocket#recvfrom_nonblock may raise any error corresponding to recvfrom(2)
failure, including Errno::EWOULDBLOCK.

If the exception is Errno::EWOULDBLOCK or Errno::EAGAIN, it is extended by
IO::WaitReadable. So IO::WaitReadable can be used to rescue the exceptions for
retrying recvfrom_nonblock.

By specifying a keyword argument *exception* to `false`, you can indicate that
recvfrom_nonblock should not raise an IO::WaitReadable exception, but return
the symbol `:wait_readable` instead.

### See
*   Socket#recvfrom

;T;0;;;I"recvfrom_nonblock;F;I"UDPSocket;T;[o;;I"L::Integer len, ?::Integer flag, ?::String outbuf, ?exception: ::boolish;T;I">[ ::String, [ ::String, ::Integer, ::String, ::String ] ];To;;I"6Sends *mesg* via *udpsocket*.

*flags* should be a bitwise OR of Socket::MSG_* constants.

    u1 = UDPSocket.new
    u1.bind("127.0.0.1", 4913)

    u2 = UDPSocket.new
    u2.send "hi", 0, "127.0.0.1", 4913

    mesg, addr = u1.recvfrom(10)
    u1.send mesg, 0, addr[3], addr[1]

    p u2.recv(100) #=> "hi"

;T;0;;;I"	send;F;I"UDPSocket;T;[o;;I"D::String msg, ?::Integer flags, ?::String host, ?::Integer port;T;I"Integer;To;;0;0;;;I"__recvfrom_nonblock;F;I"UDPSocket;T;[o;;I"'untyped, untyped, untyped, untyped;T;I"untyped;To;;I"Creates a new UDPSocket object.

*address_family* should be an integer, a string or a symbol: Socket::AF_INET,
"AF_INET", :INET, etc.

    require 'socket'

    UDPSocket.new                   #=> #<UDPSocket:fd 3>
    UDPSocket.new(Socket::AF_INET6) #=> #<UDPSocket:fd 4>

;T;0;;;I"initialize;F;I"UDPSocket;T;[o;;I"?::Integer family;T;I"untyped;To; ;I"@UNIXServer represents a UNIX domain stream server socket.

;T;0;	I"UNIXServer;T;
[ ;[ ;0;[ ;[ ;0;I"UNIXSocket;To;;I"ýAccepts an incoming connection. It returns a new UNIXSocket object.

    UNIXServer.open("/tmp/sock") {|serv|
      UNIXSocket.open("/tmp/sock") {|c|
        s = serv.accept
        s.puts "hi"
        s.close
        p c.read #=> "hi\n"
      }
    }

;T;0;;;I"accept;F;I"UNIXServer;T;[o;;I" ;F;I"UNIXSocket;To;;I"]Accepts an incoming connection using accept(2) after O_NONBLOCK is set for the
underlying file descriptor. It returns an accepted UNIXSocket for the incoming
connection.

### Example
    require 'socket'
    serv = UNIXServer.new("/tmp/sock")
    begin # emulate blocking accept
      sock = serv.accept_nonblock
    rescue IO::WaitReadable, Errno::EINTR
      IO.select([serv])
      retry
    end
    # sock is an accepted socket.

Refer to Socket#accept for the exceptions that may be thrown if the call to
UNIXServer#accept_nonblock fails.

UNIXServer#accept_nonblock may raise any error corresponding to accept(2)
failure, including Errno::EWOULDBLOCK.

If the exception is Errno::EWOULDBLOCK, Errno::EAGAIN, Errno::ECONNABORTED or
Errno::EPROTO, it is extended by IO::WaitReadable. So IO::WaitReadable can be
used to rescue the exceptions for retrying accept_nonblock.

By specifying a keyword argument *exception* to `false`, you can indicate that
accept_nonblock should not raise an IO::WaitReadable exception, but return the
symbol `:wait_readable` instead.

### See
*   UNIXServer#accept
*   Socket#accept

;T;0;;;I"accept_nonblock;F;I"UNIXServer;T;[o;;I"?exception: ::boolish;T;I" UNIXSocket | :wait_readable;To;;I"µListens for connections, using the specified `int` as the backlog. A call to
*listen* only applies if the `socket` is of type SOCK_STREAM or
SOCK_SEQPACKET.

### Parameter
*   `backlog` - the maximum length of the queue for pending connections.


### Example 1
    require 'socket'
    include Socket::Constants
    socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
    sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
    socket.bind( sockaddr )
    socket.listen( 5 )

### Example 2 (listening on an arbitrary port, unix-based systems only):
    require 'socket'
    include Socket::Constants
    socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
    socket.listen( 1 )

### Unix-based Exceptions
On unix based systems the above will work because a new `sockaddr` struct is
created on the address ADDR_ANY, for an arbitrary port number as handed off by
the kernel. It will not work on Windows, because Windows requires that the
`socket` is bound by calling *bind* before it can *listen*.

If the *backlog* amount exceeds the implementation-dependent maximum queue
length, the implementation's maximum queue length will be used.

On unix-based based systems the following system exceptions may be raised if
the call to *listen* fails:
*   Errno::EBADF - the *socket* argument is not a valid file descriptor
*   Errno::EDESTADDRREQ - the *socket* is not bound to a local address, and
    the protocol does not support listening on an unbound socket
*   Errno::EINVAL - the *socket* is already connected
*   Errno::ENOTSOCK - the *socket* argument does not refer to a socket
*   Errno::EOPNOTSUPP - the *socket* protocol does not support listen
*   Errno::EACCES - the calling process does not have appropriate privileges
*   Errno::EINVAL - the *socket* has been shut down
*   Errno::ENOBUFS - insufficient resources are available in the system to
    complete the call


### Windows Exceptions
On Windows systems the following system exceptions may be raised if the call
to *listen* fails:
*   Errno::ENETDOWN - the network is down
*   Errno::EADDRINUSE - the socket's local address is already in use. This
    usually occurs during the execution of *bind* but could be delayed if the
    call to *bind* was to a partially wildcard address (involving ADDR_ANY)
    and if a specific address needs to be committed at the time of the call to
    *listen*
*   Errno::EINPROGRESS - a Windows Sockets 1.1 call is in progress or the
    service provider is still processing a callback function
*   Errno::EINVAL - the `socket` has not been bound with a call to *bind*.
*   Errno::EISCONN - the `socket` is already connected
*   Errno::EMFILE - no more socket descriptors are available
*   Errno::ENOBUFS - no buffer space is available
*   Errno::ENOTSOC - `socket` is not a socket
*   Errno::EOPNOTSUPP - the referenced `socket` is not a type that supports
    the *listen* method


### See
*   listen manual pages on unix-based systems
*   listen function in Microsoft's Winsock functions reference

;T;0;;;I"listen;F;I"UNIXServer;T;[o;;I"::Integer backlog;T;I"	void;To;;I"&Accepts a new connection. It returns the new file descriptor which is an
integer.

    UNIXServer.open("/tmp/sock") {|serv|
      UNIXSocket.open("/tmp/sock") {|c|
        fd = serv.sysaccept
        s = IO.new(fd)
        s.puts "hi"
        s.close
        p c.read #=> "hi\n"
      }
    }

;T;0;;;I"sysaccept;F;I"UNIXServer;T;[o;;I" ;F;I"Integer;To;;0;0;;;I"__accept_nonblock;F;I"UNIXServer;T;[o;;I"untyped;T;I"untyped;To;;I"’Creates a new UNIX server socket bound to *path*.

    require 'socket'

    serv = UNIXServer.new("/tmp/sock")
    s = serv.accept
    p s.read

;T;0;;;I"initialize;F;I"UNIXServer;T;[o;;I"untyped;T;I"untyped;To; ;I"@UNIXSocket represents a UNIX domain stream client socket.

;T;0;	I"UNIXSocket;T;
[ ;[ ;0;[ ;[ ;0;I"BasicSocket;To;;I":Creates a pair of sockets connected to each other.

*socktype* should be a socket type such as: :STREAM, :DGRAM, :RAW, etc.

*protocol* should be a protocol defined in the domain. 0 is default protocol
for the domain.

    s1, s2 = UNIXSocket.pair
    s1.send "a", 0
    s1.send "b", 0
    p s2.recv(10) #=> "ab"

;T;0;;;I"	pair;F;I"UNIXSocket;T;[o;;I",?::Symbol socktype, ?::Integer protocol;T;I"[ instance, instance ];To;;I":Creates a pair of sockets connected to each other.

*socktype* should be a socket type such as: :STREAM, :DGRAM, :RAW, etc.

*protocol* should be a protocol defined in the domain. 0 is default protocol
for the domain.

    s1, s2 = UNIXSocket.pair
    s1.send "a", 0
    s1.send "b", 0
    p s2.recv(10) #=> "ab"

;T;0;;;I"socketpair;F;I"UNIXSocket;T;[o;;I",?::Symbol socktype, ?::Integer protocol;T;I"[ instance, instance ];To;;I"±Returns the local address as an array which contains address_family and
unix_path.

Example
    serv = UNIXServer.new("/tmp/sock")
    p serv.addr #=> ["AF_UNIX", "/tmp/sock"]

;T;0;;;I"	addr;F;I"UNIXSocket;T;[o;;I" ;F;I"[ ::String, ::String ];To;;I"}Returns the path of the local address of unixsocket.

    s = UNIXServer.new("/tmp/sock")
    p s.path #=> "/tmp/sock"

;T;0;;;I"	path;F;I"UNIXSocket;T;[o;;I" ;F;I"String;To;;I"×Returns the remote address as an array which contains address_family and
unix_path.

Example
    serv = UNIXServer.new("/tmp/sock")
    c = UNIXSocket.new("/tmp/sock")
    p c.peeraddr #=> ["AF_UNIX", "/tmp/sock"]

;T;0;;;I"peeraddr;F;I"UNIXSocket;T;[o;;I" ;F;I"[ ::String, ::String ];To;;I"Example

    UNIXServer.open("/tmp/sock") {|serv|
      UNIXSocket.open("/tmp/sock") {|c|
        s = serv.accept

        c.send_io STDOUT
        stdout = s.recv_io

        p STDOUT.fileno #=> 1
        p stdout.fileno #=> 7

        stdout.puts "hello" # outputs "hello\n" to standard output.
      }
    }

*klass* will determine the class of *io* returned (using the IO.for_fd
singleton method or similar). If *klass* is `nil`, an integer file descriptor
is returned.

*mode* is the same as the argument passed to IO.for_fd

;T;0;;;I"recv_io;F;I"UNIXSocket;T;[o;;I".?singleton(::BasicSocket), ?::String mode;T;I"BasicSocket;To;;I"EReceives a message via *unixsocket*.

*maxlen* is the maximum number of bytes to receive.

*flags* should be a bitwise OR of Socket::MSG_* constants.

*outbuf* will contain only the received data after the method call even if it
is not empty at the beginning.

    s1 = Socket.new(:UNIX, :DGRAM, 0)
    s1_ai = Addrinfo.unix("/tmp/sock1")
    s1.bind(s1_ai)

    s2 = Socket.new(:UNIX, :DGRAM, 0)
    s2_ai = Addrinfo.unix("/tmp/sock2")
    s2.bind(s2_ai)
    s3 = UNIXSocket.for_fd(s2.fileno)

    s1.send "a", 0, s2_ai
    p s3.recvfrom(10) #=> ["a", ["AF_UNIX", "/tmp/sock1"]]

;T;0;;;I"recvfrom;F;I"UNIXSocket;T;[o;;I"9::Integer maxlen, ?::Integer flags, ?::String outbuf;T;I")[ ::String, [ ::String, ::String ] ];To;;I"*Sends *io* as file descriptor passing.

    s1, s2 = UNIXSocket.pair

    s1.send_io STDOUT
    stdout = s2.recv_io

    p STDOUT.fileno #=> 1
    p stdout.fileno #=> 6

    stdout.puts "hello" # outputs "hello\n" to standard output.

*io* may be any kind of IO object or integer file descriptor.

;T;0;;;I"send_io;F;I"UNIXSocket;T;[o;;I"::BasicSocket | ::Integer;T;I"	void;To;;I"ˆCreates a new UNIX client socket connected to *path*.

    require 'socket'

    s = UNIXSocket.new("/tmp/sock")
    s.send "hello", 0

;T;0;;;I"initialize;F;I"UNIXSocket;T;[o;;I"::String path;T;I"untyped;To; ;I"v	StringScanner provides for lexical scanning operations on a String.  Here is
an example of its usage:

    s = StringScanner.new('This is an example string')
    s.eos?               # -> false

    p s.scan(/\w+/)      # -> "This"
    p s.scan(/\w+/)      # -> nil
    p s.scan(/\s+/)      # -> " "
    p s.scan(/\s+/)      # -> nil
    p s.scan(/\w+/)      # -> "is"
    s.eos?               # -> false

    p s.scan(/\s+/)      # -> " "
    p s.scan(/\w+/)      # -> "an"
    p s.scan(/\s+/)      # -> " "
    p s.scan(/\w+/)      # -> "example"
    p s.scan(/\s+/)      # -> " "
    p s.scan(/\w+/)      # -> "string"
    s.eos?               # -> true

    p s.scan(/\s+/)      # -> nil
    p s.scan(/\w+/)      # -> nil

Scanning a string means remembering the position of a *scan pointer*, which is
just an index.  The point of scanning is to move forward a bit at a time, so
matches are sought after the scan pointer; usually immediately after it.

Given the string "test string", here are the pertinent scan pointer positions:

      t e s t   s t r i n g
    0 1 2 ...             1
                          0

When you #scan for a pattern (a regular expression), the match must occur at
the character after the scan pointer.  If you use #scan_until, then the match
can occur anywhere after the scan pointer.  In both cases, the scan pointer
moves *just beyond* the last character of the match, ready to scan again from
the next character onwards.  This is demonstrated by the example above.

## Method Categories

There are other methods besides the plain scanners.  You can look ahead in the
string without actually scanning.  You can access the most recent match. You
can modify the string being scanned, reset or terminate the scanner, find out
or change the position of the scan pointer, skip ahead, and so on.

### Advancing the Scan Pointer

*   #getch
*   #get_byte
*   #scan
*   #scan_until
*   #skip
*   #skip_until


### Looking Ahead

*   #check
*   #check_until
*   #exist?
*   #match?
*   #peek


### Finding Where we Are

*   #beginning_of_line? (`#bol?`)
*   #eos?
*   #rest?
*   #rest_size
*   #pos


### Setting Where we Are

*   #reset
*   #terminate
*   #pos=


### Match Data

*   #matched
*   #matched?
*   #matched_size
*   `#[]`
*   #pre_match
*   #post_match


### Miscellaneous

*   `<<`
*   #concat
*   #string
*   #string=
*   #unscan


There are aliases to several of the methods.

;T;0;	I"StringScanner;T;
[ ;[ ;0;[ ;[ ;0;0o;;I"9This method is defined for backward compatibility.

;T;0;;;I"must_C_version;F;I"StringScanner;T;[o;;I" ;F;I"	self;To;;I"Appends `str` to the string being scanned. This method does not affect scan
pointer.

    s = StringScanner.new("Fri Dec 12 1975 14:39")
    s.scan(/Fri /)
    s << " +1000 GMT"
    s.string            # -> "Fri Dec 12 1975 14:39 +1000 GMT"
    s.scan(/Dec/)       # -> "Dec"

;T;0;;;I"<<;F;I"StringScanner;T;[o;;I"::String;T;I"	self;To;;I"Returns the n-th subgroup in the most recent match.

    s = StringScanner.new("Fri Dec 12 1975 14:39")
    s.scan(/(\w+) (\w+) (\d+) /)       # -> "Fri Dec 12 "
    s[0]                               # -> "Fri Dec 12 "
    s[1]                               # -> "Fri"
    s[2]                               # -> "Dec"
    s[3]                               # -> "12"
    s.post_match                       # -> "1975 14:39"
    s.pre_match                        # -> ""

    s.reset
    s.scan(/(?<wday>\w+) (?<month>\w+) (?<day>\d+) /)       # -> "Fri Dec 12 "
    s[0]                               # -> "Fri Dec 12 "
    s[1]                               # -> "Fri"
    s[2]                               # -> "Dec"
    s[3]                               # -> "12"
    s[:wday]                           # -> "Fri"
    s[:month]                          # -> "Dec"
    s[:day]                            # -> "12"
    s.post_match                       # -> "1975 14:39"
    s.pre_match                        # -> ""

;T;0;;;I"[];F;I"StringScanner;T;[o;;I"::Integer;T;I"String?;To;;I"-Returns `true` if and only if the scan pointer is at the beginning of the
line.

    s = StringScanner.new("test\ntest\n")
    s.bol?           # => true
    s.scan(/te/)
    s.bol?           # => false
    s.scan(/st\n/)
    s.bol?           # => true
    s.terminate
    s.bol?           # => true

;T;0;;;I"beginning_of_line?;F;I"StringScanner;T;[o;;I" ;F;I"	bool;To;;I"Returns the subgroups in the most recent match (not including the full match).
If nothing was priorly matched, it returns nil.

    s = StringScanner.new("Fri Dec 12 1975 14:39")
    s.scan(/(\w+) (\w+) (\d+) /)       # -> "Fri Dec 12 "
    s.captures                         # -> ["Fri", "Dec", "12"]
    s.scan(/(\w+) (\w+) (\d+) /)       # -> nil
    s.captures                         # -> nil

;T;0;;;I"captures;F;I"StringScanner;T;[o;;I" ;F;I"Array[::String]?;To;;I"§Returns the character position of the scan pointer.  In the 'reset' position,
this value is zero.  In the 'terminated' position (i.e. the string is
exhausted), this value is the size of the string.

In short, it's a 0-based index into the string.

    s = StringScanner.new("abcÃ¤defÃ¶ghi")
    s.charpos           # -> 0
    s.scan_until(/Ã¤/)   # -> "abcÃ¤"
    s.pos               # -> 5
    s.charpos           # -> 4

;T;0;;;I"charpos;F;I"StringScanner;T;[o;;I" ;F;I"Integer;To;;I"ÄThis returns the value that #scan would return, without advancing the scan
pointer.  The match register is affected, though.

    s = StringScanner.new("Fri Dec 12 1975 14:39")
    s.check /Fri/               # -> "Fri"
    s.pos                       # -> 0
    s.matched                   # -> "Fri"
    s.check /12/                # -> nil
    s.matched                   # -> nil

Mnemonic: it "checks" to see whether a #scan will return a value.

;T;0;;;I"
check;F;I"StringScanner;T;[o;;I"::Regexp;T;I"String?;To;;I"‚This returns the value that #scan_until would return, without advancing the
scan pointer.  The match register is affected, though.

    s = StringScanner.new("Fri Dec 12 1975 14:39")
    s.check_until /12/          # -> "Fri Dec 12"
    s.pos                       # -> 0
    s.matched                   # -> 12

Mnemonic: it "checks" to see whether a #scan_until will return a value.

;T;0;;;I"check_until;F;I"StringScanner;T;[o;;I"::Regexp;T;I"String;To;;I"QEquivalent to #terminate. This method is obsolete; use #terminate instead.

;T;0;;;I"
clear;F;I"StringScanner;T;[o;;I" ;F;I"	void;To;;I"GEquivalent to #eos?. This method is obsolete, use #eos? instead.

;T;0;;;I"empty?;F;I"StringScanner;T;[o;;I" ;F;I"	bool;To;;I"ðReturns `true` if the scan pointer is at the end of the string.

    s = StringScanner.new('test string')
    p s.eos?          # => false
    s.scan(/test/)
    p s.eos?          # => false
    s.terminate
    p s.eos?          # => true

;T;0;;;I"	eos?;F;I"StringScanner;T;[o;;I" ;F;I"	bool;To;;I"eLooks *ahead* to see if the `pattern` exists *anywhere* in the string, without
advancing the scan pointer.  This predicates whether a #scan_until will return
a value.

    s = StringScanner.new('test string')
    s.exist? /s/            # -> 3
    s.scan /test/           # -> "test"
    s.exist? /s/            # -> 2
    s.exist? /e/            # -> nil

;T;0;;;I"exist?;F;I"StringScanner;T;[o;;I"::Regexp;T;I"Integer?;To;;I"·Whether `scanner` uses fixed anchor mode or not.

If fixed anchor mode is used, `\A` always matches the beginning of the string.
Otherwise, `\A` always matches the current position.

;T;0;;;I"fixed_anchor?;F;I"StringScanner;T;[o;;I" ;F;I"	bool;To;;I"‹Scans one byte and returns it. This method is not multibyte character
sensitive. See also: #getch.

    s = StringScanner.new('ab')
    s.get_byte         # => "a"
    s.get_byte         # => "b"
    s.get_byte         # => nil

    s = StringScanner.new("\244\242".force_encoding("euc-jp"))
    s.get_byte         # => "\xA4"
    s.get_byte         # => "\xA2"
    s.get_byte         # => nil

;T;0;;;I"get_byte;F;I"StringScanner;T;[o;;I" ;F;I"String?;To;;I"OEquivalent to #get_byte. This method is obsolete; use #get_byte instead.

;T;0;;;I"getbyte;F;I"StringScanner;T;[o;;I" ;F;I"String?;To;;I"{Scans one character and returns it. This method is multibyte character
sensitive.

    s = StringScanner.new("ab")
    s.getch           # => "a"
    s.getch           # => "b"
    s.getch           # => nil

    s = StringScanner.new("\244\242".force_encoding("euc-jp"))
    s.getch           # => "\x{A4A2}"   # Japanese hira-kana "A" in EUC-JP
    s.getch           # => nil

;T;0;;;I"
getch;F;I"StringScanner;T;[o;;I" ;F;I"String?;To;;I"šReturns a string that represents the StringScanner object, showing:
*   the current position
*   the size of the string
*   the characters surrounding the scan pointer

    s = StringScanner.new("Fri Dec 12 1975 14:39") s.inspect            # ->
    '#<StringScanner 0/21 @ "Fri D...">' s.scan_until /12/    # -> "Fri Dec
    12" s.inspect            # -> '#<StringScanner 10/21 "...ec 12" @ "
    1975...">'

;T;0;;;I"inspect;F;I"StringScanner;T;[o;;I" ;F;I"String;To;;I"CTests whether the given `pattern` is matched from the current scan pointer.
Returns the length of the match, or `nil`.  The scan pointer is not advanced.

    s = StringScanner.new('test string')
    p s.match?(/\w+/)   # -> 4
    p s.match?(/\w+/)   # -> 4
    p s.match?("test")  # -> 4
    p s.match?(/\s+/)   # -> nil

;T;0;;;I"match?;F;I"StringScanner;T;[o;;I"::Regexp;T;I"Integer?;To;;I"Returns the last matched string.

    s = StringScanner.new('test string')
    s.match?(/\w+/)     # -> 4
    s.matched           # -> "test"

;T;0;;;I"matched;F;I"StringScanner;T;[o;;I" ;F;I"String?;To;;I"íReturns `true` if and only if the last match was successful.

    s = StringScanner.new('test string')
    s.match?(/\w+/)     # => 4
    s.matched?          # => true
    s.match?(/\d+/)     # => nil
    s.matched?          # => false

;T;0;;;I"matched?;F;I"StringScanner;T;[o;;I" ;F;I"	bool;To;;I"mReturns the size of the most recent match in bytes, or `nil` if there was no
recent match.  This is different than `matched.size`, which will return the
size in characters.

    s = StringScanner.new('test string')
    s.check /\w+/           # -> "test"
    s.matched_size          # -> 4
    s.check /\d+/           # -> nil
    s.matched_size          # -> nil

;T;0;;;I"matched_size;F;I"StringScanner;T;[o;;I" ;F;I"Integer?;To;;I"ÑExtracts a string corresponding to `string[pos,len]`, without advancing the
scan pointer.

    s = StringScanner.new('test string')
    s.peek(7)          # => "test st"
    s.peek(7)          # => "test st"

;T;0;;;I"	peek;F;I"StringScanner;T;[o;;I"::Integer;T;I"String;To;;I"GEquivalent to #peek. This method is obsolete; use #peek instead.

;T;0;;;I"	peep;F;I"StringScanner;T;[o;;I"::Integer;T;I"String;To;;I"âReturns the byte position of the scan pointer.  In the 'reset' position, this
value is zero.  In the 'terminated' position (i.e. the string is exhausted),
this value is the bytesize of the string.

In short, it's a 0-based index into bytes of the string.

    s = StringScanner.new('test string')
    s.pos               # -> 0
    s.scan_until /str/  # -> "test str"
    s.pos               # -> 8
    s.terminate         # -> #<StringScanner fin>
    s.pos               # -> 11

;T;0;;;I"pointer;F;I"StringScanner;T;[o;;I" ;F;I"Integer;To;;I"œSets the byte position of the scan pointer.

    s = StringScanner.new('test string')
    s.pos = 7            # -> 7
    s.rest               # -> "ring"

;T;0;;;I"pointer=;F;I"StringScanner;T;[o;;I"::Integer;T;I"Integer;To;;I"âReturns the byte position of the scan pointer.  In the 'reset' position, this
value is zero.  In the 'terminated' position (i.e. the string is exhausted),
this value is the bytesize of the string.

In short, it's a 0-based index into bytes of the string.

    s = StringScanner.new('test string')
    s.pos               # -> 0
    s.scan_until /str/  # -> "test str"
    s.pos               # -> 8
    s.terminate         # -> #<StringScanner fin>
    s.pos               # -> 11

;T;0;;;I"pos;F;I"StringScanner;T;[o;;I" ;F;I"Integer;To;;I"œSets the byte position of the scan pointer.

    s = StringScanner.new('test string')
    s.pos = 7            # -> 7
    s.rest               # -> "ring"

;T;0;;;I"	pos=;F;I"StringScanner;T;[o;;I"::Integer;T;I"Integer;To;;I"Returns the ***post**-match* (in the regular expression sense) of the last
scan.

    s = StringScanner.new('test string')
    s.scan(/\w+/)           # -> "test"
    s.scan(/\s+/)           # -> " "
    s.pre_match             # -> "test"
    s.post_match            # -> "string"

;T;0;;;I"post_match;F;I"StringScanner;T;[o;;I" ;F;I"String;To;;I"Returns the ***pre**-match* (in the regular expression sense) of the last
scan.

    s = StringScanner.new('test string')
    s.scan(/\w+/)           # -> "test"
    s.scan(/\s+/)           # -> " "
    s.pre_match             # -> "test"
    s.post_match            # -> "string"

;T;0;;;I"pre_match;F;I"StringScanner;T;[o;;I" ;F;I"String;To;;I"@Reset the scan pointer (index 0) and clear matching data.

;T;0;;;I"
reset;F;I"StringScanner;T;[o;;I" ;F;I"	void;To;;I"…Returns the "rest" of the string (i.e. everything after the scan pointer). If
there is no more data (eos? = true), it returns `""`.

;T;0;;;I"	rest;F;I"StringScanner;T;[o;;I" ;F;I"String;To;;I"îReturns true if and only if there is more data in the string.  See #eos?. This
method is obsolete; use #eos? instead.

    s = StringScanner.new('test string')
    s.eos?              # These two
    s.rest?             # are opposites.

;T;0;;;I"
rest?;F;I"StringScanner;T;[o;;I" ;F;I"	bool;To;;I"4`s.rest_size` is equivalent to `s.rest.size`.

;T;0;;;I"rest_size;F;I"StringScanner;T;[o;;I" ;F;I"Integer;To;;I"d`s.restsize` is equivalent to `s.rest_size`. This method is obsolete; use
#rest_size instead.

;T;0;;;I"restsize;F;I"StringScanner;T;[o;;I" ;F;I"Integer;To;;I"¥Tries to match with `pattern` at the current position. If there's a match, the
scanner advances the "scan pointer" and returns the matched string. Otherwise,
the scanner returns `nil`.

    s = StringScanner.new('test string')
    p s.scan(/\w+/)   # -> "test"
    p s.scan(/\w+/)   # -> nil
    p s.scan(/\s+/)   # -> " "
    p s.scan("str")   # -> "str"
    p s.scan(/\w+/)   # -> "ing"
    p s.scan(/./)     # -> nil

;T;0;;;I"	scan;F;I"StringScanner;T;[o;;I"::Regexp;T;I"String?;To;;I"Tests whether the given `pattern` is matched from the current scan pointer.
Advances the scan pointer if `advance_pointer_p` is true. Returns the matched
string if `return_string_p` is true. The match register is affected.

"full" means "#scan with full parameters".

;T;0;;;I"scan_full;F;I"StringScanner;T;[o;;I"C::Regexp pattern, bool advance_pointer_p, bool return_string_p;T;I"untyped;To;;I"€Scans the string *until* the `pattern` is matched.  Returns the substring up
to and including the end of the match, advancing the scan pointer to that
location. If there is no match, `nil` is returned.

    s = StringScanner.new("Fri Dec 12 1975 14:39")
    s.scan_until(/1/)        # -> "Fri Dec 1"
    s.pre_match              # -> "Fri Dec "
    s.scan_until(/XYZ/)      # -> nil

;T;0;;;I"scan_until;F;I"StringScanner;T;[o;;I"::Regexp;T;I"String?;To;;I"
Scans the string *until* the `pattern` is matched. Advances the scan pointer
if `advance_pointer_p`, otherwise not. Returns the matched string if
`return_string_p` is true, otherwise returns the number of bytes advanced.
This method does affect the match register.

;T;0;;;I"search_full;F;I"StringScanner;T;[o;;I"C::Regexp pattern, bool advance_pointer_p, bool return_string_p;T;I"untyped;To;;I"üReturns the amount of subgroups in the most recent match. The full match
counts as a subgroup.

    s = StringScanner.new("Fri Dec 12 1975 14:39")
    s.scan(/(\w+) (\w+) (\d+) /)       # -> "Fri Dec 12 "
    s.size                             # -> 4

;T;0;;;I"	size;F;I"StringScanner;T;[o;;I" ;F;I"Integer;To;;I"÷Attempts to skip over the given `pattern` beginning with the scan pointer. If
it matches, the scan pointer is advanced to the end of the match, and the
length of the match is returned.  Otherwise, `nil` is returned.

It's similar to #scan, but without returning the matched string.

    s = StringScanner.new('test string')
    p s.skip(/\w+/)   # -> 4
    p s.skip(/\w+/)   # -> nil
    p s.skip(/\s+/)   # -> 1
    p s.skip("st")    # -> 2
    p s.skip(/\w+/)   # -> 4
    p s.skip(/./)     # -> nil

;T;0;;;I"	skip;F;I"StringScanner;T;[o;;I"::Regexp;T;I"Integer?;To;;I" Advances the scan pointer until `pattern` is matched and consumed.  Returns
the number of bytes advanced, or `nil` if no match was found.

Look ahead to match `pattern`, and advance the scan pointer to the *end* of
the match.  Return the number of characters advanced, or `nil` if the match
was unsuccessful.

It's similar to #scan_until, but without returning the intervening string.

    s = StringScanner.new("Fri Dec 12 1975 14:39")
    s.skip_until /12/           # -> 10
    s                           #

;T;0;;;I"skip_until;F;I"StringScanner;T;[o;;I"::Regexp;T;I"Integer?;To;;I"(Returns the string being scanned.

;T;0;;;I"string;F;I"StringScanner;T;[o;;I" ;F;I"String;To;;I"WChanges the string being scanned to `str` and resets the scanner. Returns
`str`.

;T;0;;;I"string=;F;I"StringScanner;T;[o;;I"::String;T;I"String;To;;I"NSets the scan pointer to the end of the string and clear matching data.

;T;0;;;I"terminate;F;I"StringScanner;T;[o;;I" ;F;I"	void;To;;I"Sets the scan pointer to the previous position.  Only one previous position is
remembered, and it changes with each scanning operation.

    s = StringScanner.new('test string')
    s.scan(/\w+/)        # => "test"
    s.unscan
    s.scan(/../)         # => "te"
    s.scan(/\d/)         # => nil
    s.unscan             # ScanError: unscan failed: previous match record not exist

;T;0;;;I"unscan;F;I"StringScanner;T;[o;;I" ;F;I"	void;To;;I"’Returns the subgroups in the most recent match at the given indices. If
nothing was priorly matched, it returns nil.

    s = StringScanner.new("Fri Dec 12 1975 14:39")
    s.scan(/(\w+) (\w+) (\d+) /)       # -> "Fri Dec 12 "
    s.values_at 0, -1, 5, 2            # -> ["Fri Dec 12 ", "12", nil, "Dec"]
    s.scan(/(\w+) (\w+) (\d+) /)       # -> nil
    s.values_at 0, -1, 5, 2            # -> nil

;T;0;;;I"values_at;F;I"StringScanner;T;[o;;I"*::Integer;T;I"Array[::String]?;To;;I"÷Creates a new StringScanner object to scan over the given `string`.

If `fixed_anchor` is `true`, `\A` always matches the beginning of the string.
Otherwise, `\A` always matches the current position.

`dup` argument is obsolete and not used now.

;T;0;;;I"initialize;F;I"StringScanner;T;[o;;I"-::String, ?bool dup, ?fixed_anchor: bool;T;I"untyped;To;;I")Duplicates a StringScanner object.

;T;0;;;I"initialize_copy;F;I"StringScanner;T;[o;;I"::StringScanner;T;I"	void;To; ;I"A utility class for managing temporary files. When you create a Tempfile
object, it will create a temporary file with a unique filename. A Tempfile
objects behaves just like a File object, and you can perform all the usual
file operations on it: reading data, writing data, changing its permissions,
etc. So although this class does not explicitly document all instance methods
supported by File, you can in fact call any File instance method on a Tempfile
object.

## Synopsis

    require 'tempfile'

    file = Tempfile.new('foo')
    file.path      # => A unique filename in the OS's temp directory,
                   #    e.g.: "/tmp/foo.24722.0"
                   #    This filename contains 'foo' in its basename.
    file.write("hello world")
    file.rewind
    file.read      # => "hello world"
    file.close
    file.unlink    # deletes the temp file

## Good practices

### Explicit close

When a Tempfile object is garbage collected, or when the Ruby interpreter
exits, its associated temporary file is automatically deleted. This means that
it's unnecessary to explicitly delete a Tempfile after use, though it's a good
practice to do so: not explicitly deleting unused Tempfiles can potentially
leave behind a large number of temp files on the filesystem until they're
garbage collected. The existence of these temp files can make it harder to
determine a new Tempfile filename.

Therefore, one should always call #unlink or close in an ensure block, like
this:

    file = Tempfile.new('foo')
    begin
       # ...do something with file...
    ensure
       file.close
       file.unlink   # deletes the temp file
    end

Tempfile.create { ... } exists for this purpose and is more convenient to use.
Note that Tempfile.create returns a File instance instead of a Tempfile, which
also avoids the overhead and complications of delegation.

    Tempfile.open('foo') do |file|
       # ...do something with file...
    end

### Unlink after creation

On POSIX systems, it's possible to unlink a file right after creating it, and
before closing it. This removes the filesystem entry without closing the file
handle, so it ensures that only the processes that already had the file handle
open can access the file's contents. It's strongly recommended that you do
this if you do not want any other processes to be able to read from or write
to the Tempfile, and you do not need to know the Tempfile's filename either.

For example, a practical use case for unlink-after-creation would be this: you
need a large byte buffer that's too large to comfortably fit in RAM, e.g. when
you're writing a web server and you want to buffer the client's file upload
data.

Please refer to #unlink for more information and a code example.

## Minor notes

Tempfile's filename picking method is both thread-safe and inter-process-safe:
it guarantees that no other threads or processes will pick the same filename.

Tempfile itself however may not be entirely thread-safe. If you access the
same Tempfile object from multiple threads then you should protect it with a
mutex.

;T;0;	I"Tempfile;T;
[ ;[ ;0;[ ;[ ;0;I"	File;To;;I"tCreates a temporary file as a usual File object (not a Tempfile). It does not
use finalizer and delegation, which makes it more efficient and reliable.

If no block is given, this is similar to Tempfile.new except creating File
instead of Tempfile. In that case, the created file is not removed
automatically. You should use File.unlink to remove it.

If a block is given, then a File object will be constructed, and the block is
invoked with the object as the argument. The File object will be automatically
closed and the temporary file is removed after the block terminates, releasing
all resources that the block created. The call returns the value of the block.

In any case, all arguments (`basename`, `tmpdir`, `mode`, and `**options`)
will be treated the same as for Tempfile.new.

    Tempfile.create('foo', '/home/temp') do |f|
       # ... do something with f ...
    end

;T;0;;;I"create;F;I"Tempfile;T;[o;;I"`?::String | [ ::String, ::String ] basename, ?::String? tmpdir, ?mode: ::Integer, **untyped;T;I"	File;To;;I"`?::String | [ ::String, ::String ] basename, ?::String? tmpdir, ?mode: ::Integer, **untyped;T;I"A;Fo;;I"Creates a new Tempfile.

This method is not recommended and exists mostly for backward compatibility.
Please use Tempfile.create instead, which avoids the cost of delegation, does
not rely on a finalizer, and also unlinks the file when given a block.

Tempfile.open is still appropriate if you need the Tempfile to be unlinked by
a finalizer and you cannot explicitly know where in the program the Tempfile
can be unlinked safely.

If no block is given, this is a synonym for Tempfile.new.

If a block is given, then a Tempfile object will be constructed, and the block
is run with the Tempfile object as argument. The Tempfile object will be
automatically closed after the block terminates. However, the file will
**not** be unlinked and needs to be manually unlinked with Tempfile#close! or
Tempfile#unlink. The finalizer will try to unlink but should not be relied
upon as it can keep the file on the disk much longer than intended. For
instance, on CRuby, finalizers can be delayed due to conservative stack
scanning and references left in unused memory.

The call returns the value of the block.

In any case, all arguments (`*args`) will be passed to Tempfile.new.

    Tempfile.open('foo', '/home/temp') do |f|
       # ... do something with f ...
    end

    # Equivalent:
    f = Tempfile.open('foo', '/home/temp')
    begin
       # ... do something with f ...
    ensure
       f.close
    end

;T;0;;;I"	open;F;I"Tempfile;T;[o;;I"*untyped args, **untyped;T;I"Tempfile;To;;I"*untyped args, **untyped;T;I"A;Fo;;I"Closes the file. If `unlink_now` is true, then the file will be unlinked
(deleted) after closing. Of course, you can choose to later call #unlink if
you do not unlink it now.

If you don't explicitly unlink the temporary file, the removal will be delayed
until the object is finalized.

;T;0;;;I"
close;F;I"Tempfile;T;[o;;I"?::boolish unlink_now;T;I"	void;To;;I"ZCloses and unlinks (deletes) the file. Has the same effect as called
`close(true)`.

;T;0;;;I"close!;F;I"Tempfile;T;[o;;I" ;F;I"	void;To;;0;0;;;I"inspect;F;I"Tempfile;T;[o;;I" ;F;I"String;To;;I"0Opens or reopens the file with mode "r+".

;T;0;;;I"	open;F;I"Tempfile;T;[o;;I" ;F;I"	File;To;;I"eReturns the full path name of the temporary file. This will be nil if #unlink
has been called.

;T;0;;;I"	path;F;I"Tempfile;T;[o;;I" ;F;I"String?;To;;I"wReturns the size of the temporary file.  As a side effect, the IO buffer is
flushed before determining the size.

;T;0;;;I"	size;F;I"Tempfile;T;[o;;I" ;F;I"Integer;To;;I"ÝUnlinks (deletes) the file from the filesystem. One should always unlink the
file after using it, as is explained in the "Explicit close" good practice
section in the Tempfile overview:

    file = Tempfile.new('foo')
    begin
       # ...do something with file...
    ensure
       file.close
       file.unlink   # deletes the temp file
    end

### Unlink-before-close

On POSIX systems it's possible to unlink a file before closing it. This
practice is explained in detail in the Tempfile overview (section "Unlink
after creation"); please refer there for more information.

However, unlink-before-close may not be supported on non-POSIX operating
systems. Microsoft Windows is the most notable case: unlinking a non-closed
file will result in an error, which this method will silently ignore. If you
want to practice unlink-before-close whenever possible, then you should write
code like this:

    file = Tempfile.new('foo')
    file.unlink   # On Windows this silently fails.
    begin
       # ... do something with file ...
    ensure
       file.close!   # Closes the file handle. If the file wasn't unlinked
                     # because #unlink failed, then this method will attempt
                     # to do so again.
    end

;T;0;;;I"unlink;F;I"Tempfile;T;[o;;I" ;F;I"	void;To;;I"WCreates a temporary file with permissions 0600 (= only readable and writable
by the owner) and opens it with mode "w+".

It is recommended to use Tempfile.create { ... } instead when possible,
because that method avoids the cost of delegation and does not rely on a
finalizer to close and unlink the file, which is unreliable.

The `basename` parameter is used to determine the name of the temporary file.
You can either pass a String or an Array with 2 String elements. In the former
form, the temporary file's base name will begin with the given string. In the
latter form, the temporary file's base name will begin with the array's first
element, and end with the second element. For example:

    file = Tempfile.new('hello')
    file.path  # => something like: "/tmp/hello2843-8392-92849382--0"

    # Use the Array form to enforce an extension in the filename:
    file = Tempfile.new(['hello', '.jpg'])
    file.path  # => something like: "/tmp/hello2843-8392-92849382--0.jpg"

The temporary file will be placed in the directory as specified by the
`tmpdir` parameter. By default, this is `Dir.tmpdir`.

    file = Tempfile.new('hello', '/home/aisaka')
    file.path  # => something like: "/home/aisaka/hello2843-8392-92849382--0"

You can also pass an options hash. Under the hood, Tempfile creates the
temporary file using `File.open`. These options will be passed to `File.open`.
This is mostly useful for specifying encoding options, e.g.:

    Tempfile.new('hello', '/home/aisaka', encoding: 'ascii-8bit')

    # You can also omit the 'tmpdir' parameter:
    Tempfile.new('hello', encoding: 'ascii-8bit')

Note: `mode` keyword argument, as accepted by Tempfile, can only be numeric,
combination of the modes defined in File::Constants.

### Exceptions

If Tempfile.new cannot find a unique filename within a limited number of
tries, then it will raise an exception.

;T;0;;;I"new;F;I"Tempfile;T;[o;;I"`?::String | [ ::String, ::String ] basename, ?::String? tmpdir, ?mode: ::Integer, **untyped;T;I"instance;To;;I"`?::String | [ ::String, ::String ] basename, ?::String? tmpdir, ?mode: ::Integer, **untyped;T;I"A;Fo; ;0;0;	I"Tempfile::Remover;T;
[ ;[ ;0;[ ;[ ;0;0o;;0;0;;;I"	call;F;I"Tempfile::Remover;T;[o;;I"*untyped args;T;I"	void;To;;0;0;;;I"initialize;F;I"Tempfile::Remover;T;[o;;I"::Tempfile tmpfile;T;I"	void;To;;I"…Timeout long-running blocks

## Synopsis

    require 'timeout'
    status = Timeout::timeout(5) {
      # Something that should be interrupted if it takes more than 5 seconds...
    }

## Description

Timeout provides a way to auto-terminate a potentially long-running operation
if it hasn't finished in a fixed amount of time.

Previous versions didn't use a module for namespacing, however #timeout is
provided for backwards compatibility.  You should prefer Timeout.timeout
instead.

## Copyright

Copyright
:   (C) 2000  Network Applied Communication Laboratory, Inc.
Copyright
:   (C) 2000  Information-technology Promotion Agency, Japan

;T;0;	I"Timeout;T;
[ ;[ ;0;[ ;[ o;;I" Perform an operation in a block, raising an error if it takes longer than
`sec` seconds to complete.

`sec`
:   Number of seconds to wait for the block to terminate. Any number may be
    used, including Floats to specify fractional seconds. A value of 0 or
    `nil` will execute the block without any timeout.
`klass`
:   Exception Class to raise if the block fails to terminate in `sec` seconds.
     Omitting will use the default, Timeout::Error
`message`
:   Error message to raise with Exception Class. Omitting will use the
    default, "execution expired"


Returns the result of the block **if** the block completed before `sec`
seconds, otherwise throws an exception, based on the value of `klass`.

The exception thrown to terminate the given block cannot be rescued inside the
block unless `klass` is given explicitly. However, the block can use ensure to
prevent the handling of the exception.  For that reason, this method cannot be
relied on to enforce timeouts for untrusted blocks.

If a scheduler is defined, it will be used to handle the timeout by invoking
Scheduler#timeout_after.

Note that this is both a method of module Timeout, so you can `include
Timeout` into your classes so they have a #timeout method, as well as a module
method, so you can call it directly as Timeout.timeout().

;T;0;;;I"timeout;F;I"Timeout;T;[o;;I"E::Numeric? sec, ?singleton(::Exception) klass, ?::String message;T;I"T;Fo; ;I":Raised by Timeout.timeout when the block times out.

;T;0;	I"Timeout::Error;T;
[ ;[ ;0;[ ;[ ;0;I"RuntimeError;To;;0;0;	I"
TSort;T;
[ ;[ ;0;[ ;[ o;;0;0;	I"
TSort;T;
[ ;[ ;0;[ ;[ o;;I"~TSort implements topological sorting using Tarjan's algorithm for strongly
connected components.

TSort is designed to be able to be used with any object which can be
interpreted as a directed graph.

TSort requires two methods to interpret an object as a graph, tsort_each_node
and tsort_each_child.

*   tsort_each_node is used to iterate for all nodes over a graph.
*   tsort_each_child is used to iterate for child nodes of a given node.


The equality of nodes are defined by eql? and hash since TSort uses Hash
internally.

## A Simple Example

The following example demonstrates how to mix the TSort module into an
existing class (in this case, Hash). Here, we're treating each key in the hash
as a node in the graph, and so we simply alias the required #tsort_each_node
method to Hash's #each_key method. For each key in the hash, the associated
value is an array of the node's child nodes. This choice in turn leads to our
implementation of the required #tsort_each_child method, which fetches the
array of child nodes and then iterates over that array using the user-supplied
block.

    require 'tsort'

    class Hash
      include TSort
      alias tsort_each_node each_key
      def tsort_each_child(node, &block)
        fetch(node).each(&block)
      end
    end

    {1=>[2, 3], 2=>[3], 3=>[], 4=>[]}.tsort
    #=> [3, 2, 1, 4]

    {1=>[2], 2=>[3, 4], 3=>[2], 4=>[]}.strongly_connected_components
    #=> [[4], [2, 3], [1]]

## A More Realistic Example

A very simple `make' like tool can be implemented as follows:

    require 'tsort'

    class Make
      def initialize
        @dep = {}
        @dep.default = []
      end

      def rule(outputs, inputs=[], &block)
        triple = [outputs, inputs, block]
        outputs.each {|f| @dep[f] = [triple]}
        @dep[triple] = inputs
      end

      def build(target)
        each_strongly_connected_component_from(target) {|ns|
          if ns.length != 1
            fs = ns.delete_if {|n| Array === n}
            raise TSort::Cyclic.new("cyclic dependencies: #{fs.join ', '}")
          end
          n = ns.first
          if Array === n
            outputs, inputs, block = n
            inputs_time = inputs.map {|f| File.mtime f}.max
            begin
              outputs_time = outputs.map {|f| File.mtime f}.min
            rescue Errno::ENOENT
              outputs_time = nil
            end
            if outputs_time == nil ||
               inputs_time != nil && outputs_time <= inputs_time
              sleep 1 if inputs_time != nil && inputs_time.to_i == Time.now.to_i
              block.call
            end
          end
        }
      end

      def tsort_each_child(node, &block)
        @dep[node].each(&block)
      end
      include TSort
    end

    def command(arg)
      print arg, "\n"
      system arg
    end

    m = Make.new
    m.rule(%w[t1]) { command 'date > t1' }
    m.rule(%w[t2]) { command 'date > t2' }
    m.rule(%w[t3]) { command 'date > t3' }
    m.rule(%w[t4], %w[t1 t3]) { command 'cat t1 t3 > t4' }
    m.rule(%w[t5], %w[t4 t2]) { command 'cat t4 t2 > t5' }
    m.build('t5')

## Bugs

*   'tsort.rb' is wrong name because this library uses Tarjan's algorithm for
    strongly connected components. Although 'strongly_connected_components.rb'
    is correct but too long.


## References

    1.  Tarjan, "Depth First Search and Linear Graph Algorithms",


*SIAM Journal on Computing*, Vol. 1, No. 2, pp. 146-160, June 1972.

;T;0;	I"
TSort;T;
[ ;[ ;0;[ ;[ o;;I"JThe iterator version of the TSort.strongly_connected_components method.

The graph is represented by *each_node* and *each_child*. *each_node* should
have `call` method which yields for each node in the graph. *each_child*
should have `call` method which takes a node argument and yields for each
child node.

    g = {1=>[2, 3], 2=>[4], 3=>[2, 4], 4=>[]}
    each_node = lambda {|&b| g.each_key(&b) }
    each_child = lambda {|n, &b| g[n].each(&b) }
    TSort.each_strongly_connected_component(each_node, each_child) {|scc| p scc }
    #=> [4]
    #   [2]
    #   [3]
    #   [1]

    g = {1=>[2], 2=>[3, 4], 3=>[2], 4=>[]}
    each_node = lambda {|&b| g.each_key(&b) }
    each_child = lambda {|n, &b| g[n].each(&b) }
    TSort.each_strongly_connected_component(each_node, each_child) {|scc| p scc }
    #=> [4]
    #   [2, 3]
    #   [1]

;T;0;;;I"&each_strongly_connected_component;F;I"
TSort;T;[	o;;I"G::TSort::_EachNode[T] each_node, ::TSort::_EachChild[T] each_child;T;I"	void;To;;I"G::TSort::_EachNode[T] each_node, ::TSort::_EachChild[T] each_child;T;I"!Enumerator[::Array[T], void];To;;I"S^() { (T) -> void } -> void each_node, ^(T) { (T) -> void } -> void each_child;T;I"	void;To;;I"S^() { (T) -> void } -> void each_node, ^(T) { (T) -> void } -> void each_child;T;I"!Enumerator[::Array[T], void];To;;I"wIterates over strongly connected components in a graph. The graph is
represented by *node* and *each_child*.

*node* is the first node. *each_child* should have `call` method which takes a
node argument and yields for each child node.

Return value is unspecified.

#TSort.each_strongly_connected_component_from is a class method and it doesn't
need a class to represent a graph which includes TSort.

    graph = {1=>[2], 2=>[3, 4], 3=>[2], 4=>[]}
    each_child = lambda {|n, &b| graph[n].each(&b) }
    TSort.each_strongly_connected_component_from(1, each_child) {|scc|
      p scc
    }
    #=> [4]
    #   [2, 3]
    #   [1]

;T;0;;;I"+each_strongly_connected_component_from;F;I"
TSort;T;[	o;;I"OT node, ::TSort::_EachChild[T] each_child, ?untyped id_map, ?untyped stack;T;I"	void;To;;I"OT node, ::TSort::_EachChild[T] each_child, ?untyped id_map, ?untyped stack;T;I"!Enumerator[::Array[T], void];To;;I"UT node, ^(T) { (T) -> void } -> void each_child, ?untyped id_map, ?untyped stack;T;I"	void;To;;I"UT node, ^(T) { (T) -> void } -> void each_child, ?untyped id_map, ?untyped stack;T;I"!Enumerator[::Array[T], void];To;;I"{Returns strongly connected components as an array of arrays of nodes. The
array is sorted from children to parents. Each elements of the array
represents a strongly connected component.

The graph is represented by *each_node* and *each_child*. *each_node* should
have `call` method which yields for each node in the graph. *each_child*
should have `call` method which takes a node argument and yields for each
child node.

    g = {1=>[2, 3], 2=>[4], 3=>[2, 4], 4=>[]}
    each_node = lambda {|&b| g.each_key(&b) }
    each_child = lambda {|n, &b| g[n].each(&b) }
    p TSort.strongly_connected_components(each_node, each_child)
    #=> [[4], [2], [3], [1]]

    g = {1=>[2], 2=>[3, 4], 3=>[2], 4=>[]}
    each_node = lambda {|&b| g.each_key(&b) }
    each_child = lambda {|n, &b| g[n].each(&b) }
    p TSort.strongly_connected_components(each_node, each_child)
    #=> [[4], [2, 3], [1]]

;T;0;;;I""strongly_connected_components;F;I"
TSort;T;[o;;I"G::TSort::_EachNode[T] each_node, ::TSort::_EachChild[T] each_child;T;I"Array[::Array[T]];To;;I"S^() { (T) -> void } -> void each_node, ^(T) { (T) -> void } -> void each_child;T;I"Array[::Array[T]];To;;I"RReturns a topologically sorted array of nodes. The array is sorted from
children to parents, i.e. the first element has no child and the last node has
no parent.

The graph is represented by *each_node* and *each_child*. *each_node* should
have `call` method which yields for each node in the graph. *each_child*
should have `call` method which takes a node argument and yields for each
child node.

If there is a cycle, TSort::Cyclic is raised.

    g = {1=>[2, 3], 2=>[4], 3=>[2, 4], 4=>[]}
    each_node = lambda {|&b| g.each_key(&b) }
    each_child = lambda {|n, &b| g[n].each(&b) }
    p TSort.tsort(each_node, each_child) #=> [4, 2, 3, 1]

    g = {1=>[2], 2=>[3, 4], 3=>[2], 4=>[]}
    each_node = lambda {|&b| g.each_key(&b) }
    each_child = lambda {|n, &b| g[n].each(&b) }
    p TSort.tsort(each_node, each_child) # raises TSort::Cyclic

;T;0;;;I"
tsort;F;I"
TSort;T;[o;;I"G::TSort::_EachNode[T] each_node, ::TSort::_EachChild[T] each_child;T;I"Array[T];To;;I"S^() { (T) -> void } -> void each_node, ^(T) { (T) -> void } -> void each_child;T;I"Array[T];To;;I"The iterator version of the TSort.tsort method.

The graph is represented by *each_node* and *each_child*. *each_node* should
have `call` method which yields for each node in the graph. *each_child*
should have `call` method which takes a node argument and yields for each
child node.

    g = {1=>[2, 3], 2=>[4], 3=>[2, 4], 4=>[]}
    each_node = lambda {|&b| g.each_key(&b) }
    each_child = lambda {|n, &b| g[n].each(&b) }
    TSort.tsort_each(each_node, each_child) {|n| p n }
    #=> 4
    #   2
    #   3
    #   1

;T;0;;;I"tsort_each;F;I"
TSort;T;[	o;;I"G::TSort::_EachNode[T] each_node, ::TSort::_EachChild[T] each_child;T;I"	void;To;;I"G::TSort::_EachNode[T] each_node, ::TSort::_EachChild[T] each_child;T;I"Enumerator[T, void];To;;I"S^() { (T) -> void } -> void each_node, ^(T) { (T) -> void } -> void each_child;T;I"	void;To;;I"S^() { (T) -> void } -> void each_node, ^(T) { (T) -> void } -> void each_child;T;I"Enumerator[T, void];To;;I")The iterator version of the #strongly_connected_components method.
*`obj*.each_strongly_connected_component` is similar to
*`obj*.strongly_connected_components.each`, but modification of *obj* during
the iteration may lead to unexpected results.

#each_strongly_connected_component returns `nil`.

    class G
      include TSort
      def initialize(g)
        @g = g
      end
      def tsort_each_child(n, &b) @g[n].each(&b) end
      def tsort_each_node(&b) @g.each_key(&b) end
    end

    graph = G.new({1=>[2, 3], 2=>[4], 3=>[2, 4], 4=>[]})
    graph.each_strongly_connected_component {|scc| p scc }
    #=> [4]
    #   [2]
    #   [3]
    #   [1]

    graph = G.new({1=>[2], 2=>[3, 4], 3=>[2], 4=>[]})
    graph.each_strongly_connected_component {|scc| p scc }
    #=> [4]
    #   [2, 3]
    #   [1]

;T;0;;;I"&each_strongly_connected_component;F;I"
TSort;T;[o;;I" ;F;I"	void;To;;I" ;F;I"$Enumerator[::Array[Node], void];To;;I"¤Iterates over strongly connected component in the subgraph reachable from
*node*.

Return value is unspecified.

#each_strongly_connected_component_from doesn't call #tsort_each_node.

    class G
      include TSort
      def initialize(g)
        @g = g
      end
      def tsort_each_child(n, &b) @g[n].each(&b) end
      def tsort_each_node(&b) @g.each_key(&b) end
    end

    graph = G.new({1=>[2, 3], 2=>[4], 3=>[2, 4], 4=>[]})
    graph.each_strongly_connected_component_from(2) {|scc| p scc }
    #=> [4]
    #   [2]

    graph = G.new({1=>[2], 2=>[3, 4], 3=>[2], 4=>[]})
    graph.each_strongly_connected_component_from(2) {|scc| p scc }
    #=> [4]
    #   [2, 3]

;T;0;;;I"+each_strongly_connected_component_from;F;I"
TSort;T;[o;;I"*Node, ?untyped id_map, ?untyped stack;T;I"	void;To;;I"*Node, ?untyped id_map, ?untyped stack;T;I"$Enumerator[::Array[Node], void];To;;I"qReturns strongly connected components as an array of arrays of nodes. The
array is sorted from children to parents. Each elements of the array
represents a strongly connected component.

    class G
      include TSort
      def initialize(g)
        @g = g
      end
      def tsort_each_child(n, &b) @g[n].each(&b) end
      def tsort_each_node(&b) @g.each_key(&b) end
    end

    graph = G.new({1=>[2, 3], 2=>[4], 3=>[2, 4], 4=>[]})
    p graph.strongly_connected_components #=> [[4], [2], [3], [1]]

    graph = G.new({1=>[2], 2=>[3, 4], 3=>[2], 4=>[]})
    p graph.strongly_connected_components #=> [[4], [2, 3], [1]]

;T;0;;;I""strongly_connected_components;F;I"
TSort;T;[o;;I" ;F;I"Array[::Array[Node]];To;;I"PReturns a topologically sorted array of nodes. The array is sorted from
children to parents, i.e. the first element has no child and the last node has
no parent.

If there is a cycle, TSort::Cyclic is raised.

    class G
      include TSort
      def initialize(g)
        @g = g
      end
      def tsort_each_child(n, &b) @g[n].each(&b) end
      def tsort_each_node(&b) @g.each_key(&b) end
    end

    graph = G.new({1=>[2, 3], 2=>[4], 3=>[2, 4], 4=>[]})
    p graph.tsort #=> [4, 2, 3, 1]

    graph = G.new({1=>[2], 2=>[3, 4], 3=>[2], 4=>[]})
    p graph.tsort # raises TSort::Cyclic

;T;0;;;I"
tsort;F;I"
TSort;T;[o;;I" ;F;I"Array[Node];To;;I"=The iterator version of the #tsort method. *`obj*.tsort_each` is similar to
*`obj*.tsort.each`, but modification of *obj* during the iteration may lead to
unexpected results.

#tsort_each returns `nil`. If there is a cycle, TSort::Cyclic is raised.

    class G
      include TSort
      def initialize(g)
        @g = g
      end
      def tsort_each_child(n, &b) @g[n].each(&b) end
      def tsort_each_node(&b) @g.each_key(&b) end
    end

    graph = G.new({1=>[2, 3], 2=>[4], 3=>[2, 4], 4=>[]})
    graph.tsort_each {|n| p n }
    #=> 4
    #   2
    #   3
    #   1

;T;0;;;I"tsort_each;F;I"
TSort;T;[o;;I" ;F;I"	void;To;;I" ;F;I"Enumerator[Node, void];To; ;0;0;	I"TSort::Cyclic;T;
[ ;[ ;0;[ ;[ ;0;I"StandardError;To;;I"¶
URI is a module providing classes to handle Uniform Resource Identifiers
([RFC2396](http://tools.ietf.org/html/rfc2396)).

## Features

*   Uniform way of handling URIs.
*   Flexibility to introduce custom URI schemes.
*   Flexibility to have an alternate URI::Parser (or just different patterns
    and regexp's).


## Basic example

    require 'uri'

    uri = URI("http://foo.com/posts?id=30&limit=5#time=1305298413")
    #=> #<URI::HTTP http://foo.com/posts?id=30&limit=5#time=1305298413>

    uri.scheme    #=> "http"
    uri.host      #=> "foo.com"
    uri.path      #=> "/posts"
    uri.query     #=> "id=30&limit=5"
    uri.fragment  #=> "time=1305298413"

    uri.to_s      #=> "http://foo.com/posts?id=30&limit=5#time=1305298413"

## Adding custom URIs

    module URI
      class RSYNC < Generic
        DEFAULT_PORT = 873
      end
      register_scheme 'RSYNC', RSYNC
    end
    #=> URI::RSYNC

    URI.scheme_list
    #=> {"FILE"=>URI::File, "FTP"=>URI::FTP, "HTTP"=>URI::HTTP,
    #    "HTTPS"=>URI::HTTPS, "LDAP"=>URI::LDAP, "LDAPS"=>URI::LDAPS,
    #    "MAILTO"=>URI::MailTo, "RSYNC"=>URI::RSYNC}

    uri = URI("rsync://rsync.foo.com")
    #=> #<URI::RSYNC rsync://rsync.foo.com>

## RFC References

A good place to view an RFC spec is http://www.ietf.org/rfc.html.

Here is a list of all related RFC's:
*   [RFC822](http://tools.ietf.org/html/rfc822)
*   [RFC1738](http://tools.ietf.org/html/rfc1738)
*   [RFC2255](http://tools.ietf.org/html/rfc2255)
*   [RFC2368](http://tools.ietf.org/html/rfc2368)
*   [RFC2373](http://tools.ietf.org/html/rfc2373)
*   [RFC2396](http://tools.ietf.org/html/rfc2396)
*   [RFC2732](http://tools.ietf.org/html/rfc2732)
*   [RFC3986](http://tools.ietf.org/html/rfc3986)


## Class tree

*   URI::Generic (in uri/generic.rb)
    *   URI::File - (in uri/file.rb)
    *   URI::FTP - (in uri/ftp.rb)
    *   URI::HTTP - (in uri/http.rb)
        *   URI::HTTPS - (in uri/https.rb)

    *   URI::LDAP - (in uri/ldap.rb)
        *   URI::LDAPS - (in uri/ldaps.rb)

    *   URI::MailTo - (in uri/mailto.rb)

*   URI::Parser - (in uri/common.rb)
*   URI::REGEXP - (in uri/common.rb)
    *   URI::REGEXP::PATTERN - (in uri/common.rb)

*   URI::Util - (in uri/common.rb)
*   URI::Error - (in uri/common.rb)
    *   URI::InvalidURIError - (in uri/common.rb)
    *   URI::InvalidComponentError - (in uri/common.rb)
    *   URI::BadURIError - (in uri/common.rb)



## Copyright Info

Author
:   Akira Yamada <akira@ruby-lang.org>
Documentation
:   Akira Yamada <akira@ruby-lang.org> Dmitry V. Sabanin <sdmitry@lrn.ru>
    Vincent Batts <vbatts@hashbangbash.com>
License
:   Copyright (c) 2001 akira yamada <akira@ruby-lang.org> You can redistribute
    it and/or modify it under the same term as Ruby.

;T;0;	I"URI;T;
[ ;[ ;0;[ ;[ o;;I"[Decodes URL-encoded form data from given `str`.

This decodes application/x-www-form-urlencoded data and returns an array of
key-value arrays.

This refers http://url.spec.whatwg.org/#concept-urlencoded-parser, so this
supports only &-separator, and doesn't support ;-separator.

    ary = URI.decode_www_form("a=1&a=2&b=3")
    ary                   #=> [['a', '1'], ['a', '2'], ['b', '3']]
    ary.assoc('a').last   #=> '1'
    ary.assoc('b').last   #=> '3'
    ary.rassoc('a').last  #=> '2'
    Hash[ary]             #=> {"a"=>"2", "b"=>"3"}

See URI.decode_www_form_component, URI.encode_www_form.

;T;0;;;I"decode_www_form;F;I"URI;T;[o;;I"h::String str, ?::encoding enc, ?isindex: ::boolish, ?use__charset_: ::boolish, ?separator: ::String;T;I""Array[[ ::String, ::String ]];To;;I"Decodes given `str` of URL-encoded form data.

This decodes + to SP.

See URI.encode_www_form_component, URI.decode_www_form.

;T;0;;;I"decode_www_form_component;F;I"URI;T;[o;;I""::String str, ?::encoding enc;T;I"String;To;;I")Generates URL-encoded form data from given `enum`.

This generates application/x-www-form-urlencoded data defined in HTML5 from
given an Enumerable object.

This internally uses URI.encode_www_form_component(str).

This method doesn't convert the encoding of given items, so convert them
before calling this method if you want to send data as other than original
encoding or mixed encoding data. (Strings which are encoded in an HTML5 ASCII
incompatible encoding are converted to UTF-8.)

This method doesn't handle files.  When you send a file, use
multipart/form-data.

This refers https://url.spec.whatwg.org/#concept-urlencoded-serializer

    URI.encode_www_form([["q", "ruby"], ["lang", "en"]])
    #=> "q=ruby&lang=en"
    URI.encode_www_form("q" => "ruby", "lang" => "en")
    #=> "q=ruby&lang=en"
    URI.encode_www_form("q" => ["ruby", "perl"], "lang" => "en")
    #=> "q=ruby&q=perl&lang=en"
    URI.encode_www_form([["q", "ruby"], ["q", "perl"], ["lang", "en"]])
    #=> "q=ruby&q=perl&lang=en"

See URI.encode_www_form_component, URI.decode_www_form.

;T;0;;;I"encode_www_form;F;I"URI;T;[o;;I"<::Enumerable[[ ::_ToS, ::_ToS ]] enum, ?::encoding? enc;T;I"String;To;;I"›Encodes given `str` to URL-encoded form data.

This method doesn't convert *, -, ., 0-9, A-Z, _, a-z, but does convert SP
(ASCII space) to + and converts others to %XX.

If `enc` is given, convert `str` to the encoding before percent encoding.

This is an implementation of
https://www.w3.org/TR/2013/CR-html5-20130806/forms.html#url-encoded-form-data.

See URI.decode_www_form_component, URI.encode_www_form.

;T;0;;;I"encode_www_form_component;F;I"URI;T;[o;;I"!::_ToS str, ?::encoding? enc;T;I"String;To;;I"ú## Synopsis

    URI::extract(str[, schemes][,&blk])

## Args

`str`
:   String to extract URIs from.
`schemes`
:   Limit URI matching to specific schemes.


## Description

Extracts URIs from a string. If block given, iterates through all matched
URIs. Returns nil if block given or array with matches.

## Usage

    require "uri"

    URI.extract("text here http://foo.example.org/bla and here mailto:test@example.com and here also.")
    # => ["http://foo.example.com/bla", "mailto:test@example.com"]

;T;0;;;I"extract;F;I"URI;T;[o;;I"-::String str, ?::Array[::String] schemes;T;I"Array[::String];To;;I"-::String str, ?::Array[::String] schemes;T;I"nil;To;;0;0;;;I"get_encoding;F;I"URI;T;[o;;I"::String label;T;I"Encoding?;To;;I"¦## Synopsis

    URI::join(str[, str, ...])

## Args

`str`
:   String(s) to work with, will be converted to RFC3986 URIs before merging.


## Description

Joins URIs.

## Usage

    require 'uri'

    URI.join("http://example.com/","main.rbx")
    # => #<URI::HTTP http://example.com/main.rbx>

    URI.join('http://example.com', 'foo')
    # => #<URI::HTTP http://example.com/foo>

    URI.join('http://example.com', '/foo', '/bar')
    # => #<URI::HTTP http://example.com/bar>

    URI.join('http://example.com', '/foo', 'bar')
    # => #<URI::HTTP http://example.com/bar>

    URI.join('http://example.com', '/foo/', 'bar')
    # => #<URI::HTTP http://example.com/foo/bar>

;T;0;;;I"	join;F;I"URI;T;[o;;I"!::String str, *::String strs;T;I"URI::Generic;To;;I"## Synopsis

    URI::parse(uri_str)

## Args

`uri_str`
:   String with URI.


## Description

Creates one of the URI's subclasses instance from the string.

## Raises

URI::InvalidURIError
:   Raised if URI given is not a correct one.


## Usage

    require 'uri'

    uri = URI.parse("http://www.ruby-lang.org/")
    # => #<URI::HTTP http://www.ruby-lang.org/>
    uri.scheme
    # => "http"
    uri.host
    # => "www.ruby-lang.org"

It's recommended to first ::escape the provided `uri_str` if there are any
invalid URI characters.

;T;0;;;I"
parse;F;I"URI;T;[o;;I"::_ToStr uri;T;I"ŠURI::File | ::URI::FTP | ::URI::HTTP | ::URI::HTTPS | ::URI::LDAP | ::URI::LDAPS | ::URI::MailTo | ::URI::WS | ::URI::WSS | ::URI::Generic;To;;I"«## Synopsis

    URI::regexp([match_schemes])

## Args

`match_schemes`
:   Array of schemes. If given, resulting regexp matches to URIs whose scheme
    is one of the match_schemes.


## Description

Returns a Regexp object which matches to URI-like strings. The Regexp object
returned by this method includes arbitrary number of capture group
(parentheses).  Never rely on its number.

## Usage

    require 'uri'

    # extract first URI from html_string
    html_string.slice(URI.regexp)

    # remove ftp URIs
    html_string.sub(URI.regexp(['ftp']), '')

    # You should not rely on the number of parentheses
    html_string.scan(URI.regexp) do |*matches|
      p $&
    end

;T;0;;;I"regexp;F;I"URI;T;[o;;I" ?::Array[::String]? schemes;T;I"Regexp;To;;I"-Returns a Hash of the defined schemes.

;T;0;;;I"scheme_list;F;I"URI;T;[o;;I" ;F;I"Hash[::String, ::Class];To;;I"iConstruct a URI instance, using the scheme to detect the appropriate class
from `URI.scheme_list`.

;T;0;;;I"for;F;I"URI;T;[o;;I";::String scheme, *untyped arguments, ?default: ::Class;T;I"ŠURI::File | ::URI::FTP | ::URI::HTTP | ::URI::HTTPS | ::URI::LDAP | ::URI::LDAPS | ::URI::MailTo | ::URI::WS | ::URI::WSS | ::URI::Generic;To;;I"”## Synopsis

    URI::split(uri)

## Args

`uri`
:   String with URI.


## Description

Splits the string on following parts and returns array with result:

*   Scheme
*   Userinfo
*   Host
*   Port
*   Registry
*   Path
*   Opaque
*   Query
*   Fragment


## Usage

    require 'uri'

    URI.split("http://www.ruby-lang.org/")
    # => ["http", nil, "www.ruby-lang.org", nil, nil, "/", nil, nil, nil]

;T;0;;;I"
split;F;I"URI;T;[o;;I"::_ToStr uri;T;I"d[ ::String?, ::String?, ::String?, ::String?, nil, ::String?, ::String?, ::String?, ::String? ];To;;0;0;	I"URI;T;
[ ;[ ;0;[ ;[ o;;0;0;	I"URI;T;
[ ;[ ;0;[ ;[ o;;I"¶
URI is a module providing classes to handle Uniform Resource Identifiers
([RFC2396](http://tools.ietf.org/html/rfc2396)).

## Features

*   Uniform way of handling URIs.
*   Flexibility to introduce custom URI schemes.
*   Flexibility to have an alternate URI::Parser (or just different patterns
    and regexp's).


## Basic example

    require 'uri'

    uri = URI("http://foo.com/posts?id=30&limit=5#time=1305298413")
    #=> #<URI::HTTP http://foo.com/posts?id=30&limit=5#time=1305298413>

    uri.scheme    #=> "http"
    uri.host      #=> "foo.com"
    uri.path      #=> "/posts"
    uri.query     #=> "id=30&limit=5"
    uri.fragment  #=> "time=1305298413"

    uri.to_s      #=> "http://foo.com/posts?id=30&limit=5#time=1305298413"

## Adding custom URIs

    module URI
      class RSYNC < Generic
        DEFAULT_PORT = 873
      end
      register_scheme 'RSYNC', RSYNC
    end
    #=> URI::RSYNC

    URI.scheme_list
    #=> {"FILE"=>URI::File, "FTP"=>URI::FTP, "HTTP"=>URI::HTTP,
    #    "HTTPS"=>URI::HTTPS, "LDAP"=>URI::LDAP, "LDAPS"=>URI::LDAPS,
    #    "MAILTO"=>URI::MailTo, "RSYNC"=>URI::RSYNC}

    uri = URI("rsync://rsync.foo.com")
    #=> #<URI::RSYNC rsync://rsync.foo.com>

## RFC References

A good place to view an RFC spec is http://www.ietf.org/rfc.html.

Here is a list of all related RFC's:
*   [RFC822](http://tools.ietf.org/html/rfc822)
*   [RFC1738](http://tools.ietf.org/html/rfc1738)
*   [RFC2255](http://tools.ietf.org/html/rfc2255)
*   [RFC2368](http://tools.ietf.org/html/rfc2368)
*   [RFC2373](http://tools.ietf.org/html/rfc2373)
*   [RFC2396](http://tools.ietf.org/html/rfc2396)
*   [RFC2732](http://tools.ietf.org/html/rfc2732)
*   [RFC3986](http://tools.ietf.org/html/rfc3986)


## Class tree

*   URI::Generic (in uri/generic.rb)
    *   URI::File - (in uri/file.rb)
    *   URI::FTP - (in uri/ftp.rb)
    *   URI::HTTP - (in uri/http.rb)
        *   URI::HTTPS - (in uri/https.rb)

    *   URI::LDAP - (in uri/ldap.rb)
        *   URI::LDAPS - (in uri/ldaps.rb)

    *   URI::MailTo - (in uri/mailto.rb)

*   URI::Parser - (in uri/common.rb)
*   URI::REGEXP - (in uri/common.rb)
    *   URI::REGEXP::PATTERN - (in uri/common.rb)

*   URI::Util - (in uri/common.rb)
*   URI::Error - (in uri/common.rb)
    *   URI::InvalidURIError - (in uri/common.rb)
    *   URI::InvalidComponentError - (in uri/common.rb)
    *   URI::BadURIError - (in uri/common.rb)



## Copyright Info

Author
:   Akira Yamada <akira@ruby-lang.org>
Documentation
:   Akira Yamada <akira@ruby-lang.org> Dmitry V. Sabanin <sdmitry@lrn.ru>
    Vincent Batts <vbatts@hashbangbash.com>
License
:   Copyright (c) 2001 akira yamada <akira@ruby-lang.org> You can redistribute
    it and/or modify it under the same term as Ruby.

;T;0;	I"URI;T;
[ ;[ ;0;[ ;[ o;;0;0;	I"URI;T;
[ ;[ ;0;[ ;[ o;;0;0;	I"URI;T;
[ ;[ ;0;[ ;[ o;;0;0;	I"URI;T;
[ ;[ ;0;[ ;[ o;;0;0;	I"URI;T;
[ ;[ ;0;[ ;[ o;;0;0;	I"URI;T;
[ ;[ ;0;[ ;[ o;;0;0;	I"URI;T;
[ ;[ ;0;[ ;[ o;;0;0;	I"URI;T;
[ ;[ ;0;[ ;[ o;;0;0;	I"URI;T;
[ ;[ ;0;[ ;[ o; ;I",The "file" URI is defined by RFC8089.

;T;0;	I"URI::File;T;
[ ;[ ;0;[ ;[ ;0;I"URI::Generic;To;;I"ˆ## Description

Creates a new URI::File object from components, with syntax checking.

The components accepted are `host` and `path`.

The components should be provided either as an Array, or as a Hash with keys
formed by preceding the component names with a colon.

If an Array is used, the components must be passed in the order `[host,
path]`.

Examples:

    require 'uri'

    uri1 = URI::File.build(['host.example.com', '/path/file.zip'])
    uri1.to_s  # => "file://host.example.com/path/file.zip"

    uri2 = URI::File.build({:host => 'host.example.com',
      :path => '/ruby/src'})
    uri2.to_s  # => "file://host.example.com/ruby/src"

;T;0;;;I"
build;F;I"URI::File;T;[o;;I"::Array[::String] args;T;I"URI::File;To;;I"'{ host: ::String, path: ::String };T;I"URI::File;To;;I"QProtected setter for the host component `v`.

See also URI::Generic.host=.

;T;0;;;I"set_host;F;I"URI::File;T;[o;;I"::String? v;T;I"String;To;;I"do nothing

;T;0;;;I"set_port;F;I"URI::File;T;[o;;I"::Integer v;T;I"nil;To;;I"raise InvalidURIError

;T;0;;;I"check_userinfo;F;I"URI::File;T;[o;;I"::String user;T;I"nil;To;;I"raise InvalidURIError

;T;0;;;I"check_user;F;I"URI::File;T;[o;;I"::String user;T;I"nil;To;;I"raise InvalidURIError

;T;0;;;I"check_password;F;I"URI::File;T;[o;;I"::String user;T;I"nil;To;;I"do nothing

;T;0;;;I"set_userinfo;F;I"URI::File;T;[o;;I"::String v;T;I"nil;To;;I"do nothing

;T;0;;;I"set_user;F;I"URI::File;T;[o;;I"::String v;T;I"nil;To;;I"do nothing

;T;0;;;I"set_password;F;I"URI::File;T;[o;;I"::String v;T;I"nil;To; ;I"!FTP URI syntax is defined by RFC1738 section 3.2.

This class will be redesigned because of difference of implementations; the
structure of its path. draft-hoffman-ftp-uri-04 is a draft but it is a good
summary about the de facto spec.
http://tools.ietf.org/html/draft-hoffman-ftp-uri-04

;T;0;	I"URI::FTP;T;
[ ;[ ;0;[ ;[ ;0;I"URI::Generic;To; ;I"UBase class for all URI classes. Implements generic URI syntax as per RFC 2396.

;T;0;	I"URI::Generic;T;
[ ;[I"URI;T;0;[ ;[ ;0;0o;;I"Returns default port.

;T;0;;;I"default_port;F;I"URI::Generic;T;[o;;I" ;F;I"nil | ::Integer;To;;I"Returns default port.

;T;0;;;I"default_port;F;I"URI::Generic;T;[o;;I" ;F;I"nil | ::Integer;To;;I"*Components of the URI in the order.

;T;0;;;I"component;F;I"URI::Generic;T;[o;;I" ;F;I"Array[::Symbol];To;;0;0;;;I"use_registry;F;I"URI::Generic;T;[o;;I" ;F;I"	bool;To;;I"÷## Synopsis

See ::new.

## Description

At first, tries to create a new URI::Generic instance using
URI::Generic::build. But, if exception URI::InvalidComponentError is raised,
then it does URI::Escape.escape all URI components and tries again.

;T;0;;;I"build2;F;I"URI::Generic;T;[o;;I"(::Array[nil | ::String | ::Integer];T;I"URI::Generic;To;;I"¦{ scheme: ::String, userinfo: ::String, host: ::String, port: ::Integer, registry: ::String?, path: ::String, opaque: ::String?, query: ::String, fragment: ::String };T;I"URI::Generic;To;;I"J## Synopsis

See ::new.

## Description

Creates a new URI::Generic instance from components of URI::Generic with
check.  Components are: scheme, userinfo, host, port, registry, path, opaque,
query, and fragment. You can provide arguments either by an Array or a Hash.
See ::new for hash keys to use or for order of array items.

;T;0;;;I"
build;F;I"URI::Generic;T;[o;;I"(::Array[nil | ::String | ::Integer];T;I"URI::Generic;To;;I"¦{ scheme: ::String, userinfo: ::String, host: ::String, port: ::Integer, registry: ::String?, path: ::String, opaque: ::String?, query: ::String, fragment: ::String };T;I"URI::Generic;To;;I"J## Args

`scheme`
:   Protocol scheme, i.e. 'http','ftp','mailto' and so on.
`userinfo`
:   User name and password, i.e. 'sdmitry:bla'.
`host`
:   Server host name.
`port`
:   Server port.
`registry`
:   Registry of naming authorities.
`path`
:   Path on server.
`opaque`
:   Opaque part.
`query`
:   Query data.
`fragment`
:   Part of the URI after '#' character.
`parser`
:   Parser for internal use [URI::DEFAULT_PARSER by default].
`arg_check`
:   Check arguments [false by default].


## Description

Creates a new URI::Generic instance from ``generic'' components without check.

;T;0;;;I"initialize;F;I"URI::Generic;T;[o;;I"Î::String? scheme, ::String? userinfo, ::String? host, (::String | ::Integer)? port, nil registry, ::String? path, ::String? opaque, ::String? query, ::String? fragment, ?untyped parser, ?::boolish arg_check;T;I"	void;To;;0;0;;;I"registry;F;I"URI::Generic;T;[o;;I" ;F;I"nil;To;;I"_Returns the parser to be used.

Unless a URI::Parser is defined, DEFAULT_PARSER is used.

;T;0;;;I"parser;F;I"URI::Generic;T;[o;;I" ;F;I"untyped;To;;I")Replaces self by other URI object.

;T;0;;;I"replace!;F;I"URI::Generic;T;[o;;I"::URI::Generic oth;T;I"URI::Generic;To;;I"*Components of the URI in the order.

;T;0;;;I"component;F;I"URI::Generic;T;[o;;I" ;F;I"Array[::Symbol];To;;I"RChecks the scheme `v` component against the URI::Parser Regexp for :SCHEME.

;T;0;;;I"check_scheme;F;I"URI::Generic;T;[o;;I"::String? v;T;I"	true;Fo;;I"UProtected setter for the scheme component `v`.

See also URI::Generic.scheme=.

;T;0;;;I"set_scheme;F;I"URI::Generic;T;[o;;I"::String? v;T;I"String?;To;;I"## Args

`v`
:   String


## Description

Public setter for the scheme component `v` (with validation).

See also URI::Generic.check_scheme.

## Usage

    require 'uri'

    uri = URI.parse("http://my.example.com")
    uri.scheme = "https"
    uri.to_s  #=> "https://my.example.com"

;T;0;;;I"scheme=;F;I"URI::Generic;T;[o;;I"::String? v;T;I"String?;To;;I"ÚChecks the `user` and `password`.

If `password` is not provided, then `user` is split, using
URI::Generic.split_userinfo, to pull `user` and +password.

See also URI::Generic.check_user, URI::Generic.check_password.

;T;0;;;I"check_userinfo;F;I"URI::Generic;T;[o;;I"'::String user, ?::String? password;T;I"	true;Fo;;I"½Checks the user `v` component for RFC2396 compliance and against the
URI::Parser Regexp for :USERINFO.

Can not have a registry or opaque component defined, with a user component
defined.

;T;0;;;I"check_user;F;I"URI::Generic;T;[o;;I"::String v;T;I"String | true;To;;I"ÁChecks the password `v` component for RFC2396 compliance and against the
URI::Parser Regexp for :USERINFO.

Can not have a registry or opaque component defined, with a user component
defined.

;T;0;;;I"check_password;F;I"URI::Generic;T;[o;;I" ::String? v, ?::String user;T;I"String? | true;To;;I":Sets userinfo, argument is string like 'name:pass'.

;T;0;;;I"userinfo=;F;I"URI::Generic;T;[o;;I"::String? userinfo;T;I"String?;To;;I"4## Args

`v`
:   String


## Description

Public setter for the `user` component (with validation).

See also URI::Generic.check_user.

## Usage

    require 'uri'

    uri = URI.parse("http://john:S3nsit1ve@my.example.com")
    uri.user = "sam"
    uri.to_s  #=> "http://sam:V3ry_S3nsit1ve@my.example.com"

;T;0;;;I"
user=;F;I"URI::Generic;T;[o;;I"::String? user;T;I"String?;To;;I"L## Args

`v`
:   String


## Description

Public setter for the `password` component (with validation).

See also URI::Generic.check_password.

## Usage

    require 'uri'

    uri = URI.parse("http://john:S3nsit1ve@my.example.com")
    uri.password = "V3ry_S3nsit1ve"
    uri.to_s  #=> "http://john:V3ry_S3nsit1ve@my.example.com"

;T;0;;;I"password=;F;I"URI::Generic;T;[o;;I"::String? password;T;I"String?;To;;I"}Protected setter for the `user` component, and `password` if available (with
validation).

See also URI::Generic.userinfo=.

;T;0;;;I"set_userinfo;F;I"URI::Generic;T;[o;;I"(::String? user, ?::String? password;T;I"[ ::String?, ::String? ];To;;I"QProtected setter for the user component `v`.

See also URI::Generic.user=.

;T;0;;;I"set_user;F;I"URI::Generic;T;[o;;I"::String? v;T;I"String?;To;;I"YProtected setter for the password component `v`.

See also URI::Generic.password=.

;T;0;;;I"set_password;F;I"URI::Generic;T;[o;;I"::String? v;T;I"String?;To;;I"`Returns the userinfo `ui` as `[user, password]` if properly formatted as
'user:password'.

;T;0;;;I"split_userinfo;F;I"URI::Generic;T;[o;;I"::String ui;T;I"Array[::String | nil];To;;I"AEscapes 'user:password' `v` based on RFC 1738 section 3.1.

;T;0;;;I"escape_userpass;F;I"URI::Generic;T;[o;;I"::String v;T;I"String;To;;I"AReturns the userinfo, either as 'user' or 'user:password'.

;T;0;;;I"userinfo;F;I"URI::Generic;T;[o;;I" ;F;I"String?;To;;I""Returns the user component.

;T;0;;;I"	user;F;I"URI::Generic;T;[o;;I" ;F;I"String?;To;;I"&Returns the password component.

;T;0;;;I"password;F;I"URI::Generic;T;[o;;I" ;F;I"String?;To;;I"¹Checks the host `v` component for RFC2396 compliance and against the
URI::Parser Regexp for :HOST.

Can not have a registry or opaque component defined, with a host component
defined.

;T;0;;;I"check_host;F;I"URI::Generic;T;[o;;I"::String? v;T;I"
true?;To;;I"QProtected setter for the host component `v`.

See also URI::Generic.host=.

;T;0;;;I"set_host;F;I"URI::Generic;T;[o;;I"::String? v;T;I"String?;To;;I"## Args

`v`
:   String


## Description

Public setter for the host component `v` (with validation).

See also URI::Generic.check_host.

## Usage

    require 'uri'

    uri = URI.parse("http://my.example.com")
    uri.host = "foo.com"
    uri.to_s  #=> "http://foo.com"

;T;0;;;I"
host=;F;I"URI::Generic;T;[o;;I"::String? v;T;I"String?;To;;I"Extract the host part of the URI and unwrap brackets for IPv6 addresses.

This method is the same as URI::Generic#host except brackets for IPv6 (and
future IP) addresses are removed.

    uri = URI("http://[::1]/bar")
    uri.hostname      #=> "::1"
    uri.host          #=> "[::1]"

;T;0;;;I"hostname;F;I"URI::Generic;T;[o;;I" ;F;I"String?;To;;I"ZSets the host part of the URI as the argument with brackets for IPv6
addresses.

This method is the same as URI::Generic#host= except the argument can be a
bare IPv6 address.

    uri = URI("http://foo/bar")
    uri.hostname = "::1"
    uri.to_s  #=> "http://[::1]/bar"

If the argument seems to be an IPv6 address, it is wrapped with brackets.

;T;0;;;I"hostname=;F;I"URI::Generic;T;[o;;I"::String? v;T;I"String?;To;;I"¹Checks the port `v` component for RFC2396 compliance and against the
URI::Parser Regexp for :PORT.

Can not have a registry or opaque component defined, with a port component
defined.

;T;0;;;I"check_port;F;I"URI::Generic;T;[o;;I"(::String | ::Integer)? v;T;I"
true?;To;;I"QProtected setter for the port component `v`.

See also URI::Generic.port=.

;T;0;;;I"set_port;F;I"URI::Generic;T;[o;;I"(::String | ::Integer)? v;T;I"(::String | ::Integer)?;To;;I"## Args

`v`
:   String


## Description

Public setter for the port component `v` (with validation).

See also URI::Generic.check_port.

## Usage

    require 'uri'

    uri = URI.parse("http://my.example.com")
    uri.port = 8080
    uri.to_s  #=> "http://my.example.com:8080"

;T;0;;;I"
port=;F;I"URI::Generic;T;[o;;I"(::String | ::Integer)? v;T;I"(::String | ::Integer)?;To;;0;0;;;I"check_registry;F;I"URI::Generic;T;[o;;I"::String v;T;I"nil;To;;0;0;;;I"set_registry;F;I"URI::Generic;T;[o;;I"::String v;T;I"nil;To;;I" ;T;0;;;I"registry=;F;I"URI::Generic;T;[o;;I"::String v;T;I"nil;To;;I"¿Checks the path `v` component for RFC2396 compliance and against the
URI::Parser Regexp for :ABS_PATH and :REL_PATH.

Can not have a opaque component defined, with a path component defined.

;T;0;;;I"check_path;F;I"URI::Generic;T;[o;;I"::String? v;T;I"	true;Fo;;I"QProtected setter for the path component `v`.

See also URI::Generic.path=.

;T;0;;;I"set_path;F;I"URI::Generic;T;[o;;I"::String? v;T;I"String?;To;;I"%## Args

`v`
:   String


## Description

Public setter for the path component `v` (with validation).

See also URI::Generic.check_path.

## Usage

    require 'uri'

    uri = URI.parse("http://my.example.com/pub/files")
    uri.path = "/faq/"
    uri.to_s  #=> "http://my.example.com/faq/"

;T;0;;;I"
path=;F;I"URI::Generic;T;[o;;I"::String? v;T;I"String?;To;;I"ï## Args

`v`
:   String


## Description

Public setter for the query component `v`.

## Usage

    require 'uri'

    uri = URI.parse("http://my.example.com/?id=25")
    uri.query = "id=1"
    uri.to_s  #=> "http://my.example.com/?id=1"

;T;0;;;I"query=;F;I"URI::Generic;T;[o;;I"::String? v;T;I"String?;To;;I"ÇChecks the opaque `v` component for RFC2396 compliance and against the
URI::Parser Regexp for :OPAQUE.

Can not have a host, port, user, or path component defined, with an opaque
component defined.

;T;0;;;I"check_opaque;F;I"URI::Generic;T;[o;;I"::String? v;T;I"
true?;To;;I"UProtected setter for the opaque component `v`.

See also URI::Generic.opaque=.

;T;0;;;I"set_opaque;F;I"URI::Generic;T;[o;;I"::String? v;T;I"String?;To;;I"Ž## Args

`v`
:   String


## Description

Public setter for the opaque component `v` (with validation).

See also URI::Generic.check_opaque.

;T;0;;;I"opaque=;F;I"URI::Generic;T;[o;;I"::String? v;T;I"String?;To;;I"„Checks the fragment `v` component against the URI::Parser Regexp for
:FRAGMENT.

## Args

`v`
:   String


## Description

Public setter for the fragment component `v` (with validation).

## Usage

    require 'uri'

    uri = URI.parse("http://my.example.com/?id=25#time=1305212049")
    uri.fragment = "time=1305212086"
    uri.to_s  #=> "http://my.example.com/?id=25#time=1305212086"

;T;0;;;I"fragment=;F;I"URI::Generic;T;[o;;I"::String? v;T;I"String?;To;;I"Returns true if URI is hierarchical.

## Description

URI has components listed in order of decreasing significance from left to
right, see RFC3986 https://tools.ietf.org/html/rfc3986 1.2.3.

## Usage

    require 'uri'

    uri = URI.parse("http://my.example.com/")
    uri.hierarchical?
    #=> true
    uri = URI.parse("mailto:joe@example.com")
    uri.hierarchical?
    #=> false

;T;0;;;I"hierarchical?;F;I"URI::Generic;T;[o;;I" ;F;I"	bool;To;;I"MReturns true if URI has a scheme (e.g. http:// or https://) specified.

;T;0;;;I"absolute?;F;I"URI::Generic;T;[o;;I" ;F;I"	bool;To;;I"WReturns true if URI does not have a scheme (e.g. http:// or https://)
specified.

;T;0;;;I"relative?;F;I"URI::Generic;T;[o;;I" ;F;I"	bool;To;;I"1Returns an Array of the path split on '/'.

;T;0;;;I"split_path;F;I"URI::Generic;T;[o;;I"::String path;T;I"Array[::String];To;;I"YMerges a base path `base`, with relative path `rel`, returns a modified base
path.

;T;0;;;I"merge_path;F;I"URI::Generic;T;[o;;I" ::String base, ::String rel;T;I"String;To;;I"ù## Args

`oth`
:   URI or String


## Description

Destructive form of #merge.

## Usage

    require 'uri'

    uri = URI.parse("http://my.example.com")
    uri.merge!("/main.rbx?page=1")
    uri.to_s  # => "http://my.example.com/main.rbx?page=1"

;T;0;;;I"merge!;F;I"URI::Generic;T;[o;;I""::URI::Generic | ::string oth;T;I"String;To;;I"ã## Args

`oth`
:   URI or String


## Description

Merges two URIs.

## Usage

    require 'uri'

    uri = URI.parse("http://my.example.com")
    uri.merge("/main.rbx?page=1")
    # => "http://my.example.com/main.rbx?page=1"

;T;0;;;I"
merge;F;I"URI::Generic;T;[o;;I""::URI::Generic | ::string oth;T;I"URI::Generic;To;;I":stopdoc:
;T;0;;;I"route_from_path;F;I"URI::Generic;T;[o;;I"::String src, ::String dst;T;I"String;To;;I":stopdoc:
;T;0;;;I"route_from0;F;I"URI::Generic;T;[o;;I"::String oth;T;I"Array[::URI::Generic];To;;I"## Args

`oth`
:   URI or String


## Description

Calculates relative path from oth to self.

## Usage

    require 'uri'

    uri = URI.parse('http://my.example.com/main.rbx?page=1')
    uri.route_from('http://my.example.com')
    #=> #<URI::Generic /main.rbx?page=1>

;T;0;;;I"route_from;F;I"URI::Generic;T;[o;;I"::String oth;T;I"URI::Generic;To;;I"## Args

`oth`
:   URI or String


## Description

Calculates relative path to oth from self.

## Usage

    require 'uri'

    uri = URI.parse('http://my.example.com')
    uri.route_to('http://my.example.com/main.rbx?page=1')
    #=> #<URI::Generic /main.rbx?page=1>

;T;0;;;I"route_to;F;I"URI::Generic;T;[o;;I"::String oth;T;I"URI::Generic;To;;I"ûReturns normalized URI.

    require 'uri'

    URI("HTTP://my.EXAMPLE.com").normalize
    #=> #<URI::HTTP http://my.example.com/>

Normalization here means:

*   scheme and host are converted to lowercase,
*   an empty path component is set to "/".

;T;0;;;I"normalize;F;I"URI::Generic;T;[o;;I" ;F;I"untyped;To;;I")Destructive version of #normalize.

;T;0;;;I"normalize!;F;I"URI::Generic;T;[o;;I" ;F;I"untyped;To;;I""Constructs String from URI.

;T;0;;;I"	to_s;F;I"URI::Generic;T;[o;;I" ;F;I"String;To;;I"Compares two URIs.

;T;0;;;I"==;F;I"URI::Generic;T;[o;;I"::URI::Generic oth;T;I"	bool;To;;I" ;T;0;;;I"	hash;F;I"URI::Generic;T;[o;;I" ;F;I"Integer;To;;I" ;T;0;;;I"	eql?;F;I"URI::Generic;T;[o;;I"::URI::Generic oth;T;I"	bool;To;;I"KReturns an Array of the components defined from the COMPONENT Array.

;T;0;;;I"component_ary;F;I"URI::Generic;T;[o;;I" ;F;I"&Array[nil | ::String | ::Integer];To;;I"H## Args

`components`
:   Multiple Symbol arguments defined in URI::HTTP.


## Description

Selects specified components from URI.

## Usage

    require 'uri'

    uri = URI.parse('http://myuser:mypass@my.example.com/test.rbx')
    uri.select(:userinfo, :host, :path)
    # => ["myuser:mypass", "my.example.com", "/test.rbx"]

;T;0;;;I"select;F;I"URI::Generic;T;[o;;I"*::Symbol components;T;I"&Array[nil | ::String | ::Integer];To;;I" ;T;0;;;I"inspect;F;I"URI::Generic;T;[o;;I" ;F;I"String;To;;I"'## Args

`v`
:   URI or String


## Description

Attempts to parse other URI `oth`, returns [parsed_oth, self].

## Usage

    require 'uri'

    uri = URI.parse("http://my.example.com")
    uri.coerce("http://foo.com")
    #=> [#<URI::HTTP http://foo.com>, #<URI::HTTP http://my.example.com>]

;T;0;;;I"coerce;F;I"URI::Generic;T;[o;;I""::URI::Generic | ::String oth;T;I"Array[::URI::Generic];To;;I"LReturns a proxy URI. The proxy URI is obtained from environment variables such
as http_proxy, ftp_proxy, no_proxy, etc. If there is no proper proxy, nil is
returned.

If the optional parameter `env` is specified, it is used instead of ENV.

Note that capitalized variables (HTTP_PROXY, FTP_PROXY, NO_PROXY, etc.) are
examined, too.

But http_proxy and HTTP_PROXY is treated specially under CGI environment. It's
because HTTP_PROXY may be set by Proxy: header. So HTTP_PROXY is not used.
http_proxy is not used too if the variable is case insensitive. CGI_HTTP_PROXY
can be used instead.

;T;0;;;I"find_proxy;F;I"URI::Generic;T;[o;;I"?::String env;T;I"nil | ::URI::Generic;To;;0;0;;;I"use_proxy?;F;I"URI::Generic;T;[o;;I"H::String hostname, ::String addr, ::Integer port, ::String no_proxy;T;I"	bool;To; ;I"AThe syntax of HTTP URIs is defined in RFC1738 section 3.3.

Note that the Ruby URI library allows HTTP URLs containing usernames and
passwords. This is not legal as per the RFC, but used to be supported in
Internet Explorer 5 and 6, before the MS04-004 security update. See
<URL:http://support.microsoft.com/kb/834489>.

;T;0;	I"URI::HTTP;T;
[ ;[ ;0;[ ;[ ;0;I"URI::Generic;To;;I"¬## Description

Creates a new URI::HTTP object from components, with syntax checking.

The components accepted are userinfo, host, port, path, query, and fragment.

The components should be provided either as an Array, or as a Hash with keys
formed by preceding the component names with a colon.

If an Array is used, the components must be passed in the order `[userinfo,
host, port, path, query, fragment]`.

Example:

    uri = URI::HTTP.build(host: 'www.example.com', path: '/foo/bar')

    uri = URI::HTTP.build([nil, "www.example.com", nil, "/path",
      "query", 'fragment'])

Currently, if passed userinfo components this method generates invalid HTTP
URIs as per RFC 1738.

;T;0;;;I"
build;F;I"URI::HTTP;T;[o;;I"'::Array[::String | ::Integer] args;T;I"URI::HTTP;To;;I"q{ userinfo: ::String, host: ::String, port: ::Integer, path: ::String, query: ::String, fragment: ::String };T;I"URI::HTTP;To;;I"Å## Description

Returns the authority for an HTTP uri, as defined in
https://datatracker.ietf.org/doc/html/rfc3986/#section-3.2.

Example:

    URI::HTTP.build(host: 'www.example.com', path: '/foo/bar').authority #=> "www.example.com"
    URI::HTTP.build(host: 'www.example.com', port: 8000, path: '/foo/bar').authority #=> "www.example.com:8000"
    URI::HTTP.build(host: 'www.example.com', port: 80, path: '/foo/bar').authority #=> "www.example.com"

;T;0;;;I"authority;F;I"URI::HTTP;T;[o;;I" ;F;I"String;To;;I"&## Description

Returns the origin for an HTTP uri, as defined in
https://datatracker.ietf.org/doc/html/rfc6454.

Example:

    URI::HTTP.build(host: 'www.example.com', path: '/foo/bar').origin #=> "http://www.example.com"
    URI::HTTP.build(host: 'www.example.com', port: 8000, path: '/foo/bar').origin #=> "http://www.example.com:8000"
    URI::HTTP.build(host: 'www.example.com', port: 80, path: '/foo/bar').origin #=> "http://www.example.com"
    URI::HTTPS.build(host: 'www.example.com', path: '/foo/bar').origin #=> "https://www.example.com"

;T;0;;;I"origin;F;I"URI::HTTP;T;[o;;I" ;F;I"String;To;;I"H## Description

Returns the full path for an HTTP request, as required by Net::HTTP::Get.

If the URI contains a query, the full path is URI#path + '?' + URI#query.
Otherwise, the path is simply URI#path.

Example:

    uri = URI::HTTP.build(path: '/foo/bar', query: 'test=true')
    uri.request_uri #  => "/foo/bar?test=true"

;T;0;;;I"request_uri;F;I"URI::HTTP;T;[o;;I" ;F;I"String;To; ;I" The default port for HTTPS URIs is 443, and the scheme is 'https:' rather than
'http:'. Other than that, HTTPS URIs are identical to HTTP URIs; see
URI::HTTP.

;T;0;	I"URI::HTTPS;T;
[ ;[ ;0;[ ;[ ;0;I"URI::HTTP;To; ;I".LDAP URI SCHEMA (described in RFC2255).

;T;0;	I"URI::LDAP;T;
[ ;[ ;0;[ ;[ ;0;I"URI::Generic;To;;I"y## Description

Creates a new URI::LDAP object from components, with syntax checking.

The components accepted are host, port, dn, attributes, scope, filter, and
extensions.

The components should be provided either as an Array, or as a Hash with keys
formed by preceding the component names with a colon.

If an Array is used, the components must be passed in the order `[host, port,
dn, attributes, scope, filter, extensions]`.

Example:

    uri = URI::LDAP.build({:host => 'ldap.example.com',
      :dn => '/dc=example'})

    uri = URI::LDAP.build(["ldap.example.com", nil,
      "/dc=example;dc=com", "query", nil, nil, nil])

;T;0;;;I"
build;F;I"URI::LDAP;T;[o;;I"-::Array[nil | ::String | ::Integer] args;T;I"URI::LDAP;To;;I"…{ host: ::String, port: ::Integer?, dn: ::String, attributes: ::String?, scope: ::String?, filter: ::String?, extensions: ::String? };T;I"URI::LDAP;To;;I" ## Description

Creates a new URI::LDAP object from generic URI components as per RFC 2396. No
LDAP-specific syntax checking is performed.

Arguments are `scheme`, `userinfo`, `host`, `port`, `registry`, `path`,
`opaque`, `query`, and `fragment`, in that order.

Example:

    uri = URI::LDAP.new("ldap", nil, "ldap.example.com", nil, nil,
      "/dc=example;dc=com", nil, "query", nil)

See also URI::Generic.new.

;T;0;;;I"initialize;F;I"URI::LDAP;T;[o;;I"::String schema, ::String? userinfo, ::String host, ::Integer? port, ::String? registry, ::String? path, ::String? opaque, ::String query, ::String? fragment;T;I"URI::LDAP;To;;I"PPrivate method to cleanup `dn` from using the `path` component attribute.

;T;0;;;I"parse_dn;F;I"URI::LDAP;T;[o;;I" ;F;I"nil;To;;I"~Private method to cleanup `attributes`, `scope`, `filter`, and `extensions`
from using the `query` component attribute.

;T;0;;;I"parse_query;F;I"URI::LDAP;T;[o;;I" ;F;I"nil;To;;I"aPrivate method to assemble `query` from `attributes`, `scope`, `filter`, and
`extensions`.

;T;0;;;I"build_path_query;F;I"URI::LDAP;T;[o;;I" ;F;I"String;To;;I"Returns dn.

;T;0;;;I"dn;F;I"URI::LDAP;T;[o;;I" ;F;I"String;To;;I"#Private setter for dn `val`.

;T;0;;;I"set_dn;F;I"URI::LDAP;T;[o;;I"::String val;T;I"String;To;;I"Setter for dn `val`.

;T;0;;;I"dn=;F;I"URI::LDAP;T;[o;;I"::String val;T;I"String;To;;I"Returns attributes.

;T;0;;;I"attributes;F;I"URI::LDAP;T;[o;;I" ;F;I"String;To;;I"+Private setter for attributes `val`.

;T;0;;;I"set_attributes;F;I"URI::LDAP;T;[o;;I"::String val;T;I"String;To;;I"#Setter for attributes `val`.

;T;0;;;I"attributes=;F;I"URI::LDAP;T;[o;;I"::String val;T;I"String;To;;I"Returns scope.

;T;0;;;I"
scope;F;I"URI::LDAP;T;[o;;I" ;F;I"String;To;;I"&Private setter for scope `val`.

;T;0;;;I"set_scope;F;I"URI::LDAP;T;[o;;I"::String val;T;I"String;To;;I"Setter for scope `val`.

;T;0;;;I"scope=;F;I"URI::LDAP;T;[o;;I"::String val;T;I"String;To;;I"Returns filter.

;T;0;;;I"filter;F;I"URI::LDAP;T;[o;;I" ;F;I"String;To;;I"'Private setter for filter `val`.

;T;0;;;I"set_filter;F;I"URI::LDAP;T;[o;;I"::String val;T;I"String;To;;I"Setter for filter `val`.

;T;0;;;I"filter=;F;I"URI::LDAP;T;[o;;I"::String val;T;I"String;To;;I"Returns extensions.

;T;0;;;I"extensions;F;I"URI::LDAP;T;[o;;I" ;F;I"untyped;To;;I"+Private setter for extensions `val`.

;T;0;;;I"set_extensions;F;I"URI::LDAP;T;[o;;I"::String val;T;I"String;To;;I"#Setter for extensions `val`.

;T;0;;;I"extensions=;F;I"URI::LDAP;T;[o;;I"::String val;T;I"String;To;;I"HChecks if URI has a path. For URI::LDAP this will return `false`.

;T;0;;;I"hierarchical?;F;I"URI::LDAP;T;[o;;I" ;F;I"FalseClass;To; ;I" The default port for LDAPS URIs is 636, and the scheme is 'ldaps:' rather than
'ldap:'. Other than that, LDAPS URIs are identical to LDAP URIs; see
URI::LDAP.

;T;0;	I"URI::LDAPS;T;
[ ;[ ;0;[ ;[ ;0;I"URI::LDAP;To; ;I"&RFC6068, the mailto URL scheme.

;T;0;	I"URI::MailTo;T;
[ ;[ ;0;[ ;[ ;0;I"URI::Generic;To;;I"$Includes URI::REGEXP::PATTERN

;T;0;	I"URI::RFC2396_REGEXP;T;
[ ;[ ;0;[ ;[ o; ;I"wClass that parses String's into URI's.

It contains a Hash set of patterns and Regexp's that match and validate.

;T;0;	I"URI::RFC2396_Parser;T;
[ ;[I"URI::RFC2396_REGEXP;T;0;[ ;[ ;0;0o;;I"á## Synopsis

    URI::Parser.new([opts])

## Args

The constructor accepts a hash as options for parser. Keys of options are
pattern names of URI components and values of options are pattern strings. The
constructor generates set of regexps for parsing URIs.

You can use the following keys:

    * :ESCAPED (URI::PATTERN::ESCAPED in default)
    * :UNRESERVED (URI::PATTERN::UNRESERVED in default)
    * :DOMLABEL (URI::PATTERN::DOMLABEL in default)
    * :TOPLABEL (URI::PATTERN::TOPLABEL in default)
    * :HOSTNAME (URI::PATTERN::HOSTNAME in default)

## Examples

    p = URI::Parser.new(:ESCAPED => "(?:%[a-fA-F0-9]{2}|%u[a-fA-F0-9]{4})")
    u = p.parse("http://example.jp/%uABCD") #=> #<URI::HTTP http://example.jp/%uABCD>
    URI.parse(u.to_s) #=> raises URI::InvalidURIError

    s = "http://example.com/ABCD"
    u1 = p.parse(s) #=> #<URI::HTTP http://example.com/ABCD>
    u2 = URI.parse(s) #=> #<URI::HTTP http://example.com/ABCD>
    u1 == u2 #=> true
    u1.eql?(u2) #=> false

;T;0;;;I"initialize;F;I"URI::RFC2396_Parser;T;[o;;I"%?::Hash[::Symbol, ::String] opts;T;I"	void;To;;I"×## Args

`str`
:   String to make safe
`unsafe`
:   Regexp to apply. Defaults to `self.regexp[:UNSAFE]`


## Description

Constructs a safe String from `str`, removing unsafe characters, replacing
them with codes.

;T;0;;;I"escape;F;I"URI::RFC2396_Parser;T;[o;;I"#::String str, ?::Regexp unsafe;T;I"String;To;;I"## Args

`str`
:   String to search
`schemes`
:   Patterns to apply to `str`


## Description

Attempts to parse and merge a set of URIs. If no `block` given, then returns
the result, else it calls `block` for each element in result.

See also URI::Parser.make_regexp.

;T;0;;;I"extract;F;I"URI::RFC2396_Parser;T;[o;;I"-::String str, ?::Array[::String] schemes;T;I"Array[::String];To;;I"-::String str, ?::Array[::String] schemes;T;I"nil;To;;I"k## Args

`uris`
:   an Array of Strings


## Description

Attempts to parse and merge a set of URIs.

;T;0;;;I"	join;F;I"URI::RFC2396_Parser;T;[o;;I"*::String uris;T;I"URI::Generic;To;;I"–Returns Regexp that is default `self.regexp[:ABS_URI_REF]`, unless `schemes`
is provided. Then it is a Regexp.union with `self.pattern[:X_ABS_URI]`.

;T;0;;;I"make_regexp;F;I"URI::RFC2396_Parser;T;[o;;I"?::Array[::String] schemes;T;I"Regexp;To;;I"N## Args

`uri`
:   String


## Description

Parses `uri` and constructs either matching URI scheme object (File, FTP,
HTTP, HTTPS, LDAP, LDAPS, or MailTo) or URI::Generic.

## Usage

    p = URI::Parser.new
    p.parse("ldap://ldap.example.com/dc=example?user=john")
    #=> #<URI::LDAP ldap://ldap.example.com/dc=example?user=john>

;T;0;;;I"
parse;F;I"URI::RFC2396_Parser;T;[o;;I"::String uri;T;I"URI::Generic;To;;I"6Returns a split URI against `regexp[:ABS_URI]`.

;T;0;;;I"
split;F;I"URI::RFC2396_Parser;T;[o;;I"::String uri;T;I"j[ ::String?, ::String?, ::String?, ::String?, ::String?, ::String?, ::String?, ::String?, ::String? ];To;;I"£## Args

`str`
:   String to remove escapes from
`escaped`
:   Regexp to apply. Defaults to `self.regexp[:ESCAPED]`


## Description

Removes escapes from `str`.

;T;0;;;I"unescape;F;I"URI::RFC2396_Parser;T;[o;;I"$::String str, ?::Regexp escaped;T;I"String;To; ;0;0;	I"URI::RFC3986_Parser;T;
[ ;[ ;0;[ ;[ ;0;0o; ;I";The syntax of WS URIs is defined in RFC6455 section 3.

Note that the Ruby URI library allows WS URLs containing usernames and
passwords. This is not legal as per the RFC, but used to be supported in
Internet Explorer 5 and 6, before the MS04-004 security update. See
<URL:http://support.microsoft.com/kb/834489>.

;T;0;	I"URI::WS;T;
[ ;[ ;0;[ ;[ ;0;I"URI::Generic;To; ;I"”The default port for WSS URIs is 443, and the scheme is 'wss:' rather than
'ws:'. Other than that, WSS URIs are identical to WS URIs; see URI::WS.

;T;0;	I"URI::WSS;T;
[ ;[ ;0;[ ;[ ;0;I"URI::WS;To;;I"µYAML Ain't Markup Language

This module provides a Ruby interface for data serialization in YAML format.

The YAML module is an alias of Psych, the YAML engine for Ruby.

## Usage

Working with YAML can be very simple, for example:

    require 'yaml'
    # Parse a YAML string
    YAML.load("--- foo") #=> "foo"

    # Emit some YAML
    YAML.dump("foo")     # => "--- foo\n...\n"
    { :a => 'b'}.to_yaml  # => "---\n:a: b\n"

As the implementation is provided by the Psych library, detailed documentation
can be found in that library's docs (also part of standard library).

## Security

Do not use YAML to load untrusted data. Doing so is unsafe and could allow
malicious input to execute arbitrary code inside your application. Please see
doc/security.rdoc for more information.

## History

Syck was the original YAML implementation in Ruby's standard library developed
by why the lucky stiff.

You can still use Syck, if you prefer, for parsing and emitting YAML, but you
must install the 'syck' gem now in order to use it.

In older Ruby versions, ie. <= 1.9, Syck is still provided, however it was
completely removed with the release of Ruby 2.0.0.

## More info

For more advanced details on the implementation see Psych, and also check out
http://yaml.org for spec details and other helpful information.

Psych is maintained by Aaron Patterson on github:
https://github.com/ruby/psych

Syck can also be found on github: https://github.com/ruby/syck

;T;0;	I"	YAML;T;
[ ;[ ;0;[ ;[ o; ;I"uYAML + DBM = YDBM

YAML::DBM provides the same interface as ::DBM.

However, while DBM only allows strings for both keys and values, this library
allows one to use most Ruby objects for values by first converting them to
YAML. Keys must be strings.

Conversion to and from YAML is performed automatically.

See the documentation for ::DBM and ::YAML for more information.

;T;0;	I"YAML::DBM;T;
[ ;[ ;0;[ ;[ ;0;I"DBM;To;;I"Return value associated with `key` from database.

Returns `nil` if there is no such `key`.

See #fetch for more information.

;T;0;;;I"[];F;I"YAML::DBM;T;[o;;I"::String key;T;I"untyped;To;;I"}Set `key` to `value` in database.

`value` will be converted to YAML before storage.

See #store for more information.

;T;0;;;I"[]=;F;I"YAML::DBM;T;[o;;I"::String key, untyped val;T;I"untyped;To;;I"ÉReturn value associated with `key`.

If there is no value for `key` and no block is given, returns `ifnone`.

Otherwise, calls block passing in the given `key`.

See ::DBM#fetch for more information.

;T;0;;;I"
fetch;F;I"YAML::DBM;T;[o;;I"&::String keystr, ?untyped? ifnone;T;I"untyped;To;;I"ÊDeprecated, used YAML::DBM#key instead.
---
Note: YAML::DBM#index makes warning from internal of ::DBM#index. It says
'DBM#index is deprecated; use DBM#key', but DBM#key behaves not same as
DBM#index.

;T;0;;;I"
index;F;I"YAML::DBM;T;[o;;I"::String keystr;T;I"untyped;To;;I"/Returns the key for the specified value.

;T;0;;;I"key;F;I"YAML::DBM;T;[o;;I"::String keystr;T;I"String;To;;I"MReturns an array containing the values associated with the given keys.

;T;0;;;I"values_at;F;I"YAML::DBM;T;[o;;I"*untyped keys;T;I"Array[untyped];To;;I"RDeletes value from database associated with `key`.

Returns value or `nil`.

;T;0;;;I"delete;F;I"YAML::DBM;T;[o;;I"::String key;T;I"untyped;To;;I"‘Calls the given block once for each `key`, `value` pair in the database.
Deletes all entries for which the block returns true.

Returns `self`.

;T;0;;;I"delete_if;F;I"YAML::DBM;T;[o;;I" ;F;I"untyped;To;;I"‰Converts the contents of the database to an in-memory Hash, then calls
Hash#reject with the specified code block, returning a new Hash.

;T;0;;;I"reject;F;I"YAML::DBM;T;[o;;I" ;F;I"Hash[untyped, untyped];To;;I"`Calls the given block once for each `key`, `value` pair in the database.

Returns `self`.

;T;0;;;I"each_pair;F;I"YAML::DBM;T;[o;;I" ;F;I"untyped;To;;I"ICalls the given block for each value in database.

Returns `self`.

;T;0;;;I"each_value;F;I"YAML::DBM;T;[o;;I" ;F;I"untyped;To;;I"4Returns an array of values from the database.

;T;0;;;I"values;F;I"YAML::DBM;T;[o;;I" ;F;I"untyped;To;;I"BReturns true if specified `value` is found in the database.

;T;0;;;I"has_value?;F;I"YAML::DBM;T;[o;;I"untyped val;T;I"TrueClass | ::FalseClass;To;;I"ÜReturns a Hash (not a DBM database) created by using each value in the
database as a key, with the corresponding key as its value.

Note that all values in the hash will be Strings, but the keys will be actual
objects.

;T;0;;;I"invert;F;I"YAML::DBM;T;[o;;I" ;F;I"Hash[untyped, untyped];To;;I"ªReplaces the contents of the database with the contents of the specified
object. Takes any object which implements the each_pair method, including Hash
and DBM objects.

;T;0;;;I"replace;F;I"YAML::DBM;T;[o;;I"/::Hash[untyped, untyped] | ::YAML::DBM hsh;T;I"YAML::DBM;To;;I"¬Removes a [key, value] pair from the database, and returns it. If the database
is empty, returns `nil`.

The order in which values are removed/returned is not guaranteed.

;T;0;;;I"
shift;F;I"YAML::DBM;T;[o;;I" ;F;I"Array[untyped] | untyped;To;;I"ŒIf a block is provided, returns a new array containing [key, value] pairs for
which the block returns true.

Otherwise, same as #values_at

;T;0;;;I"select;F;I"YAML::DBM;T;[o;;I"*untyped keys;T;I"Array[untyped];To;;I"}Stores `value` in database with `key` as the index. `value` is converted to
YAML before being stored.

Returns `value`

;T;0;;;I"
store;F;I"YAML::DBM;T;[o;;I"::String key, untyped val;T;I"untyped;To;;I"¯Updates the database with multiple values from the specified object. Takes any
object which implements the each_pair method, including Hash and DBM objects.

Returns `self`.

;T;0;;;I"update;F;I"YAML::DBM;T;[o;;I"::Hash[untyped, untyped];T;I"YAML::DBM;To;;I"`Converts the contents of the database to an array of [key, value] arrays, and
returns it.

;T;0;;;I"	to_a;F;I"YAML::DBM;T;[o;;I" ;F;I"Array[untyped];To;;I"YConverts the contents of the database to an in-memory Hash object, and returns
it.

;T;0;;;I"to_hash;F;I"YAML::DBM;T;[o;;I" ;F;I"Hash[untyped, untyped];To; ;I"¹YAML::Store provides the same functionality as PStore, except it uses YAML to
dump objects instead of Marshal.

## Example

    require 'yaml/store'

    Person = Struct.new :first_name, :last_name

    people = [Person.new("Bob", "Smith"), Person.new("Mary", "Johnson")]

    store = YAML::Store.new "test.store"

    store.transaction do
      store["people"] = people
      store["greeting"] = { "hello" => "world" }
    end

After running the above code, the contents of "test.store" will be:

    ---
    people:
    - !ruby/struct:Person
      first_name: Bob
      last_name: Smith
    - !ruby/struct:Person
      first_name: Mary
      last_name: Johnson
    greeting:
      hello: world

;T;0;	I"YAML::Store;T;
[ ;[ ;0;[ ;[ ;0;I"PStore;To;;I"ƒCreates a new YAML::Store object, which will store data in `file_name`. If the
file does not already exist, it will be created.

YAML::Store objects are always reentrant. But if *thread_safe* is set to true,
then it will become thread-safe at the cost of a minor performance hit.

Options passed in through `yaml_opts` will be used when converting the store
to YAML via Hash#to_yaml().

;T;0;;;I"initialize;F;I"YAML::Store;T;[o;;I"*untyped o;T;I"YAML::Store;To;;0;0;;;I"	dump;F;I"YAML::Store;T;[o;;I"untyped table;T;I"String;To;;0;0;;;I"empty_marshal_checksum;F;I"YAML::Store;T;[o;;I" ;F;I"String;To;;0;0;;;I"empty_marshal_data;F;I"YAML::Store;T;[o;;I" ;F;I"String;To;;0;0;;;I"	load;F;I"YAML::Store;T;[o;;I"::String;T;I"untyped;To;;0;0;;;I",marshal_dump_supports_canonical_option?;F;I"YAML::Store;T;[o;;I" ;F;I"FalseClass;To;;I"®This module provides access to the [zlib library](http://zlib.net). Zlib is
designed to be a portable, free, general-purpose, legally unencumbered -- that
is, not covered by any patents -- lossless data-compression library for use on
virtually any computer hardware and operating system.

The zlib compression library provides in-memory compression and decompression
functions, including integrity checks of the uncompressed data.

The zlib compressed data format is described in RFC 1950, which is a wrapper
around a deflate stream which is described in RFC 1951.

The library also supports reading and writing files in gzip (.gz) format with
an interface similar to that of IO. The gzip format is described in RFC 1952
which is also a wrapper around a deflate stream.

The zlib format was designed to be compact and fast for use in memory and on
communications channels. The gzip format was designed for single-file
compression on file systems, has a larger header than zlib to maintain
directory information, and uses a different, slower check method than zlib.

See your system's zlib.h for further information about zlib

## Sample usage

Using the wrapper to compress strings with default parameters is quite simple:

    require "zlib"

    data_to_compress = File.read("don_quixote.txt")

    puts "Input size: #{data_to_compress.size}"
    #=> Input size: 2347740

    data_compressed = Zlib::Deflate.deflate(data_to_compress)

    puts "Compressed size: #{data_compressed.size}"
    #=> Compressed size: 887238

    uncompressed_data = Zlib::Inflate.inflate(data_compressed)

    puts "Uncompressed data is: #{uncompressed_data}"
    #=> Uncompressed data is: The Project Gutenberg EBook of Don Quixote...

## Class tree

*   Zlib::Deflate
*   Zlib::Inflate
*   Zlib::ZStream
*   Zlib::Error
    *   Zlib::StreamEnd
    *   Zlib::NeedDict
    *   Zlib::DataError
    *   Zlib::StreamError
    *   Zlib::MemError
    *   Zlib::BufError
    *   Zlib::VersionError
    *   Zlib::InProgressError



(if you have GZIP_SUPPORT)
*   Zlib::GzipReader
*   Zlib::GzipWriter
*   Zlib::GzipFile
*   Zlib::GzipFile::Error
    *   Zlib::GzipFile::LengthError
    *   Zlib::GzipFile::CRCError
    *   Zlib::GzipFile::NoFooter

;T;0;	I"	Zlib;T;
[ ;[ ;0;[ ;[ o;;I"äCalculates Adler-32 checksum for `string`, and returns updated value of
`adler`. If `string` is omitted, it returns the Adler-32 initial value. If
`adler` is omitted, it assumes that the initial value is given to `adler`. If
`string` is an IO instance, reads from the IO until the IO returns nil and
returns Adler-32 of all read data.

Example usage:

    require "zlib"

    data = "foo"
    puts "Adler32 checksum: #{Zlib.adler32(data).to_s(16)}"
    #=> Adler32 checksum: 2820145

;T;0;;;I"adler32;F;I"	Zlib;T;[o;;I" ;F;I"Integer;To;;I"::String;T;I"Integer;To;;I"::String, ::Integer;T;I"Integer;To;;I"»Combine two Adler-32 check values in to one.  `alder1` is the first Adler-32
value, `adler2` is the second Adler-32 value.  `len2` is the length of the
string used to generate `adler2`.

;T;0;;;I"adler32_combine;F;I"	Zlib;T;[o;;I"$::Integer, ::Integer, ::Integer;T;I"Integer;To;;I"XCalculates CRC checksum for `string`, and returns updated value of `crc`. If
`string` is omitted, it returns the CRC initial value. If `crc` is omitted, it
assumes that the initial value is given to `crc`. If `string` is an IO
instance, reads from the IO until the IO returns nil and returns CRC checksum
of all read data.

FIXME: expression.

;T;0;;;I"
crc32;F;I"	Zlib;T;[o;;I" ;F;I"Integer;To;;I"::String;T;I"Integer;To;;I"::String, ::Integer;T;I"Integer;To;;I"¯Combine two CRC-32 check values in to one.  `crc1` is the first CRC-32 value,
`crc2` is the second CRC-32 value.  `len2` is the length of the string used to
generate `crc2`.

;T;0;;;I"crc32_combine;F;I"	Zlib;T;[o;;I"$::Integer, ::Integer, ::Integer;T;I"Integer;To;;I"BReturns the table for calculating CRC checksum as an array.

;T;0;;;I"crc_table;F;I"	Zlib;T;[o;;I" ;F;I"Array[::Integer];To;;I"Compresses the given `string`. Valid values of level are Zlib::NO_COMPRESSION,
Zlib::BEST_SPEED, Zlib::BEST_COMPRESSION, Zlib::DEFAULT_COMPRESSION, or an
integer from 0 to 9.

This method is almost equivalent to the following code:

    def deflate(string, level)
      z = Zlib::Deflate.new(level)
      dst = z.deflate(string, Zlib::FINISH)
      z.close
      dst
    end

See also Zlib.inflate

;T;0;;;I"deflate;F;I"	Zlib;T;[o;;I"::String;T;I"String;To;;I"::String, ::Integer;T;I"String;To;;I" Decode the given gzipped `string`.

This method is almost equivalent to the following code:

    def gunzip(string)
      sio = StringIO.new(string)
      gz = Zlib::GzipReader.new(sio, encoding: Encoding::ASCII_8BIT)
      gz.read
    ensure
      gz&.close
    end

See also Zlib.gzip

;T;0;;;I"gunzip;F;I"	Zlib;T;[o;;I"::String;T;I"String;To;;I"ÔGzip the given `string`. Valid values of level are Zlib::NO_COMPRESSION,
Zlib::BEST_SPEED, Zlib::BEST_COMPRESSION, Zlib::DEFAULT_COMPRESSION (default),
or an integer from 0 to 9.

This method is almost equivalent to the following code:

    def gzip(string, level: nil, strategy: nil)
      sio = StringIO.new
      sio.binmode
      gz = Zlib::GzipWriter.new(sio, level, strategy)
      gz.write(string)
      gz.close
      sio.string
    end

See also Zlib.gunzip

;T;0;;;I"	gzip;F;I"	Zlib;T;[	o;;I"::String;T;I"String;To;;I"::String, level: ::Integer;T;I"String;To;;I""::String, strategy: ::Integer;T;I"String;To;;I"4::String, level: ::Integer, strategy: ::Integer;T;I"String;To;;I"XDecompresses `string`. Raises a Zlib::NeedDict exception if a preset
dictionary is needed for decompression.

This method is almost equivalent to the following code:

    def inflate(string)
      zstream = Zlib::Inflate.new
      buf = zstream.inflate(string)
      zstream.finish
      zstream.close
      buf
    end

See also Zlib.deflate

;T;0;;;I"inflate;F;I"	Zlib;T;[o;;I"::String;T;I"String;To;;I"GReturns the string which represents the version of zlib library.

;T;0;;;I"zlib_version;F;I"	Zlib;T;[o;;I" ;F;I"String;To:+Rucoa::Definitions::ConstantDefinition;I"The imaginary unit.

;T;0;	I"Complex::I;To;;I"¡ARGF is a stream designed for use in scripts that process files given as
command-line arguments or passed in via STDIN.

See ARGF (the class) for more details.

;T;0;	I"	ARGF;To;;I"ˆARGV contains the command line arguments used to run ruby.

A library like OptionParser can be used to process command-line arguments.

;T;0;	I"	ARGV;To;;0;0;	I"CROSS_COMPILING;To;;0;0;	I"
FALSE;To;;0;0;	I"NIL;To;;I"$The copyright string for ruby

;T;0;	I"RUBY_COPYRIGHT;To;;I":The full ruby version string, like `ruby -v` prints

;T;0;	I"RUBY_DESCRIPTION;To;;I"0The engine or interpreter this ruby uses.

;T;0;	I"RUBY_ENGINE;To;;I"?The version of the engine or interpreter this ruby uses.

;T;0;	I"RUBY_ENGINE_VERSION;To;;I"fThe patchlevel for this ruby.  If this is a development build of ruby the
patchlevel will be -1

;T;0;	I"RUBY_PATCHLEVEL;To;;I"!The platform for this ruby

;T;0;	I"RUBY_PLATFORM;To;;I"&The date this ruby was released

;T;0;	I"RUBY_RELEASE_DATE;To;;I")The GIT commit hash for this ruby.

;T;0;	I"RUBY_REVISION;To;;I""The running version of ruby

;T;0;	I"RUBY_VERSION;To;;I" Holds the original stderr

;T;0;	I"STDERR;To;;I"Holds the original stdin

;T;0;	I"
STDIN;To;;I" Holds the original stdout

;T;0;	I"STDOUT;To;;I")The Binding of the top level scope

;T;0;	I"TOPLEVEL_BINDING;To;;0;0;	I"	TRUE;To;;I"%An obsolete class, use Integer

;T;0;	I"Fixnum;To;;I"%An obsolete class, use Integer

;T;0;	I"Bignum;To;;0;0;	I"Encoding::ANSI_X3_4_1968;To;;0;0;	I"Encoding::ASCII;To;;0;0;	I"Encoding::ASCII_8BIT;To;;0;0;	I"Encoding::BIG5;To;;0;0;	I"Encoding::BIG5_HKSCS;To;;0;0;	I"Encoding::BIG5_HKSCS_2008;To;;0;0;	I"Encoding::BIG5_UAO;To;;0;0;	I"Encoding::BINARY;To;;0;0;	I"Encoding::Big5;To;;0;0;	I"Encoding::Big5_HKSCS;To;;0;0;	I"Encoding::Big5_HKSCS_2008;To;;0;0;	I"Encoding::Big5_UAO;To;;0;0;	I"Encoding::CESU_8;To;;0;0;	I"Encoding::CP1250;To;;0;0;	I"Encoding::CP1251;To;;0;0;	I"Encoding::CP1252;To;;0;0;	I"Encoding::CP1253;To;;0;0;	I"Encoding::CP1254;To;;0;0;	I"Encoding::CP1255;To;;0;0;	I"Encoding::CP1256;To;;0;0;	I"Encoding::CP1257;To;;0;0;	I"Encoding::CP1258;To;;0;0;	I"Encoding::CP437;To;;0;0;	I"Encoding::CP50220;To;;0;0;	I"Encoding::CP50221;To;;0;0;	I"Encoding::CP51932;To;;0;0;	I"Encoding::CP65000;To;;0;0;	I"Encoding::CP65001;To;;0;0;	I"Encoding::CP737;To;;0;0;	I"Encoding::CP775;To;;0;0;	I"Encoding::CP850;To;;0;0;	I"Encoding::CP852;To;;0;0;	I"Encoding::CP855;To;;0;0;	I"Encoding::CP857;To;;0;0;	I"Encoding::CP860;To;;0;0;	I"Encoding::CP861;To;;0;0;	I"Encoding::CP862;To;;0;0;	I"Encoding::CP863;To;;0;0;	I"Encoding::CP864;To;;0;0;	I"Encoding::CP865;To;;0;0;	I"Encoding::CP866;To;;0;0;	I"Encoding::CP869;To;;0;0;	I"Encoding::CP874;To;;0;0;	I"Encoding::CP878;To;;0;0;	I"Encoding::CP932;To;;0;0;	I"Encoding::CP936;To;;0;0;	I"Encoding::CP949;To;;0;0;	I"Encoding::CP950;To;;0;0;	I"Encoding::CP951;To;;0;0;	I"Encoding::CSWINDOWS31J;To;;0;0;	I"Encoding::CsWindows31J;To;;0;0;	I"Encoding::EBCDIC_CP_US;To;;0;0;	I"Encoding::EMACS_MULE;To;;0;0;	I"Encoding::EUCCN;To;;0;0;	I"Encoding::EUCJP;To;;0;0;	I"Encoding::EUCJP_MS;To;;0;0;	I"Encoding::EUCKR;To;;0;0;	I"Encoding::EUCTW;To;;0;0;	I"Encoding::EUC_CN;To;;0;0;	I"Encoding::EUC_JISX0213;To;;0;0;	I"Encoding::EUC_JIS_2004;To;;0;0;	I"Encoding::EUC_JP;To;;0;0;	I"Encoding::EUC_JP_MS;To;;0;0;	I"Encoding::EUC_KR;To;;0;0;	I"Encoding::EUC_TW;To;;0;0;	I"Encoding::Emacs_Mule;To;;0;0;	I"Encoding::EucCN;To;;0;0;	I"Encoding::EucJP;To;;0;0;	I"Encoding::EucJP_ms;To;;0;0;	I"Encoding::EucKR;To;;0;0;	I"Encoding::EucTW;To;;0;0;	I"Encoding::GB12345;To;;0;0;	I"Encoding::GB18030;To;;0;0;	I"Encoding::GB1988;To;;0;0;	I"Encoding::GB2312;To;;0;0;	I"Encoding::GBK;To;;0;0;	I"Encoding::IBM037;To;;0;0;	I"Encoding::IBM437;To;;0;0;	I"Encoding::IBM737;To;;0;0;	I"Encoding::IBM775;To;;0;0;	I"Encoding::IBM850;To;;0;0;	I"Encoding::IBM852;To;;0;0;	I"Encoding::IBM855;To;;0;0;	I"Encoding::IBM857;To;;0;0;	I"Encoding::IBM860;To;;0;0;	I"Encoding::IBM861;To;;0;0;	I"Encoding::IBM862;To;;0;0;	I"Encoding::IBM863;To;;0;0;	I"Encoding::IBM864;To;;0;0;	I"Encoding::IBM865;To;;0;0;	I"Encoding::IBM866;To;;0;0;	I"Encoding::IBM869;To;;0;0;	I"Encoding::ISO2022_JP;To;;0;0;	I"Encoding::ISO2022_JP2;To;;0;0;	I"Encoding::ISO8859_1;To;;0;0;	I"Encoding::ISO8859_10;To;;0;0;	I"Encoding::ISO8859_11;To;;0;0;	I"Encoding::ISO8859_13;To;;0;0;	I"Encoding::ISO8859_14;To;;0;0;	I"Encoding::ISO8859_15;To;;0;0;	I"Encoding::ISO8859_16;To;;0;0;	I"Encoding::ISO8859_2;To;;0;0;	I"Encoding::ISO8859_3;To;;0;0;	I"Encoding::ISO8859_4;To;;0;0;	I"Encoding::ISO8859_5;To;;0;0;	I"Encoding::ISO8859_6;To;;0;0;	I"Encoding::ISO8859_7;To;;0;0;	I"Encoding::ISO8859_8;To;;0;0;	I"Encoding::ISO8859_9;To;;0;0;	I"Encoding::ISO_2022_JP;To;;0;0;	I"Encoding::ISO_2022_JP_2;To;;0;0;	I"Encoding::ISO_2022_JP_KDDI;To;;0;0;	I"Encoding::ISO_8859_1;To;;0;0;	I"Encoding::ISO_8859_10;To;;0;0;	I"Encoding::ISO_8859_11;To;;0;0;	I"Encoding::ISO_8859_13;To;;0;0;	I"Encoding::ISO_8859_14;To;;0;0;	I"Encoding::ISO_8859_15;To;;0;0;	I"Encoding::ISO_8859_16;To;;0;0;	I"Encoding::ISO_8859_2;To;;0;0;	I"Encoding::ISO_8859_3;To;;0;0;	I"Encoding::ISO_8859_4;To;;0;0;	I"Encoding::ISO_8859_5;To;;0;0;	I"Encoding::ISO_8859_6;To;;0;0;	I"Encoding::ISO_8859_7;To;;0;0;	I"Encoding::ISO_8859_8;To;;0;0;	I"Encoding::ISO_8859_9;To;;0;0;	I"Encoding::KOI8_R;To;;0;0;	I"Encoding::KOI8_U;To;;0;0;	I"Encoding::MACCENTEURO;To;;0;0;	I"Encoding::MACCROATIAN;To;;0;0;	I"Encoding::MACCYRILLIC;To;;0;0;	I"Encoding::MACGREEK;To;;0;0;	I"Encoding::MACICELAND;To;;0;0;	I"Encoding::MACJAPAN;To;;0;0;	I"Encoding::MACJAPANESE;To;;0;0;	I"Encoding::MACROMAN;To;;0;0;	I"Encoding::MACROMANIA;To;;0;0;	I"Encoding::MACTHAI;To;;0;0;	I"Encoding::MACTURKISH;To;;0;0;	I"Encoding::MACUKRAINE;To;;0;0;	I"Encoding::MacCentEuro;To;;0;0;	I"Encoding::MacCroatian;To;;0;0;	I"Encoding::MacCyrillic;To;;0;0;	I"Encoding::MacGreek;To;;0;0;	I"Encoding::MacIceland;To;;0;0;	I"Encoding::MacJapan;To;;0;0;	I"Encoding::MacJapanese;To;;0;0;	I"Encoding::MacRoman;To;;0;0;	I"Encoding::MacRomania;To;;0;0;	I"Encoding::MacThai;To;;0;0;	I"Encoding::MacTurkish;To;;0;0;	I"Encoding::MacUkraine;To;;0;0;	I"Encoding::PCK;To;;0;0;	I"Encoding::SHIFT_JIS;To;;0;0;	I"Encoding::SJIS;To;;0;0;	I"Encoding::SJIS_DOCOMO;To;;0;0;	I"Encoding::SJIS_DoCoMo;To;;0;0;	I"Encoding::SJIS_KDDI;To;;0;0;	I"Encoding::SJIS_SOFTBANK;To;;0;0;	I"Encoding::SJIS_SoftBank;To;;0;0;	I"$Encoding::STATELESS_ISO_2022_JP;To;;0;0;	I")Encoding::STATELESS_ISO_2022_JP_KDDI;To;;0;0;	I"Encoding::Shift_JIS;To;;0;0;	I"$Encoding::Stateless_ISO_2022_JP;To;;0;0;	I")Encoding::Stateless_ISO_2022_JP_KDDI;To;;0;0;	I"Encoding::TIS_620;To;;0;0;	I"Encoding::UCS_2BE;To;;0;0;	I"Encoding::UCS_4BE;To;;0;0;	I"Encoding::UCS_4LE;To;;0;0;	I"Encoding::US_ASCII;To;;0;0;	I"Encoding::UTF8_DOCOMO;To;;0;0;	I"Encoding::UTF8_DoCoMo;To;;0;0;	I"Encoding::UTF8_KDDI;To;;0;0;	I"Encoding::UTF8_MAC;To;;0;0;	I"Encoding::UTF8_SOFTBANK;To;;0;0;	I"Encoding::UTF8_SoftBank;To;;0;0;	I"Encoding::UTF_16;To;;0;0;	I"Encoding::UTF_16BE;To;;0;0;	I"Encoding::UTF_16LE;To;;0;0;	I"Encoding::UTF_32;To;;0;0;	I"Encoding::UTF_32BE;To;;0;0;	I"Encoding::UTF_32LE;To;;0;0;	I"Encoding::UTF_7;To;;0;0;	I"Encoding::UTF_8;To;;0;0;	I"Encoding::UTF_8_HFS;To;;0;0;	I"Encoding::UTF_8_MAC;To;;0;0;	I"Encoding::WINDOWS_1250;To;;0;0;	I"Encoding::WINDOWS_1251;To;;0;0;	I"Encoding::WINDOWS_1252;To;;0;0;	I"Encoding::WINDOWS_1253;To;;0;0;	I"Encoding::WINDOWS_1254;To;;0;0;	I"Encoding::WINDOWS_1255;To;;0;0;	I"Encoding::WINDOWS_1256;To;;0;0;	I"Encoding::WINDOWS_1257;To;;0;0;	I"Encoding::WINDOWS_1258;To;;0;0;	I"Encoding::WINDOWS_31J;To;;0;0;	I"Encoding::WINDOWS_874;To;;0;0;	I"Encoding::Windows_1250;To;;0;0;	I"Encoding::Windows_1251;To;;0;0;	I"Encoding::Windows_1252;To;;0;0;	I"Encoding::Windows_1253;To;;0;0;	I"Encoding::Windows_1254;To;;0;0;	I"Encoding::Windows_1255;To;;0;0;	I"Encoding::Windows_1256;To;;0;0;	I"Encoding::Windows_1257;To;;0;0;	I"Encoding::Windows_1258;To;;0;0;	I"Encoding::Windows_31J;To;;0;0;	I"Encoding::Windows_874;To;;I"ŽAFTER_OUTPUT

Stop converting after some output is complete but before all of the input was
consumed.  See primitive_convert for an example.

;T;0;	I"&Encoding::Converter::AFTER_OUTPUT;To;;I"BCRLF_NEWLINE_DECORATOR

Decorator for converting LF to CRLF

;T;0;	I"0Encoding::Converter::CRLF_NEWLINE_DECORATOR;To;;I">CR_NEWLINE_DECORATOR

Decorator for converting LF to CR

;T;0;	I".Encoding::Converter::CR_NEWLINE_DECORATOR;To;;I"4INVALID_MASK

Mask for invalid byte sequences

;T;0;	I"&Encoding::Converter::INVALID_MASK;To;;I"6INVALID_REPLACE

Replace invalid byte sequences

;T;0;	I")Encoding::Converter::INVALID_REPLACE;To;;I"qPARTIAL_INPUT

Indicates the source may be part of a larger string.  See primitive_convert
for an example.

;T;0;	I"'Encoding::Converter::PARTIAL_INPUT;To;;I"ªUNDEF_HEX_CHARREF

Replace byte sequences that are undefined in the destination encoding with an
XML hexadecimal character reference.  This is valid for XML conversion.

;T;0;	I"+Encoding::Converter::UNDEF_HEX_CHARREF;To;;I"yUNDEF_MASK

Mask for a valid character in the source encoding but no related character(s)
in destination encoding.

;T;0;	I"$Encoding::Converter::UNDEF_MASK;To;;I"\UNDEF_REPLACE

Replace byte sequences that are undefined in the destination encoding.

;T;0;	I"'Encoding::Converter::UNDEF_REPLACE;To;;I"NUNIVERSAL_NEWLINE_DECORATOR

Decorator for converting CRLF and CR to LF

;T;0;	I"5Encoding::Converter::UNIVERSAL_NEWLINE_DECORATOR;To;;I"9XML_ATTR_CONTENT_DECORATOR

Escape as XML AttValue

;T;0;	I"4Encoding::Converter::XML_ATTR_CONTENT_DECORATOR;To;;I"7XML_ATTR_QUOTE_DECORATOR

Escape as XML AttValue

;T;0;	I"2Encoding::Converter::XML_ATTR_QUOTE_DECORATOR;To;;I"1XML_TEXT_DECORATOR

Escape as XML CharData

;T;0;	I",Encoding::Converter::XML_TEXT_DECORATOR;To;;I"dENV is a Hash-like accessor for environment variables.

See ENV (the class) for more details.

;T;0;	I"ENV;To;;0;0;	I"Errno::E2BIG::Errno;To;;0;0;	I"Errno::EACCES::Errno;To;;0;0;	I"Errno::EADDRINUSE::Errno;To;;0;0;	I" Errno::EADDRNOTAVAIL::Errno;To;;0;0;	I"Errno::EADV::Errno;To;;0;0;	I"Errno::EAFNOSUPPORT::Errno;To;;0;0;	I"Errno::EAGAIN::Errno;To;;0;0;	I"Errno::EALREADY::Errno;To;;0;0;	I"Errno::EAUTH::Errno;To;;0;0;	I"Errno::EBADE::Errno;To;;0;0;	I"Errno::EBADF::Errno;To;;0;0;	I"Errno::EBADFD::Errno;To;;0;0;	I"Errno::EBADMSG::Errno;To;;0;0;	I"Errno::EBADR::Errno;To;;0;0;	I"Errno::EBADRPC::Errno;To;;0;0;	I"Errno::EBADRQC::Errno;To;;0;0;	I"Errno::EBADSLT::Errno;To;;0;0;	I"Errno::EBFONT::Errno;To;;0;0;	I"Errno::EBUSY::Errno;To;;0;0;	I"Errno::ECANCELED::Errno;To;;0;0;	I"Errno::ECAPMODE::Errno;To;;0;0;	I"Errno::ECHILD::Errno;To;;0;0;	I"Errno::ECHRNG::Errno;To;;0;0;	I"Errno::ECOMM::Errno;To;;0;0;	I"Errno::ECONNABORTED::Errno;To;;0;0;	I"Errno::ECONNREFUSED::Errno;To;;0;0;	I"Errno::ECONNRESET::Errno;To;;0;0;	I"Errno::EDEADLK::Errno;To;;0;0;	I"Errno::EDEADLOCK::Errno;To;;0;0;	I"Errno::EDESTADDRREQ::Errno;To;;0;0;	I"Errno::EDOM::Errno;To;;0;0;	I"Errno::EDOOFUS::Errno;To;;0;0;	I"Errno::EDOTDOT::Errno;To;;0;0;	I"Errno::EDQUOT::Errno;To;;0;0;	I"Errno::EEXIST::Errno;To;;0;0;	I"Errno::EFAULT::Errno;To;;0;0;	I"Errno::EFBIG::Errno;To;;0;0;	I"Errno::EFTYPE::Errno;To;;0;0;	I"Errno::EHOSTDOWN::Errno;To;;0;0;	I"Errno::EHOSTUNREACH::Errno;To;;0;0;	I"Errno::EHWPOISON::Errno;To;;0;0;	I"Errno::EIDRM::Errno;To;;0;0;	I"Errno::EILSEQ::Errno;To;;0;0;	I"Errno::EINPROGRESS::Errno;To;;0;0;	I"Errno::EINTR::Errno;To;;0;0;	I"Errno::EINVAL::Errno;To;;0;0;	I"Errno::EIO::Errno;To;;0;0;	I"Errno::EIPSEC::Errno;To;;0;0;	I"Errno::EISCONN::Errno;To;;0;0;	I"Errno::EISDIR::Errno;To;;0;0;	I"Errno::EISNAM::Errno;To;;0;0;	I"Errno::EKEYEXPIRED::Errno;To;;0;0;	I"Errno::EKEYREJECTED::Errno;To;;0;0;	I"Errno::EKEYREVOKED::Errno;To;;0;0;	I"Errno::EL2HLT::Errno;To;;0;0;	I"Errno::EL2NSYNC::Errno;To;;0;0;	I"Errno::EL3HLT::Errno;To;;0;0;	I"Errno::EL3RST::Errno;To;;0;0;	I"Errno::ELIBACC::Errno;To;;0;0;	I"Errno::ELIBBAD::Errno;To;;0;0;	I"Errno::ELIBEXEC::Errno;To;;0;0;	I"Errno::ELIBMAX::Errno;To;;0;0;	I"Errno::ELIBSCN::Errno;To;;0;0;	I"Errno::ELNRNG::Errno;To;;0;0;	I"Errno::ELOOP::Errno;To;;0;0;	I"Errno::EMEDIUMTYPE::Errno;To;;0;0;	I"Errno::EMFILE::Errno;To;;0;0;	I"Errno::EMLINK::Errno;To;;0;0;	I"Errno::EMSGSIZE::Errno;To;;0;0;	I"Errno::EMULTIHOP::Errno;To;;0;0;	I"Errno::ENAMETOOLONG::Errno;To;;0;0;	I"Errno::ENAVAIL::Errno;To;;0;0;	I"Errno::ENEEDAUTH::Errno;To;;0;0;	I"Errno::ENETDOWN::Errno;To;;0;0;	I"Errno::ENETRESET::Errno;To;;0;0;	I"Errno::ENETUNREACH::Errno;To;;0;0;	I"Errno::ENFILE::Errno;To;;0;0;	I"Errno::ENOANO::Errno;To;;0;0;	I"Errno::ENOATTR::Errno;To;;0;0;	I"Errno::ENOBUFS::Errno;To;;0;0;	I"Errno::ENOCSI::Errno;To;;0;0;	I"Errno::ENODATA::Errno;To;;0;0;	I"Errno::ENODEV::Errno;To;;0;0;	I"Errno::ENOENT::Errno;To;;0;0;	I"Errno::ENOEXEC::Errno;To;;0;0;	I"Errno::ENOKEY::Errno;To;;0;0;	I"Errno::ENOLCK::Errno;To;;0;0;	I"Errno::ENOLINK::Errno;To;;0;0;	I"Errno::ENOMEDIUM::Errno;To;;0;0;	I"Errno::ENOMEM::Errno;To;;0;0;	I"Errno::ENOMSG::Errno;To;;0;0;	I"Errno::ENONET::Errno;To;;0;0;	I"Errno::ENOPKG::Errno;To;;0;0;	I"Errno::ENOPROTOOPT::Errno;To;;0;0;	I"Errno::ENOSPC::Errno;To;;0;0;	I"Errno::ENOSR::Errno;To;;0;0;	I"Errno::ENOSTR::Errno;To;;0;0;	I"Errno::ENOSYS::Errno;To;;0;0;	I"Errno::ENOTBLK::Errno;To;;0;0;	I"Errno::ENOTCAPABLE::Errno;To;;0;0;	I"Errno::ENOTCONN::Errno;To;;0;0;	I"Errno::ENOTDIR::Errno;To;;0;0;	I"Errno::ENOTEMPTY::Errno;To;;0;0;	I"Errno::ENOTNAM::Errno;To;;0;0;	I""Errno::ENOTRECOVERABLE::Errno;To;;0;0;	I"Errno::ENOTSOCK::Errno;To;;0;0;	I"Errno::ENOTSUP::Errno;To;;0;0;	I"Errno::ENOTTY::Errno;To;;0;0;	I"Errno::ENOTUNIQ::Errno;To;;0;0;	I"Errno::ENXIO::Errno;To;;0;0;	I"Errno::EOPNOTSUPP::Errno;To;;0;0;	I"Errno::EOVERFLOW::Errno;To;;0;0;	I"Errno::EOWNERDEAD::Errno;To;;0;0;	I"Errno::EPERM::Errno;To;;0;0;	I"Errno::EPFNOSUPPORT::Errno;To;;0;0;	I"Errno::EPIPE::Errno;To;;0;0;	I"Errno::EPROCLIM::Errno;To;;0;0;	I"Errno::EPROCUNAVAIL::Errno;To;;0;0;	I" Errno::EPROGMISMATCH::Errno;To;;0;0;	I"Errno::EPROGUNAVAIL::Errno;To;;0;0;	I"Errno::EPROTO::Errno;To;;0;0;	I""Errno::EPROTONOSUPPORT::Errno;To;;0;0;	I"Errno::EPROTOTYPE::Errno;To;;0;0;	I"Errno::ERANGE::Errno;To;;0;0;	I"Errno::EREMCHG::Errno;To;;0;0;	I"Errno::EREMOTE::Errno;To;;0;0;	I"Errno::EREMOTEIO::Errno;To;;0;0;	I"Errno::ERESTART::Errno;To;;0;0;	I"Errno::ERFKILL::Errno;To;;0;0;	I"Errno::EROFS::Errno;To;;0;0;	I"Errno::ERPCMISMATCH::Errno;To;;0;0;	I"Errno::ESHUTDOWN::Errno;To;;0;0;	I""Errno::ESOCKTNOSUPPORT::Errno;To;;0;0;	I"Errno::ESPIPE::Errno;To;;0;0;	I"Errno::ESRCH::Errno;To;;0;0;	I"Errno::ESRMNT::Errno;To;;0;0;	I"Errno::ESTALE::Errno;To;;0;0;	I"Errno::ESTRPIPE::Errno;To;;0;0;	I"Errno::ETIME::Errno;To;;0;0;	I"Errno::ETIMEDOUT::Errno;To;;0;0;	I"Errno::ETOOMANYREFS::Errno;To;;0;0;	I"Errno::ETXTBSY::Errno;To;;0;0;	I"Errno::EUCLEAN::Errno;To;;0;0;	I"Errno::EUNATCH::Errno;To;;0;0;	I"Errno::EUSERS::Errno;To;;0;0;	I"Errno::EWOULDBLOCK::Errno;To;;0;0;	I"Errno::EXDEV::Errno;To;;0;0;	I"Errno::EXFULL::Errno;To;;I".platform specific alternative separator

;T;0;	I"File::ALT_SEPARATOR;To;;I"path list separator

;T;0;	I"File::PATH_SEPARATOR;To;;I"(separates directory parts in path

;T;0;	I"File::SEPARATOR;To;;I"(separates directory parts in path

;T;0;	I"File::Separator;To;;0;0;	I"File::Constants::APPEND;To;;0;0;	I"File::Constants::BINARY;To;;0;0;	I"File::Constants::CREAT;To;;0;0;	I"File::Constants::DIRECT;To;;0;0;	I"File::Constants::DSYNC;To;;0;0;	I"File::Constants::EXCL;To;;0;0;	I""File::Constants::FNM_CASEFOLD;To;;0;0;	I""File::Constants::FNM_DOTMATCH;To;;0;0;	I"!File::Constants::FNM_EXTGLOB;To;;0;0;	I""File::Constants::FNM_NOESCAPE;To;;0;0;	I""File::Constants::FNM_PATHNAME;To;;0;0;	I"#File::Constants::FNM_SHORTNAME;To;;0;0;	I"!File::Constants::FNM_SYSCASE;To;;0;0;	I"File::Constants::LOCK_EX;To;;0;0;	I"File::Constants::LOCK_NB;To;;0;0;	I"File::Constants::LOCK_SH;To;;0;0;	I"File::Constants::LOCK_UN;To;;0;0;	I"File::Constants::NOATIME;To;;0;0;	I"File::Constants::NOCTTY;To;;0;0;	I"File::Constants::NOFOLLOW;To;;0;0;	I"File::Constants::NONBLOCK;To;;0;0;	I"File::Constants::NULL;To;;0;0;	I"File::Constants::RDONLY;To;;0;0;	I"File::Constants::RDWR;To;;0;0;	I"File::Constants::RSYNC;To;;0;0;	I""File::Constants::SHARE_DELETE;To;;0;0;	I"File::Constants::SYNC;To;;0;0;	I"File::Constants::TMPFILE;To;;0;0;	I"File::Constants::TRUNC;To;;0;0;	I"File::Constants::WRONLY;To;;I"vThe minimum number of significant decimal digits in a double-precision
floating point.

Usually defaults to 15.

;T;0;	I"Float::DIG;To;;I"The difference between 1 and the smallest double-precision floating point
number greater than 1.

Usually defaults to 2.2204460492503131e-16.

;T;0;	I"Float::EPSILON;To;;I"4An expression representing positive infinity.

;T;0;	I"Float::INFINITY;To;;I"UThe number of base digits for the `double` data type.

Usually defaults to 53.

;T;0;	I"Float::MANT_DIG;To;;I"~The largest possible integer in a double-precision floating point number.

Usually defaults to 1.7976931348623157e+308.

;T;0;	I"Float::MAX;To;;I"…The largest positive exponent in a double-precision floating point where 10
raised to this power minus 1.

Usually defaults to 308.

;T;0;	I"Float::MAX_10_EXP;To;;I"kThe largest possible exponent value in a double-precision floating point.

Usually defaults to 1024.

;T;0;	I"Float::MAX_EXP;To;;I"?The smallest positive normalized number in a double-precision floating point.

Usually defaults to 2.2250738585072014e-308.

If the platform supports denormalized numbers, there are numbers between zero
and Float::MIN. 0.0.next_float returns the smallest positive floating point
number including denormalized numbers.

;T;0;	I"Float::MIN;To;;I"‡The smallest negative exponent in a double-precision floating point where 10
raised to this power minus 1.

Usually defaults to -307.

;T;0;	I"Float::MIN_10_EXP;To;;I"mThe smallest possible exponent value in a double-precision floating point.

Usually defaults to -1021.

;T;0;	I"Float::MIN_EXP;To;;I"BAn expression representing a value which is "not a number".

;T;0;	I"Float::NAN;To;;I"«The base of the floating point, or number of unique digits used to represent
the number.

Usually defaults to 2 on most systems, which would represent a base-10
decimal.

;T;0;	I"Float::RADIX;To;;I"_Deprecated, do not use.

Represents the rounding mode for floating point addition at the start time.

Usually defaults to 1, rounding to the nearest number.

Other modes include:

-1
:   Indeterminable
0
:   Rounding towards zero
1
:   Rounding to the nearest number
2
:   Rounding towards positive infinity
3
:   Rounding towards negative infinity


;T;0;	I"Float::ROUNDS;To;;I"internal constants

;T;0;	I"GC::INTERNAL_CONSTANTS;To;;I"GC build options

;T;0;	I"GC::OPTS;To;;0;0;	I"IO::Buffer::BIG_ENDIAN;To;;0;0;	I"IO::Buffer::DEFAULT_SIZE;To;;0;0;	I"IO::Buffer::EXTERNAL;To;;0;0;	I"IO::Buffer::HOST_ENDIAN;To;;0;0;	I"IO::Buffer::INTERNAL;To;;0;0;	I"IO::Buffer::LITTLE_ENDIAN;To;;0;0;	I"IO::Buffer::LOCKED;To;;0;0;	I"IO::Buffer::MAPPED;To;;0;0;	I"IO::Buffer::NETWORK_ENDIAN;To;;0;0;	I"IO::Buffer::PAGE_SIZE;To;;0;0;	I"IO::Buffer::PRIVATE;To;;0;0;	I"IO::Buffer::READONLY;To;;0;0;	I"IO::APPEND;To;;0;0;	I"IO::BINARY;To;;0;0;	I"IO::CREAT;To;;0;0;	I"IO::DIRECT;To;;0;0;	I"IO::DSYNC;To;;0;0;	I"IO::EXCL;To;;0;0;	I"IO::FNM_CASEFOLD;To;;0;0;	I"IO::FNM_DOTMATCH;To;;0;0;	I"IO::FNM_EXTGLOB;To;;0;0;	I"IO::FNM_NOESCAPE;To;;0;0;	I"IO::FNM_PATHNAME;To;;0;0;	I"IO::FNM_SHORTNAME;To;;0;0;	I"IO::FNM_SYSCASE;To;;0;0;	I"IO::LOCK_EX;To;;0;0;	I"IO::LOCK_NB;To;;0;0;	I"IO::LOCK_SH;To;;0;0;	I"IO::LOCK_UN;To;;0;0;	I"IO::NOATIME;To;;0;0;	I"IO::NOCTTY;To;;0;0;	I"IO::NOFOLLOW;To;;0;0;	I"IO::NONBLOCK;To;;0;0;	I"IO::NULL;To;;0;0;	I"IO::RDONLY;To;;0;0;	I"IO::RDWR;To;;0;0;	I"IO::RSYNC;To;;I"1Set I/O position from the current position

;T;0;	I"IO::SEEK_CUR;To;;I"<Set I/O position to the next location containing data

;T;0;	I"IO::SEEK_DATA;To;;I"$Set I/O position from the end

;T;0;	I"IO::SEEK_END;To;;I"(Set I/O position to the next hole

;T;0;	I"IO::SEEK_HOLE;To;;I"*Set I/O position from the beginning

;T;0;	I"IO::SEEK_SET;To;;0;0;	I"IO::SHARE_DELETE;To;;0;0;	I"IO::SYNC;To;;0;0;	I"IO::TMPFILE;To;;0;0;	I"IO::TRUNC;To;;0;0;	I"IO::WRONLY;To;;0;0;	I""IO::EAGAINWaitReadable::Errno;To;;0;0;	I""IO::EAGAINWaitWritable::Errno;To;;0;0;	I"'IO::EINPROGRESSWaitReadable::Errno;To;;0;0;	I"'IO::EINPROGRESSWaitWritable::Errno;To;;0;0;	I"(Kernel::RUBYGEMS_ACTIVATION_MONITOR;To;;I"major version

;T;0;	I"Marshal::MAJOR_VERSION;To;;I"minor version

;T;0;	I"Marshal::MINOR_VERSION;To;;I"ZDefinition of the mathematical constant E for Euler's number (e) as a Float
number.

;T;0;	I"Math::E;To;;I"DDefinition of the mathematical constant PI as a Float number.

;T;0;	I"Math::PI;To;;I" see Process.clock_gettime

;T;0;	I"Process::CLOCK_BOOTTIME;To;;I" see Process.clock_gettime

;T;0;	I""Process::CLOCK_BOOTTIME_ALARM;To;;I" see Process.clock_gettime

;T;0;	I"Process::CLOCK_MONOTONIC;To;;I" see Process.clock_gettime

;T;0;	I"$Process::CLOCK_MONOTONIC_COARSE;To;;I" see Process.clock_gettime

;T;0;	I"!Process::CLOCK_MONOTONIC_RAW;To;;I" see Process.clock_gettime

;T;0;	I"&Process::CLOCK_PROCESS_CPUTIME_ID;To;;I" see Process.clock_gettime

;T;0;	I"Process::CLOCK_REALTIME;To;;I" see Process.clock_gettime

;T;0;	I""Process::CLOCK_REALTIME_ALARM;To;;I" see Process.clock_gettime

;T;0;	I"#Process::CLOCK_REALTIME_COARSE;To;;I" see Process.clock_gettime

;T;0;	I"%Process::CLOCK_THREAD_CPUTIME_ID;To;;I"see Process.setpriority

;T;0;	I"Process::PRIO_PGRP;To;;I"see Process.setpriority

;T;0;	I"Process::PRIO_PROCESS;To;;I"see Process.setpriority

;T;0;	I"Process::PRIO_USER;To;;I"~Maximum size of the process's virtual memory (address space) in bytes.

see the system getrlimit(2) manual for details.

;T;0;	I"Process::RLIMIT_AS;To;;I"VMaximum size of the core file.

see the system getrlimit(2) manual for details.

;T;0;	I"Process::RLIMIT_CORE;To;;I"RCPU time limit in seconds.

see the system getrlimit(2) manual for details.

;T;0;	I"Process::RLIMIT_CPU;To;;I"cMaximum size of the process's data segment.

see the system getrlimit(2) manual for details.

;T;0;	I"Process::RLIMIT_DATA;To;;I"jMaximum size of files that the process may create.

see the system getrlimit(2) manual for details.

;T;0;	I"Process::RLIMIT_FSIZE;To;;I"vMaximum number of bytes of memory that may be locked into RAM.

see the system getrlimit(2) manual for details.

;T;0;	I"Process::RLIMIT_MEMLOCK;To;;I"¹Specifies the limit on the number of bytes that can be allocated for POSIX
message queues for the real user ID of the calling process.

see the system getrlimit(2) manual for details.

;T;0;	I"Process::RLIMIT_MSGQUEUE;To;;I"|Specifies a ceiling to which the process's nice value can be raised.

see the system getrlimit(2) manual for details.

;T;0;	I"Process::RLIMIT_NICE;To;;I"œSpecifies a value one greater than the maximum file descriptor number that can
be opened by this process.

see the system getrlimit(2) manual for details.

;T;0;	I"Process::RLIMIT_NOFILE;To;;I"“The maximum number of processes that can be created for the real user ID of
the calling process.

see the system getrlimit(2) manual for details.

;T;0;	I"Process::RLIMIT_NPROC;To;;I"uSpecifies the limit (in pages) of the process's resident set.

see the system getrlimit(2) manual for details.

;T;0;	I"Process::RLIMIT_RSS;To;;I"‚Specifies a ceiling on the real-time priority that may be set for this
process.

see the system getrlimit(2) manual for details.

;T;0;	I"Process::RLIMIT_RTPRIO;To;;I"–Specifies limit on CPU time this process scheduled under a real-time
scheduling policy can consume.

see the system getrlimit(2) manual for details.

;T;0;	I"Process::RLIMIT_RTTIME;To;;I"Specifies a limit on the number of signals that may be queued for the real
user ID of the calling process.

see the system getrlimit(2) manual for details.

;T;0;	I"Process::RLIMIT_SIGPENDING;To;;I"\Maximum size of the stack, in bytes.

see the system getrlimit(2) manual for details.

;T;0;	I"Process::RLIMIT_STACK;To;;I"see Process.setrlimit

;T;0;	I"Process::RLIM_INFINITY;To;;I"see Process.setrlimit

;T;0;	I"Process::RLIM_SAVED_CUR;To;;I"see Process.setrlimit

;T;0;	I"Process::RLIM_SAVED_MAX;To;;I"see Process.wait

;T;0;	I"Process::WNOHANG;To;;I"see Process.wait

;T;0;	I"Process::WUNTRACED;To;;0;0;	I"Random::DEFAULT;To;;I"&The hash configurations stored.

;T;0;	I"RbConfig::CONFIG;To;;I"DESTDIR on make install.

;T;0;	I"RbConfig::DESTDIR;To;;I"àAlmost same with CONFIG. MAKEFILE_CONFIG has other variable reference like
below.

    MAKEFILE_CONFIG["bindir"] = "$(exec_prefix)/bin"

The values of this constant is used for creating Makefile.

    require 'rbconfig'

    print <<-END_OF_MAKEFILE
    prefix = #{RbConfig::MAKEFILE_CONFIG['prefix']}
    exec_prefix = #{RbConfig::MAKEFILE_CONFIG['exec_prefix']}
    bindir = #{RbConfig::MAKEFILE_CONFIG['bindir']}
    END_OF_MAKEFILE

    => prefix = /usr/local
       exec_prefix = $(prefix)
       bindir = $(exec_prefix)/bin  MAKEFILE_CONFIG = {}

RbConfig.expand is used for resolving references like above in rbconfig.

    require 'rbconfig'
    p RbConfig.expand(RbConfig::MAKEFILE_CONFIG["bindir"])
    # => "/usr/local/bin"

;T;0;	I"RbConfig::MAKEFILE_CONFIG;To;;I" Ruby installed directory.

;T;0;	I"RbConfig::TOPDIR;To;;I"(see Regexp.options and Regexp.new

;T;0;	I"Regexp::EXTENDED;To;;I"(see Regexp.options and Regexp.new

;T;0;	I"Regexp::FIXEDENCODING;To;;I"(see Regexp.options and Regexp.new

;T;0;	I"Regexp::IGNORECASE;To;;I"(see Regexp.options and Regexp.new

;T;0;	I"Regexp::MULTILINE;To;;I"(see Regexp.options and Regexp.new

;T;0;	I"Regexp::NOENCODING;To;;I"ðDEFAULT_PARAMS This constant exposes the VM's default parameters. Note that
changing these values does not affect VM execution. Specification is not
stable and you should not depend on this value. Of course, this constant is
MRI specific.

;T;0;	I"RubyVM::DEFAULT_PARAMS;To;;I"dINSTRUCTION_NAMES A list of bytecode instruction names in MRI. This constant
is MRI specific.

;T;0;	I"RubyVM::INSTRUCTION_NAMES;To;;I"HOPTS An Array of VM build options. This constant is MRI specific.

;T;0;	I"RubyVM::OPTS;To;;0;0;	I"ConditionVariable;To;;0;0;	I"
Mutex;To;;0;0;	I"
Queue;To;;0;0;	I"SizedQueue;To;;I"]The default ThreadGroup created when Ruby starts; all Threads belong to it by
default.

;T;0;	I"ThreadGroup::Default;To;;0;0;	I"Time::RFC2822_DAY_NAME;To;;0;0;	I"Time::RFC2822_MONTH_NAME;To;;0;0;	I"!Benchmark::BENCHMARK_VERSION;To;;I"CThe default caption string (heading above the output times).

;T;0;	I"Benchmark::CAPTION;To;;I"XThe default format string used to display times.  See also
Benchmark::Tms#format.

;T;0;	I"Benchmark::FORMAT;To;;I"3Default caption, see also Benchmark::CAPTION

;T;0;	I"Benchmark::Tms::CAPTION;To;;I"8Default format string, see also Benchmark::FORMAT

;T;0;	I"Benchmark::Tms::FORMAT;To;;I" Base value used in internal calculations.  On a 32 bit system, BASE is 10000,
indicating that calculation is done in groups of 4 digits. (If it were larger,
BASE**2 wouldn't fit in 32 bits, so you couldn't guarantee that two groups
could always be multiplied together without overflow.)

;T;0;	I"BigDecimal::BASE;To;;I"vDetermines whether overflow, underflow or zero divide result in an exception
being thrown. See BigDecimal.mode.

;T;0;	I"BigDecimal::EXCEPTION_ALL;To;;I"bDetermines what happens when the result of a computation is infinity.  See
BigDecimal.mode.

;T;0;	I"#BigDecimal::EXCEPTION_INFINITY;To;;I"kDetermines what happens when the result of a computation is not a number
(NaN). See BigDecimal.mode.

;T;0;	I"BigDecimal::EXCEPTION_NaN;To;;I"†Determines what happens when the result of a computation is an overflow (a
result too large to be represented). See BigDecimal.mode.

;T;0;	I"#BigDecimal::EXCEPTION_OVERFLOW;To;;I"‡Determines what happens when the result of a computation is an underflow (a
result too small to be represented). See BigDecimal.mode.

;T;0;	I"$BigDecimal::EXCEPTION_UNDERFLOW;To;;I"YDetermines what happens when a division by zero is performed. See
BigDecimal.mode.

;T;0;	I"%BigDecimal::EXCEPTION_ZERODIVIDE;To;;I"Special value constants

;T;0;	I"BigDecimal::INFINITY;To;;0;0;	I"BigDecimal::NAN;To;;I"4Round towards +Infinity. See BigDecimal.mode.

;T;0;	I"BigDecimal::ROUND_CEILING;To;;I"QIndicates that values should be rounded towards zero. See BigDecimal.mode.

;T;0;	I"BigDecimal::ROUND_DOWN;To;;I"4Round towards -Infinity. See BigDecimal.mode.

;T;0;	I"BigDecimal::ROUND_FLOOR;To;;I"aIndicates that digits >= 6 should be rounded up, others rounded down. See
BigDecimal.mode.

;T;0;	I" BigDecimal::ROUND_HALF_DOWN;To;;I"<Round towards the even neighbor. See BigDecimal.mode.

;T;0;	I" BigDecimal::ROUND_HALF_EVEN;To;;I"aIndicates that digits >= 5 should be rounded up, others rounded down. See
BigDecimal.mode.

;T;0;	I"BigDecimal::ROUND_HALF_UP;To;;I"Determines what happens when a result must be rounded in order to fit in the
appropriate number of significant digits. See BigDecimal.mode.

;T;0;	I"BigDecimal::ROUND_MODE;To;;I"SIndicates that values should be rounded away from zero. See BigDecimal.mode.

;T;0;	I"BigDecimal::ROUND_UP;To;;I"JIndicates that a value is negative and finite. See BigDecimal.sign.

;T;0;	I"%BigDecimal::SIGN_NEGATIVE_FINITE;To;;I"LIndicates that a value is negative and infinite. See BigDecimal.sign.

;T;0;	I"'BigDecimal::SIGN_NEGATIVE_INFINITE;To;;I"9Indicates that a value is -0. See BigDecimal.sign.

;T;0;	I"#BigDecimal::SIGN_NEGATIVE_ZERO;To;;I"CIndicates that a value is not a number. See BigDecimal.sign.

;T;0;	I"BigDecimal::SIGN_NaN;To;;I"JIndicates that a value is positive and finite. See BigDecimal.sign.

;T;0;	I"%BigDecimal::SIGN_POSITIVE_FINITE;To;;I"LIndicates that a value is positive and infinite. See BigDecimal.sign.

;T;0;	I"'BigDecimal::SIGN_POSITIVE_INFINITE;To;;I"9Indicates that a value is +0. See BigDecimal.sign.

;T;0;	I"#BigDecimal::SIGN_POSITIVE_ZERO;To;;I"(The version of bigdecimal library

;T;0;	I"BigDecimal::VERSION;To;;I"!String for carriage return

;T;0;	I"CGI::CR;To;;I")Standard internet newline sequence

;T;0;	I"CGI::EOL;To;;I"HTTP status codes.

;T;0;	I"CGI::HTTP_STATUS;To;;I"String for linefeed

;T;0;	I"CGI::LF;To;;I":Maximum number of request parameters when multipart

;T;0;	I"CGI::MAX_MULTIPART_COUNT;To;;I"<Whether processing will be required in binary vs text

;T;0;	I"CGI::NEEDS_BINMODE;To;;I"1Path separators in different environments.

;T;0;	I"CGI::PATH_SEPARATOR;To;;0;0;	I"CGI::REVISION;To;;0;0;	I"CGI::VERSION;To;;I"8Abbreviated day-of-week names specified by RFC 822
;T;0;	I"CGI::Util::RFC822_DAYS;To;;I"2Abbreviated month names specified by RFC 822
;T;0;	I"CGI::Util::RFC822_MONTHS;To;;I"=The set of special characters and their escaped values

;T;0;	I"'CGI::Util::TABLE_FOR_ESCAPE_HTML__;To;;I")Default values for method options.

;T;0;	I"CSV::DEFAULT_OPTIONS;To;;I",The version of the installed library.

;T;0;	I"CSV::VERSION;To;;I"TAn array of strings of abbreviated day names in English.  The first is "Sun".

;T;0;	I"Date::ABBR_DAYNAMES;To;;I"\An array of strings of abbreviated month names in English.  The first element
is nil.

;T;0;	I"Date::ABBR_MONTHNAMES;To;;I"cAn array of strings of the full names of days of the week in English. The
first is "Sunday".

;T;0;	I"Date::DAYNAMES;To;;I"XThe Julian day number of the day of calendar reform for England and her
colonies.

;T;0;	I"Date::ENGLAND;To;;I"`The Julian day number of the day of calendar reform for the proleptic
Gregorian calendar.

;T;0;	I"Date::GREGORIAN;To;;I"aThe Julian day number of the day of calendar reform for Italy and some
catholic countries.

;T;0;	I"Date::ITALY;To;;I"]The Julian day number of the day of calendar reform for the proleptic Julian
calendar.

;T;0;	I"Date::JULIAN;To;;I"UAn array of strings of full month names in English.  The first element is nil.

;T;0;	I"Date::MONTHNAMES;To;;I"¢Indicates that dbm_open() should open the database in read/write mode, create
it if it does not already exist, and delete all contents if it does already
exist.

;T;0;	I"DBM::NEWDB;To;;I"KIndicates that dbm_open() should open the database in read-only mode

;T;0;	I"DBM::READER;To;;I"íIdentifies ndbm library version.

Examples:

*   "ndbm (4.3BSD)"
*   "Berkeley DB 4.8.30: (April  9, 2010)"
*   "Berkeley DB (unknown)" (4.4BSD, maybe)
*   "GDBM version 1.8.3. 10/15/2002 (built Jul  1 2011 12:32:45)"
*   "QDBM 1.8.78"

;T;0;	I"DBM::VERSION;To;;I"xIndicates that dbm_open() should open the database in read/write mode, and
create it if it does not already exist

;T;0;	I"DBM::WRCREAT;To;;I"LIndicates that dbm_open() should open the database in read/write mode

;T;0;	I"DBM::WRITER;To;;I"TODO: Remove on 3.3:

;T;0;	I"DidYouMean::SPELL_CHECKERS;To;;0;0;	I""DidYouMean::NameErrorCheckers;To;;0;0;	I"DidYouMean::VERSION;To;;0;0;	I"8DidYouMean::Correctable::SKIP_TO_S_FOR_SUPER_LOOKUP;To;;0;0;	I"$DidYouMean::JaroWinkler::WEIGHT;To;;0;0;	I"'DidYouMean::JaroWinkler::THRESHOLD;To;;0;0;	I"4DidYouMean::MethodNameChecker::NAMES_TO_EXCLUDE;To;;I"º`MethodNameChecker::RB_RESERVED_WORDS` is the list of reserved words in Ruby
that take an argument. Unlike `VariableNameChecker::RB_RESERVED_WORDS`, these
reserved words require an argument, and a `NoMethodError` is raised due to the
presence of the argument.

The `MethodNameChecker` will use this list to suggest a reversed word if a
`NoMethodError` is raised and found closest matches.

Also see `VariableNameChecker::RB_RESERVED_WORDS`.

;T;0;	I"5DidYouMean::MethodNameChecker::RB_RESERVED_WORDS;To;;0;0;	I"6DidYouMean::RequirePathChecker::INITIAL_LOAD_PATH;To;;0;0;	I"5DidYouMean::RequirePathChecker::ENV_SPECIFIC_EXT;To;;0;0;	I"6DidYouMean::VariableNameChecker::NAMES_TO_EXCLUDE;To;;I"Á`VariableNameChecker::RB_RESERVED_WORDS` is the list of all reserved words in
Ruby. They could be declared like methods are, and a typo would cause Ruby to
raise a `NameError` because of the way they are declared.

The `:VariableNameChecker` will use this list to suggest a reversed word if a
`NameError` is raised and found closest matches, excluding:

    * +do+
    * +if+
    * +in+
    * +or+

Also see `MethodNameChecker::RB_RESERVED_WORDS`.

;T;0;	I"7DidYouMean::VariableNameChecker::RB_RESERVED_WORDS;To;;I"A mutex for Digest().

;T;0;	I"Digest::REQUIRE_MUTEX;To;;0;0;	I"Etc::CS_PATH;To;;0;0;	I"(Etc::CS_POSIX_V6_ILP32_OFF32_CFLAGS;To;;0;0;	I")Etc::CS_POSIX_V6_ILP32_OFF32_LDFLAGS;To;;0;0;	I"&Etc::CS_POSIX_V6_ILP32_OFF32_LIBS;To;;0;0;	I")Etc::CS_POSIX_V6_ILP32_OFFBIG_CFLAGS;To;;0;0;	I"*Etc::CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS;To;;0;0;	I"'Etc::CS_POSIX_V6_ILP32_OFFBIG_LIBS;To;;0;0;	I"'Etc::CS_POSIX_V6_LP64_OFF64_CFLAGS;To;;0;0;	I"(Etc::CS_POSIX_V6_LP64_OFF64_LDFLAGS;To;;0;0;	I"%Etc::CS_POSIX_V6_LP64_OFF64_LIBS;To;;0;0;	I")Etc::CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS;To;;0;0;	I"*Etc::CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS;To;;0;0;	I"'Etc::CS_POSIX_V6_LPBIG_OFFBIG_LIBS;To;;0;0;	I"+Etc::CS_POSIX_V6_WIDTH_RESTRICTED_ENVS;To;;0;0;	I"Etc::PC_2_SYMLINKS;To;;0;0;	I"Etc::PC_ALLOC_SIZE_MIN;To;;0;0;	I"Etc::PC_ASYNC_IO;To;;0;0;	I"Etc::PC_CHOWN_RESTRICTED;To;;0;0;	I"Etc::PC_FILESIZEBITS;To;;0;0;	I"Etc::PC_LINK_MAX;To;;0;0;	I"Etc::PC_MAX_CANON;To;;0;0;	I"Etc::PC_MAX_INPUT;To;;0;0;	I"Etc::PC_NAME_MAX;To;;0;0;	I"Etc::PC_NO_TRUNC;To;;0;0;	I"Etc::PC_PATH_MAX;To;;0;0;	I"Etc::PC_PIPE_BUF;To;;0;0;	I"Etc::PC_PRIO_IO;To;;0;0;	I"Etc::PC_REC_INCR_XFER_SIZE;To;;0;0;	I"Etc::PC_REC_MAX_XFER_SIZE;To;;0;0;	I"Etc::PC_REC_MIN_XFER_SIZE;To;;0;0;	I"Etc::PC_REC_XFER_ALIGN;To;;0;0;	I"Etc::PC_SYMLINK_MAX;To;;0;0;	I"Etc::PC_SYNC_IO;To;;0;0;	I"Etc::PC_VDISABLE;To;;0;0;	I"Etc::SC_2_CHAR_TERM;To;;0;0;	I"Etc::SC_2_C_BIND;To;;0;0;	I"Etc::SC_2_C_DEV;To;;0;0;	I"Etc::SC_2_FORT_DEV;To;;0;0;	I"Etc::SC_2_FORT_RUN;To;;0;0;	I"Etc::SC_2_LOCALEDEF;To;;0;0;	I"Etc::SC_2_PBS;To;;0;0;	I"Etc::SC_2_PBS_ACCOUNTING;To;;0;0;	I"Etc::SC_2_PBS_CHECKPOINT;To;;0;0;	I"Etc::SC_2_PBS_LOCATE;To;;0;0;	I"Etc::SC_2_PBS_MESSAGE;To;;0;0;	I"Etc::SC_2_PBS_TRACK;To;;0;0;	I"Etc::SC_2_SW_DEV;To;;0;0;	I"Etc::SC_2_UPE;To;;0;0;	I"Etc::SC_2_VERSION;To;;0;0;	I"Etc::SC_ADVISORY_INFO;To;;0;0;	I"Etc::SC_AIO_LISTIO_MAX;To;;0;0;	I"Etc::SC_AIO_MAX;To;;0;0;	I"Etc::SC_AIO_PRIO_DELTA_MAX;To;;0;0;	I"Etc::SC_ARG_MAX;To;;0;0;	I"Etc::SC_ASYNCHRONOUS_IO;To;;0;0;	I"Etc::SC_ATEXIT_MAX;To;;0;0;	I"Etc::SC_BARRIERS;To;;0;0;	I"Etc::SC_BC_BASE_MAX;To;;0;0;	I"Etc::SC_BC_DIM_MAX;To;;0;0;	I"Etc::SC_BC_SCALE_MAX;To;;0;0;	I"Etc::SC_BC_STRING_MAX;To;;0;0;	I"Etc::SC_CHILD_MAX;To;;0;0;	I"Etc::SC_CLK_TCK;To;;0;0;	I"Etc::SC_CLOCK_SELECTION;To;;0;0;	I"Etc::SC_COLL_WEIGHTS_MAX;To;;0;0;	I"Etc::SC_CPUTIME;To;;0;0;	I"Etc::SC_DELAYTIMER_MAX;To;;0;0;	I"Etc::SC_EXPR_NEST_MAX;To;;0;0;	I"Etc::SC_FSYNC;To;;0;0;	I"Etc::SC_GETGR_R_SIZE_MAX;To;;0;0;	I"Etc::SC_GETPW_R_SIZE_MAX;To;;0;0;	I"Etc::SC_HOST_NAME_MAX;To;;0;0;	I"Etc::SC_IOV_MAX;To;;0;0;	I"Etc::SC_IPV6;To;;0;0;	I"Etc::SC_JOB_CONTROL;To;;0;0;	I"Etc::SC_LINE_MAX;To;;0;0;	I"Etc::SC_LOGIN_NAME_MAX;To;;0;0;	I"Etc::SC_MAPPED_FILES;To;;0;0;	I"Etc::SC_MEMLOCK;To;;0;0;	I"Etc::SC_MEMLOCK_RANGE;To;;0;0;	I"Etc::SC_MEMORY_PROTECTION;To;;0;0;	I"Etc::SC_MESSAGE_PASSING;To;;0;0;	I"Etc::SC_MONOTONIC_CLOCK;To;;0;0;	I"Etc::SC_MQ_OPEN_MAX;To;;0;0;	I"Etc::SC_MQ_PRIO_MAX;To;;0;0;	I"Etc::SC_NGROUPS_MAX;To;;0;0;	I"Etc::SC_NPROCESSORS_CONF;To;;0;0;	I"Etc::SC_NPROCESSORS_ONLN;To;;0;0;	I"Etc::SC_OPEN_MAX;To;;0;0;	I"Etc::SC_PAGESIZE;To;;0;0;	I"Etc::SC_PAGE_SIZE;To;;0;0;	I"Etc::SC_PHYS_PAGES;To;;0;0;	I"Etc::SC_PRIORITIZED_IO;To;;0;0;	I" Etc::SC_PRIORITY_SCHEDULING;To;;0;0;	I"Etc::SC_RAW_SOCKETS;To;;0;0;	I" Etc::SC_READER_WRITER_LOCKS;To;;0;0;	I"Etc::SC_REALTIME_SIGNALS;To;;0;0;	I"Etc::SC_REGEXP;To;;0;0;	I"Etc::SC_RE_DUP_MAX;To;;0;0;	I"Etc::SC_RTSIG_MAX;To;;0;0;	I"Etc::SC_SAVED_IDS;To;;0;0;	I"Etc::SC_SEMAPHORES;To;;0;0;	I"Etc::SC_SEM_NSEMS_MAX;To;;0;0;	I"Etc::SC_SEM_VALUE_MAX;To;;0;0;	I""Etc::SC_SHARED_MEMORY_OBJECTS;To;;0;0;	I"Etc::SC_SHELL;To;;0;0;	I"Etc::SC_SIGQUEUE_MAX;To;;0;0;	I"Etc::SC_SPAWN;To;;0;0;	I"Etc::SC_SPIN_LOCKS;To;;0;0;	I"Etc::SC_SPORADIC_SERVER;To;;0;0;	I"Etc::SC_SS_REPL_MAX;To;;0;0;	I"Etc::SC_STREAM_MAX;To;;0;0;	I"Etc::SC_SYMLOOP_MAX;To;;0;0;	I"Etc::SC_SYNCHRONIZED_IO;To;;0;0;	I"Etc::SC_THREADS;To;;0;0;	I""Etc::SC_THREAD_ATTR_STACKADDR;To;;0;0;	I""Etc::SC_THREAD_ATTR_STACKSIZE;To;;0;0;	I"Etc::SC_THREAD_CPUTIME;To;;0;0;	I")Etc::SC_THREAD_DESTRUCTOR_ITERATIONS;To;;0;0;	I"Etc::SC_THREAD_KEYS_MAX;To;;0;0;	I"'Etc::SC_THREAD_PRIORITY_SCHEDULING;To;;0;0;	I" Etc::SC_THREAD_PRIO_INHERIT;To;;0;0;	I" Etc::SC_THREAD_PRIO_PROTECT;To;;0;0;	I""Etc::SC_THREAD_PROCESS_SHARED;To;;0;0;	I""Etc::SC_THREAD_SAFE_FUNCTIONS;To;;0;0;	I"#Etc::SC_THREAD_SPORADIC_SERVER;To;;0;0;	I"Etc::SC_THREAD_STACK_MIN;To;;0;0;	I"Etc::SC_THREAD_THREADS_MAX;To;;0;0;	I"Etc::SC_TIMEOUTS;To;;0;0;	I"Etc::SC_TIMERS;To;;0;0;	I"Etc::SC_TIMER_MAX;To;;0;0;	I"Etc::SC_TRACE;To;;0;0;	I"Etc::SC_TRACE_EVENT_FILTER;To;;0;0;	I"!Etc::SC_TRACE_EVENT_NAME_MAX;To;;0;0;	I"Etc::SC_TRACE_INHERIT;To;;0;0;	I"Etc::SC_TRACE_LOG;To;;0;0;	I"Etc::SC_TRACE_NAME_MAX;To;;0;0;	I"Etc::SC_TRACE_SYS_MAX;To;;0;0;	I"!Etc::SC_TRACE_USER_EVENT_MAX;To;;0;0;	I"Etc::SC_TTY_NAME_MAX;To;;0;0;	I"!Etc::SC_TYPED_MEMORY_OBJECTS;To;;0;0;	I"Etc::SC_TZNAME_MAX;To;;0;0;	I"Etc::SC_V6_ILP32_OFF32;To;;0;0;	I"Etc::SC_V6_ILP32_OFFBIG;To;;0;0;	I"Etc::SC_V6_LP64_OFF64;To;;0;0;	I"Etc::SC_V6_LPBIG_OFFBIG;To;;0;0;	I"Etc::SC_VERSION;To;;0;0;	I"Etc::SC_XOPEN_CRYPT;To;;0;0;	I"Etc::SC_XOPEN_ENH_I18N;To;;0;0;	I"Etc::SC_XOPEN_REALTIME;To;;0;0;	I"#Etc::SC_XOPEN_REALTIME_THREADS;To;;0;0;	I"Etc::SC_XOPEN_SHM;To;;0;0;	I"Etc::SC_XOPEN_STREAMS;To;;0;0;	I"Etc::SC_XOPEN_UNIX;To;;0;0;	I"Etc::SC_XOPEN_VERSION;To;;0;0;	I"Etc::VERSION;To;;0;0;	I"FileUtils::VERSION;To;;I""Version of `forwardable.rb`

;T;0;	I"Forwardable::VERSION;To;;0;0;	I"%Forwardable::FORWARDABLE_VERSION;To;;I"32 bit mask for IPv4

;T;0;	I"IPAddr::IN4MASK;To;;I"Format string for IPv6

;T;0;	I"IPAddr::IN6FORMAT;To;;I"128 bit mask for IPv6

;T;0;	I"IPAddr::IN6MASK;To;;0;0;	I"JSON::FAST_STATE_PROTOTYPE;To;;0;0;	I"JSON::Infinity;To;;0;0;	I"JSON::JSON_LOADED;To;;0;0;	I"JSON::MinusInfinity;To;;0;0;	I"JSON::NaN;To;;0;0;	I"!JSON::PRETTY_STATE_PROTOTYPE;To;;0;0;	I"JSON::SAFE_STATE_PROTOTYPE;To;;I"JSON version

;T;0;	I"JSON::VERSION;To;;0;0;	I"JSON::VERSION_ARRAY;To;;0;0;	I"JSON::VERSION_BUILD;To;;0;0;	I"JSON::VERSION_MAJOR;To;;0;0;	I"JSON::VERSION_MINOR;To;;0;0;	I"Logger::Formatter::Format;To;;0;0;	I"Logger::ProgName;To;;I"0Severity label for logging (max 5 chars).

;T;0;	I"Logger::SEV_LABEL;To;;0;0;	I"Logger::VERSION;To;;0;0;	I"Logger::Period::SiD;To;;I"4Low-level information, mostly for developers.

;T;0;	I"Logger::Severity::DEBUG;To;;I";Generic (useful) information about system operation.

;T;0;	I"Logger::Severity::INFO;To;;I"A warning.

;T;0;	I"Logger::Severity::WARN;To;;I"$A handleable error condition.

;T;0;	I"Logger::Severity::ERROR;To;;I"=An unhandleable error that results in a program crash.

;T;0;	I"Logger::Severity::FATAL;To;;I"7An unknown message that should always be logged.

;T;0;	I"Logger::Severity::UNKNOWN;To;;0;0;	I"Minitest::Assertions::E;To;;0;0;	I"$Minitest::Assertions::UNDEFINED;To;;0;0;	I"%Minitest::BacktraceFilter::MT_RE;To;;I"Start an escape sequence

;T;0;	I"Minitest::PrideIO::ESC;To;;I"End the escape sequence

;T;0;	I"Minitest::PrideIO::NND;To;;0;0;	I"Minitest::PrideLOL::PI_3;To;;0;0;	I" Minitest::Runnable::SIGNALS;To;;I"ËContains pairs of matchers and Spec classes to be used to calculate the
superclass of a top-level describe. This allows for automatically customizable
spec types.

See: register_spec_type and spec_type

;T;0;	I"Minitest::Spec::DSL::TYPES;To;;0;0;	I"%Minitest::Test::TEARDOWN_METHODS;To;;0;0;	I"+Minitest::Test::PASSTHROUGH_EXCEPTIONS;To;;0;0;	I"Minitest::Unit::VERSION;To;;0;0;	I"Minitest::VERSION;To;;0;0;	I"Minitest::ENCS;To;;0;0;	I"Mutex_m::VERSION;To;;0;0;	I"Net::Protocol::VERSION;To;;I":stopdoc:
;T;0;	I"Net::HTTP::VERSION;To;;0;0;	I"Net::HTTP::Revision;To;;0;0;	I"Net::HTTP::HTTPVersion;To;;0;0;	I"Net::HTTP::HAVE_ZLIB;To;;0;0;	I"Net::HTTP::SSL_IVNAMES;To;;0;0;	I"Net::HTTP::SSL_ATTRIBUTES;To;;0;0;	I"Net::HTTP::Get::METHOD;To;;0;0;	I"%Net::HTTP::Get::REQUEST_HAS_BODY;To;;0;0;	I"&Net::HTTP::Get::RESPONSE_HAS_BODY;To;;0;0;	I"Net::HTTP::Head::METHOD;To;;0;0;	I"&Net::HTTP::Head::REQUEST_HAS_BODY;To;;0;0;	I"'Net::HTTP::Head::RESPONSE_HAS_BODY;To;;0;0;	I"Net::HTTP::Post::METHOD;To;;0;0;	I"&Net::HTTP::Post::REQUEST_HAS_BODY;To;;0;0;	I"'Net::HTTP::Post::RESPONSE_HAS_BODY;To;;0;0;	I"Net::HTTP::Put::METHOD;To;;0;0;	I"%Net::HTTP::Put::REQUEST_HAS_BODY;To;;0;0;	I"&Net::HTTP::Put::RESPONSE_HAS_BODY;To;;0;0;	I"Net::HTTP::Delete::METHOD;To;;0;0;	I"(Net::HTTP::Delete::REQUEST_HAS_BODY;To;;0;0;	I")Net::HTTP::Delete::RESPONSE_HAS_BODY;To;;0;0;	I"Net::HTTP::Options::METHOD;To;;0;0;	I")Net::HTTP::Options::REQUEST_HAS_BODY;To;;0;0;	I"*Net::HTTP::Options::RESPONSE_HAS_BODY;To;;0;0;	I"Net::HTTP::Trace::METHOD;To;;0;0;	I"'Net::HTTP::Trace::REQUEST_HAS_BODY;To;;0;0;	I"(Net::HTTP::Trace::RESPONSE_HAS_BODY;To;;0;0;	I"Net::HTTP::Patch::METHOD;To;;0;0;	I"'Net::HTTP::Patch::REQUEST_HAS_BODY;To;;0;0;	I"(Net::HTTP::Patch::RESPONSE_HAS_BODY;To;;0;0;	I" Net::HTTP::Propfind::METHOD;To;;0;0;	I"*Net::HTTP::Propfind::REQUEST_HAS_BODY;To;;0;0;	I"+Net::HTTP::Propfind::RESPONSE_HAS_BODY;To;;0;0;	I"!Net::HTTP::Proppatch::METHOD;To;;0;0;	I"+Net::HTTP::Proppatch::REQUEST_HAS_BODY;To;;0;0;	I",Net::HTTP::Proppatch::RESPONSE_HAS_BODY;To;;0;0;	I"Net::HTTP::Mkcol::METHOD;To;;0;0;	I"'Net::HTTP::Mkcol::REQUEST_HAS_BODY;To;;0;0;	I"(Net::HTTP::Mkcol::RESPONSE_HAS_BODY;To;;0;0;	I"Net::HTTP::Copy::METHOD;To;;0;0;	I"&Net::HTTP::Copy::REQUEST_HAS_BODY;To;;0;0;	I"'Net::HTTP::Copy::RESPONSE_HAS_BODY;To;;0;0;	I"Net::HTTP::Move::METHOD;To;;0;0;	I"&Net::HTTP::Move::REQUEST_HAS_BODY;To;;0;0;	I"'Net::HTTP::Move::RESPONSE_HAS_BODY;To;;0;0;	I"Net::HTTP::Lock::METHOD;To;;0;0;	I"&Net::HTTP::Lock::REQUEST_HAS_BODY;To;;0;0;	I"'Net::HTTP::Lock::RESPONSE_HAS_BODY;To;;0;0;	I"Net::HTTP::Unlock::METHOD;To;;0;0;	I"(Net::HTTP::Unlock::REQUEST_HAS_BODY;To;;0;0;	I")Net::HTTP::Unlock::RESPONSE_HAS_BODY;To;;0;0;	I"'Net::HTTPUnknownResponse::HAS_BODY;To;;0;0;	I"-Net::HTTPUnknownResponse::EXCEPTION_TYPE;To;;0;0;	I"#Net::HTTPInformation::HAS_BODY;To;;0;0;	I")Net::HTTPInformation::EXCEPTION_TYPE;To;;0;0;	I"Net::HTTPSuccess::HAS_BODY;To;;0;0;	I"%Net::HTTPSuccess::EXCEPTION_TYPE;To;;0;0;	I"#Net::HTTPRedirection::HAS_BODY;To;;0;0;	I")Net::HTTPRedirection::EXCEPTION_TYPE;To;;0;0;	I"#Net::HTTPClientError::HAS_BODY;To;;0;0;	I")Net::HTTPClientError::EXCEPTION_TYPE;To;;0;0;	I"#Net::HTTPServerError::HAS_BODY;To;;0;0;	I")Net::HTTPServerError::EXCEPTION_TYPE;To;;0;0;	I" Net::HTTPContinue::HAS_BODY;To;;0;0;	I"&Net::HTTPSwitchProtocol::HAS_BODY;To;;0;0;	I""Net::HTTPProcessing::HAS_BODY;To;;0;0;	I""Net::HTTPEarlyHints::HAS_BODY;To;;0;0;	I"Net::HTTPOK::HAS_BODY;To;;0;0;	I"Net::HTTPCreated::HAS_BODY;To;;0;0;	I" Net::HTTPAccepted::HAS_BODY;To;;0;0;	I"3Net::HTTPNonAuthoritativeInformation::HAS_BODY;To;;0;0;	I"!Net::HTTPNoContent::HAS_BODY;To;;0;0;	I"$Net::HTTPResetContent::HAS_BODY;To;;0;0;	I"&Net::HTTPPartialContent::HAS_BODY;To;;0;0;	I"#Net::HTTPMultiStatus::HAS_BODY;To;;0;0;	I"'Net::HTTPAlreadyReported::HAS_BODY;To;;0;0;	I"Net::HTTPIMUsed::HAS_BODY;To;;0;0;	I"'Net::HTTPMultipleChoices::HAS_BODY;To;;0;0;	I"Net::HTTPMultipleChoice;To;;0;0;	I"(Net::HTTPMovedPermanently::HAS_BODY;To;;0;0;	I"Net::HTTPFound::HAS_BODY;To;;0;0;	I" Net::HTTPSeeOther::HAS_BODY;To;;0;0;	I"#Net::HTTPNotModified::HAS_BODY;To;;0;0;	I" Net::HTTPUseProxy::HAS_BODY;To;;0;0;	I")Net::HTTPTemporaryRedirect::HAS_BODY;To;;0;0;	I")Net::HTTPPermanentRedirect::HAS_BODY;To;;0;0;	I""Net::HTTPBadRequest::HAS_BODY;To;;0;0;	I"$Net::HTTPUnauthorized::HAS_BODY;To;;0;0;	I"'Net::HTTPPaymentRequired::HAS_BODY;To;;0;0;	I"!Net::HTTPForbidden::HAS_BODY;To;;0;0;	I" Net::HTTPNotFound::HAS_BODY;To;;0;0;	I"(Net::HTTPMethodNotAllowed::HAS_BODY;To;;0;0;	I"%Net::HTTPNotAcceptable::HAS_BODY;To;;0;0;	I"3Net::HTTPProxyAuthenticationRequired::HAS_BODY;To;;0;0;	I"&Net::HTTPRequestTimeout::HAS_BODY;To;;0;0;	I" Net::HTTPConflict::HAS_BODY;To;;0;0;	I"Net::HTTPGone::HAS_BODY;To;;0;0;	I"&Net::HTTPLengthRequired::HAS_BODY;To;;0;0;	I"*Net::HTTPPreconditionFailed::HAS_BODY;To;;0;0;	I"'Net::HTTPPayloadTooLarge::HAS_BODY;To;;0;0;	I""Net::HTTPURITooLong::HAS_BODY;To;;0;0;	I",Net::HTTPUnsupportedMediaType::HAS_BODY;To;;0;0;	I"+Net::HTTPRangeNotSatisfiable::HAS_BODY;To;;0;0;	I")Net::HTTPExpectationFailed::HAS_BODY;To;;0;0;	I"*Net::HTTPMisdirectedRequest::HAS_BODY;To;;0;0;	I"+Net::HTTPUnprocessableEntity::HAS_BODY;To;;0;0;	I"Net::HTTPLocked::HAS_BODY;To;;0;0;	I"(Net::HTTPFailedDependency::HAS_BODY;To;;0;0;	I"'Net::HTTPUpgradeRequired::HAS_BODY;To;;0;0;	I",Net::HTTPPreconditionRequired::HAS_BODY;To;;0;0;	I"'Net::HTTPTooManyRequests::HAS_BODY;To;;0;0;	I"3Net::HTTPRequestHeaderFieldsTooLarge::HAS_BODY;To;;0;0;	I"2Net::HTTPUnavailableForLegalReasons::HAS_BODY;To;;0;0;	I"+Net::HTTPInternalServerError::HAS_BODY;To;;0;0;	I"&Net::HTTPNotImplemented::HAS_BODY;To;;0;0;	I""Net::HTTPBadGateway::HAS_BODY;To;;0;0;	I"*Net::HTTPServiceUnavailable::HAS_BODY;To;;0;0;	I"&Net::HTTPGatewayTimeout::HAS_BODY;To;;0;0;	I"+Net::HTTPVersionNotSupported::HAS_BODY;To;;0;0;	I"-Net::HTTPVariantAlsoNegotiates::HAS_BODY;To;;0;0;	I"+Net::HTTPInsufficientStorage::HAS_BODY;To;;0;0;	I"$Net::HTTPLoopDetected::HAS_BODY;To;;0;0;	I"#Net::HTTPNotExtended::HAS_BODY;To;;0;0;	I"5Net::HTTPNetworkAuthenticationRequired::HAS_BODY;To;;0;0;	I")Net::HTTPResponse::CODE_CLASS_TO_OBJ;To;;0;0;	I"#Net::HTTPResponse::CODE_TO_OBJ;To;;0;0;	I"Net::HTTP::STATUS_CODES;To;;0;0;	I"NKF::ASCII;To;;0;0;	I"NKF::AUTO;To;;0;0;	I"NKF::BINARY;To;;0;0;	I"NKF::EUC;To;;0;0;	I"NKF::JIS;To;;I"Release date of nkf

;T;0;	I"NKF::NKF_RELEASE_DATE;To;;I"Version of nkf

;T;0;	I"NKF::NKF_VERSION;To;;0;0;	I"NKF::NOCONV;To;;0;0;	I"NKF::SJIS;To;;0;0;	I"NKF::UNKNOWN;To;;0;0;	I"NKF::UTF16;To;;0;0;	I"NKF::UTF32;To;;0;0;	I"NKF::UTF8;To;;I"!Full version string of nkf

;T;0;	I"NKF::VERSION;To;;I"@Boolean indicating whether OpenSSL is FIPS-capable or not

;T;0;	I"OpenSSL::OPENSSL_FIPS;To;;0;0;	I"%OpenSSL::OPENSSL_LIBRARY_VERSION;To;;I"CVersion of OpenSSL the ruby OpenSSL extension was built with

;T;0;	I"OpenSSL::OPENSSL_VERSION;To;;I"TVersion number of OpenSSL the ruby OpenSSL extension was built with (base 16)

;T;0;	I"$OpenSSL::OPENSSL_VERSION_NUMBER;To;;0;0;	I"OpenSSL::VERSION;To;;0;0;	I"OpenSSL::ASN1::BIT_STRING;To;;0;0;	I"OpenSSL::ASN1::BMPSTRING;To;;0;0;	I"OpenSSL::ASN1::BOOLEAN;To;;0;0;	I"$OpenSSL::ASN1::CHARACTER_STRING;To;;0;0;	I" OpenSSL::ASN1::EMBEDDED_PDV;To;;0;0;	I"OpenSSL::ASN1::ENUMERATED;To;;0;0;	I"OpenSSL::ASN1::EOC;To;;0;0;	I"OpenSSL::ASN1::EXTERNAL;To;;0;0;	I"#OpenSSL::ASN1::GENERALIZEDTIME;To;;0;0;	I"!OpenSSL::ASN1::GENERALSTRING;To;;0;0;	I"!OpenSSL::ASN1::GRAPHICSTRING;To;;0;0;	I"OpenSSL::ASN1::IA5STRING;To;;0;0;	I"OpenSSL::ASN1::INTEGER;To;;0;0;	I"OpenSSL::ASN1::ISO64STRING;To;;0;0;	I"OpenSSL::ASN1::NULL;To;;0;0;	I"!OpenSSL::ASN1::NUMERICSTRING;To;;0;0;	I"OpenSSL::ASN1::OBJECT;To;;0;0;	I"%OpenSSL::ASN1::OBJECT_DESCRIPTOR;To;;0;0;	I" OpenSSL::ASN1::OCTET_STRING;To;;0;0;	I"#OpenSSL::ASN1::PRINTABLESTRING;To;;0;0;	I"OpenSSL::ASN1::REAL;To;;0;0;	I" OpenSSL::ASN1::RELATIVE_OID;To;;0;0;	I"OpenSSL::ASN1::SEQUENCE;To;;0;0;	I"OpenSSL::ASN1::SET;To;;0;0;	I"OpenSSL::ASN1::T61STRING;To;;0;0;	I"#OpenSSL::ASN1::UNIVERSALSTRING;To;;I"2Array storing tag names at the tag's index.

;T;0;	I"&OpenSSL::ASN1::UNIVERSAL_TAG_NAME;To;;0;0;	I"OpenSSL::ASN1::UTCTIME;To;;0;0;	I"OpenSSL::ASN1::UTF8STRING;To;;0;0;	I""OpenSSL::ASN1::VIDEOTEXSTRING;To;;I"QDefault size to read from or write to the SSLSocket for buffer operations.

;T;0;	I"#OpenSSL::Buffering::BLOCK_SIZE;To;;0;0;	I"'OpenSSL::Buffering::Buffer::BINARY;To;;I"9The default system configuration file for OpenSSL.

;T;0;	I")OpenSSL::Config::DEFAULT_CONFIG_FILE;To;;0;0;	I" OpenSSL::Engine::METHOD_ALL;To;;0;0;	I"$OpenSSL::Engine::METHOD_CIPHERS;To;;0;0;	I"OpenSSL::Engine::METHOD_DH;To;;0;0;	I"$OpenSSL::Engine::METHOD_DIGESTS;To;;0;0;	I" OpenSSL::Engine::METHOD_DSA;To;;0;0;	I"!OpenSSL::Engine::METHOD_NONE;To;;0;0;	I"!OpenSSL::Engine::METHOD_RAND;To;;0;0;	I" OpenSSL::Engine::METHOD_RSA;To;;0;0;	I".OpenSSL::ExtConfig::HAVE_TLSEXT_HOST_NAME;To;;0;0;	I"(OpenSSL::ExtConfig::OPENSSL_NO_SOCK;To;;I"0(This flag is not used by OpenSSL 1.0.1g)

;T;0;	I"OpenSSL::OCSP::NOCASIGN;To;;I"2Do not include certificates in the response

;T;0;	I"OpenSSL::OCSP::NOCERTS;To;;I":Do not verify the certificate chain on the response

;T;0;	I"OpenSSL::OCSP::NOCHAIN;To;;I"8Do not make additional signing certificate checks

;T;0;	I"OpenSSL::OCSP::NOCHECKS;To;;I"0(This flag is not used by OpenSSL 1.0.1g)

;T;0;	I"OpenSSL::OCSP::NODELEGATED;To;;I"Do not check trust

;T;0;	I"OpenSSL::OCSP::NOEXPLICIT;To;;I"HDo not search certificates contained in the response for a signer

;T;0;	I"OpenSSL::OCSP::NOINTERN;To;;I"1Do not check the signature on the response

;T;0;	I"OpenSSL::OCSP::NOSIGS;To;;I"1Do not include producedAt time in response

;T;0;	I"OpenSSL::OCSP::NOTIME;To;;I"(Do not verify the response at all

;T;0;	I"OpenSSL::OCSP::NOVERIFY;To;;I">Identify the response by signing the certificate key ID

;T;0;	I"OpenSSL::OCSP::RESPID_KEY;To;;I"Internal error in issuer

;T;0;	I"1OpenSSL::OCSP::RESPONSE_STATUS_INTERNALERROR;To;;I"#Illegal confirmation request

;T;0;	I"4OpenSSL::OCSP::RESPONSE_STATUS_MALFORMEDREQUEST;To;;I"-You must sign the request and resubmit

;T;0;	I"/OpenSSL::OCSP::RESPONSE_STATUS_SIGREQUIRED;To;;I"'Response has valid confirmations

;T;0;	I".OpenSSL::OCSP::RESPONSE_STATUS_SUCCESSFUL;To;;I"Try again later

;T;0;	I",OpenSSL::OCSP::RESPONSE_STATUS_TRYLATER;To;;I"$Your request is unauthorized.

;T;0;	I"0OpenSSL::OCSP::RESPONSE_STATUS_UNAUTHORIZED;To;;I"BThe certificate subject's name or other information changed

;T;0;	I"5OpenSSL::OCSP::REVOKED_STATUS_AFFILIATIONCHANGED;To;;I">This CA certificate was revoked due to a key compromise

;T;0;	I"/OpenSSL::OCSP::REVOKED_STATUS_CACOMPROMISE;To;;I"!The certificate is on hold

;T;0;	I"2OpenSSL::OCSP::REVOKED_STATUS_CERTIFICATEHOLD;To;;I"*The certificate is no longer needed

;T;0;	I"7OpenSSL::OCSP::REVOKED_STATUS_CESSATIONOFOPERATION;To;;I":The certificate was revoked due to a key compromise

;T;0;	I"0OpenSSL::OCSP::REVOKED_STATUS_KEYCOMPROMISE;To;;I"8The certificate was revoked for an unknown reason

;T;0;	I"+OpenSSL::OCSP::REVOKED_STATUS_NOSTATUS;To;;I"TThe certificate was previously on hold and should now be removed from the CRL

;T;0;	I"0OpenSSL::OCSP::REVOKED_STATUS_REMOVEFROMCRL;To;;I":The certificate was superseded by a new certificate

;T;0;	I"-OpenSSL::OCSP::REVOKED_STATUS_SUPERSEDED;To;;I"<The certificate was revoked for an unspecified reason

;T;0;	I".OpenSSL::OCSP::REVOKED_STATUS_UNSPECIFIED;To;;I",Do not verify additional certificates

;T;0;	I"OpenSSL::OCSP::TRUSTOTHER;To;;I"§Indicates the certificate is not revoked but does not necessarily mean the
certificate was issued or that this response is within the certificate's
validity interval

;T;0;	I"%OpenSSL::OCSP::V_CERTSTATUS_GOOD;To;;I"^Indicates the certificate has been revoked either permanently or temporarily
(on hold).

;T;0;	I"(OpenSSL::OCSP::V_CERTSTATUS_REVOKED;To;;I"SIndicates the responder does not know about the certificate being requested.

;T;0;	I"(OpenSSL::OCSP::V_CERTSTATUS_UNKNOWN;To;;I"3The responder ID is based on the public key.

;T;0;	I" OpenSSL::OCSP::V_RESPID_KEY;To;;I"1The responder ID is based on the key name.

;T;0;	I"!OpenSSL::OCSP::V_RESPID_NAME;To;;0;0;	I"OpenSSL::PKCS7::BINARY;To;;0;0;	I"OpenSSL::PKCS7::DETACHED;To;;0;0;	I"OpenSSL::PKCS7::NOATTR;To;;0;0;	I"OpenSSL::PKCS7::NOCERTS;To;;0;0;	I"OpenSSL::PKCS7::NOCHAIN;To;;0;0;	I"OpenSSL::PKCS7::NOINTERN;To;;0;0;	I"OpenSSL::PKCS7::NOSIGS;To;;0;0;	I"OpenSSL::PKCS7::NOSMIMECAP;To;;0;0;	I"OpenSSL::PKCS7::NOVERIFY;To;;0;0;	I"OpenSSL::PKCS7::TEXT;To;;0;0;	I"&OpenSSL::PKey::EC::EXPLICIT_CURVE;To;;0;0;	I"#OpenSSL::PKey::EC::NAMED_CURVE;To;;0;0;	I"#OpenSSL::PKey::RSA::NO_PADDING;To;;0;0;	I"+OpenSSL::PKey::RSA::PKCS1_OAEP_PADDING;To;;0;0;	I"&OpenSSL::PKey::RSA::PKCS1_PADDING;To;;0;0;	I"'OpenSSL::PKey::RSA::SSLV23_PADDING;To;;0;0;	I"OpenSSL::SSL::OP_ALL;To;;0;0;	I"&OpenSSL::SSL::OP_ALLOW_NO_DHE_KEX;To;;0;0;	I"7OpenSSL::SSL::OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION;To;;0;0;	I".OpenSSL::SSL::OP_CIPHER_SERVER_PREFERENCE;To;;0;0;	I"*OpenSSL::SSL::OP_CRYPTOPRO_TLSEXT_BUG;To;;0;0;	I"1OpenSSL::SSL::OP_DONT_INSERT_EMPTY_FRAGMENTS;To;;I".Deprecated in OpenSSL 1.0.1k and 1.0.2.

;T;0;	I"#OpenSSL::SSL::OP_EPHEMERAL_RSA;To;;0;0;	I"+OpenSSL::SSL::OP_LEGACY_SERVER_CONNECT;To;;I"#Deprecated in OpenSSL 1.1.0.

;T;0;	I"0OpenSSL::SSL::OP_MICROSOFT_BIG_SSLV3_BUFFER;To;;I"#Deprecated in OpenSSL 1.1.0.

;T;0;	I"+OpenSSL::SSL::OP_MICROSOFT_SESS_ID_BUG;To;;I"/Deprecated in OpenSSL 0.9.7h and 0.9.8b.

;T;0;	I",OpenSSL::SSL::OP_MSIE_SSLV2_RSA_PADDING;To;;I"#Deprecated in OpenSSL 1.1.0.

;T;0;	I"(OpenSSL::SSL::OP_NETSCAPE_CA_DN_BUG;To;;I"#Deprecated in OpenSSL 1.1.0.

;T;0;	I",OpenSSL::SSL::OP_NETSCAPE_CHALLENGE_BUG;To;;I"#Deprecated in OpenSSL 1.1.0.

;T;0;	I"5OpenSSL::SSL::OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG;To;;I"/Deprecated in OpenSSL 0.9.8q and 1.0.0c.

;T;0;	I"6OpenSSL::SSL::OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG;To;;0;0;	I"$OpenSSL::SSL::OP_NO_COMPRESSION;To;;0;0;	I")OpenSSL::SSL::OP_NO_ENCRYPT_THEN_MAC;To;;0;0;	I"&OpenSSL::SSL::OP_NO_RENEGOTIATION;To;;0;0;	I"<OpenSSL::SSL::OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION;To;;I"#Deprecated in OpenSSL 1.1.0.

;T;0;	I"OpenSSL::SSL::OP_NO_SSLv2;To;;0;0;	I"OpenSSL::SSL::OP_NO_SSLv3;To;;0;0;	I"OpenSSL::SSL::OP_NO_TICKET;To;;0;0;	I"OpenSSL::SSL::OP_NO_TLSv1;To;;0;0;	I" OpenSSL::SSL::OP_NO_TLSv1_1;To;;0;0;	I" OpenSSL::SSL::OP_NO_TLSv1_2;To;;0;0;	I" OpenSSL::SSL::OP_NO_TLSv1_3;To;;I"#Deprecated in OpenSSL 1.0.1.

;T;0;	I"#OpenSSL::SSL::OP_PKCS1_CHECK_1;To;;I"#Deprecated in OpenSSL 1.0.1.

;T;0;	I"#OpenSSL::SSL::OP_PKCS1_CHECK_2;To;;0;0;	I",OpenSSL::SSL::OP_SAFARI_ECDHE_ECDSA_BUG;To;;I"#Deprecated in OpenSSL 1.1.0.

;T;0;	I"#OpenSSL::SSL::OP_SINGLE_DH_USE;To;;I"#Deprecated in OpenSSL 1.1.0.

;T;0;	I"%OpenSSL::SSL::OP_SINGLE_ECDH_USE;To;;I"#Deprecated in OpenSSL 1.1.0.

;T;0;	I".OpenSSL::SSL::OP_SSLEAY_080_CLIENT_DH_BUG;To;;I".Deprecated in OpenSSL 1.0.1h and 1.0.2.

;T;0;	I"1OpenSSL::SSL::OP_SSLREF2_REUSE_CERT_TYPE_BUG;To;;0;0;	I"$OpenSSL::SSL::OP_TLSEXT_PADDING;To;;I"#Deprecated in OpenSSL 1.1.0.

;T;0;	I"+OpenSSL::SSL::OP_TLS_BLOCK_PADDING_BUG;To;;I"#Deprecated in OpenSSL 1.1.0.

;T;0;	I" OpenSSL::SSL::OP_TLS_D5_BUG;To;;0;0;	I"&OpenSSL::SSL::OP_TLS_ROLLBACK_BUG;To;;I"SSL 2.0

;T;0;	I"OpenSSL::SSL::SSL2_VERSION;To;;I"SSL 3.0

;T;0;	I"OpenSSL::SSL::SSL3_VERSION;To;;I"TLS 1.1

;T;0;	I"!OpenSSL::SSL::TLS1_1_VERSION;To;;I"TLS 1.2

;T;0;	I"!OpenSSL::SSL::TLS1_2_VERSION;To;;I"TLS 1.3

;T;0;	I"!OpenSSL::SSL::TLS1_3_VERSION;To;;I"TLS 1.0

;T;0;	I"OpenSSL::SSL::TLS1_VERSION;To;;0;0;	I"%OpenSSL::SSL::VERIFY_CLIENT_ONCE;To;;0;0;	I".OpenSSL::SSL::VERIFY_FAIL_IF_NO_PEER_CERT;To;;0;0;	I"OpenSSL::SSL::VERIFY_NONE;To;;0;0;	I"OpenSSL::SSL::VERIFY_PEER;To;;0;0;	I"1OpenSSL::SSL::SSLContext::DEFAULT_CERT_STORE;To;;0;0;	I"-OpenSSL::SSL::SSLContext::DEFAULT_PARAMS;To;;0;0;	I"6OpenSSL::SSL::SSLContext::DEFAULT_TMP_DH_CALLBACK;To;;I"iThe list of available SSL/TLS methods. This constant is only provided for
backwards compatibility.

;T;0;	I"&OpenSSL::SSL::SSLContext::METHODS;To;;I"EBoth client and server sessions are added to the session cache

;T;0;	I"1OpenSSL::SSL::SSLContext::SESSION_CACHE_BOTH;To;;I"5Client sessions are added to the session cache

;T;0;	I"3OpenSSL::SSL::SSLContext::SESSION_CACHE_CLIENT;To;;I"ãNormally the session cache is checked for expired sessions every 255
connections.  Since this may lead to a delay that cannot be controlled, the
automatic flushing may be disabled and #flush_sessions can be called
explicitly.

;T;0;	I":OpenSSL::SSL::SSLContext::SESSION_CACHE_NO_AUTO_CLEAR;To;;I"YEnables both SESSION_CACHE_NO_INTERNAL_LOOKUP and
SESSION_CACHE_NO_INTERNAL_STORE.

;T;0;	I"8OpenSSL::SSL::SSLContext::SESSION_CACHE_NO_INTERNAL;To;;I"~Always perform external lookups of sessions even if they are in the internal
cache.

This flag has no effect on clients

;T;0;	I"?OpenSSL::SSL::SSLContext::SESSION_CACHE_NO_INTERNAL_LOOKUP;To;;I"@Never automatically store sessions in the internal store.

;T;0;	I">OpenSSL::SSL::SSLContext::SESSION_CACHE_NO_INTERNAL_STORE;To;;I".No session caching for client or server

;T;0;	I"0OpenSSL::SSL::SSLContext::SESSION_CACHE_OFF;To;;I"5Server sessions are added to the session cache

;T;0;	I"3OpenSSL::SSL::SSLContext::SESSION_CACHE_SERVER;To;;I"5Indicates a successful response. Equal to `0`.

;T;0;	I"*OpenSSL::Timestamp::Response::GRANTED;To;;I"sIndicates a successful response that probably contains modifications from the
initial request. Equal to `1`.

;T;0;	I"4OpenSSL::Timestamp::Response::GRANTED_WITH_MODS;To;;I"IIndicates a failure. No timestamp token was created. Equal to `2`.

;T;0;	I",OpenSSL::Timestamp::Response::REJECTION;To;;I"iIndicates a failure. No timestamp token was created. A certificate has been
revoked. Equal to `5`.

;T;0;	I":OpenSSL::Timestamp::Response::REVOCATION_NOTIFICATION;To;;I"rIndicates a failure. No timestamp token was created. Revocation of a
certificate is imminent. Equal to `4`.

;T;0;	I"5OpenSSL::Timestamp::Response::REVOCATION_WARNING;To;;I"IIndicates a failure. No timestamp token was created. Equal to `3`.

;T;0;	I"*OpenSSL::Timestamp::Response::WAITING;To;;0;0;	I"%OpenSSL::X509::DEFAULT_CERT_AREA;To;;0;0;	I"$OpenSSL::X509::DEFAULT_CERT_DIR;To;;0;0;	I"(OpenSSL::X509::DEFAULT_CERT_DIR_ENV;To;;0;0;	I"%OpenSSL::X509::DEFAULT_CERT_FILE;To;;0;0;	I")OpenSSL::X509::DEFAULT_CERT_FILE_ENV;To;;0;0;	I"'OpenSSL::X509::DEFAULT_PRIVATE_DIR;To;;0;0;	I"OpenSSL::X509::PURPOSE_ANY;To;;0;0;	I"$OpenSSL::X509::PURPOSE_CRL_SIGN;To;;0;0;	I")OpenSSL::X509::PURPOSE_NS_SSL_SERVER;To;;0;0;	I"'OpenSSL::X509::PURPOSE_OCSP_HELPER;To;;0;0;	I")OpenSSL::X509::PURPOSE_SMIME_ENCRYPT;To;;0;0;	I"&OpenSSL::X509::PURPOSE_SMIME_SIGN;To;;0;0;	I"&OpenSSL::X509::PURPOSE_SSL_CLIENT;To;;0;0;	I"&OpenSSL::X509::PURPOSE_SSL_SERVER;To;;0;0;	I"*OpenSSL::X509::PURPOSE_TIMESTAMP_SIGN;To;;0;0;	I" OpenSSL::X509::TRUST_COMPAT;To;;0;0;	I"OpenSSL::X509::TRUST_EMAIL;To;;0;0;	I"%OpenSSL::X509::TRUST_OBJECT_SIGN;To;;0;0;	I"&OpenSSL::X509::TRUST_OCSP_REQUEST;To;;0;0;	I"#OpenSSL::X509::TRUST_OCSP_SIGN;To;;0;0;	I"$OpenSSL::X509::TRUST_SSL_CLIENT;To;;0;0;	I"$OpenSSL::X509::TRUST_SSL_SERVER;To;;0;0;	I"OpenSSL::X509::TRUST_TSA;To;;0;0;	I"5OpenSSL::X509::V_ERR_AKID_ISSUER_SERIAL_MISMATCH;To;;0;0;	I",OpenSSL::X509::V_ERR_AKID_SKID_MISMATCH;To;;0;0;	I"2OpenSSL::X509::V_ERR_APPLICATION_VERIFICATION;To;;0;0;	I"*OpenSSL::X509::V_ERR_CA_KEY_TOO_SMALL;To;;0;0;	I"(OpenSSL::X509::V_ERR_CA_MD_TOO_WEAK;To;;0;0;	I"-OpenSSL::X509::V_ERR_CERT_CHAIN_TOO_LONG;To;;0;0;	I"*OpenSSL::X509::V_ERR_CERT_HAS_EXPIRED;To;;0;0;	I",OpenSSL::X509::V_ERR_CERT_NOT_YET_VALID;To;;0;0;	I"'OpenSSL::X509::V_ERR_CERT_REJECTED;To;;0;0;	I"&OpenSSL::X509::V_ERR_CERT_REVOKED;To;;0;0;	I"0OpenSSL::X509::V_ERR_CERT_SIGNATURE_FAILURE;To;;0;0;	I"(OpenSSL::X509::V_ERR_CERT_UNTRUSTED;To;;0;0;	I")OpenSSL::X509::V_ERR_CRL_HAS_EXPIRED;To;;0;0;	I"+OpenSSL::X509::V_ERR_CRL_NOT_YET_VALID;To;;0;0;	I"3OpenSSL::X509::V_ERR_CRL_PATH_VALIDATION_ERROR;To;;0;0;	I"/OpenSSL::X509::V_ERR_CRL_SIGNATURE_FAILURE;To;;0;0;	I"'OpenSSL::X509::V_ERR_DANE_NO_MATCH;To;;0;0;	I"5OpenSSL::X509::V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT;To;;0;0;	I"-OpenSSL::X509::V_ERR_DIFFERENT_CRL_SCOPE;To;;0;0;	I"*OpenSSL::X509::V_ERR_EE_KEY_TOO_SMALL;To;;0;0;	I"(OpenSSL::X509::V_ERR_EMAIL_MISMATCH;To;;0;0;	I"7OpenSSL::X509::V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD;To;;0;0;	I"8OpenSSL::X509::V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD;To;;0;0;	I"8OpenSSL::X509::V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD;To;;0;0;	I"8OpenSSL::X509::V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD;To;;0;0;	I",OpenSSL::X509::V_ERR_EXCLUDED_VIOLATION;To;;0;0;	I"+OpenSSL::X509::V_ERR_HOSTNAME_MISMATCH;To;;0;0;	I"$OpenSSL::X509::V_ERR_INVALID_CA;To;;0;0;	I"&OpenSSL::X509::V_ERR_INVALID_CALL;To;;0;0;	I"+OpenSSL::X509::V_ERR_INVALID_EXTENSION;To;;0;0;	I"(OpenSSL::X509::V_ERR_INVALID_NON_CA;To;;0;0;	I"2OpenSSL::X509::V_ERR_INVALID_POLICY_EXTENSION;To;;0;0;	I")OpenSSL::X509::V_ERR_INVALID_PURPOSE;To;;0;0;	I"-OpenSSL::X509::V_ERR_IP_ADDRESS_MISMATCH;To;;0;0;	I".OpenSSL::X509::V_ERR_KEYUSAGE_NO_CERTSIGN;To;;0;0;	I".OpenSSL::X509::V_ERR_KEYUSAGE_NO_CRL_SIGN;To;;0;0;	I"7OpenSSL::X509::V_ERR_KEYUSAGE_NO_DIGITAL_SIGNATURE;To;;0;0;	I",OpenSSL::X509::V_ERR_NO_EXPLICIT_POLICY;To;;0;0;	I"'OpenSSL::X509::V_ERR_NO_VALID_SCTS;To;;0;0;	I"+OpenSSL::X509::V_ERR_OCSP_CERT_UNKNOWN;To;;0;0;	I",OpenSSL::X509::V_ERR_OCSP_VERIFY_FAILED;To;;0;0;	I",OpenSSL::X509::V_ERR_OCSP_VERIFY_NEEDED;To;;0;0;	I"$OpenSSL::X509::V_ERR_OUT_OF_MEM;To;;0;0;	I".OpenSSL::X509::V_ERR_PATH_LENGTH_EXCEEDED;To;;0;0;	I"#OpenSSL::X509::V_ERR_PATH_LOOP;To;;0;0;	I"-OpenSSL::X509::V_ERR_PERMITTED_VIOLATION;To;;0;0;	I"8OpenSSL::X509::V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED;To;;0;0;	I"4OpenSSL::X509::V_ERR_PROXY_PATH_LENGTH_EXCEEDED;To;;0;0;	I"6OpenSSL::X509::V_ERR_PROXY_SUBJECT_NAME_VIOLATION;To;;0;0;	I"3OpenSSL::X509::V_ERR_SELF_SIGNED_CERT_IN_CHAIN;To;;0;0;	I"&OpenSSL::X509::V_ERR_STORE_LOOKUP;To;;0;0;	I"1OpenSSL::X509::V_ERR_SUBJECT_ISSUER_MISMATCH;To;;0;0;	I"(OpenSSL::X509::V_ERR_SUBTREE_MINMAX;To;;0;0;	I">OpenSSL::X509::V_ERR_SUITE_B_CANNOT_SIGN_P_384_WITH_P_256;To;;0;0;	I"3OpenSSL::X509::V_ERR_SUITE_B_INVALID_ALGORITHM;To;;0;0;	I"/OpenSSL::X509::V_ERR_SUITE_B_INVALID_CURVE;To;;0;0;	I"=OpenSSL::X509::V_ERR_SUITE_B_INVALID_SIGNATURE_ALGORITHM;To;;0;0;	I"1OpenSSL::X509::V_ERR_SUITE_B_INVALID_VERSION;To;;0;0;	I"1OpenSSL::X509::V_ERR_SUITE_B_LOS_NOT_ALLOWED;To;;0;0;	I"<OpenSSL::X509::V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY;To;;0;0;	I":OpenSSL::X509::V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE;To;;0;0;	I"9OpenSSL::X509::V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE;To;;0;0;	I"+OpenSSL::X509::V_ERR_UNABLE_TO_GET_CRL;To;;0;0;	I"2OpenSSL::X509::V_ERR_UNABLE_TO_GET_CRL_ISSUER;To;;0;0;	I"3OpenSSL::X509::V_ERR_UNABLE_TO_GET_ISSUER_CERT;To;;0;0;	I";OpenSSL::X509::V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY;To;;0;0;	I"9OpenSSL::X509::V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE;To;;0;0;	I":OpenSSL::X509::V_ERR_UNHANDLED_CRITICAL_CRL_EXTENSION;To;;0;0;	I"6OpenSSL::X509::V_ERR_UNHANDLED_CRITICAL_EXTENSION;To;;0;0;	I"+OpenSSL::X509::V_ERR_UNNESTED_RESOURCE;To;;0;0;	I"%OpenSSL::X509::V_ERR_UNSPECIFIED;To;;0;0;	I"7OpenSSL::X509::V_ERR_UNSUPPORTED_CONSTRAINT_SYNTAX;To;;0;0;	I"5OpenSSL::X509::V_ERR_UNSUPPORTED_CONSTRAINT_TYPE;To;;0;0;	I"7OpenSSL::X509::V_ERR_UNSUPPORTED_EXTENSION_FEATURE;To;;0;0;	I"1OpenSSL::X509::V_ERR_UNSUPPORTED_NAME_SYNTAX;To;;0;0;	I",OpenSSL::X509::V_FLAG_ALLOW_PROXY_CERTS;To;;0;0;	I"-OpenSSL::X509::V_FLAG_CHECK_SS_SIGNATURE;To;;0;0;	I"$OpenSSL::X509::V_FLAG_CRL_CHECK;To;;0;0;	I"(OpenSSL::X509::V_FLAG_CRL_CHECK_ALL;To;;0;0;	I"*OpenSSL::X509::V_FLAG_EXPLICIT_POLICY;To;;0;0;	I"/OpenSSL::X509::V_FLAG_EXTENDED_CRL_SUPPORT;To;;0;0;	I"*OpenSSL::X509::V_FLAG_IGNORE_CRITICAL;To;;0;0;	I"&OpenSSL::X509::V_FLAG_INHIBIT_ANY;To;;0;0;	I"&OpenSSL::X509::V_FLAG_INHIBIT_MAP;To;;0;0;	I"(OpenSSL::X509::V_FLAG_NOTIFY_POLICY;To;;0;0;	I"(OpenSSL::X509::V_FLAG_NO_ALT_CHAINS;To;;0;0;	I"(OpenSSL::X509::V_FLAG_NO_CHECK_TIME;To;;0;0;	I"(OpenSSL::X509::V_FLAG_PARTIAL_CHAIN;To;;0;0;	I"'OpenSSL::X509::V_FLAG_POLICY_CHECK;To;;0;0;	I")OpenSSL::X509::V_FLAG_SUITEB_128_LOS;To;;0;0;	I".OpenSSL::X509::V_FLAG_SUITEB_128_LOS_ONLY;To;;0;0;	I")OpenSSL::X509::V_FLAG_SUITEB_192_LOS;To;;0;0;	I"(OpenSSL::X509::V_FLAG_TRUSTED_FIRST;To;;0;0;	I")OpenSSL::X509::V_FLAG_USE_CHECK_TIME;To;;0;0;	I"%OpenSSL::X509::V_FLAG_USE_DELTAS;To;;0;0;	I"&OpenSSL::X509::V_FLAG_X509_STRICT;To;;0;0;	I"OpenSSL::X509::V_OK;To;;I"dA flag for #to_s.

Breaks the name returned into multiple lines if longer than 80 characters.

;T;0;	I" OpenSSL::X509::Name::COMPAT;To;;I"0The default object type for name entries.

;T;0;	I"-OpenSSL::X509::Name::DEFAULT_OBJECT_TYPE;To;;I"5A flag for #to_s.

Returns a multiline format.

;T;0;	I"#OpenSSL::X509::Name::MULTILINE;To;;I"9The default object type template for name entries.

;T;0;	I".OpenSSL::X509::Name::OBJECT_TYPE_TEMPLATE;To;;I"FA flag for #to_s.

Returns a more readable format than RFC2253.

;T;0;	I"!OpenSSL::X509::Name::ONELINE;To;;I"9A flag for #to_s.

Returns an RFC2253 format name.

;T;0;	I"!OpenSSL::X509::Name::RFC2253;To;;0;0;	I"2OpenSSL::X509::Name::RFC2253DN::AttributeType;To;;0;0;	I"3OpenSSL::X509::Name::RFC2253DN::AttributeValue;To;;0;0;	I",OpenSSL::X509::Name::RFC2253DN::HexChar;To;;0;0;	I",OpenSSL::X509::Name::RFC2253DN::HexPair;To;;0;0;	I".OpenSSL::X509::Name::RFC2253DN::HexString;To;;0;0;	I")OpenSSL::X509::Name::RFC2253DN::Pair;To;;0;0;	I".OpenSSL::X509::Name::RFC2253DN::QuoteChar;To;;0;0;	I",OpenSSL::X509::Name::RFC2253DN::Special;To;;0;0;	I"/OpenSSL::X509::Name::RFC2253DN::StringChar;To;;0;0;	I"1OpenSSL::X509::Name::RFC2253DN::TypeAndValue;To;;0;0;	I" OptionParser::ArgumentStyle;To;;0;0;	I"!OptionParser::COMPSYS_HEADER;To;;I":Decimal integer format, to be converted to Integer.

;T;0;	I"!OptionParser::DecimalInteger;To;;I"rDecimal integer/float number format, to be converted to Integer for integer
format, Float for float format.

;T;0;	I"!OptionParser::DecimalNumeric;To;;0;0;	I"OptionParser::DefaultList;To;;0;0;	I"OptionParser::NO_ARGUMENT;To;;0;0;	I"OptionParser::NoArgument;To;;0;0;	I"$OptionParser::OPTIONAL_ARGUMENT;To;;I"WRuby/C like octal/hexadecimal/binary integer format, to be converted to
Integer.

;T;0;	I"OptionParser::OctalInteger;To;;0;0;	I"OptionParser::Officious;To;;0;0;	I"#OptionParser::OptionalArgument;To;;0;0;	I"$OptionParser::REQUIRED_ARGUMENT;To;;0;0;	I"#OptionParser::RequiredArgument;To;;0;0;	I"OptionParser::SPLAT_PROC;To;;0;0;	I"OptionParser::Version;To;;0;0;	I".OptionParser::Acceptables::DecimalInteger;To;;0;0;	I".OptionParser::Acceptables::DecimalNumeric;To;;0;0;	I",OptionParser::Acceptables::OctalInteger;To;;0;0;	I",OptionParser::AmbiguousArgument::Reason;To;;0;0;	I"*OptionParser::AmbiguousOption::Reason;To;;0;0;	I"*OptionParser::InvalidArgument::Reason;To;;0;0;	I"(OptionParser::InvalidOption::Reason;To;;0;0;	I"*OptionParser::MissingArgument::Reason;To;;0;0;	I"+OptionParser::NeedlessArgument::Reason;To;;I"%Reason which caused the error.

;T;0;	I"%OptionParser::ParseError::Reason;To;;0;0;	I"Pathname::SAME_PATHS;To;;0;0;	I"Pathname::SEPARATOR_LIST;To;;0;0;	I"Pathname::SEPARATOR_PAT;To;;0;0;	I"Pathname::TO_PATH;To;;0;0;	I"#PStore::EMPTY_MARSHAL_CHECKSUM;To;;0;0;	I"PStore::EMPTY_MARSHAL_DATA;To;;0;0;	I"PStore::EMPTY_STRING;To;;0;0;	I"PStore::RDWR_ACCESS;To;;0;0;	I"PStore::RD_ACCESS;To;;0;0;	I"PStore::VERSION;To;;0;0;	I"PStore::WR_ACCESS;To;;I"7Address Regexp to use for matching IP addresses.

;T;0;	I"Resolv::AddressRegex;To;;I"8Default resolver to use for Resolv class methods.

;T;0;	I"Resolv::DefaultResolver;To;;I"Default DNS Port

;T;0;	I"Resolv::DNS::Port;To;;0;0;	I"Resolv::DNS::RequestID;To;;0;0;	I" Resolv::DNS::RequestIDMutex;To;;I""Default DNS UDP packet size

;T;0;	I"Resolv::DNS::UDPSize;To;;0;0;	I"(Resolv::DNS::Config::InitialTimeout;To;;0;0;	I" Resolv::DNS::OpCode::IQuery;To;;0;0;	I" Resolv::DNS::OpCode::Notify;To;;0;0;	I"Resolv::DNS::OpCode::Query;To;;0;0;	I" Resolv::DNS::OpCode::Status;To;;0;0;	I" Resolv::DNS::OpCode::Update;To;;0;0;	I"Resolv::DNS::RCode::BADALG;To;;0;0;	I"Resolv::DNS::RCode::BADKEY;To;;0;0;	I" Resolv::DNS::RCode::BADMODE;To;;0;0;	I" Resolv::DNS::RCode::BADNAME;To;;0;0;	I"Resolv::DNS::RCode::BADSIG;To;;0;0;	I" Resolv::DNS::RCode::BADTIME;To;;0;0;	I" Resolv::DNS::RCode::BADVERS;To;;0;0;	I" Resolv::DNS::RCode::FormErr;To;;0;0;	I"!Resolv::DNS::RCode::NXDomain;To;;0;0;	I" Resolv::DNS::RCode::NXRRSet;To;;0;0;	I" Resolv::DNS::RCode::NoError;To;;0;0;	I" Resolv::DNS::RCode::NotAuth;To;;0;0;	I"Resolv::DNS::RCode::NotImp;To;;0;0;	I" Resolv::DNS::RCode::NotZone;To;;0;0;	I" Resolv::DNS::RCode::Refused;To;;0;0;	I"!Resolv::DNS::RCode::ServFail;To;;0;0;	I"!Resolv::DNS::RCode::YXDomain;To;;0;0;	I" Resolv::DNS::RCode::YXRRSet;To;;0;0;	I"%Resolv::DNS::Resource::ClassHash;To;;0;0;	I"1Resolv::DNS::Resource::ClassInsensitiveTypes;To;;0;0;	I"&Resolv::DNS::Resource::ClassValue;To;;0;0;	I"*Resolv::DNS::Resource::ANY::TypeValue;To;;0;0;	I",Resolv::DNS::Resource::CNAME::TypeValue;To;;0;0;	I",Resolv::DNS::Resource::HINFO::TypeValue;To;;0;0;	I"*Resolv::DNS::Resource::IN::ClassValue;To;;0;0;	I"-Resolv::DNS::Resource::IN::A::ClassValue;To;;0;0;	I",Resolv::DNS::Resource::IN::A::TypeValue;To;;0;0;	I"0Resolv::DNS::Resource::IN::AAAA::ClassValue;To;;0;0;	I"/Resolv::DNS::Resource::IN::AAAA::TypeValue;To;;0;0;	I"/Resolv::DNS::Resource::IN::ANY::ClassValue;To;;0;0;	I".Resolv::DNS::Resource::IN::ANY::TypeValue;To;;0;0;	I"1Resolv::DNS::Resource::IN::CNAME::ClassValue;To;;0;0;	I"0Resolv::DNS::Resource::IN::CNAME::TypeValue;To;;0;0;	I"1Resolv::DNS::Resource::IN::HINFO::ClassValue;To;;0;0;	I"0Resolv::DNS::Resource::IN::HINFO::TypeValue;To;;0;0;	I"/Resolv::DNS::Resource::IN::LOC::ClassValue;To;;0;0;	I".Resolv::DNS::Resource::IN::LOC::TypeValue;To;;0;0;	I"1Resolv::DNS::Resource::IN::MINFO::ClassValue;To;;0;0;	I"0Resolv::DNS::Resource::IN::MINFO::TypeValue;To;;0;0;	I".Resolv::DNS::Resource::IN::MX::ClassValue;To;;0;0;	I"-Resolv::DNS::Resource::IN::MX::TypeValue;To;;0;0;	I".Resolv::DNS::Resource::IN::NS::ClassValue;To;;0;0;	I"-Resolv::DNS::Resource::IN::NS::TypeValue;To;;0;0;	I"/Resolv::DNS::Resource::IN::PTR::ClassValue;To;;0;0;	I".Resolv::DNS::Resource::IN::PTR::TypeValue;To;;0;0;	I"/Resolv::DNS::Resource::IN::SOA::ClassValue;To;;0;0;	I".Resolv::DNS::Resource::IN::SOA::TypeValue;To;;0;0;	I"/Resolv::DNS::Resource::IN::SRV::ClassValue;To;;0;0;	I".Resolv::DNS::Resource::IN::SRV::TypeValue;To;;0;0;	I"/Resolv::DNS::Resource::IN::TXT::ClassValue;To;;0;0;	I".Resolv::DNS::Resource::IN::TXT::TypeValue;To;;0;0;	I"/Resolv::DNS::Resource::IN::WKS::ClassValue;To;;0;0;	I".Resolv::DNS::Resource::IN::WKS::TypeValue;To;;0;0;	I"*Resolv::DNS::Resource::LOC::TypeValue;To;;0;0;	I",Resolv::DNS::Resource::MINFO::TypeValue;To;;0;0;	I")Resolv::DNS::Resource::MX::TypeValue;To;;0;0;	I")Resolv::DNS::Resource::NS::TypeValue;To;;0;0;	I"*Resolv::DNS::Resource::PTR::TypeValue;To;;0;0;	I"*Resolv::DNS::Resource::SOA::TypeValue;To;;0;0;	I"*Resolv::DNS::Resource::TXT::TypeValue;To;;0;0;	I"#Resolv::Hosts::DefaultFileName;To;;0;0;	I"Resolv::IPv4::Regex;To;;I"4Regular expression IPv4 addresses must match.

;T;0;	I"Resolv::IPv4::Regex256;To;;I"'A composite IPv6 address Regexp.

;T;0;	I"Resolv::IPv6::Regex;To;;I":IPv4 mapped IPv6 address format a:b:c:d:e:f:w.x.y.z

;T;0;	I"!Resolv::IPv6::Regex_6Hex4Dec;To;;I"*IPv6 address format a:b:c:d:e:f:g:h

;T;0;	I"Resolv::IPv6::Regex_8Hex;To;;I"<IPv6 link local address format fe80:b:c:d:e:f:g:h%em1

;T;0;	I"&Resolv::IPv6::Regex_8HexLinkLocal;To;;I"*Compressed IPv6 address format a::b

;T;0;	I"&Resolv::IPv6::Regex_CompressedHex;To;;I">Compressed IPv4 mapped IPv6 address format a::b:w.x.y.z

;T;0;	I"*Resolv::IPv6::Regex_CompressedHex4Dec;To;;I"<Compressed IPv6 link local address format fe80::b%em1

;T;0;	I"/Resolv::IPv6::Regex_CompressedHexLinkLocal;To;;0;0;	I"Resolv::LOC::Alt::Regex;To;;0;0;	I"Resolv::LOC::Coord::Regex;To;;0;0;	I"Resolv::LOC::Size::Regex;To;;I" Default IPv4 mDNS address

;T;0;	I"Resolv::MDNS::AddressV4;To;;I" Default IPv6 mDNS address

;T;0;	I"Resolv::MDNS::AddressV6;To;;I"Default mDNS addresses

;T;0;	I"Resolv::MDNS::Addresses;To;;I"Default mDNS Port

;T;0;	I"Resolv::MDNS::Port;To;;I"2The default requirement matches any version

;T;0;	I"3Gem::Requirement::DefaultPrereleaseRequirement;To;;I"AThe default requirement matches any non-prerelease version

;T;0;	I")Gem::Requirement::DefaultRequirement;To;;I"6A regular expression that matches a requirement

;T;0;	I"Gem::Requirement::PATTERN;To;;0;0;	I"Gem::DEFAULT_HOST;To;;0;0;	I"Gem::GEM_DEP_FILES;To;;I"jWhen https://bugs.ruby-lang.org/issues/17259 is available, there is no need to
override Kernel#warn

;T;0;	I".Gem::KERNEL_WARN_IGNORES_INTERNAL_ENTRIES;To;;0;0;	I"Gem::LOADED_SPECS_MUTEX;To;;I"@Location of Marshal quick gemspecs on remote repositories

;T;0;	I"Gem::MARSHAL_SPEC_DIR;To;;I"EException classes used in a Gem.read_binary `rescue` statement

;T;0;	I"Gem::READ_BINARY_ERRORS;To;;I":Subdirectories in a gem repository for default gems

;T;0;	I"/Gem::REPOSITORY_DEFAULT_GEM_SUBDIRECTORIES;To;;I")Subdirectories in a gem repository

;T;0;	I"#Gem::REPOSITORY_SUBDIRECTORIES;To;;0;0;	I"Gem::RUBYGEMS_DIR;To;;I"Taint support is deprecated in Ruby 2.7. This allows switching ".untaint" to
".tap(&Gem::UNTAINT)", to avoid deprecation warnings in Ruby 2.7.

;T;0;	I"Gem::UNTAINT;To;;0;0;	I"Gem::VERSION;To;;I"=An Array of Regexps that match windows Ruby platforms.

;T;0;	I"Gem::WIN_PATTERNS;To;;I"DException classes used in Gem.write_binary `rescue` statement

;T;0;	I"Gem::WRITE_BINARY_ERRORS;To;;0;0;	I"Singleton::VERSION;To;;I"AppleTalk protocol

;T;0;	I"Socket::AF_APPLETALK;To;;I""CCITT (now ITU-T) protocols

;T;0;	I"Socket::AF_CCITT;To;;I"MIT CHAOS protocols

;T;0;	I"Socket::AF_CHAOS;To;;I""Computer Network Technology

;T;0;	I"Socket::AF_CNT;To;;I"Connection-oriented IP

;T;0;	I"Socket::AF_COIP;To;;I"Datakit protocol

;T;0;	I"Socket::AF_DATAKIT;To;;I".DEC Direct Data Link Interface protocol

;T;0;	I"Socket::AF_DLI;To;;I")CCITT (ITU-T) E.164 recommendation

;T;0;	I"Socket::AF_E164;To;;I"0European Computer Manufacturers protocols

;T;0;	I"Socket::AF_ECMA;To;;I" NSC Hyperchannel protocol

;T;0;	I"Socket::AF_HYLINK;To;;I"ARPANET IMP protocol

;T;0;	I"Socket::AF_IMPLINK;To;;I"IPv4 protocol

;T;0;	I"Socket::AF_INET;To;;I"IPv6 protocol

;T;0;	I"Socket::AF_INET6;To;;I"IPX protocol

;T;0;	I"Socket::AF_IPX;To;;I"*Integrated Services Digital Network

;T;0;	I"Socket::AF_ISDN;To;;I"1ISO Open Systems Interconnection protocols

;T;0;	I"Socket::AF_ISO;To;;I"$Local Area Transport protocol

;T;0;	I"Socket::AF_LAT;To;;I"Link layer interface

;T;0;	I"Socket::AF_LINK;To;;I"Host-internal protocols

;T;0;	I"Socket::AF_LOCAL;To;;I"/Maximum address family for this platform

;T;0;	I"Socket::AF_MAX;To;;I"Native ATM access

;T;0;	I"Socket::AF_NATM;To;;I" Network driver raw access

;T;0;	I"Socket::AF_NDRV;To;;I"NetBIOS

;T;0;	I"Socket::AF_NETBIOS;To;;I"XEROX NS protocols

;T;0;	I"Socket::AF_NS;To;;I"1ISO Open Systems Interconnection protocols

;T;0;	I"Socket::AF_OSI;To;;I"Point-to-Point Protocol

;T;0;	I"Socket::AF_PPP;To;;I"%PARC Universal Packet protocol

;T;0;	I"Socket::AF_PUP;To;;I" Internal routing protocol

;T;0;	I"Socket::AF_ROUTE;To;;I"Simple Internet Protocol

;T;0;	I"Socket::AF_SIP;To;;I"IBM SNA protocol

;T;0;	I"Socket::AF_SNA;To;;0;0;	I"Socket::AF_SYSTEM;To;;I"UNIX sockets

;T;0;	I"Socket::AF_UNIX;To;;I"9Unspecified protocol, any supported address family

;T;0;	I"Socket::AF_UNSPEC;To;;I"-Accept only if any address is assigned

;T;0;	I"Socket::AI_ADDRCONFIG;To;;I"Allow all addresses

;T;0;	I"Socket::AI_ALL;To;;I"!Fill in the canonical name

;T;0;	I"Socket::AI_CANONNAME;To;;I"$Default flags for getaddrinfo

;T;0;	I"Socket::AI_DEFAULT;To;;I"@Valid flag mask for getaddrinfo (not for application use)

;T;0;	I"Socket::AI_MASK;To;;I"#Prevent host name resolution

;T;0;	I"Socket::AI_NUMERICHOST;To;;I"&Prevent service name resolution

;T;0;	I"Socket::AI_NUMERICSERV;To;;I"%Get address to use with bind()

;T;0;	I"Socket::AI_PASSIVE;To;;I"(Accept IPv4-mapped IPv6 addresses

;T;0;	I"Socket::AI_V4MAPPED;To;;I"=Accept IPv4 mapped addresses if the kernel supports it

;T;0;	I"Socket::AI_V4MAPPED_CFG;To;;I"0Address family for hostname not supported

;T;0;	I"Socket::EAI_ADDRFAMILY;To;;I"+Temporary failure in name resolution

;T;0;	I"Socket::EAI_AGAIN;To;;I"Invalid flags

;T;0;	I"Socket::EAI_BADFLAGS;To;;I"Invalid value for hints

;T;0;	I"Socket::EAI_BADHINTS;To;;I"1Non-recoverable failure in name resolution

;T;0;	I"Socket::EAI_FAIL;To;;I"#Address family not supported

;T;0;	I"Socket::EAI_FAMILY;To;;I"*Maximum error code from getaddrinfo

;T;0;	I"Socket::EAI_MAX;To;;I" Memory allocation failure

;T;0;	I"Socket::EAI_MEMORY;To;;I"*No address associated with hostname

;T;0;	I"Socket::EAI_NODATA;To;;I"*Hostname nor servname, or not known

;T;0;	I"Socket::EAI_NONAME;To;;I"Argument buffer overflow

;T;0;	I"Socket::EAI_OVERFLOW;To;;I"#Resolved protocol is unknown

;T;0;	I"Socket::EAI_PROTOCOL;To;;I"-Servname not supported for socket type

;T;0;	I"Socket::EAI_SERVICE;To;;I" Socket type not supported

;T;0;	I"Socket::EAI_SOCKTYPE;To;;I"%System error returned in errno

;T;0;	I"Socket::EAI_SYSTEM;To;;I"$receive all multicast packets

;T;0;	I"Socket::IFF_ALLMULTI;To;;I"(use alternate physical connection

;T;0;	I"Socket::IFF_ALTPHYS;To;;I"broadcast address valid

;T;0;	I"Socket::IFF_BROADCAST;To;;I"turn on debugging

;T;0;	I"Socket::IFF_DEBUG;To;;I"#per link layer defined bit 0

;T;0;	I"Socket::IFF_LINK0;To;;I"#per link layer defined bit 1

;T;0;	I"Socket::IFF_LINK1;To;;I"#per link layer defined bit 2

;T;0;	I"Socket::IFF_LINK2;To;;I"loopback net

;T;0;	I"Socket::IFF_LOOPBACK;To;;I"supports multicast

;T;0;	I"Socket::IFF_MULTICAST;To;;I"%no address resolution protocol

;T;0;	I"Socket::IFF_NOARP;To;;I"avoid use of trailers

;T;0;	I"Socket::IFF_NOTRAILERS;To;;I"transmission in progress

;T;0;	I"Socket::IFF_OACTIVE;To;;I"point-to-point link

;T;0;	I"Socket::IFF_POINTOPOINT;To;;I"receive all packets

;T;0;	I"Socket::IFF_PROMISC;To;;I"resources allocated

;T;0;	I"Socket::IFF_RUNNING;To;;I"#can't hear own transmissions

;T;0;	I"Socket::IFF_SIMPLEX;To;;I"interface is up

;T;0;	I"Socket::IFF_UP;To;;I""Maximum interface name size

;T;0;	I"Socket::IFNAMSIZ;To;;I""Maximum interface name size

;T;0;	I"Socket::IF_NAMESIZE;To;;I"5Multicast group for all systems on this subset

;T;0;	I""Socket::INADDR_ALLHOSTS_GROUP;To;;I"nA socket bound to INADDR_ANY receives packets from all interfaces and sends
from the default IP address

;T;0;	I"Socket::INADDR_ANY;To;;I"$The network broadcast address

;T;0;	I"Socket::INADDR_BROADCAST;To;;I"The loopback address

;T;0;	I"Socket::INADDR_LOOPBACK;To;;I"-The last local network multicast group

;T;0;	I"#Socket::INADDR_MAX_LOCAL_GROUP;To;;I"1A bitmask for matching no valid IP address

;T;0;	I"Socket::INADDR_NONE;To;;I"#The reserved multicast group

;T;0;	I" Socket::INADDR_UNSPEC_GROUP;To;;I"/Maximum length of an IPv6 address string

;T;0;	I"Socket::INET6_ADDRSTRLEN;To;;I"/Maximum length of an IPv4 address string

;T;0;	I"Socket::INET_ADDRSTRLEN;To;;I"2Default minimum address for bind or connect

;T;0;	I"Socket::IPPORT_RESERVED;To;;I"2Default maximum address for bind or connect

;T;0;	I" Socket::IPPORT_USERRESERVED;To;;I"IP6 auth header

;T;0;	I"Socket::IPPROTO_AH;To;;I"IP6 destination option

;T;0;	I"Socket::IPPROTO_DSTOPTS;To;;I" Exterior Gateway Protocol

;T;0;	I"Socket::IPPROTO_EGP;To;;I"ISO cnlp

;T;0;	I"Socket::IPPROTO_EON;To;;I"(IP6 Encapsulated Security Payload

;T;0;	I"Socket::IPPROTO_ESP;To;;I"IP6 fragmentation header

;T;0;	I"Socket::IPPROTO_FRAGMENT;To;;I""Gateway to Gateway Protocol

;T;0;	I"Socket::IPPROTO_GGP;To;;I""hello" routing protocol

;T;0;	I"Socket::IPPROTO_HELLO;To;;I"IP6 hop-by-hop options

;T;0;	I"Socket::IPPROTO_HOPOPTS;To;;I"Control message protocol

;T;0;	I"Socket::IPPROTO_ICMP;To;;I"ICMP6

;T;0;	I"Socket::IPPROTO_ICMPV6;To;;I"XNS IDP

;T;0;	I"Socket::IPPROTO_IDP;To;;I" Group Management Protocol

;T;0;	I"Socket::IPPROTO_IGMP;To;;I"Dummy protocol for IP

;T;0;	I"Socket::IPPROTO_IP;To;;I"IP6 header

;T;0;	I"Socket::IPPROTO_IPV6;To;;I"Maximum IPPROTO constant

;T;0;	I"Socket::IPPROTO_MAX;To;;I"Sun net disk protocol

;T;0;	I"Socket::IPPROTO_ND;To;;I"IP6 no next header

;T;0;	I"Socket::IPPROTO_NONE;To;;I"%PARC Universal Packet protocol

;T;0;	I"Socket::IPPROTO_PUP;To;;I"Raw IP packet

;T;0;	I"Socket::IPPROTO_RAW;To;;I"IP6 routing header

;T;0;	I"Socket::IPPROTO_ROUTING;To;;I"
TCP

;T;0;	I"Socket::IPPROTO_TCP;To;;I"%ISO transport protocol class 4

;T;0;	I"Socket::IPPROTO_TP;To;;I"
UDP

;T;0;	I"Socket::IPPROTO_UDP;To;;I" Xpress Transport Protocol

;T;0;	I"Socket::IPPROTO_XTP;To;;I"&Checksum offset for raw sockets

;T;0;	I"Socket::IPV6_CHECKSUM;To;;I"Don't fragment packets

;T;0;	I"Socket::IPV6_DONTFRAG;To;;I"Destination option

;T;0;	I"Socket::IPV6_DSTOPTS;To;;I"Hop limit

;T;0;	I"Socket::IPV6_HOPLIMIT;To;;I"Hop-by-hop option

;T;0;	I"Socket::IPV6_HOPOPTS;To;;I"Join a group membership

;T;0;	I"Socket::IPV6_JOIN_GROUP;To;;I"Leave a group membership

;T;0;	I"Socket::IPV6_LEAVE_GROUP;To;;I"IP6 multicast hops

;T;0;	I" Socket::IPV6_MULTICAST_HOPS;To;;I"IP6 multicast interface

;T;0;	I"Socket::IPV6_MULTICAST_IF;To;;I"IP6 multicast loopback

;T;0;	I" Socket::IPV6_MULTICAST_LOOP;To;;I"Next hop address

;T;0;	I"Socket::IPV6_NEXTHOP;To;;I" Retrieve current path MTU

;T;0;	I"Socket::IPV6_PATHMTU;To;;I"/Receive packet information with datagram

;T;0;	I"Socket::IPV6_PKTINFO;To;;I"+Receive all IP6 options for response

;T;0;	I"Socket::IPV6_RECVDSTOPTS;To;;I"&Receive hop limit with datagram

;T;0;	I"Socket::IPV6_RECVHOPLIMIT;To;;I"!Receive hop-by-hop options

;T;0;	I"Socket::IPV6_RECVHOPOPTS;To;;I"-Receive current path MTU with datagram

;T;0;	I"Socket::IPV6_RECVPATHMTU;To;;I"<Receive destination IP address and incoming interface

;T;0;	I"Socket::IPV6_RECVPKTINFO;To;;I"Receive routing header

;T;0;	I"Socket::IPV6_RECVRTHDR;To;;I"Receive traffic class

;T;0;	I"Socket::IPV6_RECVTCLASS;To;;I"/Allows removal of sticky routing headers

;T;0;	I"Socket::IPV6_RTHDR;To;;I":Allows removal of sticky destination options header

;T;0;	I"Socket::IPV6_RTHDRDSTOPTS;To;;I"Routing header type 0

;T;0;	I"Socket::IPV6_RTHDR_TYPE_0;To;;I" Specify the traffic class

;T;0;	I"Socket::IPV6_TCLASS;To;;I"IP6 unicast hops

;T;0;	I"Socket::IPV6_UNICAST_HOPS;To;;I"Use the minimum MTU size

;T;0;	I"Socket::IPV6_USE_MIN_MTU;To;;I"*Only bind IPv6 with a wildcard bind

;T;0;	I"Socket::IPV6_V6ONLY;To;;I"'Add a multicast group membership

;T;0;	I"Socket::IP_ADD_MEMBERSHIP;To;;I"'Add a multicast group membership

;T;0;	I"%Socket::IP_ADD_SOURCE_MEMBERSHIP;To;;I">Block IPv4 multicast packets with a give source address

;T;0;	I"Socket::IP_BLOCK_SOURCE;To;;I"!Default multicast loopback

;T;0;	I"&Socket::IP_DEFAULT_MULTICAST_LOOP;To;;I"Default multicast TTL

;T;0;	I"%Socket::IP_DEFAULT_MULTICAST_TTL;To;;I"(Drop a multicast group membership

;T;0;	I"Socket::IP_DROP_MEMBERSHIP;To;;I"(Drop a multicast group membership

;T;0;	I"&Socket::IP_DROP_SOURCE_MEMBERSHIP;To;;I"#Header is included with data

;T;0;	I"Socket::IP_HDRINCL;To;;I"IPsec security policy

;T;0;	I"Socket::IP_IPSEC_POLICY;To;;I"8Maximum number multicast groups a socket can join

;T;0;	I"Socket::IP_MAX_MEMBERSHIPS;To;;I"!Multicast source filtering

;T;0;	I"Socket::IP_MSFILTER;To;;I"IP multicast interface

;T;0;	I"Socket::IP_MULTICAST_IF;To;;I"IP multicast loopback

;T;0;	I"Socket::IP_MULTICAST_LOOP;To;;I"IP multicast TTL

;T;0;	I"Socket::IP_MULTICAST_TTL;To;;I"+IP options to be included in packets

;T;0;	I"Socket::IP_OPTIONS;To;;I"0Receive packet information with datagrams

;T;0;	I"Socket::IP_PKTINFO;To;;I"CSet the port range for sockets with unspecified port numbers

;T;0;	I"Socket::IP_PORTRANGE;To;;I"3Receive IP destination address with datagram

;T;0;	I"Socket::IP_RECVDSTADDR;To;;I"3Receive interface information with datagrams

;T;0;	I"Socket::IP_RECVIF;To;;I"+Receive all IP options with datagram

;T;0;	I"Socket::IP_RECVOPTS;To;;I"*Receive all IP options for response

;T;0;	I"Socket::IP_RECVRETOPTS;To;;I"(Receive TOS with incoming packets

;T;0;	I"Socket::IP_RECVTOS;To;;I"$Receive IP TTL with datagrams

;T;0;	I"Socket::IP_RECVTTL;To;;I"-IP options to be included in datagrams

;T;0;	I"Socket::IP_RETOPTS;To;;I"IP type-of-service

;T;0;	I"Socket::IP_TOS;To;;I"IP time-to-live

;T;0;	I"Socket::IP_TTL;To;;I"@Unblock IPv4 multicast packets with a give source address

;T;0;	I"Socket::IP_UNBLOCK_SOURCE;To;;I" Retrieve peer credentials

;T;0;	I"Socket::LOCAL_PEERCRED;To;;I"/Block multicast packets from this source

;T;0;	I"Socket::MCAST_BLOCK_SOURCE;To;;I"(Exclusive multicast source filter

;T;0;	I"Socket::MCAST_EXCLUDE;To;;I"(Inclusive multicast source filter

;T;0;	I"Socket::MCAST_INCLUDE;To;;I"Join a multicast group

;T;0;	I"Socket::MCAST_JOIN_GROUP;To;;I"$Join a multicast source group

;T;0;	I"$Socket::MCAST_JOIN_SOURCE_GROUP;To;;I"Leave a multicast group

;T;0;	I"Socket::MCAST_LEAVE_GROUP;To;;I"%Leave a multicast source group

;T;0;	I"%Socket::MCAST_LEAVE_SOURCE_GROUP;To;;I"1Unblock multicast packets from this source

;T;0;	I"!Socket::MCAST_UNBLOCK_SOURCE;To;;I"(Control data lost before delivery

;T;0;	I"Socket::MSG_CTRUNC;To;;I",Send without using the routing tables

;T;0;	I"Socket::MSG_DONTROUTE;To;;I"*This message should be non-blocking

;T;0;	I"Socket::MSG_DONTWAIT;To;;I" Data completes connection

;T;0;	I"Socket::MSG_EOF;To;;I"Data completes record

;T;0;	I"Socket::MSG_EOR;To;;I"2Start of a hold sequence.  Dumps to so_temp

;T;0;	I"Socket::MSG_FLUSH;To;;I"Data ready to be read

;T;0;	I"Socket::MSG_HAVEMORE;To;;I"Hold fragment in so_temp

;T;0;	I"Socket::MSG_HOLD;To;;I"Process out-of-band data

;T;0;	I"Socket::MSG_OOB;To;;I"Peek at incoming message

;T;0;	I"Socket::MSG_PEEK;To;;I")Data remains in the current packet

;T;0;	I"Socket::MSG_RCVMORE;To;;I"!Send the packet in so_temp

;T;0;	I"Socket::MSG_SEND;To;;I"%Data discarded before delivery

;T;0;	I"Socket::MSG_TRUNC;To;;I"%Wait for full request or error

;T;0;	I"Socket::MSG_WAITALL;To;;I"GThe service specified is a datagram service (looks up UDP ports)

;T;0;	I"Socket::NI_DGRAM;To;;I"#Maximum length of a hostname

;T;0;	I"Socket::NI_MAXHOST;To;;I"'Maximum length of a service name

;T;0;	I"Socket::NI_MAXSERV;To;;I"A name is required

;T;0;	I"Socket::NI_NAMEREQD;To;;I"JAn FQDN is not required for local hosts, return only the local part

;T;0;	I"Socket::NI_NOFQDN;To;;I"Return a numeric address

;T;0;	I"Socket::NI_NUMERICHOST;To;;I"0Return the service name as a digit string

;T;0;	I"Socket::NI_NUMERICSERV;To;;I"AppleTalk protocol

;T;0;	I"Socket::PF_APPLETALK;To;;I""CCITT (now ITU-T) protocols

;T;0;	I"Socket::PF_CCITT;To;;I"MIT CHAOS protocols

;T;0;	I"Socket::PF_CHAOS;To;;I""Computer Network Technology

;T;0;	I"Socket::PF_CNT;To;;I"Connection-oriented IP

;T;0;	I"Socket::PF_COIP;To;;I"Datakit protocol

;T;0;	I"Socket::PF_DATAKIT;To;;I".DEC Direct Data Link Interface protocol

;T;0;	I"Socket::PF_DLI;To;;I"0European Computer Manufacturers protocols

;T;0;	I"Socket::PF_ECMA;To;;I" NSC Hyperchannel protocol

;T;0;	I"Socket::PF_HYLINK;To;;I"ARPANET IMP protocol

;T;0;	I"Socket::PF_IMPLINK;To;;I"IPv4 protocol

;T;0;	I"Socket::PF_INET;To;;I"IPv6 protocol

;T;0;	I"Socket::PF_INET6;To;;I"IPX protocol

;T;0;	I"Socket::PF_IPX;To;;I"*Integrated Services Digital Network

;T;0;	I"Socket::PF_ISDN;To;;I"1ISO Open Systems Interconnection protocols

;T;0;	I"Socket::PF_ISO;To;;I"IKey management protocol, originally developed for usage with IPsec

;T;0;	I"Socket::PF_KEY;To;;I"$Local Area Transport protocol

;T;0;	I"Socket::PF_LAT;To;;I"Link layer interface

;T;0;	I"Socket::PF_LINK;To;;I"Host-internal protocols

;T;0;	I"Socket::PF_LOCAL;To;;I"/Maximum address family for this platform

;T;0;	I"Socket::PF_MAX;To;;I"Native ATM access

;T;0;	I"Socket::PF_NATM;To;;I" Network driver raw access

;T;0;	I"Socket::PF_NDRV;To;;I"NetBIOS

;T;0;	I"Socket::PF_NETBIOS;To;;I"XEROX NS protocols

;T;0;	I"Socket::PF_NS;To;;I"1ISO Open Systems Interconnection protocols

;T;0;	I"Socket::PF_OSI;To;;0;0;	I"Socket::PF_PIP;To;;I"Point-to-Point Protocol

;T;0;	I"Socket::PF_PPP;To;;I"%PARC Universal Packet protocol

;T;0;	I"Socket::PF_PUP;To;;I" Internal routing protocol

;T;0;	I"Socket::PF_ROUTE;To;;0;0;	I"Socket::PF_RTIP;To;;I"Simple Internet Protocol

;T;0;	I"Socket::PF_SIP;To;;I"IBM SNA protocol

;T;0;	I"Socket::PF_SNA;To;;0;0;	I"Socket::PF_SYSTEM;To;;I"UNIX sockets

;T;0;	I"Socket::PF_UNIX;To;;I"9Unspecified protocol, any supported address family

;T;0;	I"Socket::PF_UNSPEC;To;;I" eXpress Transfer Protocol

;T;0;	I"Socket::PF_XTP;To;;I"Process credentials

;T;0;	I"Socket::SCM_CREDS;To;;I"Access rights

;T;0;	I"Socket::SCM_RIGHTS;To;;I"Timestamp (timeval)

;T;0;	I"Socket::SCM_TIMESTAMP;To;;I"/Shut down the reading side of the socket

;T;0;	I"Socket::SHUT_RD;To;;I"-Shut down the both sides of the socket

;T;0;	I"Socket::SHUT_RDWR;To;;I"/Shut down the writing side of the socket

;T;0;	I"Socket::SHUT_WR;To;;I"FA datagram socket provides connectionless, unreliable messaging

;T;0;	I"Socket::SOCK_DGRAM;To;;I"aA raw socket provides low-level access for direct access or implementing
network protocols

;T;0;	I"Socket::SOCK_RAW;To;;I"HA reliable datagram socket provides reliable delivery of messages

;T;0;	I"Socket::SOCK_RDM;To;;I"_A sequential packet socket provides sequenced, reliable two-way connection for
datagrams

;T;0;	I"Socket::SOCK_SEQPACKET;To;;I"ZA stream socket provides a sequenced, reliable two-way connection for a byte
stream

;T;0;	I"Socket::SOCK_STREAM;To;;I"Socket-level options

;T;0;	I"Socket::SOL_SOCKET;To;;I"BMaximum connection requests that may be queued for a socket

;T;0;	I"Socket::SOMAXCONN;To;;I"+Socket has had listen() called on it

;T;0;	I"Socket::SO_ACCEPTCONN;To;;I"+Permit sending of broadcast messages

;T;0;	I"Socket::SO_BROADCAST;To;;I"Debug info recording

;T;0;	I"Socket::SO_DEBUG;To;;I"Use interface addresses

;T;0;	I"Socket::SO_DONTROUTE;To;;I"Retain unread data

;T;0;	I"Socket::SO_DONTTRUNC;To;;I"%Get and clear the error status

;T;0;	I"Socket::SO_ERROR;To;;I"Keep connections alive

;T;0;	I"Socket::SO_KEEPALIVE;To;;I")Linger on close if data is present

;T;0;	I"Socket::SO_LINGER;To;;I"4Install socket-level Network Kernel Extension

;T;0;	I"Socket::SO_NKE;To;;I"Don't SIGPIPE on EPIPE

;T;0;	I"Socket::SO_NOSIGPIPE;To;;I""Get first packet byte count

;T;0;	I"Socket::SO_NREAD;To;;I".Leave received out-of-band data in-line

;T;0;	I"Socket::SO_OOBINLINE;To;;I"Receive buffer size

;T;0;	I"Socket::SO_RCVBUF;To;;I"Receive low-water mark

;T;0;	I"Socket::SO_RCVLOWAT;To;;I"Receive timeout

;T;0;	I"Socket::SO_RCVTIMEO;To;;I" Allow local address reuse

;T;0;	I"Socket::SO_REUSEADDR;To;;I")Allow local address and port reuse

;T;0;	I"Socket::SO_REUSEPORT;To;;I"Send buffer size

;T;0;	I"Socket::SO_SNDBUF;To;;I"Send low-water mark

;T;0;	I"Socket::SO_SNDLOWAT;To;;I"Send timeout

;T;0;	I"Socket::SO_SNDTIMEO;To;;I"1Receive timestamp with datagrams (timeval)

;T;0;	I"Socket::SO_TIMESTAMP;To;;I"Get the socket type

;T;0;	I"Socket::SO_TYPE;To;;I"$Bypass hardware when possible

;T;0;	I"Socket::SO_USELOOPBACK;To;;I"*Give a hint when more data is ready

;T;0;	I"Socket::SO_WANTMORE;To;;I"0OOB data is wanted in MSG_FLAG on receive

;T;0;	I"Socket::SO_WANTOOBFLAG;To;;I"CReduce step of the handshake process (Linux 3.7, glibc 2.18)

;T;0;	I"Socket::TCP_FASTOPEN;To;;I"eMaximum number of keepalive probes allowed before dropping a connection (Linux
2.4, glibc 2.2)

;T;0;	I"Socket::TCP_KEEPCNT;To;;I";Time between keepalive probes (Linux 2.4, glibc 2.2)

;T;0;	I"Socket::TCP_KEEPINTVL;To;;I"Set maximum segment size

;T;0;	I"Socket::TCP_MAXSEG;To;;I".Don't delay sending to coalesce packets

;T;0;	I"Socket::TCP_NODELAY;To;;I"Don't use TCP options

;T;0;	I"Socket::TCP_NOOPT;To;;I")Don't push the last block of write

;T;0;	I"Socket::TCP_NOPUSH;To;;0;0;	I"StringScanner::Id;To;;0;0;	I"StringScanner::Version;To;;0;0;	I"Timeout::VERSION;To;;0;0;	I"URI::ABS_PATH;To;;0;0;	I"URI::ABS_URI;To;;0;0;	I"URI::ABS_URI_REF;To;;I"URI::Parser.new

;T;0;	I"URI::DEFAULT_PARSER;To;;0;0;	I"URI::ESCAPED;To;;0;0;	I"URI::FRAGMENT;To;;0;0;	I"URI::HOST;To;;0;0;	I"URI::OPAQUE;To;;0;0;	I"URI::PORT;To;;0;0;	I"URI::QUERY;To;;0;0;	I"URI::REGISTRY;To;;0;0;	I"URI::REL_PATH;To;;0;0;	I"URI::REL_URI;To;;0;0;	I"URI::REL_URI_REF;To;;0;0;	I"URI::RFC3986_PARSER;To;;0;0;	I"URI::SCHEME;To;;0;0;	I"URI::TBLDECWWWCOMP_;To;;0;0;	I"URI::TBLENCWWWCOMP_;To;;0;0;	I"URI::UNSAFE;To;;0;0;	I"URI::URI_REF;To;;0;0;	I"URI::USERINFO;To;;0;0;	I"URI::VERSION;To;;0;0;	I"URI::VERSION_CODE;To;;0;0;	I"URI::WEB_ENCODINGS_;To;;I"+A Default port of nil for URI::File.

;T;0;	I"URI::File::DEFAULT_PORT;To;;I":An Array of the available components for URI::File.

;T;0;	I"URI::File::COMPONENT;To;;I".A Default port of nil for URI::Generic.

;T;0;	I"URI::Generic::DEFAULT_PORT;To;;I"=An Array of the available components for URI::Generic.

;T;0;	I"URI::Generic::COMPONENT;To;;0;0;	I"URI::Generic::USE_REGISTRY;To;;I"*A Default port of 80 for URI::HTTP.

;T;0;	I"URI::HTTP::DEFAULT_PORT;To;;I":An Array of the available components for URI::HTTP.

;T;0;	I"URI::HTTP::COMPONENT;To;;I"+A Default port of 443 for URI::HTTPS

;T;0;	I"URI::HTTPS::DEFAULT_PORT;To;;I"+A Default port of 389 for URI::LDAP.

;T;0;	I"URI::LDAP::DEFAULT_PORT;To;;I":An Array of the available components for URI::LDAP.

;T;0;	I"URI::LDAP::COMPONENT;To;;I"òScopes available for the starting point.

*   SCOPE_BASE - the Base DN
*   SCOPE_ONE  - one level under the Base DN, not including the base DN and
    not including any entries under this
*   SCOPE_SUB  - subtrees, all entries at all levels

;T;0;	I"URI::LDAP::SCOPE;To;;I"+A Default port of 636 for URI::LDAPS

;T;0;	I"URI::LDAPS::DEFAULT_PORT;To;;0;0;	I"YAML::DBM::VERSION;To;;I"ÓRepresents text data as guessed by deflate.

NOTE: The underlying constant Z_ASCII was deprecated in favor of Z_TEXT in
zlib 1.2.2.  New applications should not use this constant.

See Zlib::Deflate#data_type.

;T;0;	I"Zlib::ASCII;To;;I"BSlowest compression level, but with the best space savings.

;T;0;	I"Zlib::BEST_COMPRESSION;To;;I"DFastest compression level, but with the lowest space savings.

;T;0;	I"Zlib::BEST_SPEED;To;;I"RRepresents binary data as guessed by deflate.

See Zlib::Deflate#data_type.

;T;0;	I"Zlib::BINARY;To;;I"QDefault compression level which is a good trade-off between space and time

;T;0;	I"Zlib::DEFAULT_COMPRESSION;To;;I">Default deflate strategy which is used for normal data.

;T;0;	I"Zlib::DEFAULT_STRATEGY;To;;I"NThe default memory level for allocating zlib deflate compression state.

;T;0;	I"Zlib::DEF_MEM_LEVEL;To;;I"*Deflate strategy for data produced by a filter (or predictor). The effect of
FILTERED is to force more Huffman codes and less string matching; it is
somewhat intermediate between DEFAULT_STRATEGY and HUFFMAN_ONLY. Filtered data
consists mostly of small values with a somewhat random distribution.

;T;0;	I"Zlib::FILTERED;To;;I">Processes all pending input and flushes pending output.

;T;0;	I"Zlib::FINISH;To;;I"€Deflate strategy which prevents the use of dynamic Huffman codes, allowing for
a simpler decoder for specialized applications.

;T;0;	I"Zlib::FIXED;To;;I"Flushes all output as with SYNC_FLUSH, and the compression state is reset so
that decompression can restart from this point if previous compressed data has
been damaged or if random access is desired. Like SYNC_FLUSH, using FULL_FLUSH
too often can seriously degrade compression.

;T;0;	I"Zlib::FULL_FLUSH;To;;I"KDeflate strategy which uses Huffman codes only (no string matching).

;T;0;	I"Zlib::HUFFMAN_ONLY;To;;I"NThe maximum memory level for allocating zlib deflate compression state.

;T;0;	I"Zlib::MAX_MEM_LEVEL;To;;I"šThe maximum size of the zlib history buffer.  Note that zlib allows larger
values to enable different inflate modes.  See Zlib::Inflate.new for details.

;T;0;	I"Zlib::MAX_WBITS;To;;I"vNo compression, passes through data untouched.  Use this for appending
pre-compressed data to a deflate stream.

;T;0;	I"Zlib::NO_COMPRESSION;To;;I"™NO_FLUSH is the default flush method and allows deflate to decide how much
data to accumulate before producing output in order to maximize compression.

;T;0;	I"Zlib::NO_FLUSH;To;;I"OS code for Amiga hosts

;T;0;	I"Zlib::OS_AMIGA;To;;I"OS code for Atari hosts

;T;0;	I"Zlib::OS_ATARI;To;;I""The OS code of current host

;T;0;	I"Zlib::OS_CODE;To;;I"OS code for CP/M hosts

;T;0;	I"Zlib::OS_CPM;To;;I"OS code for Mac OS hosts

;T;0;	I"Zlib::OS_MACOS;To;;I"OS code for MSDOS hosts

;T;0;	I"Zlib::OS_MSDOS;To;;I"OS code for OS2 hosts

;T;0;	I"Zlib::OS_OS2;To;;I"OS code for QDOS hosts

;T;0;	I"Zlib::OS_QDOS;To;;I" OS code for RISC OS hosts

;T;0;	I"Zlib::OS_RISCOS;To;;I" OS code for TOPS-20 hosts

;T;0;	I"Zlib::OS_TOPS20;To;;I"OS code for UNIX hosts

;T;0;	I"Zlib::OS_UNIX;To;;I" OS code for unknown hosts

;T;0;	I"Zlib::OS_UNKNOWN;To;;I"OS code for VM OS hosts

;T;0;	I"Zlib::OS_VMCMS;To;;I"OS code for VMS hosts

;T;0;	I"Zlib::OS_VMS;To;;I"OS code for Win32 hosts

;T;0;	I"Zlib::OS_WIN32;To;;I"!OS code for Z-System hosts

;T;0;	I"Zlib::OS_ZSYSTEM;To;;I"}Deflate compression strategy designed to be almost as fast as HUFFMAN_ONLY,
but give better compression for PNG image data.

;T;0;	I"Zlib::RLE;To;;I" The SYNC_FLUSH method flushes all pending output to the output buffer and the
output is aligned on a byte boundary. Flushing may degrade compression so it
should be used only when necessary, such as at a request or response boundary
for a network stream.

;T;0;	I"Zlib::SYNC_FLUSH;To;;I"PRepresents text data as guessed by deflate.

See Zlib::Deflate#data_type.

;T;0;	I"Zlib::TEXT;To;;I"[Represents an unknown data type as guessed by deflate.

See Zlib::Deflate#data_type.

;T;0;	I"Zlib::UNKNOWN;To;;I"$The Ruby/zlib version string.

;T;0;	I"Zlib::VERSION;To;;I"8The string which represents the version of zlib.h

;T;0;	I"Zlib::ZLIB_VERSION;T